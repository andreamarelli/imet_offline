var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
import { m as mergeModels, d as ref, i as inject, u as useModel, e as computed, f as onBeforeMount, w as watch, g as resolveComponent, h as createBlock, j as withCtx, o as openBlock, c as createElementBlock, F as Fragment, k as renderList, l as createBaseVNode, b as createCommentVNode, t as toDisplayString, p as withDirectives, v as vShow, q as withKeys, s as withModifiers, x as vModelText, r as renderSlot, y as reactive, z as onMounted, A as resolveDirective, B as normalizeProps, C as guardReactiveProps, a as createTextVNode, D as resolveDynamicComponent, E as mergeProps, G as toHandlers, H as createVNode, n as normalizeClass, T as Transition, I as createApp, J as provide, K as vModelSelect, L as vue_esmBundler, M as unref, N as toRaw, O as nextTick, P as normalizeStyle, Q as effectScope, R as markRaw, S as isRef, U as isReactive, V as toRef, W as hasInjectionContext, X as getCurrentInstance, Y as getCurrentScope, Z as onScopeDispose, _ as toRefs, $ as defineComponent, a0 as render, a1 as onBeforeUnmount, a2 as readonly, a3 as shallowRef, a4 as useSlots, a5 as Teleport, a6 as pushScopeId, a7 as popScopeId } from "./vue-CftvIENP.js";
import { _ as _export_sfc, v as vueDropzone } from "./dropzone-CNduCgSz.js";
import { c as commonjsGlobal, g as getDefaultExportFromCjs, a as getAugmentedNamespace, m as mapboxgl } from "./mapbox-BJtTVmXE.js";
import { i as init, e as echarts } from "./echarts-Bf8QDmg4.js";
var require_index_001 = __commonJS({
  "assets/index-B2Uj7aaf.js"(exports, module) {
    var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o2, _p, _q, _r2, _s, _t2, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, _M, _N, _O, _P, _Q, _R, _S, _T, _U, _V, _W, _X, _Y;
    class I18n {
      /**
       * Initialize a new translation instance.
       *
       * @param  {string}  key
       * @return {void}
       */
      constructor(key = "translations") {
        this.key = key;
      }
      /**
       * Get and replace the string of the given key.
       *
       * @param  {string}  key
       * @param  {object}  replace
       * @return {string}
       */
      trans(key, replace2 = {}) {
        return this._replace(this._extract(key), replace2);
      }
      /**
       * Get and pluralize the strings of the given key.
       *
       * @param  {string}  key
       * @param  {number}  count
       * @param  {object}  replace
       * @return {string}
       */
      trans_choice(key, count2 = 1, replace2 = {}) {
        let translations = this._extract(key, "|").split("|"), translation;
        translations.some((t2) => translation = this._match(t2, count2));
        translation = translation || (count2 > 1 ? translations[1] : translations[0]);
        translation = translation.replace(/\[.*?\]|\{.*?\}/, "");
        return this._replace(translation, replace2);
      }
      /**
       * Match the translation limit with the count.
       *
       * @param  {string}  translation
       * @param  {number}  count
       * @return {string|null}
       */
      _match(translation, count2) {
        let match = translation.match(/^[\{\[]([^\[\]\{\}]*)[\}\]](.*)/);
        if (!match) return;
        if (match[1].includes(",")) {
          let [from, to2] = match[1].split(",", 2);
          if (to2 === "*" && count2 >= from) {
            return match[2];
          } else if (from === "*" && count2 <= to2) {
            return match[2];
          } else if (count2 >= from && count2 <= to2) {
            return match[2];
          }
        }
        return match[1] == count2 ? match[2] : null;
      }
      /**
       * Replace the placeholders.
       *
       * @param  {string}  translation
       * @param  {object}  replace
       * @return {string}
       */
      _replace(translation, replace2) {
        if (typeof translation === "object") {
          return translation;
        }
        for (let placeholder in replace2) {
          translation = translation.toString().replace(`:${placeholder}`, replace2[placeholder]).replace(`:${placeholder.toUpperCase()}`, replace2[placeholder].toString().toUpperCase()).replace(
            `:${placeholder.charAt(0).toUpperCase()}${placeholder.slice(1)}`,
            replace2[placeholder].toString().charAt(0).toUpperCase() + replace2[placeholder].toString().slice(1)
          );
        }
        return translation.toString().trim();
      }
      /**
       * Extract values from objects by dot notation.
       *
       * @param  {string}  key
       * @param  {mixed}  value
       * @return {mixed}
       */
      _extract(key, value = null) {
        let path = key.toString().split("::"), keys2 = path.pop().toString().split(".");
        if (path.length > 0) {
          path[0] += "::";
        }
        return path.concat(keys2).reduce((t2, i2) => t2[i2] || (value || key), window[this.key]);
      }
    }
    const Locale$1 = {
      getLocale() {
        return window.Laravel.locale;
      },
      getLabel(key, arg = null) {
        let translator = new I18n();
        let label = "";
        if (arg === null) {
          label = translator.trans(key);
        } else if (typeof arg === "object") {
          label = translator.trans(key, arg);
        } else if (typeof arg === "number") {
          label = translator.trans_choice(key, arg);
        }
        return label.charAt(0).toUpperCase() + label.slice(1);
      }
    };
    const Animation = {
      scrollPageTo(scrollTo) {
        window.scroll({
          top: scrollTo,
          left: 0,
          behavior: "smooth"
        });
      },
      scrollPageToAnchor(anchor) {
        this.scrollPageTo(document.querySelector("#" + anchor).offsetTop);
      },
      copyToClipboard(textToCopy, alertMessage) {
        let dummy = document.createElement("textarea");
        document.body.appendChild(dummy);
        dummy.value = textToCopy;
        dummy.select();
        document.execCommand("copy");
        document.body.removeChild(dummy);
        this.showAlert(alertMessage);
      },
      showAlert(message) {
        let element = document.createElement("div");
        element.style.display = "none";
        element.className = "alert-popup";
        element.innerHTML = message;
        document.body.appendChild(element);
        $(element).fadeTo(2e3, 500).slideUp(500, function() {
          document.body.removeChild(element);
        });
      }
    };
    const Common = {
      isEmpty(value) {
        return value === "" || value === "{}" || value === {} || value === "[]" || value === [] || value === null;
      },
      isNumeric(value) {
        if (typeof value === "string") {
          value = value.replace(" ", "");
        }
        return !(this.isEmpty(value) || value === false || isNaN(value));
      },
      pretty_number(value, precision = 0) {
        value = Number(parseFloat(value).toFixed(precision));
        return isNaN(value) ? "-" : value.toLocaleString("fr-FR");
      },
      isValidJSON(value) {
        try {
          JSON.parse(value);
        } catch (e2) {
          return false;
        }
        return true;
      }
    };
    const Cookie = {
      create(name, value) {
        document.cookie = `${name}=${value};max-age=86400`;
      },
      update(name, value) {
        document.cookie = `${name}=${value}`;
      },
      delete(name) {
        document.cookie = `${name}=;expires=Thu, 01 Jan 1970 00:00:00 GMT`;
      },
      getByName(name) {
        return document.cookie.split(";").find((element) => element.includes(name));
      }
    };
    const version$1 = "3.7.7";
    const VERSION$1 = version$1;
    const _hasBuffer = typeof Buffer === "function";
    const _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
    const _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
    const b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    const b64chs = Array.prototype.slice.call(b64ch);
    const b64tab = ((a2) => {
      let tab = {};
      a2.forEach((c2, i2) => tab[c2] = i2);
      return tab;
    })(b64chs);
    const b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
    const _fromCC = String.fromCharCode.bind(String);
    const _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : (it2) => new Uint8Array(Array.prototype.slice.call(it2, 0));
    const _mkUriSafe = (src) => src.replace(/=/g, "").replace(/[+\/]/g, (m0) => m0 == "+" ? "-" : "_");
    const _tidyB64 = (s2) => s2.replace(/[^A-Za-z0-9\+\/]/g, "");
    const btoaPolyfill = (bin) => {
      let u32, c0, c1, c2, asc = "";
      const pad3 = bin.length % 3;
      for (let i2 = 0; i2 < bin.length; ) {
        if ((c0 = bin.charCodeAt(i2++)) > 255 || (c1 = bin.charCodeAt(i2++)) > 255 || (c2 = bin.charCodeAt(i2++)) > 255)
          throw new TypeError("invalid character found");
        u32 = c0 << 16 | c1 << 8 | c2;
        asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
      }
      return pad3 ? asc.slice(0, pad3 - 3) + "===".substring(pad3) : asc;
    };
    const _btoa = typeof btoa === "function" ? (bin) => btoa(bin) : _hasBuffer ? (bin) => Buffer.from(bin, "binary").toString("base64") : btoaPolyfill;
    const _fromUint8Array = _hasBuffer ? (u8a) => Buffer.from(u8a).toString("base64") : (u8a) => {
      const maxargs = 4096;
      let strs = [];
      for (let i2 = 0, l2 = u8a.length; i2 < l2; i2 += maxargs) {
        strs.push(_fromCC.apply(null, u8a.subarray(i2, i2 + maxargs)));
      }
      return _btoa(strs.join(""));
    };
    const fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
    const cb_utob = (c2) => {
      if (c2.length < 2) {
        var cc = c2.charCodeAt(0);
        return cc < 128 ? c2 : cc < 2048 ? _fromCC(192 | cc >>> 6) + _fromCC(128 | cc & 63) : _fromCC(224 | cc >>> 12 & 15) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
      } else {
        var cc = 65536 + (c2.charCodeAt(0) - 55296) * 1024 + (c2.charCodeAt(1) - 56320);
        return _fromCC(240 | cc >>> 18 & 7) + _fromCC(128 | cc >>> 12 & 63) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
      }
    };
    const re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
    const utob = (u2) => u2.replace(re_utob, cb_utob);
    const _encode = _hasBuffer ? (s2) => Buffer.from(s2, "utf8").toString("base64") : _TE ? (s2) => _fromUint8Array(_TE.encode(s2)) : (s2) => _btoa(utob(s2));
    const encode = (src, urlsafe = false) => urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
    const encodeURI$1 = (src) => encode(src, true);
    const re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
    const cb_btou = (cccc) => {
      switch (cccc.length) {
        case 4:
          var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset2 = cp - 65536;
          return _fromCC((offset2 >>> 10) + 55296) + _fromCC((offset2 & 1023) + 56320);
        case 3:
          return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
        default:
          return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
      }
    };
    const btou = (b2) => b2.replace(re_btou, cb_btou);
    const atobPolyfill = (asc) => {
      asc = asc.replace(/\s+/g, "");
      if (!b64re.test(asc))
        throw new TypeError("malformed base64.");
      asc += "==".slice(2 - (asc.length & 3));
      let u24, bin = "", r1, r2;
      for (let i2 = 0; i2 < asc.length; ) {
        u24 = b64tab[asc.charAt(i2++)] << 18 | b64tab[asc.charAt(i2++)] << 12 | (r1 = b64tab[asc.charAt(i2++)]) << 6 | (r2 = b64tab[asc.charAt(i2++)]);
        bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
      }
      return bin;
    };
    const _atob = typeof atob === "function" ? (asc) => atob(_tidyB64(asc)) : _hasBuffer ? (asc) => Buffer.from(asc, "base64").toString("binary") : atobPolyfill;
    const _toUint8Array = _hasBuffer ? (a2) => _U8Afrom(Buffer.from(a2, "base64")) : (a2) => _U8Afrom(_atob(a2).split("").map((c2) => c2.charCodeAt(0)));
    const toUint8Array = (a2) => _toUint8Array(_unURI(a2));
    const _decode = _hasBuffer ? (a2) => Buffer.from(a2, "base64").toString("utf8") : _TD ? (a2) => _TD.decode(_toUint8Array(a2)) : (a2) => btou(_atob(a2));
    const _unURI = (a2) => _tidyB64(a2.replace(/[-_]/g, (m0) => m0 == "-" ? "+" : "/"));
    const decode = (src) => _decode(_unURI(src));
    const isValid = (src) => {
      if (typeof src !== "string")
        return false;
      const s2 = src.replace(/\s+/g, "").replace(/={0,2}$/, "");
      return !/[^\s0-9a-zA-Z\+/]/.test(s2) || !/[^\s0-9a-zA-Z\-_]/.test(s2);
    };
    const _noEnum = (v2) => {
      return {
        value: v2,
        enumerable: false,
        writable: true,
        configurable: true
      };
    };
    const extendString = function() {
      const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));
      _add("fromBase64", function() {
        return decode(this);
      });
      _add("toBase64", function(urlsafe) {
        return encode(this, urlsafe);
      });
      _add("toBase64URI", function() {
        return encode(this, true);
      });
      _add("toBase64URL", function() {
        return encode(this, true);
      });
      _add("toUint8Array", function() {
        return toUint8Array(this);
      });
    };
    const extendUint8Array = function() {
      const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
      _add("toBase64", function(urlsafe) {
        return fromUint8Array(this, urlsafe);
      });
      _add("toBase64URI", function() {
        return fromUint8Array(this, true);
      });
      _add("toBase64URL", function() {
        return fromUint8Array(this, true);
      });
    };
    const extendBuiltins = () => {
      extendString();
      extendUint8Array();
    };
    const gBase64 = {
      version: version$1,
      VERSION: VERSION$1,
      atob: _atob,
      atobPolyfill,
      btoa: _btoa,
      btoaPolyfill,
      fromBase64: decode,
      toBase64: encode,
      encode,
      encodeURI: encodeURI$1,
      encodeURL: encodeURI$1,
      utob,
      btou,
      decode,
      isValid,
      fromUint8Array,
      toUint8Array,
      extendString,
      extendUint8Array,
      extendBuiltins
    };
    const Payload = {
      /**
       * Encode JSON object to Base64
       * @param obj
       * @returns {string}
       */
      encode(obj) {
        return gBase64.encode(JSON.stringify(obj));
      },
      /**
       * Decode JSON object from Base64
       *
       * @param encoded_obj
       * @returns {any}
       */
      decode(encoded_obj) {
        return JSON.parse(gBase64.decode(encoded_obj));
      }
    };
    const _sfc_main$1d = {
      __name: "selector-dialog",
      props: /* @__PURE__ */ mergeModels({
        parentId: {
          type: String,
          default: null
        },
        searchUrl: {
          type: String,
          default: null
        },
        labelUrl: {
          type: String,
          default: null
        },
        createUrl: {
          type: String,
          default: null
        },
        withInsert: {
          type: Boolean,
          default: false
        },
        withId: {
          type: Boolean,
          default: false
        },
        multiple: {
          type: Boolean,
          default: false
        },
        keyMinLength: {
          type: Number,
          default: 4
        },
        parentSearchParamsValid: {
          type: Boolean,
          default: false
        }
      }, {
        "modelValue": {},
        "modelModifiers": {}
      }),
      emits: ["update:modelValue"],
      setup(__props, { expose: __expose }) {
        const Locale2 = window.ModularForms.Helpers.Locale;
        const Common2 = window.ModularForms.Helpers.Common;
        const props = __props;
        const dialogComponent = ref(null);
        const selectorComponent_AfterSearch = inject("afterSearch", null);
        const selectorComponent_AfterLabelRetrieve = inject("afterLabelRetrieve", null);
        const selectorComponent_SetLabel = inject("setLabel", null);
        const selectorComponent_SetValue = inject("setValue", null);
        const selectorComponent_beforeDialogClose = inject("beforeDialogClose", null);
        const selectorComponent_getSearchParams = inject("getSearchParams", null);
        const selectorComponent_validateInsert = inject("validateInsert", null);
        __expose({
          filterShowList
        });
        const inputValue = useModel(__props, "modelValue");
        const selectedItem = ref(null);
        const insertedItem = ref(null);
        const confirmedItem = ref(null);
        const searchKey = ref("");
        const isSearching = ref(false);
        const searchResults = ref({});
        const showList = ref({});
        const totalCount = ref(null);
        const searchExecuted = ref(false);
        const errorLabel = ref(null);
        const isSearchable = computed(() => {
          return props.parentSearchParamsValid || searchKey.value.length >= props.keyMinLength;
        });
        const keyLengthErrorMessage = computed(() => {
          return Locale2.getLabel("modular-forms::common.search_key_min_length", { num_chars: props.keyMinLength });
        });
        const recordFoundLabel = computed(() => {
          return Locale2.getLabel("modular-forms::common.record_found", totalCount.value);
        });
        const displaySearch = ref(true);
        const displayInsertText = ref(false);
        const displayInsertObject = ref(false);
        onBeforeMount(() => {
          setConfirmedItem(inputValue.value);
          insertedItem.value = props.withId ? {} : null;
        });
        watch(inputValue, (newValue, oldValue) => {
          if (oldValue !== newValue) {
            setConfirmedItem(newValue);
          }
        });
        function setConfirmedItem(value) {
          if (!window.ModularForms.Helpers.Common.isEmpty(value) && value !== false && props.withId) {
            retrieveItemFromId(value);
          } else {
            confirmedItem.value = value;
          }
        }
        function retrieveItemFromId(value) {
          fetch(props.labelUrl, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-CSRF-Token": window.Laravel.csrfToken
            },
            body: JSON.stringify({
              id: value
            })
          }).then((response) => response.json()).then(function(data) {
            if (typeof selectorComponent_AfterLabelRetrieve === "function") {
              selectorComponent_AfterLabelRetrieve(data.records);
            }
            confirmedItem.value = data.records;
          }).catch(function(error) {
          });
        }
        function anchorLabel() {
          if (typeof selectorComponent_SetLabel === "function" && confirmedItem.value !== null) {
            return props.withId ? selectorComponent_SetLabel(confirmedItem.value[0]) : selectorComponent_SetLabel(confirmedItem.value);
          }
          return confirmedItem.value;
        }
        function anchorMultipleLabel(item) {
          return typeof selectorComponent_SetLabel === "function" ? selectorComponent_SetLabel(item) : item;
        }
        function resetSelectorDialog() {
          resetSearchResult();
          resetError();
          searchKey.value = "";
          errorLabel.value = null;
          displayInsertText.value = false;
          displayInsertObject.value = false;
          displaySearch.value = true;
          selectedItem.value = null;
          insertedItem.value = props.withId ? {} : null;
        }
        function resetSearchResult() {
          isSearching.value = false;
          searchExecuted.value = false;
          totalCount.value = null;
          selectedItem.value = null;
          searchResults.value = {};
          showList.value = {};
        }
        function resetError() {
          errorLabel.value = null;
        }
        function closeSelectorDialog() {
          if (typeof selectorComponent_beforeDialogClose === "function") {
            selectorComponent_beforeDialogClose();
          }
          resetSelectorDialog();
          dialogComponent.value.closeDialog();
        }
        function applyAndClose() {
          if (typeof selectorComponent_SetValue === "function") {
            if (props.multiple) {
              let values2 = [];
              confirmedItem.value.forEach(function(item) {
                values2.push(selectorComponent_SetValue(item).toString());
              });
              inputValue.value = JSON.stringify(values2);
            } else if (props.withId) {
              inputValue.value = selectorComponent_SetValue(confirmedItem.value[0]);
            } else {
              inputValue.value = selectorComponent_SetValue(confirmedItem.value);
            }
          } else {
            inputValue.value = confirmedItem.value;
          }
          closeSelectorDialog();
        }
        function setError(label = null) {
          label = label === null ? Locale2.getLabel("modular-forms::common.saved_error") : label;
          errorLabel.value = Locale2.getLabel(label);
        }
        function searchParams() {
          let params = {
            "search_key": searchKey.value
          };
          if (typeof selectorComponent_getSearchParams === "function") {
            Object.entries(selectorComponent_getSearchParams()).forEach(([key, value]) => {
              params[key] = value;
            });
          }
          return params;
        }
        function applySearch(event) {
          if (isSearchable.value) {
            resetSearchResult();
            isSearching.value = true;
            fetch(props.searchUrl, {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "X-CSRF-Token": window.Laravel.csrfToken
              },
              body: JSON.stringify(searchParams())
            }).then((response) => response.json()).then(function(data) {
              searchResults.value = data["records"];
              showList.value = data["records"];
              totalCount.value = Object.keys(searchResults.value).length;
              searchExecuted.value = true;
              isSearching.value = false;
              if (typeof selectorComponent_AfterSearch === "function") {
                selectorComponent_AfterSearch(data);
              }
            }).catch(function() {
              setError();
            });
          }
        }
        function filterShowList(filters) {
          selectedItem.value = null;
          let filteredList = searchResults.value;
          filteredList = Object.values(filteredList);
          Object.keys(filters).forEach(function(key) {
            filteredList = filterByAttribute(filteredList, filters[key], key);
          });
          showList.value = filteredList;
        }
        function selectResultItem(item) {
          selectedItem.value = item;
        }
        function confirmSelection() {
          if (props.multiple) {
            confirmedItem.value = confirmedItem.value || [];
            confirmedItem.value.push(selectedItem.value);
          } else if (props.withId) {
            confirmedItem.value = [selectedItem.value];
          } else {
            confirmedItem.value = selectedItem.value;
          }
          applyAndClose();
        }
        function removeItem(item) {
          let idx = confirmedItem.value.indexOf(item);
          if (idx > -1) {
            confirmedItem.value.splice(idx, 1);
          }
          applyAndClose();
        }
        function enableInsert() {
          displayInsertText.value = !props.withId;
          displayInsertObject.value = props.withId;
          displaySearch.value = false;
        }
        function confirmInsert() {
          let valid = false;
          if (typeof selectorComponent_validateInsert === "function") {
            valid = selectorComponent_validateInsert(insertedItem.value);
          } else {
            valid = props.withId ? insertedItem.value !== {} : insertedItem.value !== null;
          }
          if (valid) {
            resetError();
            confirmedItem.value = insertedItem.value;
            if (props.withId) {
              saveNewItem();
            } else {
              applyAndClose();
            }
          } else {
            setError(Locale2.getLabel("modular-forms::common.validation_error"));
          }
        }
        function saveNewItem() {
          fetch(props.createUrl, {
            method: "post",
            headers: {
              "Content-Type": "application/json",
              "X-CSRF-Token": window.Laravel.csrfToken
            },
            body: JSON.stringify(confirmedItem.value)
          }).then((response) => response.json()).then(function(data) {
            confirmedItem.value = data.records;
            applyAndClose();
          }).catch(function() {
            setError();
          });
        }
        const __returned__ = { Locale: Locale2, Common: Common2, props, dialogComponent, selectorComponent_AfterSearch, selectorComponent_AfterLabelRetrieve, selectorComponent_SetLabel, selectorComponent_SetValue, selectorComponent_beforeDialogClose, selectorComponent_getSearchParams, selectorComponent_validateInsert, inputValue, selectedItem, insertedItem, confirmedItem, searchKey, isSearching, searchResults, showList, totalCount, searchExecuted, errorLabel, isSearchable, keyLengthErrorMessage, recordFoundLabel, displaySearch, displayInsertText, displayInsertObject, setConfirmedItem, retrieveItemFromId, anchorLabel, anchorMultipleLabel, resetSelectorDialog, resetSearchResult, resetError, closeSelectorDialog, applyAndClose, setError, searchParams, applySearch, filterShowList, selectResultItem, confirmSelection, removeItem, enableInsert, confirmInsert, saveNewItem, computed, ref, inject, onBeforeMount, watch };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$W = ["innerHTML"];
    const _hoisted_2$J = {
      key: 1,
      class: "field-preview"
    };
    const _hoisted_3$A = { class: "multiple dontOpenDialog" };
    const _hoisted_4$p = ["innerHTML"];
    const _hoisted_5$n = ["onClick"];
    const _hoisted_6$h = { class: "with_header_and_footer" };
    const _hoisted_7$d = { class: "header" };
    const _hoisted_8$9 = { class: "dialog-title" };
    const _hoisted_9$8 = { class: "body" };
    const _hoisted_10$6 = { class: "dialog_search" };
    const _hoisted_11$6 = ["onKeydown"];
    const _hoisted_12$5 = ["disabled"];
    const _hoisted_13$5 = {
      key: 0,
      class: "dialog_search_error"
    };
    const _hoisted_14$4 = {
      key: 1,
      class: "dialog_search_count"
    };
    const _hoisted_15$4 = {
      key: 2,
      class: "dialog_search_loading"
    };
    const _hoisted_16$4 = {
      key: 3,
      class: "dialog_search_results_filters"
    };
    const _hoisted_17$3 = {
      key: 4,
      class: "striped dialog_search_results"
    };
    const _hoisted_18$2 = ["name", "id", "onClick"];
    const _hoisted_19$1 = ["for"];
    const _hoisted_20$1 = { class: "dialog_insert" };
    const _hoisted_21$1 = { class: "dialog_insert_msg" };
    const _hoisted_22$1 = {
      key: 0,
      class: "dialog_insert"
    };
    const _hoisted_23$1 = { class: "footer" };
    const _hoisted_24 = ["innerHTML"];
    const _hoisted_25 = ["disabled"];
    function _sfc_render$1d(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_dialog_box = resolveComponent("dialog-box");
      return openBlock(), createBlock(_component_dialog_box, {
        ref: "dialogComponent",
        class: "selector-dialog"
      }, {
        "dialog-anchor": withCtx(() => [
          !$props.multiple ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "field-preview",
            innerHTML: $setup.anchorLabel()
          }, null, 8, _hoisted_1$W)) : (openBlock(), createElementBlock("div", _hoisted_2$J, [
            !$setup.Common.isEmpty($setup.confirmedItem) ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList($setup.confirmedItem, (item) => {
              return openBlock(), createElementBlock("span", _hoisted_3$A, [
                createBaseVNode("span", {
                  innerHTML: $setup.anchorMultipleLabel(item)
                }, null, 8, _hoisted_4$p),
                createBaseVNode("i", {
                  class: "remove_item fa-solid fa-xmark",
                  onClick: ($event) => $setup.removeItem(item)
                }, null, 8, _hoisted_5$n)
              ]);
            }), 256)) : createCommentVNode("", true)
          ]))
        ]),
        "dialog-content": withCtx(() => [
          createBaseVNode("div", _hoisted_6$h, [
            createBaseVNode("div", _hoisted_7$d, [
              createBaseVNode("div", _hoisted_8$9, toDisplayString($setup.Locale.getLabel("modular-forms::common.select_item")), 1),
              createBaseVNode("button", {
                type: "button",
                class: "close",
                onClick: $setup.closeSelectorDialog
              }, _cache[2] || (_cache[2] = [
                createBaseVNode("i", { class: "fa fa-times black" }, null, -1)
              ]))
            ]),
            createBaseVNode("div", _hoisted_9$8, [
              withDirectives(createBaseVNode("div", _hoisted_10$6, [
                createBaseVNode("i", null, toDisplayString($setup.Locale.getLabel("modular-forms::common.search_item")) + ": ", 1),
                withDirectives(createBaseVNode("input", {
                  type: "text",
                  class: "field-edit dialog_search_by_key",
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.searchKey = $event),
                  onKeydown: withKeys(withModifiers($setup.applySearch, ["prevent"]), ["enter"])
                }, null, 40, _hoisted_11$6), [
                  [vModelText, $setup.searchKey]
                ]),
                renderSlot(_ctx.$slots, "searchFilters", {}, void 0, true),
                createBaseVNode("button", {
                  type: "button",
                  class: "btn-nav gray small",
                  onClick: $setup.applySearch,
                  disabled: !$setup.isSearchable
                }, toDisplayString($setup.Locale.getLabel("modular-forms::common.search")), 9, _hoisted_12$5),
                $setup.searchKey.length > 0 && $setup.searchKey.length < $props.keyMinLength ? (openBlock(), createElementBlock("div", _hoisted_13$5, [
                  createBaseVNode("i", null, toDisplayString($setup.keyLengthErrorMessage), 1)
                ])) : createCommentVNode("", true),
                $setup.searchExecuted ? (openBlock(), createElementBlock("div", _hoisted_14$4, [
                  createBaseVNode("b", null, toDisplayString($setup.totalCount) + " " + toDisplayString($setup.recordFoundLabel), 1),
                  _cache[3] || (_cache[3] = createBaseVNode("br", null, null, -1))
                ])) : createCommentVNode("", true),
                $setup.isSearching ? (openBlock(), createElementBlock("div", _hoisted_15$4, _cache[4] || (_cache[4] = [
                  createBaseVNode("br", null, null, -1),
                  createBaseVNode("i", { class: "fa fa-spinner fa-spin fa-2x primary-800" }, null, -1)
                ]))) : createCommentVNode("", true),
                $setup.searchExecuted ? (openBlock(), createElementBlock("div", _hoisted_16$4, [
                  renderSlot(_ctx.$slots, "searchResultFilters", {}, void 0, true)
                ])) : createCommentVNode("", true),
                $setup.searchExecuted ? (openBlock(), createElementBlock("table", _hoisted_17$3, [
                  createBaseVNode("thead", null, [
                    createBaseVNode("tr", null, [
                      _cache[5] || (_cache[5] = createBaseVNode("th", null, null, -1)),
                      renderSlot(_ctx.$slots, "searchResultHeader", {}, void 0, true)
                    ])
                  ]),
                  createBaseVNode("tbody", null, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList($setup.showList, (item, index) => {
                      return openBlock(), createElementBlock("tr", null, [
                        createBaseVNode("td", null, [
                          createBaseVNode("input", {
                            type: "radio",
                            name: $props.parentId + "_radio",
                            id: $props.parentId + "_radio" + index,
                            onClick: ($event) => $setup.selectResultItem(item)
                          }, null, 8, _hoisted_18$2),
                          createBaseVNode("label", {
                            for: $props.parentId + "_radio" + index
                          }, null, 8, _hoisted_19$1)
                        ]),
                        renderSlot(_ctx.$slots, "searchResultItem", { item }, void 0, true)
                      ]);
                    }), 256))
                  ])
                ])) : createCommentVNode("", true)
              ], 512), [
                [vShow, $setup.displaySearch]
              ]),
              withDirectives(createBaseVNode("div", _hoisted_20$1, [
                withDirectives(createBaseVNode("input", {
                  type: "text",
                  class: "field-edit dialog_insert_freetext",
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $setup.insertedItem = $event)
                }, null, 512), [
                  [vModelText, $setup.insertedItem]
                ]),
                createBaseVNode("div", _hoisted_21$1, [
                  createBaseVNode("i", null, toDisplayString($setup.Locale.getLabel("modular-forms::common.be_specific_as_possible")), 1)
                ])
              ], 512), [
                [vShow, $setup.displayInsertText]
              ]),
              $props.withId ? withDirectives((openBlock(), createElementBlock("div", _hoisted_22$1, [
                renderSlot(_ctx.$slots, "insertObject", { item: $setup.insertedItem }, void 0, true)
              ], 512)), [
                [vShow, $setup.displayInsertObject]
              ]) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", _hoisted_23$1, [
              withDirectives(createBaseVNode("button", {
                type: "button",
                class: "btn-nav dark small",
                onClick: $setup.enableInsert
              }, toDisplayString($setup.Locale.getLabel("modular-forms::common.add_if_not_found")), 513), [
                [vShow, $props.withInsert && $setup.displaySearch]
              ]),
              _cache[6] || (_cache[6] = createBaseVNode("div", { class: "spacer" }, null, -1)),
              createBaseVNode("div", {
                innerHTML: $setup.errorLabel,
                class: "error text-sm"
              }, null, 8, _hoisted_24),
              createBaseVNode("button", {
                type: "button",
                class: "btn-nav dark small",
                onClick: $setup.closeSelectorDialog
              }, toDisplayString($setup.Locale.getLabel("modular-forms::common.cancel")), 1),
              withDirectives(createBaseVNode("button", {
                type: "button",
                class: "btn-nav dark small",
                onClick: $setup.confirmInsert
              }, toDisplayString($setup.Locale.getLabel("modular-forms::common.add")), 513), [
                [vShow, $setup.displayInsertText || $setup.displayInsertObject]
              ]),
              withDirectives(createBaseVNode("button", {
                type: "button",
                class: "btn-nav dark small",
                disabled: $setup.selectedItem === null,
                onClick: $setup.confirmSelection
              }, toDisplayString($setup.Locale.getLabel("modular-forms::common.confirm_select")), 9, _hoisted_25), [
                [vShow, $setup.displaySearch]
              ])
            ])
          ])
        ]),
        _: 3
      }, 512);
    }
    const selectorDialog = /* @__PURE__ */ _export_sfc(_sfc_main$1d, [["render", _sfc_render$1d], ["__scopeId", "data-v-c95f5480"], ["__file", "/var/www/html/vendor/andreamarelli/modular-forms/src/resources/assets/js/inputs/components/selector-dialog.vue"]]);
    const min$2 = Math.min;
    const max$2 = Math.max;
    const round$2 = Math.round;
    const floor$1 = Math.floor;
    const createCoords = (v2) => ({
      x: v2,
      y: v2
    });
    const oppositeSideMap = {
      left: "right",
      right: "left",
      bottom: "top",
      top: "bottom"
    };
    const oppositeAlignmentMap = {
      start: "end",
      end: "start"
    };
    function clamp$1(start2, value, end2) {
      return max$2(start2, min$2(value, end2));
    }
    function evaluate(value, param) {
      return typeof value === "function" ? value(param) : value;
    }
    function getSide(placement) {
      return placement.split("-")[0];
    }
    function getAlignment(placement) {
      return placement.split("-")[1];
    }
    function getOppositeAxis(axis) {
      return axis === "x" ? "y" : "x";
    }
    function getAxisLength(axis) {
      return axis === "y" ? "height" : "width";
    }
    function getSideAxis(placement) {
      return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
    }
    function getAlignmentAxis(placement) {
      return getOppositeAxis(getSideAxis(placement));
    }
    function getAlignmentSides(placement, rects, rtl) {
      if (rtl === void 0) {
        rtl = false;
      }
      const alignment = getAlignment(placement);
      const alignmentAxis = getAlignmentAxis(placement);
      const length = getAxisLength(alignmentAxis);
      let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
      if (rects.reference[length] > rects.floating[length]) {
        mainAlignmentSide = getOppositePlacement$1(mainAlignmentSide);
      }
      return [mainAlignmentSide, getOppositePlacement$1(mainAlignmentSide)];
    }
    function getExpandedPlacements(placement) {
      const oppositePlacement = getOppositePlacement$1(placement);
      return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
    }
    function getOppositeAlignmentPlacement(placement) {
      return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
    }
    function getSideList(side, isStart, rtl) {
      const lr2 = ["left", "right"];
      const rl = ["right", "left"];
      const tb = ["top", "bottom"];
      const bt2 = ["bottom", "top"];
      switch (side) {
        case "top":
        case "bottom":
          if (rtl) return isStart ? rl : lr2;
          return isStart ? lr2 : rl;
        case "left":
        case "right":
          return isStart ? tb : bt2;
        default:
          return [];
      }
    }
    function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
      const alignment = getAlignment(placement);
      let list = getSideList(getSide(placement), direction === "start", rtl);
      if (alignment) {
        list = list.map((side) => side + "-" + alignment);
        if (flipAlignment) {
          list = list.concat(list.map(getOppositeAlignmentPlacement));
        }
      }
      return list;
    }
    function getOppositePlacement$1(placement) {
      return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
    }
    function expandPaddingObject(padding) {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        ...padding
      };
    }
    function getPaddingObject(padding) {
      return typeof padding !== "number" ? expandPaddingObject(padding) : {
        top: padding,
        right: padding,
        bottom: padding,
        left: padding
      };
    }
    function rectToClientRect$1(rect) {
      const {
        x: x2,
        y: y2,
        width,
        height
      } = rect;
      return {
        width,
        height,
        top: y2,
        left: x2,
        right: x2 + width,
        bottom: y2 + height,
        x: x2,
        y: y2
      };
    }
    function computeCoordsFromPlacement(_ref, placement, rtl) {
      let {
        reference: reference2,
        floating
      } = _ref;
      const sideAxis = getSideAxis(placement);
      const alignmentAxis = getAlignmentAxis(placement);
      const alignLength = getAxisLength(alignmentAxis);
      const side = getSide(placement);
      const isVertical = sideAxis === "y";
      const commonX = reference2.x + reference2.width / 2 - floating.width / 2;
      const commonY = reference2.y + reference2.height / 2 - floating.height / 2;
      const commonAlign = reference2[alignLength] / 2 - floating[alignLength] / 2;
      let coords;
      switch (side) {
        case "top":
          coords = {
            x: commonX,
            y: reference2.y - floating.height
          };
          break;
        case "bottom":
          coords = {
            x: commonX,
            y: reference2.y + reference2.height
          };
          break;
        case "right":
          coords = {
            x: reference2.x + reference2.width,
            y: commonY
          };
          break;
        case "left":
          coords = {
            x: reference2.x - floating.width,
            y: commonY
          };
          break;
        default:
          coords = {
            x: reference2.x,
            y: reference2.y
          };
      }
      switch (getAlignment(placement)) {
        case "start":
          coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
          break;
        case "end":
          coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
          break;
      }
      return coords;
    }
    const computePosition$1 = async (reference2, floating, config2) => {
      const {
        placement = "bottom",
        strategy = "absolute",
        middleware = [],
        platform: platform2
      } = config2;
      const validMiddleware = middleware.filter(Boolean);
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
      let rects = await platform2.getElementRects({
        reference: reference2,
        floating,
        strategy
      });
      let {
        x: x2,
        y: y2
      } = computeCoordsFromPlacement(rects, placement, rtl);
      let statefulPlacement = placement;
      let middlewareData = {};
      let resetCount = 0;
      for (let i2 = 0; i2 < validMiddleware.length; i2++) {
        const {
          name,
          fn: fn2
        } = validMiddleware[i2];
        const {
          x: nextX,
          y: nextY,
          data,
          reset
        } = await fn2({
          x: x2,
          y: y2,
          initialPlacement: placement,
          placement: statefulPlacement,
          strategy,
          middlewareData,
          rects,
          platform: platform2,
          elements: {
            reference: reference2,
            floating
          }
        });
        x2 = nextX != null ? nextX : x2;
        y2 = nextY != null ? nextY : y2;
        middlewareData = {
          ...middlewareData,
          [name]: {
            ...middlewareData[name],
            ...data
          }
        };
        if (reset && resetCount <= 50) {
          resetCount++;
          if (typeof reset === "object") {
            if (reset.placement) {
              statefulPlacement = reset.placement;
            }
            if (reset.rects) {
              rects = reset.rects === true ? await platform2.getElementRects({
                reference: reference2,
                floating,
                strategy
              }) : reset.rects;
            }
            ({
              x: x2,
              y: y2
            } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
          }
          i2 = -1;
        }
      }
      return {
        x: x2,
        y: y2,
        placement: statefulPlacement,
        strategy,
        middlewareData
      };
    };
    async function detectOverflow$1(state, options) {
      var _await$platform$isEle;
      if (options === void 0) {
        options = {};
      }
      const {
        x: x2,
        y: y2,
        platform: platform2,
        rects,
        elements: elements2,
        strategy
      } = state;
      const {
        boundary = "clippingAncestors",
        rootBoundary = "viewport",
        elementContext = "floating",
        altBoundary = false,
        padding = 0
      } = evaluate(options, state);
      const paddingObject = getPaddingObject(padding);
      const altContext = elementContext === "floating" ? "reference" : "floating";
      const element = elements2[altBoundary ? altContext : elementContext];
      const clippingClientRect = rectToClientRect$1(await platform2.getClippingRect({
        element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements2.floating)),
        boundary,
        rootBoundary,
        strategy
      }));
      const rect = elementContext === "floating" ? {
        x: x2,
        y: y2,
        width: rects.floating.width,
        height: rects.floating.height
      } : rects.reference;
      const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements2.floating));
      const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
        x: 1,
        y: 1
      } : {
        x: 1,
        y: 1
      };
      const elementClientRect = rectToClientRect$1(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
        elements: elements2,
        rect,
        offsetParent,
        strategy
      }) : rect);
      return {
        top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
        bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
        left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
        right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
      };
    }
    const arrow$3 = (options) => ({
      name: "arrow",
      options,
      async fn(state) {
        const {
          x: x2,
          y: y2,
          placement,
          rects,
          platform: platform2,
          elements: elements2,
          middlewareData
        } = state;
        const {
          element,
          padding = 0
        } = evaluate(options, state) || {};
        if (element == null) {
          return {};
        }
        const paddingObject = getPaddingObject(padding);
        const coords = {
          x: x2,
          y: y2
        };
        const axis = getAlignmentAxis(placement);
        const length = getAxisLength(axis);
        const arrowDimensions = await platform2.getDimensions(element);
        const isYAxis = axis === "y";
        const minProp = isYAxis ? "top" : "left";
        const maxProp = isYAxis ? "bottom" : "right";
        const clientProp = isYAxis ? "clientHeight" : "clientWidth";
        const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
        const startDiff = coords[axis] - rects.reference[axis];
        const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
        let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
        if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
          clientSize = elements2.floating[clientProp] || rects.floating[length];
        }
        const centerToReference = endDiff / 2 - startDiff / 2;
        const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
        const minPadding = min$2(paddingObject[minProp], largestPossiblePadding);
        const maxPadding = min$2(paddingObject[maxProp], largestPossiblePadding);
        const min$12 = minPadding;
        const max2 = clientSize - arrowDimensions[length] - maxPadding;
        const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
        const offset2 = clamp$1(min$12, center, max2);
        const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$12 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
        const alignmentOffset = shouldAddOffset ? center < min$12 ? center - min$12 : center - max2 : 0;
        return {
          [axis]: coords[axis] + alignmentOffset,
          data: {
            [axis]: offset2,
            centerOffset: center - offset2 - alignmentOffset,
            ...shouldAddOffset && {
              alignmentOffset
            }
          },
          reset: shouldAddOffset
        };
      }
    });
    const flip$5 = function(options) {
      if (options === void 0) {
        options = {};
      }
      return {
        name: "flip",
        options,
        async fn(state) {
          var _middlewareData$arrow, _middlewareData$flip;
          const {
            placement,
            middlewareData,
            rects,
            initialPlacement,
            platform: platform2,
            elements: elements2
          } = state;
          const {
            mainAxis: checkMainAxis = true,
            crossAxis: checkCrossAxis = true,
            fallbackPlacements: specifiedFallbackPlacements,
            fallbackStrategy = "bestFit",
            fallbackAxisSideDirection = "none",
            flipAlignment = true,
            ...detectOverflowOptions
          } = evaluate(options, state);
          if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
            return {};
          }
          const side = getSide(placement);
          const initialSideAxis = getSideAxis(initialPlacement);
          const isBasePlacement = getSide(initialPlacement) === initialPlacement;
          const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements2.floating));
          const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement$1(initialPlacement)] : getExpandedPlacements(initialPlacement));
          const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
          if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
            fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
          }
          const placements2 = [initialPlacement, ...fallbackPlacements];
          const overflow = await detectOverflow$1(state, detectOverflowOptions);
          const overflows = [];
          let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
          if (checkMainAxis) {
            overflows.push(overflow[side]);
          }
          if (checkCrossAxis) {
            const sides = getAlignmentSides(placement, rects, rtl);
            overflows.push(overflow[sides[0]], overflow[sides[1]]);
          }
          overflowsData = [...overflowsData, {
            placement,
            overflows
          }];
          if (!overflows.every((side2) => side2 <= 0)) {
            var _middlewareData$flip2, _overflowsData$filter;
            const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
            const nextPlacement = placements2[nextIndex];
            if (nextPlacement) {
              return {
                data: {
                  index: nextIndex,
                  overflows: overflowsData
                },
                reset: {
                  placement: nextPlacement
                }
              };
            }
            let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a2, b2) => a2.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
            if (!resetPlacement) {
              switch (fallbackStrategy) {
                case "bestFit": {
                  var _overflowsData$filter2;
                  const placement2 = (_overflowsData$filter2 = overflowsData.filter((d2) => {
                    if (hasFallbackAxisSideDirection) {
                      const currentSideAxis = getSideAxis(d2.placement);
                      return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                      // reading directions favoring greater width.
                      currentSideAxis === "y";
                    }
                    return true;
                  }).map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
                  if (placement2) {
                    resetPlacement = placement2;
                  }
                  break;
                }
                case "initialPlacement":
                  resetPlacement = initialPlacement;
                  break;
              }
            }
            if (placement !== resetPlacement) {
              return {
                reset: {
                  placement: resetPlacement
                }
              };
            }
          }
          return {};
        }
      };
    };
    async function convertValueToCoords(state, options) {
      const {
        placement,
        platform: platform2,
        elements: elements2
      } = state;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements2.floating));
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isVertical = getSideAxis(placement) === "y";
      const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
      const crossAxisMulti = rtl && isVertical ? -1 : 1;
      const rawValue = evaluate(options, state);
      let {
        mainAxis,
        crossAxis,
        alignmentAxis
      } = typeof rawValue === "number" ? {
        mainAxis: rawValue,
        crossAxis: 0,
        alignmentAxis: null
      } : {
        mainAxis: rawValue.mainAxis || 0,
        crossAxis: rawValue.crossAxis || 0,
        alignmentAxis: rawValue.alignmentAxis
      };
      if (alignment && typeof alignmentAxis === "number") {
        crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
      }
      return isVertical ? {
        x: crossAxis * crossAxisMulti,
        y: mainAxis * mainAxisMulti
      } : {
        x: mainAxis * mainAxisMulti,
        y: crossAxis * crossAxisMulti
      };
    }
    const offset$3 = function(options) {
      if (options === void 0) {
        options = 0;
      }
      return {
        name: "offset",
        options,
        async fn(state) {
          var _middlewareData$offse, _middlewareData$arrow;
          const {
            x: x2,
            y: y2,
            placement,
            middlewareData
          } = state;
          const diffCoords = await convertValueToCoords(state, options);
          if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
            return {};
          }
          return {
            x: x2 + diffCoords.x,
            y: y2 + diffCoords.y,
            data: {
              ...diffCoords,
              placement
            }
          };
        }
      };
    };
    const shift$1 = function(options) {
      if (options === void 0) {
        options = {};
      }
      return {
        name: "shift",
        options,
        async fn(state) {
          const {
            x: x2,
            y: y2,
            placement
          } = state;
          const {
            mainAxis: checkMainAxis = true,
            crossAxis: checkCrossAxis = false,
            limiter = {
              fn: (_ref) => {
                let {
                  x: x3,
                  y: y3
                } = _ref;
                return {
                  x: x3,
                  y: y3
                };
              }
            },
            ...detectOverflowOptions
          } = evaluate(options, state);
          const coords = {
            x: x2,
            y: y2
          };
          const overflow = await detectOverflow$1(state, detectOverflowOptions);
          const crossAxis = getSideAxis(getSide(placement));
          const mainAxis = getOppositeAxis(crossAxis);
          let mainAxisCoord = coords[mainAxis];
          let crossAxisCoord = coords[crossAxis];
          if (checkMainAxis) {
            const minSide = mainAxis === "y" ? "top" : "left";
            const maxSide = mainAxis === "y" ? "bottom" : "right";
            const min2 = mainAxisCoord + overflow[minSide];
            const max2 = mainAxisCoord - overflow[maxSide];
            mainAxisCoord = clamp$1(min2, mainAxisCoord, max2);
          }
          if (checkCrossAxis) {
            const minSide = crossAxis === "y" ? "top" : "left";
            const maxSide = crossAxis === "y" ? "bottom" : "right";
            const min2 = crossAxisCoord + overflow[minSide];
            const max2 = crossAxisCoord - overflow[maxSide];
            crossAxisCoord = clamp$1(min2, crossAxisCoord, max2);
          }
          const limitedCoords = limiter.fn({
            ...state,
            [mainAxis]: mainAxisCoord,
            [crossAxis]: crossAxisCoord
          });
          return {
            ...limitedCoords,
            data: {
              x: limitedCoords.x - x2,
              y: limitedCoords.y - y2,
              enabled: {
                [mainAxis]: checkMainAxis,
                [crossAxis]: checkCrossAxis
              }
            }
          };
        }
      };
    };
    function hasWindow() {
      return typeof window !== "undefined";
    }
    function getNodeName$1(node) {
      if (isNode$1(node)) {
        return (node.nodeName || "").toLowerCase();
      }
      return "#document";
    }
    function getWindow$2(node) {
      var _node$ownerDocument;
      return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
    }
    function getDocumentElement$1(node) {
      var _ref;
      return (_ref = (isNode$1(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
    }
    function isNode$1(value) {
      if (!hasWindow()) {
        return false;
      }
      return value instanceof Node || value instanceof getWindow$2(value).Node;
    }
    function isElement$4(value) {
      if (!hasWindow()) {
        return false;
      }
      return value instanceof Element || value instanceof getWindow$2(value).Element;
    }
    function isHTMLElement$1(value) {
      if (!hasWindow()) {
        return false;
      }
      return value instanceof HTMLElement || value instanceof getWindow$2(value).HTMLElement;
    }
    function isShadowRoot$1(value) {
      if (!hasWindow() || typeof ShadowRoot === "undefined") {
        return false;
      }
      return value instanceof ShadowRoot || value instanceof getWindow$2(value).ShadowRoot;
    }
    function isOverflowElement(element) {
      const {
        overflow,
        overflowX,
        overflowY,
        display
      } = getComputedStyle$2(element);
      return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
    }
    function isTableElement$1(element) {
      return ["table", "td", "th"].includes(getNodeName$1(element));
    }
    function isTopLayer(element) {
      return [":popover-open", ":modal"].some((selector) => {
        try {
          return element.matches(selector);
        } catch (e2) {
          return false;
        }
      });
    }
    function isContainingBlock(elementOrCss) {
      const webkit = isWebKit();
      const css = isElement$4(elementOrCss) ? getComputedStyle$2(elementOrCss) : elementOrCss;
      return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
    }
    function getContainingBlock$1(element) {
      let currentNode = getParentNode$1(element);
      while (isHTMLElement$1(currentNode) && !isLastTraversableNode(currentNode)) {
        if (isContainingBlock(currentNode)) {
          return currentNode;
        } else if (isTopLayer(currentNode)) {
          return null;
        }
        currentNode = getParentNode$1(currentNode);
      }
      return null;
    }
    function isWebKit() {
      if (typeof CSS === "undefined" || !CSS.supports) return false;
      return CSS.supports("-webkit-backdrop-filter", "none");
    }
    function isLastTraversableNode(node) {
      return ["html", "body", "#document"].includes(getNodeName$1(node));
    }
    function getComputedStyle$2(element) {
      return getWindow$2(element).getComputedStyle(element);
    }
    function getNodeScroll$1(element) {
      if (isElement$4(element)) {
        return {
          scrollLeft: element.scrollLeft,
          scrollTop: element.scrollTop
        };
      }
      return {
        scrollLeft: element.scrollX,
        scrollTop: element.scrollY
      };
    }
    function getParentNode$1(node) {
      if (getNodeName$1(node) === "html") {
        return node;
      }
      const result2 = (
        // Step into the shadow DOM of the parent of a slotted node.
        node.assignedSlot || // DOM Element detected.
        node.parentNode || // ShadowRoot detected.
        isShadowRoot$1(node) && node.host || // Fallback.
        getDocumentElement$1(node)
      );
      return isShadowRoot$1(result2) ? result2.host : result2;
    }
    function getNearestOverflowAncestor(node) {
      const parentNode = getParentNode$1(node);
      if (isLastTraversableNode(parentNode)) {
        return node.ownerDocument ? node.ownerDocument.body : node.body;
      }
      if (isHTMLElement$1(parentNode) && isOverflowElement(parentNode)) {
        return parentNode;
      }
      return getNearestOverflowAncestor(parentNode);
    }
    function getOverflowAncestors(node, list, traverseIframes) {
      var _node$ownerDocument2;
      if (list === void 0) {
        list = [];
      }
      if (traverseIframes === void 0) {
        traverseIframes = true;
      }
      const scrollableAncestor = getNearestOverflowAncestor(node);
      const isBody2 = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
      const win = getWindow$2(scrollableAncestor);
      if (isBody2) {
        const frameElement = getFrameElement(win);
        return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
      }
      return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
    }
    function getFrameElement(win) {
      return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
    }
    function getCssDimensions(element) {
      const css = getComputedStyle$2(element);
      let width = parseFloat(css.width) || 0;
      let height = parseFloat(css.height) || 0;
      const hasOffset = isHTMLElement$1(element);
      const offsetWidth = hasOffset ? element.offsetWidth : width;
      const offsetHeight = hasOffset ? element.offsetHeight : height;
      const shouldFallback = round$2(width) !== offsetWidth || round$2(height) !== offsetHeight;
      if (shouldFallback) {
        width = offsetWidth;
        height = offsetHeight;
      }
      return {
        width,
        height,
        $: shouldFallback
      };
    }
    function unwrapElement(element) {
      return !isElement$4(element) ? element.contextElement : element;
    }
    function getScale(element) {
      const domElement = unwrapElement(element);
      if (!isHTMLElement$1(domElement)) {
        return createCoords(1);
      }
      const rect = domElement.getBoundingClientRect();
      const {
        width,
        height,
        $: $2
      } = getCssDimensions(domElement);
      let x2 = ($2 ? round$2(rect.width) : rect.width) / width;
      let y2 = ($2 ? round$2(rect.height) : rect.height) / height;
      if (!x2 || !Number.isFinite(x2)) {
        x2 = 1;
      }
      if (!y2 || !Number.isFinite(y2)) {
        y2 = 1;
      }
      return {
        x: x2,
        y: y2
      };
    }
    const noOffsets = /* @__PURE__ */ createCoords(0);
    function getVisualOffsets(element) {
      const win = getWindow$2(element);
      if (!isWebKit() || !win.visualViewport) {
        return noOffsets;
      }
      return {
        x: win.visualViewport.offsetLeft,
        y: win.visualViewport.offsetTop
      };
    }
    function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
      if (isFixed === void 0) {
        isFixed = false;
      }
      if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow$2(element)) {
        return false;
      }
      return isFixed;
    }
    function getBoundingClientRect$1(element, includeScale, isFixedStrategy, offsetParent) {
      if (includeScale === void 0) {
        includeScale = false;
      }
      if (isFixedStrategy === void 0) {
        isFixedStrategy = false;
      }
      const clientRect = element.getBoundingClientRect();
      const domElement = unwrapElement(element);
      let scale = createCoords(1);
      if (includeScale) {
        if (offsetParent) {
          if (isElement$4(offsetParent)) {
            scale = getScale(offsetParent);
          }
        } else {
          scale = getScale(element);
        }
      }
      const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
      let x2 = (clientRect.left + visualOffsets.x) / scale.x;
      let y2 = (clientRect.top + visualOffsets.y) / scale.y;
      let width = clientRect.width / scale.x;
      let height = clientRect.height / scale.y;
      if (domElement) {
        const win = getWindow$2(domElement);
        const offsetWin = offsetParent && isElement$4(offsetParent) ? getWindow$2(offsetParent) : offsetParent;
        let currentWin = win;
        let currentIFrame = getFrameElement(currentWin);
        while (currentIFrame && offsetParent && offsetWin !== currentWin) {
          const iframeScale = getScale(currentIFrame);
          const iframeRect = currentIFrame.getBoundingClientRect();
          const css = getComputedStyle$2(currentIFrame);
          const left2 = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
          const top2 = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
          x2 *= iframeScale.x;
          y2 *= iframeScale.y;
          width *= iframeScale.x;
          height *= iframeScale.y;
          x2 += left2;
          y2 += top2;
          currentWin = getWindow$2(currentIFrame);
          currentIFrame = getFrameElement(currentWin);
        }
      }
      return rectToClientRect$1({
        width,
        height,
        x: x2,
        y: y2
      });
    }
    function getWindowScrollBarX$1(element, rect) {
      const leftScroll = getNodeScroll$1(element).scrollLeft;
      if (!rect) {
        return getBoundingClientRect$1(getDocumentElement$1(element)).left + leftScroll;
      }
      return rect.left + leftScroll;
    }
    function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
      if (ignoreScrollbarX === void 0) {
        ignoreScrollbarX = false;
      }
      const htmlRect = documentElement.getBoundingClientRect();
      const x2 = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
        // RTL <body> scrollbar.
        getWindowScrollBarX$1(documentElement, htmlRect)
      ));
      const y2 = htmlRect.top + scroll.scrollTop;
      return {
        x: x2,
        y: y2
      };
    }
    function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
      let {
        elements: elements2,
        rect,
        offsetParent,
        strategy
      } = _ref;
      const isFixed = strategy === "fixed";
      const documentElement = getDocumentElement$1(offsetParent);
      const topLayer = elements2 ? isTopLayer(elements2.floating) : false;
      if (offsetParent === documentElement || topLayer && isFixed) {
        return rect;
      }
      let scroll = {
        scrollLeft: 0,
        scrollTop: 0
      };
      let scale = createCoords(1);
      const offsets = createCoords(0);
      const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
      if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if (getNodeName$1(offsetParent) !== "body" || isOverflowElement(documentElement)) {
          scroll = getNodeScroll$1(offsetParent);
        }
        if (isHTMLElement$1(offsetParent)) {
          const offsetRect = getBoundingClientRect$1(offsetParent);
          scale = getScale(offsetParent);
          offsets.x = offsetRect.x + offsetParent.clientLeft;
          offsets.y = offsetRect.y + offsetParent.clientTop;
        }
      }
      const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
      return {
        width: rect.width * scale.x,
        height: rect.height * scale.y,
        x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
        y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
      };
    }
    function getClientRects(element) {
      return Array.from(element.getClientRects());
    }
    function getDocumentRect$1(element) {
      const html2 = getDocumentElement$1(element);
      const scroll = getNodeScroll$1(element);
      const body = element.ownerDocument.body;
      const width = max$2(html2.scrollWidth, html2.clientWidth, body.scrollWidth, body.clientWidth);
      const height = max$2(html2.scrollHeight, html2.clientHeight, body.scrollHeight, body.clientHeight);
      let x2 = -scroll.scrollLeft + getWindowScrollBarX$1(element);
      const y2 = -scroll.scrollTop;
      if (getComputedStyle$2(body).direction === "rtl") {
        x2 += max$2(html2.clientWidth, body.clientWidth) - width;
      }
      return {
        width,
        height,
        x: x2,
        y: y2
      };
    }
    function getViewportRect$1(element, strategy) {
      const win = getWindow$2(element);
      const html2 = getDocumentElement$1(element);
      const visualViewport = win.visualViewport;
      let width = html2.clientWidth;
      let height = html2.clientHeight;
      let x2 = 0;
      let y2 = 0;
      if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height;
        const visualViewportBased = isWebKit();
        if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
          x2 = visualViewport.offsetLeft;
          y2 = visualViewport.offsetTop;
        }
      }
      return {
        width,
        height,
        x: x2,
        y: y2
      };
    }
    function getInnerBoundingClientRect$1(element, strategy) {
      const clientRect = getBoundingClientRect$1(element, true, strategy === "fixed");
      const top2 = clientRect.top + element.clientTop;
      const left2 = clientRect.left + element.clientLeft;
      const scale = isHTMLElement$1(element) ? getScale(element) : createCoords(1);
      const width = element.clientWidth * scale.x;
      const height = element.clientHeight * scale.y;
      const x2 = left2 * scale.x;
      const y2 = top2 * scale.y;
      return {
        width,
        height,
        x: x2,
        y: y2
      };
    }
    function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
      let rect;
      if (clippingAncestor === "viewport") {
        rect = getViewportRect$1(element, strategy);
      } else if (clippingAncestor === "document") {
        rect = getDocumentRect$1(getDocumentElement$1(element));
      } else if (isElement$4(clippingAncestor)) {
        rect = getInnerBoundingClientRect$1(clippingAncestor, strategy);
      } else {
        const visualOffsets = getVisualOffsets(element);
        rect = {
          x: clippingAncestor.x - visualOffsets.x,
          y: clippingAncestor.y - visualOffsets.y,
          width: clippingAncestor.width,
          height: clippingAncestor.height
        };
      }
      return rectToClientRect$1(rect);
    }
    function hasFixedPositionAncestor(element, stopNode) {
      const parentNode = getParentNode$1(element);
      if (parentNode === stopNode || !isElement$4(parentNode) || isLastTraversableNode(parentNode)) {
        return false;
      }
      return getComputedStyle$2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
    }
    function getClippingElementAncestors(element, cache2) {
      const cachedResult = cache2.get(element);
      if (cachedResult) {
        return cachedResult;
      }
      let result2 = getOverflowAncestors(element, [], false).filter((el) => isElement$4(el) && getNodeName$1(el) !== "body");
      let currentContainingBlockComputedStyle = null;
      const elementIsFixed = getComputedStyle$2(element).position === "fixed";
      let currentNode = elementIsFixed ? getParentNode$1(element) : element;
      while (isElement$4(currentNode) && !isLastTraversableNode(currentNode)) {
        const computedStyle = getComputedStyle$2(currentNode);
        const currentNodeIsContaining = isContainingBlock(currentNode);
        if (!currentNodeIsContaining && computedStyle.position === "fixed") {
          currentContainingBlockComputedStyle = null;
        }
        const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
        if (shouldDropCurrentNode) {
          result2 = result2.filter((ancestor) => ancestor !== currentNode);
        } else {
          currentContainingBlockComputedStyle = computedStyle;
        }
        currentNode = getParentNode$1(currentNode);
      }
      cache2.set(element, result2);
      return result2;
    }
    function getClippingRect$1(_ref) {
      let {
        element,
        boundary,
        rootBoundary,
        strategy
      } = _ref;
      const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
      const clippingAncestors = [...elementClippingAncestors, rootBoundary];
      const firstClippingAncestor = clippingAncestors[0];
      const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
        const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
        accRect.top = max$2(rect.top, accRect.top);
        accRect.right = min$2(rect.right, accRect.right);
        accRect.bottom = min$2(rect.bottom, accRect.bottom);
        accRect.left = max$2(rect.left, accRect.left);
        return accRect;
      }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
      return {
        width: clippingRect.right - clippingRect.left,
        height: clippingRect.bottom - clippingRect.top,
        x: clippingRect.left,
        y: clippingRect.top
      };
    }
    function getDimensions(element) {
      const {
        width,
        height
      } = getCssDimensions(element);
      return {
        width,
        height
      };
    }
    function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
      const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
      const documentElement = getDocumentElement$1(offsetParent);
      const isFixed = strategy === "fixed";
      const rect = getBoundingClientRect$1(element, true, isFixed, offsetParent);
      let scroll = {
        scrollLeft: 0,
        scrollTop: 0
      };
      const offsets = createCoords(0);
      if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if (getNodeName$1(offsetParent) !== "body" || isOverflowElement(documentElement)) {
          scroll = getNodeScroll$1(offsetParent);
        }
        if (isOffsetParentAnElement) {
          const offsetRect = getBoundingClientRect$1(offsetParent, true, isFixed, offsetParent);
          offsets.x = offsetRect.x + offsetParent.clientLeft;
          offsets.y = offsetRect.y + offsetParent.clientTop;
        } else if (documentElement) {
          offsets.x = getWindowScrollBarX$1(documentElement);
        }
      }
      const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
      const x2 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
      const y2 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
      return {
        x: x2,
        y: y2,
        width: rect.width,
        height: rect.height
      };
    }
    function isStaticPositioned(element) {
      return getComputedStyle$2(element).position === "static";
    }
    function getTrueOffsetParent$1(element, polyfill) {
      if (!isHTMLElement$1(element) || getComputedStyle$2(element).position === "fixed") {
        return null;
      }
      if (polyfill) {
        return polyfill(element);
      }
      let rawOffsetParent = element.offsetParent;
      if (getDocumentElement$1(element) === rawOffsetParent) {
        rawOffsetParent = rawOffsetParent.ownerDocument.body;
      }
      return rawOffsetParent;
    }
    function getOffsetParent$1(element, polyfill) {
      const win = getWindow$2(element);
      if (isTopLayer(element)) {
        return win;
      }
      if (!isHTMLElement$1(element)) {
        let svgOffsetParent = getParentNode$1(element);
        while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
          if (isElement$4(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
            return svgOffsetParent;
          }
          svgOffsetParent = getParentNode$1(svgOffsetParent);
        }
        return win;
      }
      let offsetParent = getTrueOffsetParent$1(element, polyfill);
      while (offsetParent && isTableElement$1(offsetParent) && isStaticPositioned(offsetParent)) {
        offsetParent = getTrueOffsetParent$1(offsetParent, polyfill);
      }
      if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
        return win;
      }
      return offsetParent || getContainingBlock$1(element) || win;
    }
    const getElementRects = async function(data) {
      const getOffsetParentFn = this.getOffsetParent || getOffsetParent$1;
      const getDimensionsFn = this.getDimensions;
      const floatingDimensions = await getDimensionsFn(data.floating);
      return {
        reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
        floating: {
          x: 0,
          y: 0,
          width: floatingDimensions.width,
          height: floatingDimensions.height
        }
      };
    };
    function isRTL(element) {
      return getComputedStyle$2(element).direction === "rtl";
    }
    const platform = {
      convertOffsetParentRelativeRectToViewportRelativeRect,
      getDocumentElement: getDocumentElement$1,
      getClippingRect: getClippingRect$1,
      getOffsetParent: getOffsetParent$1,
      getElementRects,
      getClientRects,
      getDimensions,
      getScale,
      isElement: isElement$4,
      isRTL
    };
    function observeMove(element, onMove) {
      let io2 = null;
      let timeoutId;
      const root2 = getDocumentElement$1(element);
      function cleanup() {
        var _io;
        clearTimeout(timeoutId);
        (_io = io2) == null || _io.disconnect();
        io2 = null;
      }
      function refresh(skip, threshold) {
        if (skip === void 0) {
          skip = false;
        }
        if (threshold === void 0) {
          threshold = 1;
        }
        cleanup();
        const {
          left: left2,
          top: top2,
          width,
          height
        } = element.getBoundingClientRect();
        if (!skip) {
          onMove();
        }
        if (!width || !height) {
          return;
        }
        const insetTop = floor$1(top2);
        const insetRight = floor$1(root2.clientWidth - (left2 + width));
        const insetBottom = floor$1(root2.clientHeight - (top2 + height));
        const insetLeft = floor$1(left2);
        const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
        const options = {
          rootMargin,
          threshold: max$2(0, min$2(1, threshold)) || 1
        };
        let isFirstUpdate = true;
        function handleObserve(entries) {
          const ratio = entries[0].intersectionRatio;
          if (ratio !== threshold) {
            if (!isFirstUpdate) {
              return refresh();
            }
            if (!ratio) {
              timeoutId = setTimeout(() => {
                refresh(false, 1e-7);
              }, 1e3);
            } else {
              refresh(false, ratio);
            }
          }
          isFirstUpdate = false;
        }
        try {
          io2 = new IntersectionObserver(handleObserve, {
            ...options,
            // Handle <iframe>s
            root: root2.ownerDocument
          });
        } catch (e2) {
          io2 = new IntersectionObserver(handleObserve, options);
        }
        io2.observe(element);
      }
      refresh(true);
      return cleanup;
    }
    function autoUpdate(reference2, floating, update2, options) {
      if (options === void 0) {
        options = {};
      }
      const {
        ancestorScroll = true,
        ancestorResize = true,
        elementResize = typeof ResizeObserver === "function",
        layoutShift = typeof IntersectionObserver === "function",
        animationFrame = false
      } = options;
      const referenceEl = unwrapElement(reference2);
      const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
      ancestors.forEach((ancestor) => {
        ancestorScroll && ancestor.addEventListener("scroll", update2, {
          passive: true
        });
        ancestorResize && ancestor.addEventListener("resize", update2);
      });
      const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update2) : null;
      let reobserveFrame = -1;
      let resizeObserver = null;
      if (elementResize) {
        resizeObserver = new ResizeObserver((_ref) => {
          let [firstEntry] = _ref;
          if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
            resizeObserver.unobserve(floating);
            cancelAnimationFrame(reobserveFrame);
            reobserveFrame = requestAnimationFrame(() => {
              var _resizeObserver;
              (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
            });
          }
          update2();
        });
        if (referenceEl && !animationFrame) {
          resizeObserver.observe(referenceEl);
        }
        resizeObserver.observe(floating);
      }
      let frameId;
      let prevRefRect = animationFrame ? getBoundingClientRect$1(reference2) : null;
      if (animationFrame) {
        frameLoop();
      }
      function frameLoop() {
        const nextRefRect = getBoundingClientRect$1(reference2);
        if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
          update2();
        }
        prevRefRect = nextRefRect;
        frameId = requestAnimationFrame(frameLoop);
      }
      update2();
      return () => {
        var _resizeObserver2;
        ancestors.forEach((ancestor) => {
          ancestorScroll && ancestor.removeEventListener("scroll", update2);
          ancestorResize && ancestor.removeEventListener("resize", update2);
        });
        cleanupIo == null || cleanupIo();
        (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
        resizeObserver = null;
        if (animationFrame) {
          cancelAnimationFrame(frameId);
        }
      };
    }
    const offset$2 = offset$3;
    const shift = shift$1;
    const flip$4 = flip$5;
    const arrow$2 = arrow$3;
    const computePosition = (reference2, floating, options) => {
      const cache2 = /* @__PURE__ */ new Map();
      const mergedOptions = {
        platform,
        ...options
      };
      const platformWithCache = {
        ...mergedOptions.platform,
        _c: cache2
      };
      return computePosition$1(reference2, floating, {
        ...mergedOptions,
        platform: platformWithCache
      });
    };
    const _sfc_main$1c = {
      props: {
        anchorElemId: {
          type: String,
          default: null
        },
        onClick: {
          type: Boolean,
          default: false
        }
      },
      setup(props) {
        const tooltipElem = ref(null);
        const arrowElem = ref(null);
        const anchorElem = ref(null);
        const state = reactive({
          isVisible: false
        });
        onMounted(() => {
          anchorElem.value = props.anchorElemId !== null ? document.querySelector("#" + props.anchorElemId) : tooltipElem.value.previousElementSibling;
          if (props.onClick) {
            enableClickListeners();
          } else {
            enableHoverListeners();
          }
        });
        const enableHoverListeners = () => {
          [
            ["mouseenter", showTooltip],
            ["mouseleave", hideTooltip],
            ["focus", hideTooltip],
            ["blur", hideTooltip]
          ].forEach(([event, listener]) => {
            anchorElem.value.addEventListener(event, listener);
          });
        };
        const enableClickListeners = () => {
          anchorElem.value.addEventListener("click", toggleTooltip);
          document.addEventListener("click", function(evt) {
            if (state.isVisible) {
              let clickedElem = evt.target;
              if (clickedElem.closest("[role=tooltip]") == null && clickedElem.closest("#" + props.anchorElemId) == null) {
                hideTooltip();
              }
            }
          });
        };
        const setTooltipPosition = () => {
          autoUpdate(anchorElem.value, tooltipElem.value, () => {
            if (anchorElem.value !== null && arrowElem.value !== null) {
              const arrowWidth = arrowElem.value.offsetWidth;
              const floatingOffset = Math.sqrt(2 * arrowWidth ** 2) / 2;
              computePosition(anchorElem.value, tooltipElem.value, {
                placement: "top",
                middleware: [
                  flip$4(),
                  shift({
                    padding: 5
                  }),
                  offset$2({
                    mainAxis: floatingOffset
                  }),
                  arrow$2({ element: arrowElem.value })
                ]
              }).then(({ x: x2, y: y2, placement, middlewareData }) => {
                Object.assign(tooltipElem.value.style, {
                  left: `${x2}px`,
                  top: `${y2}px`
                });
                if (middlewareData.arrow) {
                  const { x: x3, y: y3 } = middlewareData.arrow;
                  const staticSide = {
                    top: "bottom",
                    right: "left",
                    bottom: "top",
                    left: "right"
                  }[placement.split("-")[0]];
                  Object.assign(arrowElem.value.style, {
                    left: x3 != null ? `${x3}px` : "",
                    top: y3 != null ? `${y3}px` : "",
                    right: "",
                    bottom: "",
                    [staticSide]: `${-arrowElem.value.offsetWidth / 2}px`
                  });
                }
              });
            }
          });
        };
        const toggleTooltip = () => {
          if (state.isVisible) {
            hideTooltip();
          } else {
            showTooltip();
          }
        };
        const showTooltip = () => {
          if (!state.isVisible) {
            let content = tooltipElem.value.querySelector(".tooltip-content").textContent.trim();
            if (content !== "") {
              tooltipElem.value.style.display = "block";
              setTooltipPosition();
              state.isVisible = true;
              if (!props.onClick) {
                setTimeout(function() {
                  hideTooltip();
                }, 1e4);
              }
            }
          }
        };
        const hideTooltip = () => {
          if (state.isVisible) {
            tooltipElem.value.style.display = "";
            state.isVisible = false;
          }
        };
        return {
          tooltipElem,
          arrowElem
          // state
        };
      }
    };
    const _hoisted_1$V = {
      ref: "tooltipElem",
      role: "tooltip"
    };
    const _hoisted_2$I = { class: "tooltip-content" };
    const _hoisted_3$z = {
      ref: "arrowElem",
      class: "tooltip-arrow"
    };
    function _sfc_render$1c(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", _hoisted_1$V, [
        createBaseVNode("div", _hoisted_2$I, [
          renderSlot(_ctx.$slots, "default", {}, void 0, true)
        ]),
        createBaseVNode("div", _hoisted_3$z, null, 512)
      ], 512);
    }
    const tooltip = /* @__PURE__ */ _export_sfc(_sfc_main$1c, [["render", _sfc_render$1c], ["__scopeId", "data-v-09ff0b06"], ["__file", "/var/www/html/vendor/andreamarelli/modular-forms/src/resources/assets/js/templates/tooltip.vue"]]);
    const _sfc_main$1b = {
      __name: "dialog_box",
      setup(__props, { expose: __expose }) {
        const anchorElem = ref(null);
        const dialogOverlayElem = ref(null);
        const dialogContentElem = ref(null);
        const originalBodyOverflow = ref(null);
        __expose({
          openDialog,
          closeDialog
        });
        onMounted(() => {
          originalBodyOverflow.value = dialogOverlayElem.value.style.overflow;
          anchorElem.value.addEventListener("click", function(evt) {
            let clickedElem = evt.target;
            if (!clickedElem.classList.contains("dontOpenDialog") && clickedElem.closest(".dontOpenDialog") == null) {
              openDialog();
            }
          });
          dialogOverlayElem.value.addEventListener("click", function(evt) {
            let clickedElem = evt.target;
            if (clickedElem.closest(".dialog-content") == null) {
              closeDialog();
            }
          });
          dialogContentElem.value.querySelectorAll('[role="closeDialog"]').forEach(function(item) {
            item.addEventListener("click", closeDialog);
          });
        });
        function openDialog() {
          document.querySelector("body").style.overflow = "hidden";
          dialogOverlayElem.value.classList.add("visible");
          dialogContentElem.value.classList.add("visible");
        }
        function closeDialog() {
          document.querySelector("body").style.overflow = originalBodyOverflow.value;
          dialogContentElem.value.classList.remove("visible");
          dialogOverlayElem.value.classList.remove("visible");
        }
        const __returned__ = { anchorElem, dialogOverlayElem, dialogContentElem, originalBodyOverflow, openDialog, closeDialog, onMounted, ref };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$U = { role: "dialog" };
    const _hoisted_2$H = {
      ref: "anchorElem",
      class: "dialog-anchor"
    };
    const _hoisted_3$y = {
      ref: "dialogOverlayElem",
      class: "dialog-overlay"
    };
    const _hoisted_4$o = {
      ref: "dialogContentElem",
      class: "dialog-content"
    };
    function _sfc_render$1b(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", _hoisted_1$U, [
        createBaseVNode("div", _hoisted_2$H, [
          renderSlot(_ctx.$slots, "dialog-anchor", {}, void 0, true)
        ], 512),
        createBaseVNode("div", _hoisted_3$y, [
          createBaseVNode("div", _hoisted_4$o, [
            renderSlot(_ctx.$slots, "dialog-content", {}, void 0, true)
          ], 512)
        ], 512)
      ]);
    }
    const dialogBox = /* @__PURE__ */ _export_sfc(_sfc_main$1b, [["render", _sfc_render$1b], ["__scopeId", "data-v-903b9ef3"], ["__file", "/var/www/html/vendor/andreamarelli/modular-forms/src/resources/assets/js/templates/dialog_box.vue"]]);
    function useList$1(component_data) {
      const sortBy2 = ref(component_data.sortBy || null);
      const sortDir = ref(component_data.sortDir || "asc");
      function sortList(items) {
        return sortBy2 !== null ? sorter(items) : items;
      }
      function sorter(data) {
        return data.sort(function(a2, b2) {
          let dir = sortDir.value === "asc" ? 1 : -1;
          let text_a = getAttribute(a2, sortBy2.value || "");
          let text_b = getAttribute(b2, sortBy2.value || "");
          if (typeof text_a !== "undefined" && typeof text_b !== "undefined") {
            if (text_a.toString().toLowerCase() > text_b.toString().toLowerCase()) {
              return dir;
            }
            if (text_a.toString().toLowerCase() < text_b.toString().toLowerCase()) {
              return -1 * dir;
            }
          }
          return 0;
        });
      }
      function filterByAttribute2(items, filter_value, filter_on) {
        filter_value = filter_value === "" || filter_value === "null" ? null : filter_value;
        if (filter_value !== null) {
          items = items.filter((item) => {
            let value = getAttribute(item, filter_on);
            if (value.toString().toLowerCase() === filter_value.toString().toLowerCase()) {
              return true;
            }
          });
        }
        return items;
      }
      function getAttribute(item, attribute) {
        let value = null;
        if (attribute.includes(".")) {
          let path = attribute.split(".");
          value = item;
          for (let i2 = 0; i2 < path.length; ++i2) {
            value = value.hasOwnProperty(path[i2]) ? value[path[i2]] : "";
          }
        } else {
          value = item[attribute];
        }
        value = value === null ? "" : value;
        return value;
      }
      return {
        sortList,
        filterByAttribute: filterByAttribute2
      };
    }
    var E$2 = Object.defineProperty, M$2 = Object.defineProperties;
    var x$2 = Object.getOwnPropertyDescriptors;
    var V$2 = Object.getOwnPropertySymbols;
    var I$2 = Object.prototype.hasOwnProperty, N$2 = Object.prototype.propertyIsEnumerable;
    var C$2 = (e2, t2, s2) => t2 in e2 ? E$2(e2, t2, { enumerable: true, configurable: true, writable: true, value: s2 }) : e2[t2] = s2, f$2 = (e2, t2) => {
      for (var s2 in t2 || (t2 = {}))
        I$2.call(t2, s2) && C$2(e2, s2, t2[s2]);
      if (V$2)
        for (var s2 of V$2(t2))
          N$2.call(t2, s2) && C$2(e2, s2, t2[s2]);
      return e2;
    }, m$2 = (e2, t2) => M$2(e2, x$2(t2));
    const U$1 = {
      props: {
        autoscroll: {
          type: Boolean,
          default: true
        }
      },
      watch: {
        typeAheadPointer() {
          this.autoscroll && this.maybeAdjustScroll();
        },
        open(e2) {
          this.autoscroll && e2 && this.$nextTick(() => this.maybeAdjustScroll());
        }
      },
      methods: {
        maybeAdjustScroll() {
          var t2;
          const e2 = ((t2 = this.$refs.dropdownMenu) == null ? void 0 : t2.children[this.typeAheadPointer]) || false;
          if (e2) {
            const s2 = this.getDropdownViewport(), { top: n2, bottom: l2, height: i2 } = e2.getBoundingClientRect();
            if (n2 < s2.top)
              return this.$refs.dropdownMenu.scrollTop = e2.offsetTop;
            if (l2 > s2.bottom)
              return this.$refs.dropdownMenu.scrollTop = e2.offsetTop - (s2.height - i2);
          }
        },
        getDropdownViewport() {
          return this.$refs.dropdownMenu ? this.$refs.dropdownMenu.getBoundingClientRect() : {
            height: 0,
            top: 0,
            bottom: 0
          };
        }
      }
    }, q$3 = {
      data() {
        return {
          typeAheadPointer: -1
        };
      },
      watch: {
        filteredOptions() {
          for (let e2 = 0; e2 < this.filteredOptions.length; e2++)
            if (this.selectable(this.filteredOptions[e2])) {
              this.typeAheadPointer = e2;
              break;
            }
        },
        open(e2) {
          e2 && this.typeAheadToLastSelected();
        },
        selectedValue() {
          this.open && this.typeAheadToLastSelected();
        }
      },
      methods: {
        typeAheadUp() {
          for (let e2 = this.typeAheadPointer - 1; e2 >= 0; e2--)
            if (this.selectable(this.filteredOptions[e2])) {
              this.typeAheadPointer = e2;
              break;
            }
        },
        typeAheadDown() {
          for (let e2 = this.typeAheadPointer + 1; e2 < this.filteredOptions.length; e2++)
            if (this.selectable(this.filteredOptions[e2])) {
              this.typeAheadPointer = e2;
              break;
            }
        },
        typeAheadSelect() {
          const e2 = this.filteredOptions[this.typeAheadPointer];
          e2 && this.selectable(e2) && this.select(e2);
        },
        typeAheadToLastSelected() {
          this.typeAheadPointer = this.selectedValue.length !== 0 ? this.filteredOptions.indexOf(this.selectedValue[this.selectedValue.length - 1]) : -1;
        }
      }
    }, J$2 = {
      props: {
        loading: {
          type: Boolean,
          default: false
        }
      },
      data() {
        return {
          mutableLoading: false
        };
      },
      watch: {
        search() {
          this.$emit("search", this.search, this.toggleLoading);
        },
        loading(e2) {
          this.mutableLoading = e2;
        }
      },
      methods: {
        toggleLoading(e2 = null) {
          return e2 == null ? this.mutableLoading = !this.mutableLoading : this.mutableLoading = e2;
        }
      }
    }, S$2 = (e2, t2) => {
      const s2 = e2.__vccOpts || e2;
      for (const [n2, l2] of t2)
        s2[n2] = l2;
      return s2;
    }, H$1 = {}, X$1 = {
      xmlns: "http://www.w3.org/2000/svg",
      width: "10",
      height: "10"
    }, Y$2 = /* @__PURE__ */ createBaseVNode("path", { d: "M6.895455 5l2.842897-2.842898c.348864-.348863.348864-.914488 0-1.263636L9.106534.261648c-.348864-.348864-.914489-.348864-1.263636 0L5 3.104545 2.157102.261648c-.348863-.348864-.914488-.348864-1.263636 0L.261648.893466c-.348864.348864-.348864.914489 0 1.263636L3.104545 5 .261648 7.842898c-.348864.348863-.348864.914488 0 1.263636l.631818.631818c.348864.348864.914773.348864 1.263636 0L5 6.895455l2.842898 2.842897c.348863.348864.914772.348864 1.263636 0l.631818-.631818c.348864-.348864.348864-.914489 0-1.263636L6.895455 5z" }, null, -1), Q$1 = [
      Y$2
    ];
    function G$1(e2, t2) {
      return openBlock(), createElementBlock("svg", X$1, Q$1);
    }
    const W$2 = /* @__PURE__ */ S$2(H$1, [["render", G$1]]), Z$1 = {}, ee$1 = {
      xmlns: "http://www.w3.org/2000/svg",
      width: "14",
      height: "10"
    }, te$1 = /* @__PURE__ */ createBaseVNode("path", { d: "M9.211364 7.59931l4.48338-4.867229c.407008-.441854.407008-1.158247 0-1.60046l-.73712-.80023c-.407008-.441854-1.066904-.441854-1.474243 0L7 5.198617 2.51662.33139c-.407008-.441853-1.066904-.441853-1.474243 0l-.737121.80023c-.407008.441854-.407008 1.158248 0 1.600461l4.48338 4.867228L7 10l2.211364-2.40069z" }, null, -1), se$1 = [
      te$1
    ];
    function ie$1(e2, t2) {
      return openBlock(), createElementBlock("svg", ee$1, se$1);
    }
    const oe$1 = /* @__PURE__ */ S$2(Z$1, [["render", ie$1]]), T$2 = {
      Deselect: W$2,
      OpenIndicator: oe$1
    }, ne$1 = {
      mounted(e2, { instance: t2 }) {
        if (t2.appendToBody) {
          const {
            height: s2,
            top: n2,
            left: l2,
            width: i2
          } = t2.$refs.toggle.getBoundingClientRect();
          let y2 = window.scrollX || window.pageXOffset, o2 = window.scrollY || window.pageYOffset;
          e2.unbindPosition = t2.calculatePosition(e2, t2, {
            width: i2 + "px",
            left: y2 + l2 + "px",
            top: o2 + n2 + s2 + "px"
          }), document.body.appendChild(e2);
        }
      },
      unmounted(e2, { instance: t2 }) {
        t2.appendToBody && (e2.unbindPosition && typeof e2.unbindPosition == "function" && e2.unbindPosition(), e2.parentNode && e2.parentNode.removeChild(e2));
      }
    };
    function le$1(e2) {
      const t2 = {};
      return Object.keys(e2).sort().forEach((s2) => {
        t2[s2] = e2[s2];
      }), JSON.stringify(t2);
    }
    let ae$1 = 0;
    function re$2() {
      return ++ae$1;
    }
    const de$2 = {
      components: f$2({}, T$2),
      directives: { appendToBody: ne$1 },
      mixins: [U$1, q$3, J$2],
      compatConfig: {
        MODE: 3
      },
      emits: [
        "open",
        "close",
        "update:modelValue",
        "search",
        "search:compositionstart",
        "search:compositionend",
        "search:keydown",
        "search:blur",
        "search:focus",
        "search:input",
        "option:created",
        "option:selecting",
        "option:selected",
        "option:deselecting",
        "option:deselected"
      ],
      props: {
        modelValue: {},
        components: {
          type: Object,
          default: () => ({})
        },
        options: {
          type: Array,
          default() {
            return [];
          }
        },
        disabled: {
          type: Boolean,
          default: false
        },
        clearable: {
          type: Boolean,
          default: true
        },
        deselectFromDropdown: {
          type: Boolean,
          default: false
        },
        searchable: {
          type: Boolean,
          default: true
        },
        multiple: {
          type: Boolean,
          default: false
        },
        placeholder: {
          type: String,
          default: ""
        },
        transition: {
          type: String,
          default: "vs__fade"
        },
        clearSearchOnSelect: {
          type: Boolean,
          default: true
        },
        closeOnSelect: {
          type: Boolean,
          default: true
        },
        label: {
          type: String,
          default: "label"
        },
        autocomplete: {
          type: String,
          default: "off"
        },
        reduce: {
          type: Function,
          default: (e2) => e2
        },
        selectable: {
          type: Function,
          default: (e2) => true
        },
        getOptionLabel: {
          type: Function,
          default(e2) {
            return typeof e2 == "object" ? e2.hasOwnProperty(this.label) ? e2[this.label] : console.warn(`[vue-select warn]: Label key "option.${this.label}" does not exist in options object ${JSON.stringify(e2)}.
https://vue-select.org/api/props.html#getoptionlabel`) : e2;
          }
        },
        getOptionKey: {
          type: Function,
          default(e2) {
            if (typeof e2 != "object")
              return e2;
            try {
              return e2.hasOwnProperty("id") ? e2.id : le$1(e2);
            } catch (t2) {
              return console.warn(`[vue-select warn]: Could not stringify this option to generate unique key. Please provide'getOptionKey' prop to return a unique key for each option.
https://vue-select.org/api/props.html#getoptionkey`, e2, t2);
            }
          }
        },
        onTab: {
          type: Function,
          default: function() {
            this.selectOnTab && !this.isComposing && this.typeAheadSelect();
          }
        },
        taggable: {
          type: Boolean,
          default: false
        },
        tabindex: {
          type: Number,
          default: null
        },
        pushTags: {
          type: Boolean,
          default: false
        },
        filterable: {
          type: Boolean,
          default: true
        },
        filterBy: {
          type: Function,
          default(e2, t2, s2) {
            return (t2 || "").toLocaleLowerCase().indexOf(s2.toLocaleLowerCase()) > -1;
          }
        },
        filter: {
          type: Function,
          default(e2, t2) {
            return e2.filter((s2) => {
              let n2 = this.getOptionLabel(s2);
              return typeof n2 == "number" && (n2 = n2.toString()), this.filterBy(s2, n2, t2);
            });
          }
        },
        createOption: {
          type: Function,
          default(e2) {
            return typeof this.optionList[0] == "object" ? { [this.label]: e2 } : e2;
          }
        },
        resetOnOptionsChange: {
          default: false,
          validator: (e2) => ["function", "boolean"].includes(typeof e2)
        },
        clearSearchOnBlur: {
          type: Function,
          default: function({ clearSearchOnSelect: e2, multiple: t2 }) {
            return e2 && !t2;
          }
        },
        noDrop: {
          type: Boolean,
          default: false
        },
        inputId: {
          type: String
        },
        dir: {
          type: String,
          default: "auto"
        },
        selectOnTab: {
          type: Boolean,
          default: false
        },
        selectOnKeyCodes: {
          type: Array,
          default: () => [13]
        },
        searchInputQuerySelector: {
          type: String,
          default: "[type=search]"
        },
        mapKeydown: {
          type: Function,
          default: (e2, t2) => e2
        },
        appendToBody: {
          type: Boolean,
          default: false
        },
        calculatePosition: {
          type: Function,
          default(e2, t2, { width: s2, top: n2, left: l2 }) {
            e2.style.top = n2, e2.style.left = l2, e2.style.width = s2;
          }
        },
        dropdownShouldOpen: {
          type: Function,
          default({ noDrop: e2, open: t2, mutableLoading: s2 }) {
            return e2 ? false : t2 && !s2;
          }
        },
        uid: {
          type: [String, Number],
          default: () => re$2()
        }
      },
      data() {
        return {
          search: "",
          open: false,
          isComposing: false,
          pushedTags: [],
          _value: [],
          deselectButtons: []
        };
      },
      computed: {
        isReducingValues() {
          return this.$props.reduce !== this.$options.props.reduce.default;
        },
        isTrackingValues() {
          return typeof this.modelValue == "undefined" || this.isReducingValues;
        },
        selectedValue() {
          let e2 = this.modelValue;
          return this.isTrackingValues && (e2 = this.$data._value), e2 != null && e2 !== "" ? [].concat(e2) : [];
        },
        optionList() {
          return this.options.concat(this.pushTags ? this.pushedTags : []);
        },
        searchEl() {
          return this.$slots.search ? this.$refs.selectedOptions.querySelector(this.searchInputQuerySelector) : this.$refs.search;
        },
        scope() {
          const e2 = {
            search: this.search,
            loading: this.loading,
            searching: this.searching,
            filteredOptions: this.filteredOptions
          };
          return {
            search: {
              attributes: f$2({
                disabled: this.disabled,
                placeholder: this.searchPlaceholder,
                tabindex: this.tabindex,
                readonly: !this.searchable,
                id: this.inputId,
                "aria-autocomplete": "list",
                "aria-labelledby": `vs${this.uid}__combobox`,
                "aria-controls": `vs${this.uid}__listbox`,
                ref: "search",
                type: "search",
                autocomplete: this.autocomplete,
                value: this.search
              }, this.dropdownOpen && this.filteredOptions[this.typeAheadPointer] ? {
                "aria-activedescendant": `vs${this.uid}__option-${this.typeAheadPointer}`
              } : {}),
              events: {
                compositionstart: () => this.isComposing = true,
                compositionend: () => this.isComposing = false,
                keydown: this.onSearchKeyDown,
                blur: this.onSearchBlur,
                focus: this.onSearchFocus,
                input: (t2) => this.search = t2.target.value
              }
            },
            spinner: {
              loading: this.mutableLoading
            },
            noOptions: {
              search: this.search,
              loading: this.mutableLoading,
              searching: this.searching
            },
            openIndicator: {
              attributes: {
                ref: "openIndicator",
                role: "presentation",
                class: "vs__open-indicator"
              }
            },
            listHeader: e2,
            listFooter: e2,
            header: m$2(f$2({}, e2), { deselect: this.deselect }),
            footer: m$2(f$2({}, e2), { deselect: this.deselect })
          };
        },
        childComponents() {
          return f$2(f$2({}, T$2), this.components);
        },
        stateClasses() {
          return {
            "vs--open": this.dropdownOpen,
            "vs--single": !this.multiple,
            "vs--multiple": this.multiple,
            "vs--searching": this.searching && !this.noDrop,
            "vs--searchable": this.searchable && !this.noDrop,
            "vs--unsearchable": !this.searchable,
            "vs--loading": this.mutableLoading,
            "vs--disabled": this.disabled
          };
        },
        searching() {
          return !!this.search;
        },
        dropdownOpen() {
          return this.dropdownShouldOpen(this);
        },
        searchPlaceholder() {
          return this.isValueEmpty && this.placeholder ? this.placeholder : void 0;
        },
        filteredOptions() {
          const e2 = [].concat(this.optionList);
          if (!this.filterable && !this.taggable)
            return e2;
          const t2 = this.search.length ? this.filter(e2, this.search, this) : e2;
          if (this.taggable && this.search.length) {
            const s2 = this.createOption(this.search);
            this.optionExists(s2) || t2.unshift(s2);
          }
          return t2;
        },
        isValueEmpty() {
          return this.selectedValue.length === 0;
        },
        showClearButton() {
          return !this.multiple && this.clearable && !this.open && !this.isValueEmpty;
        }
      },
      watch: {
        options(e2, t2) {
          const s2 = () => typeof this.resetOnOptionsChange == "function" ? this.resetOnOptionsChange(e2, t2, this.selectedValue) : this.resetOnOptionsChange;
          !this.taggable && s2() && this.clearSelection(), this.modelValue && this.isTrackingValues && this.setInternalValueFromOptions(this.modelValue);
        },
        modelValue: {
          immediate: true,
          handler(e2) {
            this.isTrackingValues && this.setInternalValueFromOptions(e2);
          }
        },
        multiple() {
          this.clearSelection();
        },
        open(e2) {
          this.$emit(e2 ? "open" : "close");
        }
      },
      created() {
        this.mutableLoading = this.loading;
      },
      methods: {
        setInternalValueFromOptions(e2) {
          Array.isArray(e2) ? this.$data._value = e2.map((t2) => this.findOptionFromReducedValue(t2)) : this.$data._value = this.findOptionFromReducedValue(e2);
        },
        select(e2) {
          this.$emit("option:selecting", e2), this.isOptionSelected(e2) ? this.deselectFromDropdown && (this.clearable || this.multiple && this.selectedValue.length > 1) && this.deselect(e2) : (this.taggable && !this.optionExists(e2) && (this.$emit("option:created", e2), this.pushTag(e2)), this.multiple && (e2 = this.selectedValue.concat(e2)), this.updateValue(e2), this.$emit("option:selected", e2)), this.onAfterSelect(e2);
        },
        deselect(e2) {
          this.$emit("option:deselecting", e2), this.updateValue(this.selectedValue.filter((t2) => !this.optionComparator(t2, e2))), this.$emit("option:deselected", e2);
        },
        clearSelection() {
          this.updateValue(this.multiple ? [] : null);
        },
        onAfterSelect(e2) {
          this.closeOnSelect && (this.open = !this.open, this.searchEl.blur()), this.clearSearchOnSelect && (this.search = "");
        },
        updateValue(e2) {
          typeof this.modelValue == "undefined" && (this.$data._value = e2), e2 !== null && (Array.isArray(e2) ? e2 = e2.map((t2) => this.reduce(t2)) : e2 = this.reduce(e2)), this.$emit("update:modelValue", e2);
        },
        toggleDropdown(e2) {
          const t2 = e2.target !== this.searchEl;
          t2 && e2.preventDefault();
          const s2 = [
            ...this.deselectButtons || [],
            this.$refs.clearButton
          ];
          if (this.searchEl === void 0 || s2.filter(Boolean).some((n2) => n2.contains(e2.target) || n2 === e2.target)) {
            e2.preventDefault();
            return;
          }
          this.open && t2 ? this.searchEl.blur() : this.disabled || (this.open = true, this.searchEl.focus());
        },
        isOptionSelected(e2) {
          return this.selectedValue.some((t2) => this.optionComparator(t2, e2));
        },
        isOptionDeselectable(e2) {
          return this.isOptionSelected(e2) && this.deselectFromDropdown;
        },
        optionComparator(e2, t2) {
          return this.getOptionKey(e2) === this.getOptionKey(t2);
        },
        findOptionFromReducedValue(e2) {
          const t2 = (n2) => JSON.stringify(this.reduce(n2)) === JSON.stringify(e2), s2 = [...this.options, ...this.pushedTags].filter(t2);
          return s2.length === 1 ? s2[0] : s2.find((n2) => this.optionComparator(n2, this.$data._value)) || e2;
        },
        closeSearchOptions() {
          this.open = false, this.$emit("search:blur");
        },
        maybeDeleteValue() {
          if (!this.searchEl.value.length && this.selectedValue && this.selectedValue.length && this.clearable) {
            let e2 = null;
            this.multiple && (e2 = [
              ...this.selectedValue.slice(0, this.selectedValue.length - 1)
            ]), this.updateValue(e2);
          }
        },
        optionExists(e2) {
          return this.optionList.some((t2) => this.optionComparator(t2, e2));
        },
        normalizeOptionForSlot(e2) {
          return typeof e2 == "object" ? e2 : { [this.label]: e2 };
        },
        pushTag(e2) {
          this.pushedTags.push(e2);
        },
        onEscape() {
          this.search.length ? this.search = "" : this.searchEl.blur();
        },
        onSearchBlur() {
          if (this.mousedown && !this.searching)
            this.mousedown = false;
          else {
            const { clearSearchOnSelect: e2, multiple: t2 } = this;
            this.clearSearchOnBlur({ clearSearchOnSelect: e2, multiple: t2 }) && (this.search = ""), this.closeSearchOptions();
            return;
          }
          if (this.search.length === 0 && this.options.length === 0) {
            this.closeSearchOptions();
            return;
          }
        },
        onSearchFocus() {
          this.open = true, this.$emit("search:focus");
        },
        onMousedown() {
          this.mousedown = true;
        },
        onMouseUp() {
          this.mousedown = false;
        },
        onSearchKeyDown(e2) {
          const t2 = (l2) => (l2.preventDefault(), !this.isComposing && this.typeAheadSelect()), s2 = {
            8: (l2) => this.maybeDeleteValue(),
            9: (l2) => this.onTab(),
            27: (l2) => this.onEscape(),
            38: (l2) => (l2.preventDefault(), this.typeAheadUp()),
            40: (l2) => (l2.preventDefault(), this.typeAheadDown())
          };
          this.selectOnKeyCodes.forEach((l2) => s2[l2] = t2);
          const n2 = this.mapKeydown(s2, this);
          if (typeof n2[e2.keyCode] == "function")
            return n2[e2.keyCode](e2);
        }
      }
    }, he$1 = ["dir"], ce$1 = ["id", "aria-expanded", "aria-owns"], ue$2 = {
      ref: "selectedOptions",
      class: "vs__selected-options"
    }, pe$1 = ["disabled", "title", "aria-label", "onClick"], fe$2 = {
      ref: "actions",
      class: "vs__actions"
    }, ge$1 = ["disabled"], ye$2 = { class: "vs__spinner" }, me$2 = ["id"], be$2 = ["id", "aria-selected", "onMouseover", "onClick"], _e$2 = {
      key: 0,
      class: "vs__no-options"
    }, Oe$1 = /* @__PURE__ */ createTextVNode(" Sorry, no matching options. "), we$1 = ["id"];
    function ve$2(e2, t2, s2, n2, l2, i2) {
      const y2 = resolveDirective("append-to-body");
      return openBlock(), createElementBlock("div", {
        dir: s2.dir,
        class: normalizeClass(["v-select", i2.stateClasses])
      }, [
        renderSlot(e2.$slots, "header", normalizeProps(guardReactiveProps(i2.scope.header))),
        createBaseVNode("div", {
          id: `vs${s2.uid}__combobox`,
          ref: "toggle",
          class: "vs__dropdown-toggle",
          role: "combobox",
          "aria-expanded": i2.dropdownOpen.toString(),
          "aria-owns": `vs${s2.uid}__listbox`,
          "aria-label": "Search for option",
          onMousedown: t2[1] || (t2[1] = (o2) => i2.toggleDropdown(o2))
        }, [
          createBaseVNode("div", ue$2, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(i2.selectedValue, (o2, p2) => renderSlot(e2.$slots, "selected-option-container", {
              option: i2.normalizeOptionForSlot(o2),
              deselect: i2.deselect,
              multiple: s2.multiple,
              disabled: s2.disabled
            }, () => [
              (openBlock(), createElementBlock("span", {
                key: s2.getOptionKey(o2),
                class: "vs__selected"
              }, [
                renderSlot(e2.$slots, "selected-option", normalizeProps(guardReactiveProps(i2.normalizeOptionForSlot(o2))), () => [
                  createTextVNode(toDisplayString(s2.getOptionLabel(o2)), 1)
                ]),
                s2.multiple ? (openBlock(), createElementBlock("button", {
                  key: 0,
                  ref_for: true,
                  ref: (g2) => l2.deselectButtons[p2] = g2,
                  disabled: s2.disabled,
                  type: "button",
                  class: "vs__deselect",
                  title: `Deselect ${s2.getOptionLabel(o2)}`,
                  "aria-label": `Deselect ${s2.getOptionLabel(o2)}`,
                  onClick: (g2) => i2.deselect(o2)
                }, [
                  (openBlock(), createBlock(resolveDynamicComponent(i2.childComponents.Deselect)))
                ], 8, pe$1)) : createCommentVNode("", true)
              ]))
            ])), 256)),
            renderSlot(e2.$slots, "search", normalizeProps(guardReactiveProps(i2.scope.search)), () => [
              createBaseVNode("input", mergeProps({ class: "vs__search" }, i2.scope.search.attributes, toHandlers(i2.scope.search.events)), null, 16)
            ])
          ], 512),
          createBaseVNode("div", fe$2, [
            withDirectives(createBaseVNode("button", {
              ref: "clearButton",
              disabled: s2.disabled,
              type: "button",
              class: "vs__clear",
              title: "Clear Selected",
              "aria-label": "Clear Selected",
              onClick: t2[0] || (t2[0] = (...o2) => i2.clearSelection && i2.clearSelection(...o2))
            }, [
              (openBlock(), createBlock(resolveDynamicComponent(i2.childComponents.Deselect)))
            ], 8, ge$1), [
              [vShow, i2.showClearButton]
            ]),
            renderSlot(e2.$slots, "open-indicator", normalizeProps(guardReactiveProps(i2.scope.openIndicator)), () => [
              s2.noDrop ? createCommentVNode("", true) : (openBlock(), createBlock(resolveDynamicComponent(i2.childComponents.OpenIndicator), normalizeProps(mergeProps({ key: 0 }, i2.scope.openIndicator.attributes)), null, 16))
            ]),
            renderSlot(e2.$slots, "spinner", normalizeProps(guardReactiveProps(i2.scope.spinner)), () => [
              withDirectives(createBaseVNode("div", ye$2, "Loading...", 512), [
                [vShow, e2.mutableLoading]
              ])
            ])
          ], 512)
        ], 40, ce$1),
        createVNode(Transition, { name: s2.transition }, {
          default: withCtx(() => [
            i2.dropdownOpen ? withDirectives((openBlock(), createElementBlock("ul", {
              id: `vs${s2.uid}__listbox`,
              ref: "dropdownMenu",
              key: `vs${s2.uid}__listbox`,
              class: "vs__dropdown-menu",
              role: "listbox",
              tabindex: "-1",
              onMousedown: t2[2] || (t2[2] = withModifiers((...o2) => i2.onMousedown && i2.onMousedown(...o2), ["prevent"])),
              onMouseup: t2[3] || (t2[3] = (...o2) => i2.onMouseUp && i2.onMouseUp(...o2))
            }, [
              renderSlot(e2.$slots, "list-header", normalizeProps(guardReactiveProps(i2.scope.listHeader))),
              (openBlock(true), createElementBlock(Fragment, null, renderList(i2.filteredOptions, (o2, p2) => (openBlock(), createElementBlock("li", {
                id: `vs${s2.uid}__option-${p2}`,
                key: s2.getOptionKey(o2),
                role: "option",
                class: normalizeClass(["vs__dropdown-option", {
                  "vs__dropdown-option--deselect": i2.isOptionDeselectable(o2) && p2 === e2.typeAheadPointer,
                  "vs__dropdown-option--selected": i2.isOptionSelected(o2),
                  "vs__dropdown-option--highlight": p2 === e2.typeAheadPointer,
                  "vs__dropdown-option--disabled": !s2.selectable(o2)
                }]),
                "aria-selected": p2 === e2.typeAheadPointer ? true : null,
                onMouseover: (g2) => s2.selectable(o2) ? e2.typeAheadPointer = p2 : null,
                onClick: withModifiers((g2) => s2.selectable(o2) ? i2.select(o2) : null, ["prevent", "stop"])
              }, [
                renderSlot(e2.$slots, "option", normalizeProps(guardReactiveProps(i2.normalizeOptionForSlot(o2))), () => [
                  createTextVNode(toDisplayString(s2.getOptionLabel(o2)), 1)
                ])
              ], 42, be$2))), 128)),
              i2.filteredOptions.length === 0 ? (openBlock(), createElementBlock("li", _e$2, [
                renderSlot(e2.$slots, "no-options", normalizeProps(guardReactiveProps(i2.scope.noOptions)), () => [
                  Oe$1
                ])
              ])) : createCommentVNode("", true),
              renderSlot(e2.$slots, "list-footer", normalizeProps(guardReactiveProps(i2.scope.listFooter)))
            ], 40, me$2)), [
              [y2]
            ]) : (openBlock(), createElementBlock("ul", {
              key: 1,
              id: `vs${s2.uid}__listbox`,
              role: "listbox",
              style: { display: "none", visibility: "hidden" }
            }, null, 8, we$1))
          ]),
          _: 3
        }, 8, ["name"]),
        renderSlot(e2.$slots, "footer", normalizeProps(guardReactiveProps(i2.scope.footer)))
      ], 10, he$1);
    }
    const Ce$2 = /* @__PURE__ */ S$2(de$2, [["render", ve$2]]);
    const __default__ = {
      components: {
        "v-select": Ce$2
      }
    };
    const _sfc_main$1a = /* @__PURE__ */ Object.assign(__default__, {
      __name: "dropdown",
      props: /* @__PURE__ */ mergeModels({
        id: {
          type: String,
          default: null
        },
        dataValues: {
          type: String,
          default: "{}"
        },
        taggable: {
          type: Boolean,
          default: false
        },
        multiple: {
          type: Boolean,
          default: false
        }
      }, {
        "modelValue": {},
        "modelModifiers": {},
        "selectedValue": {},
        "selectedValueModifiers": {}
      }),
      emits: ["update:modelValue", "update:selectedValue"],
      setup(__props, { expose: __expose }) {
        __expose();
        const { sortList } = useList$1({});
        const props = __props;
        const inputValue = useModel(__props, "modelValue");
        let selectedValue = useModel(__props, "selectedValue");
        const selectElem = ref(null);
        const optionList = computed(() => {
          return buildOptionList();
        });
        watch(inputValue, (value) => {
          onUpdateInput();
        });
        onBeforeMount(() => {
          selectedValue.value = refreshSelectValue();
        });
        onMounted(() => {
          selectElem.value.onSearchBlurOriginal = selectElem.value.onSearchBlur;
          selectElem.value.onSearchBlur = () => {
            if (props.taggable && selectElem.value.search !== "") {
              let searchValue = {
                label: selectElem.value.search,
                code: selectElem.value.search
              };
              selectElem.value.select(searchValue);
            }
            selectElem.value.onSearchBlurOriginal();
          };
        });
        function buildOptionList() {
          let option_list = JSON.parse(props.dataValues);
          let list = [];
          for (let key in option_list) {
            if (key !== "" && key !== "null" && option_list.hasOwnProperty(key)) {
              list.push(getPair(key));
            }
          }
          if (inputValue !== null && !(inputValue.value in option_list) && !props.multiple) {
            list.push(getPair(inputValue.value));
          }
          list = sortList(list);
          return list;
        }
        function refreshSelectValue() {
          let value = inputValue.value;
          if (value !== null) {
            if (props.multiple) {
              try {
                value = JSON.parse(value);
              } catch (e2) {
                value = value.split(",");
              }
              return value.map(function(item) {
                return getPair(item);
              });
            } else {
              return getPair(value);
            }
          }
          return null;
        }
        function getPair(item) {
          let option_list = JSON.parse(props.dataValues);
          return {
            label: option_list[item] ?? item,
            code: item
          };
        }
        function onUpdateSelected() {
          if (props.multiple) {
            inputValue.value = JSON.stringify(selectedValue.value.map(function(item) {
              return item.code;
            }));
          } else {
            inputValue.value = selectedValue.value !== null ? selectedValue.value.code : null;
          }
        }
        function onUpdateInput() {
          selectedValue.value = refreshSelectValue();
        }
        const __returned__ = { sortList, props, inputValue, get selectedValue() {
          return selectedValue;
        }, set selectedValue(v2) {
          selectedValue = v2;
        }, selectElem, optionList, buildOptionList, refreshSelectValue, getPair, onUpdateSelected, onUpdateInput, get vSelect() {
          return Ce$2;
        }, onBeforeMount, onMounted, ref, watch, computed, get useList() {
          return useList$1;
        } };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    });
    const _hoisted_1$T = ["id"];
    function _sfc_render$1a(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("span", null, [
        createVNode($setup["vSelect"], {
          taggable: $props.taggable,
          "push-tags": $props.taggable,
          multiple: $props.multiple,
          ref: "selectElem",
          modelValue: $setup.selectedValue,
          "onUpdate:modelValue": [
            _cache[0] || (_cache[0] = ($event) => $setup.selectedValue = $event),
            $setup.onUpdateSelected
          ],
          options: $setup.optionList
        }, null, 8, ["taggable", "push-tags", "multiple", "modelValue", "options"]),
        withDirectives(createBaseVNode("input", {
          type: "hidden",
          id: $props.id,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $setup.inputValue = $event)
        }, null, 8, _hoisted_1$T), [
          [vModelText, $setup.inputValue]
        ])
      ]);
    }
    const dropdown = /* @__PURE__ */ _export_sfc(_sfc_main$1a, [["render", _sfc_render$1a], ["__file", "/var/www/html/vendor/andreamarelli/modular-forms/src/resources/assets/js/inputs/dropdown.vue"]]);
    class Base {
      constructor(options, input_data) {
        const app = createApp(
          options || {},
          input_data || {}
        );
        app.component("tooltip", tooltip);
        app.component("dialogBox", dialogBox);
        app.component("dropdown", dropdown);
        return app;
      }
    }
    const _sfc_main$19 = {
      props: {
        name: {
          type: String,
          default: null
        },
        iso2: {
          type: String,
          default: null
        }
      },
      computed: {
        countryName: function() {
          return this.name || null;
        },
        flagClasses: function() {
          if (this.iso2 === null || this.iso2 === "") {
            return "";
          }
          let iso2 = this.iso2.toLowerCase();
          iso2 = iso2 === "en" ? "gb" : iso2;
          iso2 = iso2 === "sp" ? "es" : iso2;
          return "fi fi-" + iso2;
        }
      }
    };
    function _sfc_render$19(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_tooltip = resolveComponent("tooltip");
      return openBlock(), createElementBlock("span", null, [
        createBaseVNode("span", {
          class: normalizeClass($options.flagClasses)
        }, null, 2),
        createVNode(_component_tooltip, null, {
          default: withCtx(() => [
            createTextVNode(toDisplayString($options.countryName), 1)
          ]),
          _: 1
        })
      ]);
    }
    const flag = /* @__PURE__ */ _export_sfc(_sfc_main$19, [["render", _sfc_render$19], ["__file", "/var/www/html/vendor/andreamarelli/modular-forms/src/resources/assets/js/templates/flag.vue"]]);
    const _sfc_main$18 = {
      __name: "destroyFormButton",
      props: {
        action: {
          type: String,
          required: true
        }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const Locale2 = window.ModularForms.Helpers.Locale;
        const csrfToken = window.Laravel.csrfToken;
        const props = __props;
        const destroyDialog = ref(null);
        function closeDestroyDialog() {
          destroyDialog.value.closeDialog();
        }
        const __returned__ = { Locale: Locale2, csrfToken, props, destroyDialog, closeDestroyDialog, ref };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$S = { class: "with_header_and_footer" };
    const _hoisted_2$G = { class: "header" };
    const _hoisted_3$x = { class: "footer" };
    const _hoisted_4$n = ["action"];
    const _hoisted_5$m = ["value"];
    const _hoisted_6$g = {
      type: "submit",
      class: "btn-nav small red"
    };
    function _sfc_render$18(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_tooltip = resolveComponent("tooltip");
      const _component_dialog_box = resolveComponent("dialog-box");
      return openBlock(), createBlock(_component_dialog_box, { ref: "destroyDialog" }, {
        "dialog-anchor": withCtx(() => [
          _cache[0] || (_cache[0] = createBaseVNode("button", {
            type: "button",
            class: "btn-nav small red"
          }, [
            createBaseVNode("span", { class: "fas fa-fw fa-trash" })
          ], -1)),
          createVNode(_component_tooltip, null, {
            default: withCtx(() => [
              createTextVNode(toDisplayString($setup.Locale.getLabel("modular-forms::common.delete")), 1)
            ]),
            _: 1
          })
        ]),
        "dialog-content": withCtx(() => [
          createBaseVNode("div", _hoisted_1$S, [
            createBaseVNode("div", _hoisted_2$G, toDisplayString($setup.Locale.getLabel("modular-forms::common.confirm_deletion")), 1),
            _cache[4] || (_cache[4] = createBaseVNode("div", { class: "body" }, null, -1)),
            createBaseVNode("div", _hoisted_3$x, [
              _cache[3] || (_cache[3] = createBaseVNode("div", { class: "spacer" }, null, -1)),
              createBaseVNode("button", {
                type: "button",
                onClick: $setup.closeDestroyDialog,
                class: "btn-nav small green"
              }, toDisplayString($setup.Locale.getLabel("modular-forms::common.cancel")), 1),
              createBaseVNode("form", {
                style: { "display": "inline-block" },
                method: "POST",
                action: $props.action
              }, [
                createBaseVNode("input", {
                  type: "hidden",
                  name: "_token",
                  value: $setup.csrfToken
                }, null, 8, _hoisted_5$m),
                _cache[2] || (_cache[2] = createBaseVNode("input", {
                  type: "hidden",
                  name: "_method",
                  value: "DELETE"
                }, null, -1)),
                createBaseVNode("button", _hoisted_6$g, [
                  _cache[1] || (_cache[1] = createBaseVNode("span", { class: "fas fa-fw fa-trash" }, null, -1)),
                  createTextVNode(" " + toDisplayString($setup.Locale.getLabel("modular-forms::common.delete")), 1)
                ])
              ], 8, _hoisted_4$n)
            ])
          ])
        ]),
        _: 1
      }, 512);
    }
    const destroyButton = /* @__PURE__ */ _export_sfc(_sfc_main$18, [["render", _sfc_render$18], ["__file", "/var/www/html/vendor/andreamarelli/modular-forms/src/resources/assets/js/components/destroyFormButton.vue"]]);
    class FormList {
      constructor(input_data = {}) {
        const options = {
          name: "FormList"
        };
        const app = createApp(
          options || {},
          input_data || {}
        );
        app.component("flag", flag);
        app.component("tooltip", tooltip);
        app.component("dialogBox", dialogBox);
        app.component("destroyButton", destroyButton);
        return app;
      }
    }
    class FormErrors {
      constructor(input_data = {}) {
        const options = {
          name: "FormErrors",
          props: {
            initial_errors: {
              type: Array,
              default: () => []
            }
          },
          setup(props) {
            const validation_errors = reactive(props.initial_errors);
            let has_errors = computed(() => {
              return Object.entries(validation_errors).length >= 1 && typeof validation_errors[0] !== "undefined" && validation_errors[0] !== null;
            });
            onMounted(() => {
              displayNonValidModules();
            });
            watch(validation_errors, () => {
              displayNonValidModules();
            });
            function displayNonValidModules() {
              let error_class = "validation-error";
              let invalid_modules = validation_errors.map((a2) => "module_" + a2.key);
              let containers = document.querySelectorAll(".module-container");
              containers.forEach(function(container2) {
                if (invalid_modules.includes(container2.id)) {
                  if (!container2.classList.contains(error_class)) {
                    container2.classList.add(error_class);
                  }
                } else {
                  if (container2.classList.contains(error_class)) {
                    container2.classList.remove(error_class);
                  }
                }
              });
            }
            function refreshErrors(errors) {
              validation_errors.forEach(function(error, index) {
                validation_errors.splice(index, 1);
              });
              errors.forEach(function(error, index) {
                validation_errors[index] = JSON.parse(JSON.stringify(error));
              });
            }
            return {
              validation_errors,
              has_errors,
              refreshErrors
            };
          }
        };
        return createApp(options, input_data);
      }
    }
    function mitt(n2) {
      return { all: n2 = n2 || /* @__PURE__ */ new Map(), on: function(t2, e2) {
        var i2 = n2.get(t2);
        i2 ? i2.push(e2) : n2.set(t2, [e2]);
      }, off: function(t2, e2) {
        var i2 = n2.get(t2);
        i2 && (e2 ? i2.splice(i2.indexOf(e2) >>> 0, 1) : n2.set(t2, []));
      }, emit: function(t2, e2) {
        var i2 = n2.get(t2);
        i2 && i2.slice().map(function(n3) {
          n3(e2);
        }), (i2 = n2.get("*")) && i2.slice().map(function(n3) {
          n3(t2, e2);
        });
      } };
    }
    const _sfc_main$17 = {
      __name: "simple-text",
      props: /* @__PURE__ */ mergeModels({
        id: {
          type: String,
          default: null
        },
        tooltipEnabled: {
          type: Boolean,
          default: true
        }
      }, {
        "modelValue": {},
        "modelModifiers": {}
      }),
      emits: ["update:modelValue"],
      setup(__props, { expose: __expose }) {
        __expose();
        const props = __props;
        const inputValue = useModel(__props, "modelValue");
        const __returned__ = { props, inputValue };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$R = ["id", "name"];
    function _sfc_render$17(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_tooltip = resolveComponent("tooltip");
      return openBlock(), createElementBlock("span", null, [
        withDirectives(createBaseVNode("input", {
          type: "text",
          id: $props.id,
          name: $props.id,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.inputValue = $event),
          class: "field-edit",
          autocomplete: "off"
        }, null, 8, _hoisted_1$R), [
          [vModelText, $setup.inputValue]
        ]),
        $props.tooltipEnabled ? (openBlock(), createBlock(_component_tooltip, {
          key: 0,
          "anchor-elem-id": $props.id
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString($setup.inputValue), 1)
          ]),
          _: 1
        }, 8, ["anchor-elem-id"])) : createCommentVNode("", true)
      ]);
    }
    const simpleText = /* @__PURE__ */ _export_sfc(_sfc_main$17, [["render", _sfc_render$17], ["__file", "/var/www/html/vendor/andreamarelli/modular-forms/src/resources/assets/js/inputs/simple-text.vue"]]);
    const _sfc_main$16 = {
      __name: "simple-textarea",
      props: /* @__PURE__ */ mergeModels({
        id: {
          type: String,
          default: null
        },
        disabled: {
          type: Boolean,
          default: false
        }
      }, {
        "modelValue": {},
        "modelModifiers": {}
      }),
      emits: ["update:modelValue"],
      setup(__props, { expose: __expose }) {
        __expose();
        const props = __props;
        const inputValue = useModel(__props, "modelValue");
        function onInput(e2) {
          inputValue.value = e2.target.innerText;
        }
        const __returned__ = { props, inputValue, onInput };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$Q = ["id", "textContent"];
    const _hoisted_2$F = ["id", "textContent"];
    function _sfc_render$16(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("span", null, [
        $props.disabled ? (openBlock(), createElementBlock("span", {
          key: 0,
          id: $props.id,
          class: "field-preview disabled",
          onInput: $setup.onInput,
          textContent: toDisplayString($setup.inputValue)
        }, null, 40, _hoisted_1$Q)) : (openBlock(), createElementBlock("span", {
          key: 1,
          id: $props.id,
          class: "field-preview",
          contenteditable: "",
          onInput: $setup.onInput,
          textContent: toDisplayString($setup.inputValue)
        }, null, 40, _hoisted_2$F))
      ]);
    }
    const simpleTextarea = /* @__PURE__ */ _export_sfc(_sfc_main$16, [["render", _sfc_render$16], ["__file", "/var/www/html/vendor/andreamarelli/modular-forms/src/resources/assets/js/inputs/simple-textarea.vue"]]);
    const _sfc_main$15 = {
      __name: "simple-url",
      props: /* @__PURE__ */ mergeModels({
        id: {
          type: String,
          default: null
        },
        dataRules: {
          type: String,
          default: ""
        }
      }, {
        "modelValue": {},
        "modelModifiers": {}
      }),
      emits: ["update:modelValue"],
      setup(__props, { expose: __expose }) {
        __expose();
        const props = __props;
        const inputValue = useModel(__props, "modelValue");
        const __returned__ = { props, inputValue };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    function _sfc_render$15(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_simple_text = resolveComponent("simple-text");
      return openBlock(), createBlock(_component_simple_text, {
        modelValue: $setup.inputValue,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.inputValue = $event),
        id: $props.id,
        name: $props.id,
        "data-rules": $props.dataRules !== "" ? $props.dataRules + "|url" : "url"
      }, null, 8, ["modelValue", "id", "name", "data-rules"]);
    }
    const simpleUrl = /* @__PURE__ */ _export_sfc(_sfc_main$15, [["render", _sfc_render$15], ["__file", "/var/www/html/vendor/andreamarelli/modular-forms/src/resources/assets/js/inputs/simple-url.vue"]]);
    const _sfc_main$14 = {
      __name: "simple-email",
      props: /* @__PURE__ */ mergeModels({
        id: {
          type: String,
          default: null
        },
        dataRules: {
          type: String,
          default: ""
        }
      }, {
        "modelValue": {},
        "modelModifiers": {}
      }),
      emits: ["update:modelValue"],
      setup(__props, { expose: __expose }) {
        __expose();
        const props = __props;
        const inputValue = useModel(__props, "modelValue");
        const __returned__ = { props, inputValue };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    function _sfc_render$14(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_simple_text = resolveComponent("simple-text");
      return openBlock(), createBlock(_component_simple_text, {
        modelValue: $setup.inputValue,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.inputValue = $event),
        id: $props.id,
        name: $props.id,
        "data-rules": $props.dataRules !== "" ? $props.dataRules + "|email" : "email"
      }, null, 8, ["modelValue", "id", "name", "data-rules"]);
    }
    const simpleEmail = /* @__PURE__ */ _export_sfc(_sfc_main$14, [["render", _sfc_render$14], ["__file", "/var/www/html/vendor/andreamarelli/modular-forms/src/resources/assets/js/inputs/simple-email.vue"]]);
    const _sfc_main$13 = {
      __name: "simple-password",
      props: /* @__PURE__ */ mergeModels({
        id: {
          type: String,
          default: null
        },
        tooltipEnabled: {
          type: Boolean,
          default: true
        }
      }, {
        "modelValue": {},
        "modelModifiers": {}
      }),
      emits: ["update:modelValue"],
      setup(__props, { expose: __expose }) {
        __expose();
        const props = __props;
        const inputValue = useModel(__props, "modelValue");
        const __returned__ = { props, inputValue };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$P = ["id", "name"];
    function _sfc_render$13(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_tooltip = resolveComponent("tooltip");
      return openBlock(), createElementBlock("span", null, [
        withDirectives(createBaseVNode("input", {
          type: "password",
          id: $props.id,
          name: $props.id,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.inputValue = $event),
          class: "field-edit",
          autocomplete: "off"
        }, null, 8, _hoisted_1$P), [
          [vModelText, $setup.inputValue]
        ]),
        $props.tooltipEnabled ? (openBlock(), createBlock(_component_tooltip, {
          key: 0,
          "anchor-elem-id": $props.id
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString($setup.inputValue), 1)
          ]),
          _: 1
        }, 8, ["anchor-elem-id"])) : createCommentVNode("", true)
      ]);
    }
    const simplePassword = /* @__PURE__ */ _export_sfc(_sfc_main$13, [["render", _sfc_render$13], ["__file", "/var/www/html/vendor/andreamarelli/modular-forms/src/resources/assets/js/inputs/simple-password.vue"]]);
    const _sfc_main$12 = {
      __name: "rating",
      props: /* @__PURE__ */ mergeModels({
        id: {
          type: String,
          default: null
        },
        ratingType: String,
        legend: {
          type: Array,
          default: () => null
        }
      }, {
        "modelValue": {},
        "modelModifiers": {}
      }),
      emits: ["update:modelValue"],
      setup(__props, { expose: __expose }) {
        __expose();
        const props = __props;
        const ratingOptions = ref(null);
        const list = computed(() => {
          return buildOptionList();
        });
        const inputValue = useModel(__props, "modelValue");
        function buildOptionList() {
          let list2 = [];
          let ratingType = props.ratingType;
          if (ratingType.includes("WithNA")) {
            list2.push({ "value": "-99", "label": "N/A" });
            ratingType = ratingType.replace("WithNA", "");
          }
          ratingType = ratingType.replace("Minus", "-");
          let [min2, max2] = ratingType.split("to");
          for (let i2 = min2; i2 <= max2; i2++) {
            list2.push({ "value": i2, "label": i2 });
          }
          return list2;
        }
        function isNA(value) {
          return value === "-99" || value === -99;
        }
        function setActive(value) {
          let applyClass = __applyClass(value, inputValue.value);
          return applyClass ? "active" : "";
        }
        function __applyClass(localValue, globalValue) {
          if (!isNA(localValue) && parseFloat(localValue) <= parseFloat(globalValue)) {
            return true;
          } else if (isNA(localValue) && isNA(globalValue)) {
            return true;
          }
          return false;
        }
        function setHover(evt) {
          let hoverValue = evt.target.getAttribute("rate");
          let ratingItems = ratingOptions.value.querySelectorAll(".rating");
          for (let item of ratingItems.values()) {
            let value = item.getAttribute("rate");
            let applyClass = __applyClass(value, hoverValue);
            if (applyClass && evt.type === "mouseover") {
              item.classList.add("hover");
            } else {
              item.classList.remove("hover");
            }
          }
        }
        function updateRating(value) {
          if (inputValue.value !== null && value.toString() === inputValue.value.toString()) {
            value = null;
          }
          inputValue.value = value;
          let ratingItems = ratingOptions.value.querySelectorAll(".rating");
          for (let item of ratingItems.values()) {
            item.classList.remove("hover");
          }
        }
        function tooltipLabel(index) {
          if (props.legend != null) {
            if (props.legend.hasOwnProperty(index)) {
              return props.legend[index].charAt(0).toUpperCase() + props.legend[index].slice(1);
            }
          }
          return "";
        }
        const __returned__ = { props, ratingOptions, list, inputValue, buildOptionList, isNA, setActive, __applyClass, setHover, updateRating, tooltipLabel, computed, ref };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$O = {
      ref: "ratingOptions",
      class: "rating-container"
    };
    const _hoisted_2$E = ["onClick", "rate"];
    const _hoisted_3$w = ["id"];
    function _sfc_render$12(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_tooltip = resolveComponent("tooltip");
      return openBlock(), createElementBlock("div", null, [
        createBaseVNode("span", _hoisted_1$O, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($setup.list, (item, index) => {
            return openBlock(), createElementBlock("span", null, [
              createBaseVNode("span", {
                class: normalizeClass(["rating field-edit", [$setup.isNA(item["value"]) ? "ratingNa" : "ratingNum", $setup.setActive(item["value"])]]),
                onClick: ($event) => $setup.updateRating(item["value"]),
                onMouseover: $setup.setHover,
                onMouseout: $setup.setHover,
                rate: item["value"]
              }, toDisplayString(item["label"]), 43, _hoisted_2$E),
              createVNode(_component_tooltip, null, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString($setup.tooltipLabel(index)), 1)
                ]),
                _: 2
              }, 1024)
            ]);
          }), 256))
        ], 512),
        withDirectives(createBaseVNode("input", {
          type: "hidden",
          id: $props.id,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.inputValue = $event)
        }, null, 8, _hoisted_3$w), [
          [vModelText, $setup.inputValue]
        ])
      ]);
    }
    const rating = /* @__PURE__ */ _export_sfc(_sfc_main$12, [["render", _sfc_render$12], ["__file", "/var/www/html/vendor/andreamarelli/modular-forms/src/resources/assets/js/inputs/rating.vue"]]);
    var airDatepicker = { exports: {} };
    (function(module2, exports2) {
      !function(e2, t2) {
        module2.exports = t2();
      }(commonjsGlobal, function() {
        return function() {
          var e2 = { d: function(t3, i3) {
            for (var s3 in i3) e2.o(i3, s3) && !e2.o(t3, s3) && Object.defineProperty(t3, s3, { enumerable: true, get: i3[s3] });
          }, o: function(e3, t3) {
            return Object.prototype.hasOwnProperty.call(e3, t3);
          } }, t2 = {};
          e2.d(t2, { default: function() {
            return R2;
          } });
          var i2 = { days: "days", months: "months", years: "years", day: "day", month: "month", year: "year", eventChangeViewDate: "changeViewDate", eventChangeCurrentView: "changeCurrentView", eventChangeFocusDate: "changeFocusDate", eventChangeSelectedDate: "changeSelectedDate", eventChangeTime: "changeTime", eventChangeLastSelectedDate: "changeLastSelectedDate", actionSelectDate: "selectDate", actionUnselectDate: "unselectDate", cssClassWeekend: "-weekend-" }, s2 = { classes: "", inline: false, locale: { days: ["", "", "", "", "", "", ""], daysShort: ["", "", "", "", "", "", ""], daysMin: ["", "", "", "", "", "", ""], months: ["", "", "", "", "", "", "", "", "", "", "", ""], monthsShort: ["", "", "", "", "", "", "", "", "", "", "", ""], today: "", clear: "", dateFormat: "dd.MM.yyyy", timeFormat: "HH:mm", firstDay: 1 }, startDate: /* @__PURE__ */ new Date(), firstDay: "", weekends: [6, 0], dateFormat: "", altField: "", altFieldDateFormat: "T", toggleSelected: true, keyboardNav: true, selectedDates: false, container: "", isMobile: false, visible: false, position: "bottom left", offset: 12, view: i2.days, minView: i2.days, showOtherMonths: true, selectOtherMonths: true, moveToOtherMonthsOnSelect: true, showOtherYears: true, selectOtherYears: true, moveToOtherYearsOnSelect: true, minDate: "", maxDate: "", disableNavWhenOutOfRange: true, multipleDates: false, multipleDatesSeparator: ", ", range: false, dynamicRange: true, buttons: false, monthsField: "monthsShort", showEvent: "focus", autoClose: false, fixedHeight: false, prevHtml: '<svg><path d="M 17,12 l -5,5 l 5,5"></path></svg>', nextHtml: '<svg><path d="M 14,12 l 5,5 l -5,5"></path></svg>', navTitles: { days: "MMMM, <i>yyyy</i>", months: "yyyy", years: "yyyy1 - yyyy2" }, timepicker: false, onlyTimepicker: false, dateTimeSeparator: " ", timeFormat: "", minHours: 0, maxHours: 24, minMinutes: 0, maxMinutes: 59, hoursStep: 1, minutesStep: 1, onSelect: false, onChangeViewDate: false, onChangeView: false, onRenderCell: false, onShow: false, onHide: false, onClickDayName: false };
          function a2(e3) {
            let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : document;
            return "string" == typeof e3 ? t3.querySelector(e3) : e3;
          }
          function n2() {
            let { tagName: e3 = "div", className: t3 = "", innerHtml: i3 = "", id: s3 = "", attrs: a3 = {} } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, n3 = document.createElement(e3);
            return t3 && n3.classList.add(...t3.split(" ")), s3 && (n3.id = s3), i3 && (n3.innerHTML = i3), a3 && r2(n3, a3), n3;
          }
          function r2(e3, t3) {
            for (let [i3, s3] of Object.entries(t3)) void 0 !== s3 && e3.setAttribute(i3, s3);
            return e3;
          }
          function o2(e3) {
            return new Date(e3.getFullYear(), e3.getMonth() + 1, 0).getDate();
          }
          function h2(e3) {
            let t3 = e3.getHours(), { hours: i3, dayPeriod: s3 } = l2(t3);
            return { year: e3.getFullYear(), month: e3.getMonth(), fullMonth: e3.getMonth() + 1 < 10 ? "0" + (e3.getMonth() + 1) : e3.getMonth() + 1, date: e3.getDate(), fullDate: e3.getDate() < 10 ? "0" + e3.getDate() : e3.getDate(), day: e3.getDay(), hours: t3, fullHours: d2(t3), hours12: i3, dayPeriod: s3, fullHours12: d2(i3), minutes: e3.getMinutes(), fullMinutes: e3.getMinutes() < 10 ? "0" + e3.getMinutes() : e3.getMinutes() };
          }
          function l2(e3) {
            return { dayPeriod: e3 > 11 ? "pm" : "am", hours: e3 % 12 == 0 ? 12 : e3 % 12 };
          }
          function d2(e3) {
            return e3 < 10 ? "0" + e3 : e3;
          }
          function c2(e3) {
            let t3 = 10 * Math.floor(e3.getFullYear() / 10);
            return [t3, t3 + 9];
          }
          function u2() {
            let e3 = [];
            for (var t3 = arguments.length, i3 = new Array(t3), s3 = 0; s3 < t3; s3++) i3[s3] = arguments[s3];
            return i3.forEach((t4) => {
              if ("object" == typeof t4) for (let i4 in t4) t4[i4] && e3.push(i4);
              else t4 && e3.push(t4);
            }), e3.join(" ");
          }
          function p2(e3, t3) {
            let s3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : i2.days;
            if (!e3 || !t3) return false;
            let a3 = h2(e3), n3 = h2(t3);
            return { [i2.days]: a3.date === n3.date && a3.month === n3.month && a3.year === n3.year, [i2.months]: a3.month === n3.month && a3.year === n3.year, [i2.years]: a3.year === n3.year }[s3];
          }
          function m2(e3, t3, i3) {
            let s3 = g2(e3, false).getTime(), a3 = g2(t3, false).getTime();
            return i3 ? s3 >= a3 : s3 > a3;
          }
          function v2(e3, t3) {
            return !m2(e3, t3, true);
          }
          function g2(e3) {
            let t3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i3 = new Date(e3.getTime());
            return "boolean" != typeof t3 || t3 || function(e4) {
              e4.setHours(0, 0, 0, 0);
            }(i3), i3;
          }
          function D2(e3, t3, i3) {
            e3.length ? e3.forEach((e4) => {
              e4.addEventListener(t3, i3);
            }) : e3.addEventListener(t3, i3);
          }
          function y2(e3, t3) {
            return !(!e3 || e3 === document || e3 instanceof DocumentFragment) && (e3.matches(t3) ? e3 : y2(e3.parentNode, t3));
          }
          function f2(e3, t3, i3) {
            return e3 > i3 ? i3 : e3 < t3 ? t3 : e3;
          }
          function w2(e3) {
            for (var t3 = arguments.length, i3 = new Array(t3 > 1 ? t3 - 1 : 0), s3 = 1; s3 < t3; s3++) i3[s3 - 1] = arguments[s3];
            return i3.filter((e4) => e4).forEach((t4) => {
              for (let [i4, s4] of Object.entries(t4)) if (void 0 !== s4 && "[object Object]" === s4.toString()) {
                let t5 = void 0 !== e3[i4] ? e3[i4].toString() : void 0, a3 = s4.toString(), n3 = Array.isArray(s4) ? [] : {};
                e3[i4] = e3[i4] ? t5 !== a3 ? n3 : e3[i4] : n3, w2(e3[i4], s4);
              } else e3[i4] = s4;
            }), e3;
          }
          function b2(e3) {
            let t3 = e3;
            return e3 instanceof Date || ("string" == typeof e3 && /^\d{4}-\d{2}-\d{2}$/.test(e3) && (e3 += "T00:00:00"), t3 = new Date(e3)), isNaN(t3.getTime()) && (console.log(`Unable to convert value "${e3}" to Date object`), t3 = false), t3;
          }
          function k2(e3) {
            let t3 = "\\s|\\.|-|/|\\\\|,|\\$|\\!|\\?|:|;";
            return new RegExp("(^|>|" + t3 + ")(" + e3 + ")($|<|" + t3 + ")", "g");
          }
          function $2(e3, t3, i3) {
            return (t3 = function(e4) {
              var t4 = function(e5, t5) {
                if ("object" != typeof e5 || null === e5) return e5;
                var i4 = e5[Symbol.toPrimitive];
                if (void 0 !== i4) {
                  var s3 = i4.call(e5, "string");
                  if ("object" != typeof s3) return s3;
                  throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return String(e5);
              }(e4);
              return "symbol" == typeof t4 ? t4 : String(t4);
            }(t3)) in e3 ? Object.defineProperty(e3, t3, { value: i3, enumerable: true, configurable: true, writable: true }) : e3[t3] = i3, e3;
          }
          class C2 {
            constructor() {
              let { type: e3, date: t3, dp: i3, opts: s3, body: a3 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
              $2(this, "focus", () => {
                this.$cell.classList.add("-focus-"), this.focused = true;
              }), $2(this, "removeFocus", () => {
                this.$cell.classList.remove("-focus-"), this.focused = false;
              }), $2(this, "select", () => {
                this.$cell.classList.add("-selected-"), this.selected = true;
              }), $2(this, "removeSelect", () => {
                this.$cell.classList.remove("-selected-", "-range-from-", "-range-to-"), this.selected = false;
              }), $2(this, "onChangeSelectedDate", () => {
                this.isDisabled || (this._handleSelectedStatus(), this.opts.range && this._handleRangeStatus());
              }), $2(this, "onChangeFocusDate", (e4) => {
                if (!e4) return void (this.focused && this.removeFocus());
                let t4 = p2(e4, this.date, this.type);
                t4 ? this.focus() : !t4 && this.focused && this.removeFocus(), this.opts.range && this._handleRangeStatus();
              }), $2(this, "render", () => (this.$cell.innerHTML = this._getHtml(), this._handleClasses(), this.$cell)), this.type = e3, this.singleType = this.type.slice(0, -1), this.date = t3, this.dp = i3, this.opts = s3, this.body = a3, this.customData = false, this.init();
            }
            init() {
              var e3;
              let { onRenderCell: t3 } = this.opts;
              t3 && (this.customData = t3({ date: this.date, cellType: this.singleType, datepicker: this.dp })), this._createElement(), this._bindDatepickerEvents(), null !== (e3 = this.customData) && void 0 !== e3 && e3.disabled && this.dp.disableDate(this.date);
            }
            _bindDatepickerEvents() {
              this.dp.on(i2.eventChangeSelectedDate, this.onChangeSelectedDate), this.dp.on(i2.eventChangeFocusDate, this.onChangeFocusDate);
            }
            unbindDatepickerEvents() {
              this.dp.off(i2.eventChangeSelectedDate, this.onChangeSelectedDate), this.dp.off(i2.eventChangeFocusDate, this.onChangeFocusDate);
            }
            _createElement() {
              var e3;
              let { year: t3, month: i3, date: s3 } = h2(this.date), a3 = (null === (e3 = this.customData) || void 0 === e3 ? void 0 : e3.attrs) || {};
              this.$cell = n2({ attrs: { "data-year": t3, "data-month": i3, "data-date": s3, ...a3 } }), this.$cell.adpCell = this;
            }
            _getClassName() {
              var e3;
              let t3 = /* @__PURE__ */ new Date(), { selectOtherMonths: s3, selectOtherYears: a3 } = this.opts, { minDate: n3, maxDate: r3, isDateDisabled: o3 } = this.dp, { day: l3 } = h2(this.date), d3 = this._isOutOfMinMaxRange(), c3 = o3(this.date), m3 = u2("air-datepicker-cell", `-${this.singleType}-`, { "-current-": p2(t3, this.date, this.type), "-min-date-": n3 && p2(n3, this.date, this.type), "-max-date-": r3 && p2(r3, this.date, this.type) }), v3 = "";
              switch (this.type) {
                case i2.days:
                  v3 = u2({ "-weekend-": this.dp.isWeekend(l3), "-other-month-": this.isOtherMonth, "-disabled-": this.isOtherMonth && !s3 || d3 || c3 });
                  break;
                case i2.months:
                  v3 = u2({ "-disabled-": d3 });
                  break;
                case i2.years:
                  v3 = u2({ "-other-decade-": this.isOtherDecade, "-disabled-": d3 || this.isOtherDecade && !a3 });
              }
              return u2(m3, v3, null === (e3 = this.customData) || void 0 === e3 ? void 0 : e3.classes).split(" ");
            }
            _getHtml() {
              var e3;
              let { year: t3, month: s3, date: a3 } = h2(this.date), { showOtherMonths: n3, showOtherYears: r3 } = this.opts;
              if (null !== (e3 = this.customData) && void 0 !== e3 && e3.html) return this.customData.html;
              switch (this.type) {
                case i2.days:
                  return !n3 && this.isOtherMonth ? "" : a3;
                case i2.months:
                  return this.dp.locale[this.opts.monthsField][s3];
                case i2.years:
                  return !r3 && this.isOtherDecade ? "" : t3;
              }
            }
            _isOutOfMinMaxRange() {
              let { minDate: e3, maxDate: t3 } = this.dp, { type: s3, date: a3 } = this, { month: n3, year: r3, date: o3 } = h2(a3), l3 = s3 === i2.days, d3 = s3 === i2.years, c3 = !!e3 && new Date(r3, d3 ? e3.getMonth() : n3, l3 ? o3 : e3.getDate()), u3 = !!t3 && new Date(r3, d3 ? t3.getMonth() : n3, l3 ? o3 : t3.getDate());
              return e3 && t3 ? v2(c3, e3) || m2(u3, t3) : e3 ? v2(c3, e3) : t3 ? m2(u3, t3) : void 0;
            }
            destroy() {
              this.unbindDatepickerEvents();
            }
            _handleRangeStatus() {
              const { selectedDates: e3, focusDate: t3, rangeDateTo: i3, rangeDateFrom: s3 } = this.dp, a3 = e3.length;
              if (!a3) return;
              let n3 = s3, r3 = i3;
              if (1 === a3 && t3) {
                const i4 = m2(t3, e3[0]);
                n3 = i4 ? e3[0] : t3, r3 = i4 ? t3 : e3[0];
              }
              let o3 = u2({ "-in-range-": n3 && r3 && (h3 = this.date, l3 = n3, d3 = r3, m2(h3, l3) && v2(h3, d3)), "-range-from-": n3 && p2(this.date, n3, this.type), "-range-to-": r3 && p2(this.date, r3, this.type) });
              var h3, l3, d3;
              this.$cell.classList.remove("-range-from-", "-range-to-", "-in-range-"), o3 && this.$cell.classList.add(...o3.split(" "));
            }
            _handleSelectedStatus() {
              let e3 = this.dp._checkIfDateIsSelected(this.date, this.type);
              e3 ? this.select() : !e3 && this.selected && this.removeSelect();
            }
            _handleInitialFocusStatus() {
              p2(this.dp.focusDate, this.date, this.type) && this.focus();
            }
            _handleClasses() {
              this.$cell.setAttribute("class", ""), this._handleInitialFocusStatus(), this.dp.hasSelectedDates && (this._handleSelectedStatus(), this.dp.opts.range && this._handleRangeStatus()), this.$cell.classList.add(...this._getClassName());
            }
            get isDisabled() {
              return this.$cell.matches(".-disabled-");
            }
            get isOtherMonth() {
              return this.dp.isOtherMonth(this.date);
            }
            get isOtherDecade() {
              return this.dp.isOtherDecade(this.date);
            }
          }
          function _2(e3, t3, i3) {
            return (t3 = function(e4) {
              var t4 = function(e5, t5) {
                if ("object" != typeof e5 || null === e5) return e5;
                var i4 = e5[Symbol.toPrimitive];
                if (void 0 !== i4) {
                  var s3 = i4.call(e5, "string");
                  if ("object" != typeof s3) return s3;
                  throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return String(e5);
              }(e4);
              return "symbol" == typeof t4 ? t4 : String(t4);
            }(t3)) in e3 ? Object.defineProperty(e3, t3, { value: i3, enumerable: true, configurable: true, writable: true }) : e3[t3] = i3, e3;
          }
          let M2 = { [i2.days]: `<div class="air-datepicker-body--day-names"></div><div class="air-datepicker-body--cells -${i2.days}-"></div>`, [i2.months]: `<div class="air-datepicker-body--cells -${i2.months}-"></div>`, [i2.years]: `<div class="air-datepicker-body--cells -${i2.years}-"></div>` };
          const S2 = ".air-datepicker-cell";
          class T2 {
            constructor(e3) {
              let { dp: t3, type: s3, opts: a3 } = e3;
              _2(this, "handleClick", (e4) => {
                let t4 = e4.target.closest(S2).adpCell;
                if (t4.isDisabled) return;
                if (!this.dp.isMinViewReached) return void this.dp.down();
                let i3 = this.dp._checkIfDateIsSelected(t4.date, t4.type);
                i3 ? this.dp._handleAlreadySelectedDates(i3, t4.date) : this.dp.selectDate(t4.date);
              }), _2(this, "handleDayNameClick", (e4) => {
                let t4 = e4.target.getAttribute("data-day-index");
                this.opts.onClickDayName({ dayIndex: Number(t4), datepicker: this.dp });
              }), _2(this, "onChangeCurrentView", (e4) => {
                e4 !== this.type ? this.hide() : (this.show(), this.render());
              }), _2(this, "onMouseOverCell", (e4) => {
                let t4 = y2(e4.target, S2);
                this.dp.setFocusDate(!!t4 && t4.adpCell.date);
              }), _2(this, "onMouseOutCell", () => {
                this.dp.setFocusDate(false);
              }), _2(this, "onClickBody", (e4) => {
                let { onClickDayName: t4 } = this.opts, i3 = e4.target;
                i3.closest(S2) && this.handleClick(e4), t4 && i3.closest(".air-datepicker-body--day-name") && this.handleDayNameClick(e4);
              }), _2(this, "onMouseDown", (e4) => {
                this.pressed = true;
                let t4 = y2(e4.target, S2), i3 = t4 && t4.adpCell;
                p2(i3.date, this.dp.rangeDateFrom) && (this.rangeFromFocused = true), p2(i3.date, this.dp.rangeDateTo) && (this.rangeToFocused = true);
              }), _2(this, "onMouseMove", (e4) => {
                if (!this.pressed || !this.dp.isMinViewReached) return;
                e4.preventDefault();
                let t4 = y2(e4.target, S2), i3 = t4 && t4.adpCell, { selectedDates: s4, rangeDateTo: a4, rangeDateFrom: n3 } = this.dp;
                if (!i3 || i3.isDisabled) return;
                let { date: r3 } = i3;
                if (2 === s4.length) {
                  if (this.rangeFromFocused && !m2(r3, a4)) {
                    let { hours: e5, minutes: t5 } = h2(n3);
                    r3.setHours(e5), r3.setMinutes(t5), this.dp.rangeDateFrom = r3, this.dp.replaceDate(n3, r3);
                  }
                  if (this.rangeToFocused && !v2(r3, n3)) {
                    let { hours: e5, minutes: t5 } = h2(a4);
                    r3.setHours(e5), r3.setMinutes(t5), this.dp.rangeDateTo = r3, this.dp.replaceDate(a4, r3);
                  }
                }
              }), _2(this, "onMouseUp", () => {
                this.pressed = false, this.rangeFromFocused = false, this.rangeToFocused = false;
              }), _2(this, "onChangeViewDate", (e4, t4) => {
                if (!this.isVisible) return;
                let s4 = c2(e4), a4 = c2(t4);
                switch (this.dp.currentView) {
                  case i2.days:
                    if (p2(e4, t4, i2.months)) return;
                    break;
                  case i2.months:
                    if (p2(e4, t4, i2.years)) return;
                    break;
                  case i2.years:
                    if (s4[0] === a4[0] && s4[1] === a4[1]) return;
                }
                this.render();
              }), _2(this, "render", () => {
                this.destroyCells(), this._generateCells(), this.cells.forEach((e4) => {
                  this.$cells.appendChild(e4.render());
                });
              }), this.dp = t3, this.type = s3, this.opts = a3, this.cells = [], this.$el = "", this.pressed = false, this.isVisible = true, this.init();
            }
            init() {
              this._buildBaseHtml(), this.type === i2.days && this.renderDayNames(), this.render(), this._bindEvents(), this._bindDatepickerEvents();
            }
            _bindEvents() {
              let { range: e3, dynamicRange: t3 } = this.opts;
              D2(this.$el, "mouseover", this.onMouseOverCell), D2(this.$el, "mouseout", this.onMouseOutCell), D2(this.$el, "click", this.onClickBody), e3 && t3 && (D2(this.$el, "mousedown", this.onMouseDown), D2(this.$el, "mousemove", this.onMouseMove), D2(window.document, "mouseup", this.onMouseUp));
            }
            _bindDatepickerEvents() {
              this.dp.on(i2.eventChangeViewDate, this.onChangeViewDate), this.dp.on(i2.eventChangeCurrentView, this.onChangeCurrentView);
            }
            _buildBaseHtml() {
              this.$el = n2({ className: `air-datepicker-body -${this.type}-`, innerHtml: M2[this.type] }), this.$names = a2(".air-datepicker-body--day-names", this.$el), this.$cells = a2(".air-datepicker-body--cells", this.$el);
            }
            _getDayNamesHtml() {
              let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.dp.locale.firstDay, t3 = "", s3 = this.dp.isWeekend, { onClickDayName: a3 } = this.opts, n3 = e3, r3 = 0;
              for (; r3 < 7; ) {
                let e4 = n3 % 7;
                t3 += `<div class="${u2("air-datepicker-body--day-name", { [i2.cssClassWeekend]: s3(e4), "-clickable-": !!a3 })}" data-day-index='${e4}'>${this.dp.locale.daysMin[e4]}</div>`, r3++, n3++;
              }
              return t3;
            }
            renderDayNames() {
              this.$names.innerHTML = this._getDayNamesHtml();
            }
            _generateCell(e3) {
              let { type: t3, dp: i3, opts: s3 } = this;
              return new C2({ type: t3, dp: i3, opts: s3, date: e3, body: this });
            }
            _generateCells() {
              T2.getDatesFunction(this.type)(this.dp, (e3) => {
                this.cells.push(this._generateCell(e3));
              });
            }
            show() {
              this.isVisible = true, this.$el.classList.remove("-hidden-");
            }
            hide() {
              this.isVisible = false, this.$el.classList.add("-hidden-");
            }
            destroyCells() {
              this.cells.forEach((e3) => e3.destroy()), this.cells = [], this.$cells.innerHTML = "";
            }
            destroy() {
              this.destroyCells(), this.dp.off(i2.eventChangeViewDate, this.onChangeViewDate), this.dp.off(i2.eventChangeCurrentView, this.onChangeCurrentView);
            }
            static getDaysDates(e3, t3) {
              let { viewDate: i3, opts: { fixedHeight: s3 }, locale: { firstDay: a3 } } = e3, n3 = o2(i3), { year: r3, month: l3 } = h2(i3), d3 = new Date(r3, l3, 1), c3 = new Date(r3, l3, n3), u3 = d3.getDay() - a3, p3 = 6 - c3.getDay() + a3;
              u3 = u3 < 0 ? u3 + 7 : u3, p3 = p3 > 6 ? p3 - 7 : p3;
              let m3 = function(e4, t4) {
                let { year: i4, month: s4, date: a4 } = h2(e4);
                return new Date(i4, s4, a4 - t4);
              }(d3, u3), v3 = n3 + u3 + p3, g3 = m3.getDate(), { year: D3, month: y3 } = h2(m3), f3 = 0;
              s3 && (v3 = 42);
              const w3 = [];
              for (; f3 < v3; ) {
                let e4 = new Date(D3, y3, g3 + f3);
                t3 && t3(e4), w3.push(e4), f3++;
              }
              return w3;
            }
            static getMonthsDates(e3, t3) {
              let { year: i3 } = e3.parsedViewDate, s3 = 0, a3 = [];
              for (; s3 < 12; ) {
                const e4 = new Date(i3, s3);
                a3.push(e4), t3 && t3(e4), s3++;
              }
              return a3;
            }
            static getYearsDates(e3, t3) {
              let i3 = c2(e3.viewDate), s3 = i3[0] - 1, a3 = i3[1] + 1, n3 = s3, r3 = [];
              for (; n3 <= a3; ) {
                const e4 = new Date(n3, 0);
                r3.push(e4), t3 && t3(e4), n3++;
              }
              return r3;
            }
            static getDatesFunction() {
              let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : i2.days;
              return { [i2.days]: T2.getDaysDates, [i2.months]: T2.getMonthsDates, [i2.years]: T2.getYearsDates }[e3];
            }
          }
          function F2(e3, t3, i3) {
            return (t3 = function(e4) {
              var t4 = function(e5, t5) {
                if ("object" != typeof e5 || null === e5) return e5;
                var i4 = e5[Symbol.toPrimitive];
                if (void 0 !== i4) {
                  var s3 = i4.call(e5, "string");
                  if ("object" != typeof s3) return s3;
                  throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return String(e5);
              }(e4);
              return "symbol" == typeof t4 ? t4 : String(t4);
            }(t3)) in e3 ? Object.defineProperty(e3, t3, { value: i3, enumerable: true, configurable: true, writable: true }) : e3[t3] = i3, e3;
          }
          class V2 {
            constructor(e3) {
              let { dp: t3, opts: i3 } = e3;
              F2(this, "onClickNav", (e4) => {
                let t4 = y2(e4.target, ".air-datepicker-nav--action");
                if (!t4) return;
                let i4 = t4.dataset.action;
                this.dp[i4]();
              }), F2(this, "onChangeViewDate", () => {
                this.render(), this._resetNavStatus(), this.handleNavStatus();
              }), F2(this, "onChangeCurrentView", () => {
                this.render(), this._resetNavStatus(), this.handleNavStatus();
              }), F2(this, "onClickNavTitle", () => {
                this.dp.isFinalView || this.dp.up();
              }), F2(this, "update", () => {
                let { prevHtml: e4, nextHtml: t4 } = this.opts;
                this.$prev.innerHTML = e4, this.$next.innerHTML = t4, this._resetNavStatus(), this.render(), this.handleNavStatus();
              }), F2(this, "renderDelay", () => {
                setTimeout(this.render);
              }), F2(this, "render", () => {
                this.$title.innerHTML = this._getTitle(), function(e4, t4) {
                  for (let i4 in t4) t4[i4] ? e4.classList.add(i4) : e4.classList.remove(i4);
                }(this.$title, { "-disabled-": this.dp.isFinalView });
              }), this.dp = t3, this.opts = i3, this.init();
            }
            init() {
              this._createElement(), this._buildBaseHtml(), this._defineDOM(), this.render(), this.handleNavStatus(), this._bindEvents(), this._bindDatepickerEvents();
            }
            _defineDOM() {
              this.$title = a2(".air-datepicker-nav--title", this.$el), this.$prev = a2('[data-action="prev"]', this.$el), this.$next = a2('[data-action="next"]', this.$el);
            }
            _bindEvents() {
              this.$el.addEventListener("click", this.onClickNav), this.$title.addEventListener("click", this.onClickNavTitle);
            }
            _bindDatepickerEvents() {
              this.dp.on(i2.eventChangeViewDate, this.onChangeViewDate), this.dp.on(i2.eventChangeCurrentView, this.onChangeCurrentView), this.isNavIsFunction && (this.dp.on(i2.eventChangeSelectedDate, this.renderDelay), this.dp.opts.timepicker && this.dp.on(i2.eventChangeTime, this.render));
            }
            destroy() {
              this.dp.off(i2.eventChangeViewDate, this.onChangeViewDate), this.dp.off(i2.eventChangeCurrentView, this.onChangeCurrentView), this.isNavIsFunction && (this.dp.off(i2.eventChangeSelectedDate, this.renderDelay), this.dp.opts.timepicker && this.dp.off(i2.eventChangeTime, this.render));
            }
            _createElement() {
              this.$el = n2({ tagName: "nav", className: "air-datepicker-nav" });
            }
            _getTitle() {
              let { dp: e3, opts: t3 } = this, i3 = t3.navTitles[e3.currentView];
              return "function" == typeof i3 ? i3(e3) : e3.formatDate(e3.viewDate, i3);
            }
            handleNavStatus() {
              let { disableNavWhenOutOfRange: e3 } = this.opts, { minDate: t3, maxDate: s3 } = this.dp;
              if (!t3 && !s3 || !e3) return;
              let { year: a3, month: n3 } = this.dp.parsedViewDate, r3 = !!t3 && h2(t3), o3 = !!s3 && h2(s3);
              switch (this.dp.currentView) {
                case i2.days:
                  t3 && r3.month >= n3 && r3.year >= a3 && this._disableNav("prev"), s3 && o3.month <= n3 && o3.year <= a3 && this._disableNav("next");
                  break;
                case i2.months:
                  t3 && r3.year >= a3 && this._disableNav("prev"), s3 && o3.year <= a3 && this._disableNav("next");
                  break;
                case i2.years: {
                  let e4 = c2(this.dp.viewDate);
                  t3 && r3.year >= e4[0] && this._disableNav("prev"), s3 && o3.year <= e4[1] && this._disableNav("next");
                  break;
                }
              }
            }
            _disableNav(e3) {
              a2('[data-action="' + e3 + '"]', this.$el).classList.add("-disabled-");
            }
            _resetNavStatus() {
              !function(e3) {
                for (var t3 = arguments.length, i3 = new Array(t3 > 1 ? t3 - 1 : 0), s3 = 1; s3 < t3; s3++) i3[s3 - 1] = arguments[s3];
                e3.length ? e3.forEach((e4) => {
                  e4.classList.remove(...i3);
                }) : e3.classList.remove(...i3);
              }(this.$el.querySelectorAll(".air-datepicker-nav--action"), "-disabled-");
            }
            _buildBaseHtml() {
              let { prevHtml: e3, nextHtml: t3 } = this.opts;
              this.$el.innerHTML = `<div class="air-datepicker-nav--action" data-action="prev">${e3}</div><div class="air-datepicker-nav--title"></div><div class="air-datepicker-nav--action" data-action="next">${t3}</div>`;
            }
            get isNavIsFunction() {
              let { navTitles: e3 } = this.opts;
              return Object.keys(e3).find((t3) => "function" == typeof e3[t3]);
            }
          }
          var x2 = { today: { content: (e3) => e3.locale.today, onClick: (e3) => e3.setViewDate(/* @__PURE__ */ new Date()) }, clear: { content: (e3) => e3.locale.clear, onClick: (e3) => e3.clear() } };
          class H2 {
            constructor(e3) {
              let { dp: t3, opts: i3 } = e3;
              this.dp = t3, this.opts = i3, this.init();
            }
            init() {
              this.createElement(), this.render();
            }
            createElement() {
              this.$el = n2({ className: "air-datepicker-buttons" });
            }
            destroy() {
              this.$el.parentNode.removeChild(this.$el);
            }
            clearHtml() {
              return this.$el.innerHTML = "", this;
            }
            generateButtons() {
              let { buttons: e3 } = this.opts;
              Array.isArray(e3) || (e3 = [e3]), e3.forEach((e4) => {
                let t3 = e4;
                "string" == typeof e4 && x2[e4] && (t3 = x2[e4]);
                let i3 = this.createButton(t3);
                t3.onClick && this.attachEventToButton(i3, t3.onClick), this.$el.appendChild(i3);
              });
            }
            attachEventToButton(e3, t3) {
              e3.addEventListener("click", () => {
                t3(this.dp);
              });
            }
            createButton(e3) {
              let { content: t3, className: i3, tagName: s3 = "button", attrs: a3 = {} } = e3;
              return n2({ tagName: s3, innerHtml: `<span tabindex='-1'>${"function" == typeof t3 ? t3(this.dp) : t3}</span>`, className: u2("air-datepicker-button", i3), attrs: a3 });
            }
            render() {
              this.generateButtons();
            }
          }
          function E2(e3, t3, i3) {
            return (t3 = function(e4) {
              var t4 = function(e5, t5) {
                if ("object" != typeof e5 || null === e5) return e5;
                var i4 = e5[Symbol.toPrimitive];
                if (void 0 !== i4) {
                  var s3 = i4.call(e5, "string");
                  if ("object" != typeof s3) return s3;
                  throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return String(e5);
              }(e4);
              return "symbol" == typeof t4 ? t4 : String(t4);
            }(t3)) in e3 ? Object.defineProperty(e3, t3, { value: i3, enumerable: true, configurable: true, writable: true }) : e3[t3] = i3, e3;
          }
          class L2 {
            constructor() {
              let { opts: e3, dp: t3 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
              E2(this, "toggleTimepickerIsActive", (e4) => {
                this.dp.timepickerIsActive = e4;
              }), E2(this, "onChangeSelectedDate", (e4) => {
                let { date: t4, updateTime: i3 = false } = e4;
                t4 && (this.setMinMaxTime(t4), this.setCurrentTime(!!i3 && t4), this.addTimeToDate(t4));
              }), E2(this, "onChangeLastSelectedDate", (e4) => {
                e4 && (this.setTime(e4), this.render());
              }), E2(this, "onChangeInputRange", (e4) => {
                let t4 = e4.target;
                this[t4.getAttribute("name")] = t4.value, this.updateText(), this.dp.trigger(i2.eventChangeTime, { hours: this.hours, minutes: this.minutes });
              }), E2(this, "onMouseEnterLeave", (e4) => {
                let t4 = e4.target.getAttribute("name"), i3 = this.$minutesText;
                "hours" === t4 && (i3 = this.$hoursText), i3.classList.toggle("-focus-");
              }), E2(this, "onFocus", () => {
                this.toggleTimepickerIsActive(true);
              }), E2(this, "onBlur", () => {
                this.toggleTimepickerIsActive(false);
              }), this.opts = e3, this.dp = t3;
              let { timeFormat: s3 } = this.dp.locale;
              s3 && (s3.match(k2("h")) || s3.match(k2("hh"))) && (this.ampm = true), this.init();
            }
            init() {
              this.setTime(this.dp.lastSelectedDate || this.dp.viewDate), this.createElement(), this.buildHtml(), this.defineDOM(), this.render(), this.bindDatepickerEvents(), this.bindDOMEvents();
            }
            bindDatepickerEvents() {
              this.dp.on(i2.eventChangeSelectedDate, this.onChangeSelectedDate), this.dp.on(i2.eventChangeLastSelectedDate, this.onChangeLastSelectedDate);
            }
            bindDOMEvents() {
              let e3 = "input";
              navigator.userAgent.match(/trident/gi) && (e3 = "change"), D2(this.$ranges, e3, this.onChangeInputRange), D2(this.$ranges, "mouseenter", this.onMouseEnterLeave), D2(this.$ranges, "mouseleave", this.onMouseEnterLeave), D2(this.$ranges, "focus", this.onFocus), D2(this.$ranges, "mousedown", this.onFocus), D2(this.$ranges, "blur", this.onBlur);
            }
            createElement() {
              this.$el = n2({ className: u2("air-datepicker-time", { "-am-pm-": this.dp.ampm }) });
            }
            destroy() {
              this.dp.off(i2.eventChangeSelectedDate, this.onChangeSelectedDate), this.dp.off(i2.eventChangeLastSelectedDate, this.onChangeLastSelectedDate), this.$el.parentNode.removeChild(this.$el);
            }
            buildHtml() {
              let { ampm: e3, hours: t3, displayHours: i3, minutes: s3, minHours: a3, minMinutes: n3, maxHours: r3, maxMinutes: o3, dayPeriod: h3, opts: { hoursStep: l3, minutesStep: c3 } } = this;
              this.$el.innerHTML = `<div class="air-datepicker-time--current">   <span class="air-datepicker-time--current-hours">${d2(i3)}</span>   <span class="air-datepicker-time--current-colon">:</span>   <span class="air-datepicker-time--current-minutes">${d2(s3)}</span>   ` + (e3 ? `<span class='air-datepicker-time--current-ampm'>${h3}</span>` : "") + `</div><div class="air-datepicker-time--sliders">   <div class="air-datepicker-time--row">      <input type="range" name="hours" value="${t3}" min="${a3}" max="${r3}" step="${l3}"/>   </div>   <div class="air-datepicker-time--row">      <input type="range" name="minutes" value="${s3}" min="${n3}" max="${o3}" step="${c3}"/>   </div></div>`;
            }
            defineDOM() {
              let e3 = (e4) => a2(e4, this.$el);
              this.$ranges = this.$el.querySelectorAll('[type="range"]'), this.$hours = e3('[name="hours"]'), this.$minutes = e3('[name="minutes"]'), this.$hoursText = e3(".air-datepicker-time--current-hours"), this.$minutesText = e3(".air-datepicker-time--current-minutes"), this.$ampm = e3(".air-datepicker-time--current-ampm");
            }
            setTime(e3) {
              this.setMinMaxTime(e3), this.setCurrentTime(e3);
            }
            addTimeToDate(e3) {
              e3 && (e3.setHours(this.hours), e3.setMinutes(this.minutes));
            }
            setMinMaxTime(e3) {
              if (this.setMinMaxTimeFromOptions(), e3) {
                let { minDate: t3, maxDate: i3 } = this.dp;
                t3 && p2(e3, t3) && this.setMinTimeFromMinDate(t3), i3 && p2(e3, i3) && this.setMaxTimeFromMaxDate(i3);
              }
            }
            setCurrentTime(e3) {
              let { hours: t3, minutes: i3 } = e3 ? h2(e3) : this;
              this.hours = f2(t3, this.minHours, this.maxHours), this.minutes = f2(i3, this.minMinutes, this.maxMinutes);
            }
            setMinMaxTimeFromOptions() {
              let { minHours: e3, minMinutes: t3, maxHours: i3, maxMinutes: s3 } = this.opts;
              this.minHours = f2(e3, 0, 23), this.minMinutes = f2(t3, 0, 59), this.maxHours = f2(i3, 0, 23), this.maxMinutes = f2(s3, 0, 59);
            }
            setMinTimeFromMinDate(e3) {
              let { lastSelectedDate: t3 } = this.dp;
              this.minHours = e3.getHours(), t3 && t3.getHours() > e3.getHours() ? this.minMinutes = this.opts.minMinutes : this.minMinutes = e3.getMinutes();
            }
            setMaxTimeFromMaxDate(e3) {
              let { lastSelectedDate: t3 } = this.dp;
              this.maxHours = e3.getHours(), t3 && t3.getHours() < e3.getHours() ? this.maxMinutes = this.opts.maxMinutes : this.maxMinutes = e3.getMinutes();
            }
            updateSliders() {
              r2(this.$hours, { min: this.minHours, max: this.maxHours }).value = this.hours, r2(this.$minutes, { min: this.minMinutes, max: this.maxMinutes }).value = this.minutes;
            }
            updateText() {
              this.$hoursText.innerHTML = d2(this.displayHours), this.$minutesText.innerHTML = d2(this.minutes), this.ampm && (this.$ampm.innerHTML = this.dayPeriod);
            }
            set hours(e3) {
              this._hours = e3;
              let { hours: t3, dayPeriod: i3 } = l2(e3);
              this.displayHours = this.ampm ? t3 : e3, this.dayPeriod = i3;
            }
            get hours() {
              return this._hours;
            }
            render() {
              this.updateSliders(), this.updateText();
            }
          }
          function O2(e3, t3, i3) {
            return (t3 = function(e4) {
              var t4 = function(e5, t5) {
                if ("object" != typeof e5 || null === e5) return e5;
                var i4 = e5[Symbol.toPrimitive];
                if (void 0 !== i4) {
                  var s3 = i4.call(e5, "string");
                  if ("object" != typeof s3) return s3;
                  throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return String(e5);
              }(e4);
              return "symbol" == typeof t4 ? t4 : String(t4);
            }(t3)) in e3 ? Object.defineProperty(e3, t3, { value: i3, enumerable: true, configurable: true, writable: true }) : e3[t3] = i3, e3;
          }
          class A2 {
            constructor(e3) {
              let { dp: t3, opts: i3 } = e3;
              O2(this, "pressedKeys", /* @__PURE__ */ new Set()), O2(this, "hotKeys", /* @__PURE__ */ new Map([[[["Control", "ArrowRight"], ["Control", "ArrowUp"]], (e4) => e4.month++], [[["Control", "ArrowLeft"], ["Control", "ArrowDown"]], (e4) => e4.month--], [[["Shift", "ArrowRight"], ["Shift", "ArrowUp"]], (e4) => e4.year++], [[["Shift", "ArrowLeft"], ["Shift", "ArrowDown"]], (e4) => e4.year--], [[["Alt", "ArrowRight"], ["Alt", "ArrowUp"]], (e4) => e4.year += 10], [[["Alt", "ArrowLeft"], ["Alt", "ArrowDown"]], (e4) => e4.year -= 10], [["Control", "Shift", "ArrowUp"], (e4, t4) => t4.up()]])), O2(this, "handleHotKey", (e4) => {
                let t4 = this.hotKeys.get(e4), i4 = h2(this.getInitialFocusDate());
                t4(i4, this.dp);
                let { year: s3, month: a3, date: n3 } = i4, r3 = o2(new Date(s3, a3));
                r3 < n3 && (n3 = r3);
                let l3 = this.dp.getClampedDate(new Date(s3, a3, n3));
                this.dp.setFocusDate(l3, { viewDateTransition: true });
              }), O2(this, "isHotKeyPressed", () => {
                let e4 = false, t4 = this.pressedKeys.size, i4 = (e5) => this.pressedKeys.has(e5);
                for (let [s3] of this.hotKeys) {
                  if (e4) break;
                  if (Array.isArray(s3[0])) s3.forEach((a3) => {
                    e4 || t4 !== a3.length || (e4 = a3.every(i4) && s3);
                  });
                  else {
                    if (t4 !== s3.length) continue;
                    e4 = s3.every(i4) && s3;
                  }
                }
                return e4;
              }), O2(this, "isArrow", (e4) => e4 >= 37 && e4 <= 40), O2(this, "onKeyDown", (e4) => {
                let { key: t4, which: i4 } = e4, { dp: s3, dp: { focusDate: a3 }, opts: n3 } = this;
                this.registerKey(t4);
                let r3 = this.isHotKeyPressed();
                if (r3) return e4.preventDefault(), void this.handleHotKey(r3);
                if (this.isArrow(i4)) return e4.preventDefault(), void this.focusNextCell(t4);
                if ("Enter" === t4) {
                  if (s3.currentView !== n3.minView) return void s3.down();
                  if (a3) {
                    let e5 = s3._checkIfDateIsSelected(a3);
                    return void (e5 ? s3._handleAlreadySelectedDates(e5, a3) : s3.selectDate(a3));
                  }
                }
                "Escape" === t4 && this.dp.hide();
              }), O2(this, "onKeyUp", (e4) => {
                this.removeKey(e4.key);
              }), this.dp = t3, this.opts = i3, this.init();
            }
            init() {
              this.bindKeyboardEvents();
            }
            bindKeyboardEvents() {
              let { $el: e3 } = this.dp;
              e3.addEventListener("keydown", this.onKeyDown), e3.addEventListener("keyup", this.onKeyUp);
            }
            destroy() {
              let { $el: e3 } = this.dp;
              e3.removeEventListener("keydown", this.onKeyDown), e3.removeEventListener("keyup", this.onKeyUp), this.hotKeys = null, this.pressedKeys = null;
            }
            getInitialFocusDate() {
              let { focusDate: e3, currentView: t3, selectedDates: s3, parsedViewDate: { year: a3, month: n3 } } = this.dp, r3 = e3 || s3[s3.length - 1];
              if (!r3) switch (t3) {
                case i2.days:
                  r3 = new Date(a3, n3, (/* @__PURE__ */ new Date()).getDate());
                  break;
                case i2.months:
                  r3 = new Date(a3, n3, 1);
                  break;
                case i2.years:
                  r3 = new Date(a3, 0, 1);
              }
              return r3;
            }
            focusNextCell(e3) {
              let t3 = this.getInitialFocusDate(), { currentView: s3 } = this.dp, { days: a3, months: n3, years: r3 } = i2, o3 = h2(t3), l3 = o3.year, d3 = o3.month, c3 = o3.date;
              switch (e3) {
                case "ArrowLeft":
                  s3 === a3 && (c3 -= 1), s3 === n3 && (d3 -= 1), s3 === r3 && (l3 -= 1);
                  break;
                case "ArrowUp":
                  s3 === a3 && (c3 -= 7), s3 === n3 && (d3 -= 3), s3 === r3 && (l3 -= 4);
                  break;
                case "ArrowRight":
                  s3 === a3 && (c3 += 1), s3 === n3 && (d3 += 1), s3 === r3 && (l3 += 1);
                  break;
                case "ArrowDown":
                  s3 === a3 && (c3 += 7), s3 === n3 && (d3 += 3), s3 === r3 && (l3 += 4);
              }
              let u3 = this.dp.getClampedDate(new Date(l3, d3, c3));
              this.dp.setFocusDate(u3, { viewDateTransition: true });
            }
            registerKey(e3) {
              this.pressedKeys.add(e3);
            }
            removeKey(e3) {
              this.pressedKeys.delete(e3);
            }
          }
          let N2 = { on(e3, t3) {
            this.__events || (this.__events = {}), this.__events[e3] ? this.__events[e3].push(t3) : this.__events[e3] = [t3];
          }, off(e3, t3) {
            this.__events && this.__events[e3] && (this.__events[e3] = this.__events[e3].filter((e4) => e4 !== t3));
          }, removeAllEvents() {
            this.__events = {};
          }, trigger(e3) {
            for (var t3 = arguments.length, i3 = new Array(t3 > 1 ? t3 - 1 : 0), s3 = 1; s3 < t3; s3++) i3[s3 - 1] = arguments[s3];
            this.__events && this.__events[e3] && this.__events[e3].forEach((e4) => {
              e4(...i3);
            });
          } };
          function I2(e3, t3, i3) {
            return (t3 = function(e4) {
              var t4 = function(e5, t5) {
                if ("object" != typeof e5 || null === e5) return e5;
                var i4 = e5[Symbol.toPrimitive];
                if (void 0 !== i4) {
                  var s3 = i4.call(e5, "string");
                  if ("object" != typeof s3) return s3;
                  throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return String(e5);
              }(e4);
              return "symbol" == typeof t4 ? t4 : String(t4);
            }(t3)) in e3 ? Object.defineProperty(e3, t3, { value: i3, enumerable: true, configurable: true, writable: true }) : e3[t3] = i3, e3;
          }
          let P2 = "", j2 = "", B2 = false;
          class R2 {
            static buildGlobalContainer(e3) {
              B2 = true, P2 = n2({ className: e3, id: e3 }), a2("body").appendChild(P2);
            }
            constructor(e3, t3) {
              var r3 = this;
              if (I2(this, "viewIndexes", [i2.days, i2.months, i2.years]), I2(this, "next", () => {
                let { year: e4, month: t4 } = this.parsedViewDate;
                switch (this.currentView) {
                  case i2.days:
                    this.setViewDate(new Date(e4, t4 + 1, 1));
                    break;
                  case i2.months:
                    this.setViewDate(new Date(e4 + 1, t4, 1));
                    break;
                  case i2.years:
                    this.setViewDate(new Date(e4 + 10, 0, 1));
                }
              }), I2(this, "prev", () => {
                let { year: e4, month: t4 } = this.parsedViewDate;
                switch (this.currentView) {
                  case i2.days:
                    this.setViewDate(new Date(e4, t4 - 1, 1));
                    break;
                  case i2.months:
                    this.setViewDate(new Date(e4 - 1, t4, 1));
                    break;
                  case i2.years:
                    this.setViewDate(new Date(e4 - 10, 0, 1));
                }
              }), I2(this, "_finishHide", () => {
                this.hideAnimation = false, this._destroyComponents(), this.$container.removeChild(this.$datepicker);
              }), I2(this, "setPosition", function(e4) {
                let t4 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                if ("function" == typeof (e4 = e4 || r3.opts.position)) return void (r3.customHide = e4({ $datepicker: r3.$datepicker, $target: r3.$el, $pointer: r3.$pointer, isViewChange: t4, done: r3._finishHide }));
                let i3, s3, { isMobile: a3 } = r3.opts, n3 = r3.$el.getBoundingClientRect(), o4 = r3.$el.getBoundingClientRect(), h3 = r3.$datepicker.offsetParent, l4 = r3.$el.offsetParent, d3 = r3.$datepicker.getBoundingClientRect(), c3 = e4.split(" "), u3 = window.scrollY, p3 = window.scrollX, m3 = r3.opts.offset, v3 = c3[0], g3 = c3[1];
                if (a3) r3.$datepicker.style.cssText = "left: 50%; top: 50%";
                else {
                  if (h3 === l4 && h3 !== document.body && (o4 = { top: r3.$el.offsetTop, left: r3.$el.offsetLeft, width: n3.width, height: r3.$el.offsetHeight }, u3 = 0, p3 = 0), h3 !== l4 && h3 !== document.body) {
                    let e5 = h3.getBoundingClientRect();
                    o4 = { top: n3.top - e5.top, left: n3.left - e5.left, width: n3.width, height: n3.height }, u3 = 0, p3 = 0;
                  }
                  switch (v3) {
                    case "top":
                      i3 = o4.top - d3.height - m3;
                      break;
                    case "right":
                      s3 = o4.left + o4.width + m3;
                      break;
                    case "bottom":
                      i3 = o4.top + o4.height + m3;
                      break;
                    case "left":
                      s3 = o4.left - d3.width - m3;
                  }
                  switch (g3) {
                    case "top":
                      i3 = o4.top;
                      break;
                    case "right":
                      s3 = o4.left + o4.width - d3.width;
                      break;
                    case "bottom":
                      i3 = o4.top + o4.height - d3.height;
                      break;
                    case "left":
                      s3 = o4.left;
                      break;
                    case "center":
                      /left|right/.test(v3) ? i3 = o4.top + o4.height / 2 - d3.height / 2 : s3 = o4.left + o4.width / 2 - d3.width / 2;
                  }
                  r3.$datepicker.style.cssText = `left: ${s3 + p3}px; top: ${i3 + u3}px`;
                }
              }), I2(this, "_setInputValue", () => {
                let { opts: e4, $altField: t4, locale: { dateFormat: i3 } } = this, { altFieldDateFormat: s3, altField: a3 } = e4;
                a3 && t4 && (t4.value = this._getInputValue(s3)), this.$el.value = this._getInputValue(i3);
              }), I2(this, "_getInputValue", (e4) => {
                let { selectedDates: t4, opts: i3 } = this, { multipleDates: s3, multipleDatesSeparator: a3 } = i3;
                if (!t4.length) return "";
                let n3 = "function" == typeof e4, r4 = n3 ? e4(s3 ? t4 : t4[0]) : t4.map((t5) => this.formatDate(t5, e4));
                return r4 = n3 ? r4 : r4.join(a3), r4;
              }), I2(this, "_checkIfDateIsSelected", function(e4) {
                let t4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : i2.days, s3 = false;
                return r3.selectedDates.some((i3) => {
                  let a3 = p2(e4, i3, t4);
                  return s3 = a3 && i3, a3;
                }), s3;
              }), I2(this, "_scheduleCallAfterTransition", (e4) => {
                this._cancelScheduledCall(), e4 && e4(false), this._onTransitionEnd = () => {
                  e4 && e4(true);
                }, this.$datepicker.addEventListener("transitionend", this._onTransitionEnd, { once: true });
              }), I2(this, "_cancelScheduledCall", () => {
                this.$datepicker.removeEventListener("transitionend", this._onTransitionEnd);
              }), I2(this, "setViewDate", (e4) => {
                if (!((e4 = b2(e4)) instanceof Date)) return;
                if (p2(e4, this.viewDate)) return;
                let t4 = this.viewDate;
                this.viewDate = e4;
                let { onChangeViewDate: s3 } = this.opts;
                if (s3) {
                  let { month: e5, year: t5 } = this.parsedViewDate;
                  s3({ month: e5, year: t5, decade: this.curDecade });
                }
                this.trigger(i2.eventChangeViewDate, e4, t4);
              }), I2(this, "setFocusDate", function(e4) {
                let t4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                (!e4 || (e4 = b2(e4)) instanceof Date) && (r3.focusDate = e4, r3.trigger(i2.eventChangeFocusDate, e4, t4));
              }), I2(this, "setCurrentView", function(e4) {
                let t4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                if (r3.viewIndexes.includes(e4)) {
                  if (r3.currentView = e4, r3.elIsInput && r3.visible && r3.setPosition(void 0, true), r3.trigger(i2.eventChangeCurrentView, e4), !r3.views[e4]) {
                    let t5 = r3.views[e4] = new T2({ dp: r3, opts: r3.opts, type: e4 });
                    r3.shouldUpdateDOM && r3.$content.appendChild(t5.$el);
                  }
                  r3.opts.onChangeView && !t4.silent && r3.opts.onChangeView(e4);
                }
              }), I2(this, "_updateLastSelectedDate", (e4) => {
                this.lastSelectedDate = e4, this.trigger(i2.eventChangeLastSelectedDate, e4);
              }), I2(this, "destroy", () => {
                if (this.isDestroyed) return;
                let { showEvent: e4, isMobile: t4 } = this.opts, i3 = this.$datepicker.parentNode;
                i3 && i3.removeChild(this.$datepicker), this.$el.removeEventListener(e4, this._onFocus), this.$el.removeEventListener("blur", this._onBlur), window.removeEventListener("resize", this._onResize), t4 && this._removeMobileAttributes(), this.keyboardNav && this.keyboardNav.destroy(), this.views = null, this.nav = null, this.$datepicker = null, this.opts = {}, this.$customContainer = null, this.viewDate = null, this.focusDate = null, this.selectedDates = [], this.rangeDateFrom = null, this.rangeDateTo = null, this.isDestroyed = true;
              }), I2(this, "update", function() {
                let e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, s3 = w2({}, r3.opts), { silent: a3 } = t4;
                w2(r3.opts, e4);
                let { timepicker: n3, buttons: o4, range: h3, selectedDates: l4, isMobile: d3 } = r3.opts, c3 = r3.visible || r3.treatAsInline;
                r3._createMinMaxDates(), r3._limitViewDateByMaxMinDates(), r3._handleLocale(), l4 && (r3.selectedDates = [], r3.selectDate(l4, { silent: a3 })), e4.view && r3.setCurrentView(e4.view, { silent: a3 }), r3._setInputValue(), s3.range && !h3 ? (r3.rangeDateTo = false, r3.rangeDateFrom = false) : !s3.range && h3 && r3.selectedDates.length && (r3.rangeDateFrom = r3.selectedDates[0], r3.rangeDateTo = r3.selectedDates[1]), s3.timepicker && !n3 ? (c3 && r3.timepicker.destroy(), r3.timepicker = false, r3.$timepicker.parentNode.removeChild(r3.$timepicker)) : !s3.timepicker && n3 && r3._addTimepicker(), !s3.buttons && o4 ? r3._addButtons() : s3.buttons && !o4 ? (r3.buttons.destroy(), r3.$buttons.parentNode.removeChild(r3.$buttons)) : c3 && s3.buttons && o4 && r3.buttons.clearHtml().render(), !s3.isMobile && d3 ? (r3.treatAsInline || j2 || r3._createMobileOverlay(), r3._addMobileAttributes(), r3.visible && r3._showMobileOverlay()) : s3.isMobile && !d3 && (r3._removeMobileAttributes(), r3.visible && (j2.classList.remove("-active-"), "function" != typeof r3.opts.position && r3.setPosition())), c3 && (r3.nav.update(), r3.views[r3.currentView].render(), r3.currentView === i2.days && r3.views[r3.currentView].renderDayNames());
              }), I2(this, "disableDate", (e4, t4) => {
                (Array.isArray(e4) ? e4 : [e4]).forEach((e5) => {
                  let i3 = b2(e5);
                  if (!i3) return;
                  let s3 = t4 ? "delete" : "add";
                  this.disabledDates[s3](this.formatDate(i3, "yyyy-MM-dd"));
                  let a3 = this.getCell(i3, this.currentViewSingular);
                  a3 && a3.adpCell.render();
                }, []);
              }), I2(this, "enableDate", (e4) => {
                this.disableDate(e4, true);
              }), I2(this, "isDateDisabled", (e4) => {
                let t4 = b2(e4);
                return this.disabledDates.has(this.formatDate(t4, "yyyy-MM-dd"));
              }), I2(this, "isOtherMonth", (e4) => {
                let { month: t4 } = h2(e4);
                return t4 !== this.parsedViewDate.month;
              }), I2(this, "isOtherYear", (e4) => {
                let { year: t4 } = h2(e4);
                return t4 !== this.parsedViewDate.year;
              }), I2(this, "isOtherDecade", (e4) => {
                let { year: t4 } = h2(e4), [i3, s3] = c2(this.viewDate);
                return t4 < i3 || t4 > s3;
              }), I2(this, "_onChangeSelectedDate", (e4) => {
                let { silent: t4 } = e4;
                setTimeout(() => {
                  this._setInputValue(), this.opts.onSelect && !t4 && this._triggerOnSelect();
                });
              }), I2(this, "_onChangeFocusedDate", function(e4) {
                let { viewDateTransition: t4 } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                if (!e4) return;
                let i3 = false;
                t4 && (i3 = r3.isOtherMonth(e4) || r3.isOtherYear(e4) || r3.isOtherDecade(e4)), i3 && r3.setViewDate(e4), r3.opts.onFocus && r3.opts.onFocus({ datepicker: r3, date: e4 });
              }), I2(this, "_onChangeTime", (e4) => {
                let { hours: t4, minutes: i3 } = e4, s3 = /* @__PURE__ */ new Date(), { lastSelectedDate: a3, opts: { onSelect: n3 } } = this, r4 = a3;
                a3 || (r4 = s3);
                let o4 = this.getCell(r4, this.currentViewSingular), h3 = o4 && o4.adpCell;
                h3 && h3.isDisabled || (r4.setHours(t4), r4.setMinutes(i3), a3 ? (this._setInputValue(), n3 && this._triggerOnSelect()) : this.selectDate(r4));
              }), I2(this, "_onFocus", (e4) => {
                this.visible || this.show();
              }), I2(this, "_onBlur", (e4) => {
                this.inFocus || !this.visible || this.opts.isMobile || this.hide();
              }), I2(this, "_onMouseDown", (e4) => {
                this.inFocus = true;
              }), I2(this, "_onMouseUp", (e4) => {
                this.inFocus = false, this.$el.focus();
              }), I2(this, "_onResize", () => {
                this.visible && "function" != typeof this.opts.position && this.setPosition();
              }), I2(this, "_onClickOverlay", () => {
                this.visible && this.hide();
              }), I2(this, "getViewDates", function() {
                let e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : i2.days;
                return T2.getDatesFunction(e4)(r3);
              }), I2(this, "isWeekend", (e4) => this.opts.weekends.includes(e4)), I2(this, "getClampedDate", (e4) => {
                let { minDate: t4, maxDate: i3 } = this, s3 = e4;
                return i3 && m2(e4, i3) ? s3 = i3 : t4 && v2(e4, t4) && (s3 = t4), s3;
              }), this.$el = a2(e3), !this.$el) return;
              this.$datepicker = n2({ className: "air-datepicker" }), this.opts = w2({}, s2, t3), this.$customContainer = !!this.opts.container && a2(this.opts.container), this.$altField = a2(this.opts.altField || false);
              let { view: o3, startDate: l3 } = this.opts;
              l3 || (this.opts.startDate = /* @__PURE__ */ new Date()), "INPUT" === this.$el.nodeName && (this.elIsInput = true), this.inited = false, this.visible = false, this.viewDate = b2(this.opts.startDate), this.focusDate = false, this.initialReadonly = this.$el.getAttribute("readonly"), this.customHide = false, this.currentView = o3, this.selectedDates = [], this.disabledDates = /* @__PURE__ */ new Set(), this.isDestroyed = false, this.views = {}, this.keys = [], this.rangeDateFrom = "", this.rangeDateTo = "", this.timepickerIsActive = false, this.treatAsInline = this.opts.inline || !this.elIsInput, this.init();
            }
            init() {
              let { opts: e3, treatAsInline: t3, opts: { inline: i3, isMobile: s3, selectedDates: n3, keyboardNav: r3, onlyTimepicker: o3 } } = this, h3 = a2("body");
              (!B2 || B2 && P2 && !h3.contains(P2)) && !i3 && this.elIsInput && !this.$customContainer && R2.buildGlobalContainer(R2.defaultGlobalContainerId), !s3 || j2 || t3 || this._createMobileOverlay(), this._handleLocale(), this._bindSubEvents(), this._createMinMaxDates(), this._limitViewDateByMaxMinDates(), this.elIsInput && (i3 || this._bindEvents(), r3 && !o3 && (this.keyboardNav = new A2({ dp: this, opts: e3 }))), n3 && this.selectDate(n3, { silent: true }), this.opts.visible && !t3 && this.show(), s3 && !t3 && this.$el.setAttribute("readonly", true), t3 && this._createComponents();
            }
            _createMobileOverlay() {
              j2 = n2({ className: "air-datepicker-overlay" }), P2.appendChild(j2);
            }
            _createComponents() {
              let { opts: e3, treatAsInline: t3, opts: { inline: i3, buttons: s3, timepicker: a3, position: n3, classes: r3, onlyTimepicker: o3, isMobile: h3 } } = this;
              this._buildBaseHtml(), this.elIsInput && (i3 || this._setPositionClasses(n3)), !i3 && this.elIsInput || this.$datepicker.classList.add("-inline-"), r3 && this.$datepicker.classList.add(...r3.split(" ")), o3 && this.$datepicker.classList.add("-only-timepicker-"), h3 && !t3 && this._addMobileAttributes(), this.views[this.currentView] = new T2({ dp: this, type: this.currentView, opts: e3 }), this.nav = new V2({ dp: this, opts: e3 }), a3 && this._addTimepicker(), s3 && this._addButtons(), this.$content.appendChild(this.views[this.currentView].$el), this.$nav.appendChild(this.nav.$el);
            }
            _destroyComponents() {
              for (let e3 in this.views) this.views[e3].destroy();
              this.views = {}, this.nav.destroy(), this.timepicker && this.timepicker.destroy();
            }
            _addMobileAttributes() {
              j2.addEventListener("click", this._onClickOverlay), this.$datepicker.classList.add("-is-mobile-"), this.$el.setAttribute("readonly", true);
            }
            _removeMobileAttributes() {
              j2.removeEventListener("click", this._onClickOverlay), this.$datepicker.classList.remove("-is-mobile-"), this.initialReadonly || "" === this.initialReadonly || this.$el.removeAttribute("readonly");
            }
            _createMinMaxDates() {
              let { minDate: e3, maxDate: t3 } = this.opts;
              this.minDate = !!e3 && b2(e3), this.maxDate = !!t3 && b2(t3);
            }
            _addTimepicker() {
              this.$timepicker = n2({ className: "air-datepicker--time" }), this.$datepicker.appendChild(this.$timepicker), this.timepicker = new L2({ dp: this, opts: this.opts }), this.$timepicker.appendChild(this.timepicker.$el);
            }
            _addButtons() {
              this.$buttons = n2({ className: "air-datepicker--buttons" }), this.$datepicker.appendChild(this.$buttons), this.buttons = new H2({ dp: this, opts: this.opts }), this.$buttons.appendChild(this.buttons.$el);
            }
            _bindSubEvents() {
              this.on(i2.eventChangeSelectedDate, this._onChangeSelectedDate), this.on(i2.eventChangeFocusDate, this._onChangeFocusedDate), this.on(i2.eventChangeTime, this._onChangeTime);
            }
            _buildBaseHtml() {
              let { inline: e3 } = this.opts;
              var t3, i3;
              this.elIsInput ? e3 ? (t3 = this.$datepicker, (i3 = this.$el).parentNode.insertBefore(t3, i3.nextSibling)) : this.$container.appendChild(this.$datepicker) : this.$el.appendChild(this.$datepicker), this.$datepicker.innerHTML = '<i class="air-datepicker--pointer"></i><div class="air-datepicker--navigation"></div><div class="air-datepicker--content"></div>', this.$content = a2(".air-datepicker--content", this.$datepicker), this.$pointer = a2(".air-datepicker--pointer", this.$datepicker), this.$nav = a2(".air-datepicker--navigation", this.$datepicker);
            }
            _handleLocale() {
              let { locale: e3, dateFormat: t3, firstDay: i3, timepicker: s3, onlyTimepicker: a3, timeFormat: n3, dateTimeSeparator: r3 } = this.opts;
              var o3;
              this.locale = (o3 = e3, JSON.parse(JSON.stringify(o3))), t3 && (this.locale.dateFormat = t3), void 0 !== n3 && "" !== n3 && (this.locale.timeFormat = n3);
              let { timeFormat: h3 } = this.locale;
              if ("" !== i3 && (this.locale.firstDay = i3), s3 && "function" != typeof t3) {
                let e4 = h3 ? r3 : "";
                this.locale.dateFormat = [this.locale.dateFormat, h3 || ""].join(e4);
              }
              a3 && "function" != typeof t3 && (this.locale.dateFormat = this.locale.timeFormat);
            }
            _setPositionClasses(e3) {
              if ("function" == typeof e3) return void this.$datepicker.classList.add("-custom-position-");
              let t3 = (e3 = e3.split(" "))[0], i3 = `air-datepicker -${t3}-${e3[1]}- -from-${t3}-`;
              this.$datepicker.classList.add(...i3.split(" "));
            }
            _bindEvents() {
              this.$el.addEventListener(this.opts.showEvent, this._onFocus), this.$el.addEventListener("blur", this._onBlur), this.$datepicker.addEventListener("mousedown", this._onMouseDown), this.$datepicker.addEventListener("mouseup", this._onMouseUp), window.addEventListener("resize", this._onResize);
            }
            _limitViewDateByMaxMinDates() {
              let { viewDate: e3, minDate: t3, maxDate: i3 } = this;
              i3 && m2(e3, i3) && this.setViewDate(i3), t3 && v2(e3, t3) && this.setViewDate(t3);
            }
            formatDate() {
              let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.viewDate, t3 = arguments.length > 1 ? arguments[1] : void 0;
              if (e3 = b2(e3), !(e3 instanceof Date)) return;
              let i3 = t3, s3 = this.locale, a3 = h2(e3), n3 = a3.dayPeriod, r3 = c2(e3), o3 = R2.replacer, l3 = { T: e3.getTime(), m: a3.minutes, mm: a3.fullMinutes, h: a3.hours12, hh: a3.fullHours12, H: a3.hours, HH: a3.fullHours, aa: n3, AA: n3.toUpperCase(), E: s3.daysShort[a3.day], EEEE: s3.days[a3.day], d: a3.date, dd: a3.fullDate, M: a3.month + 1, MM: a3.fullMonth, MMM: s3.monthsShort[a3.month], MMMM: s3.months[a3.month], yy: a3.year.toString().slice(-2), yyyy: a3.year, yyyy1: r3[0], yyyy2: r3[1] };
              for (let [e4, t4] of Object.entries(l3)) i3 = o3(i3, k2(e4), t4);
              return i3;
            }
            down(e3) {
              this._handleUpDownActions(e3, "down");
            }
            up(e3) {
              this._handleUpDownActions(e3, "up");
            }
            selectDate(e3) {
              let t3, s3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, { currentView: a3, parsedViewDate: n3, selectedDates: r3 } = this, { updateTime: o3 } = s3, { moveToOtherMonthsOnSelect: h3, moveToOtherYearsOnSelect: l3, multipleDates: d3, range: c3, autoClose: u3, onBeforeSelect: p3 } = this.opts, v3 = r3.length;
              if (Array.isArray(e3)) return e3.forEach((e4) => {
                this.selectDate(e4, s3);
              }), new Promise((e4) => {
                setTimeout(e4);
              });
              if ((e3 = b2(e3)) instanceof Date) {
                if (p3 && !p3({ date: e3, datepicker: this })) return Promise.resolve();
                if (a3 === i2.days && e3.getMonth() !== n3.month && h3 && (t3 = new Date(e3.getFullYear(), e3.getMonth(), 1)), a3 === i2.years && e3.getFullYear() !== n3.year && l3 && (t3 = new Date(e3.getFullYear(), 0, 1)), t3 && this.setViewDate(t3), d3 && !c3) {
                  if (v3 === d3) return;
                  this._checkIfDateIsSelected(e3) || r3.push(e3);
                } else if (c3) switch (v3) {
                  case 1:
                    r3.push(e3), this.rangeDateTo || (this.rangeDateTo = e3), m2(this.rangeDateFrom, this.rangeDateTo) && (this.rangeDateTo = this.rangeDateFrom, this.rangeDateFrom = e3), this.selectedDates = [this.rangeDateFrom, this.rangeDateTo];
                    break;
                  case 2:
                    this.selectedDates = [e3], this.rangeDateFrom = e3, this.rangeDateTo = "";
                    break;
                  default:
                    this.selectedDates = [e3], this.rangeDateFrom = e3;
                }
                else this.selectedDates = [e3];
                return this.trigger(i2.eventChangeSelectedDate, { action: i2.actionSelectDate, silent: null == s3 ? void 0 : s3.silent, date: e3, updateTime: o3 }), this._updateLastSelectedDate(e3), u3 && !this.timepickerIsActive && this.visible && (d3 || c3 ? c3 && 1 === v3 && this.hide() : this.hide()), new Promise((e4) => {
                  setTimeout(e4);
                });
              }
            }
            unselectDate(e3) {
              let t3 = this.selectedDates, s3 = this;
              if ((e3 = b2(e3)) instanceof Date) return t3.some((a3, n3) => {
                if (p2(a3, e3)) return t3.splice(n3, 1), s3.selectedDates.length ? (s3.rangeDateTo = "", s3.rangeDateFrom = t3[0], s3._updateLastSelectedDate(s3.selectedDates[s3.selectedDates.length - 1])) : (s3.rangeDateFrom = "", s3.rangeDateTo = "", s3._updateLastSelectedDate(false)), this.trigger(i2.eventChangeSelectedDate, { action: i2.actionUnselectDate, date: e3 }), true;
              });
            }
            replaceDate(e3, t3) {
              let s3 = this.selectedDates.find((t4) => p2(t4, e3, this.currentView)), a3 = this.selectedDates.indexOf(s3);
              a3 < 0 || p2(this.selectedDates[a3], t3, this.currentView) || (this.selectedDates[a3] = t3, this.trigger(i2.eventChangeSelectedDate, { action: i2.actionSelectDate, date: t3, updateTime: true }), this._updateLastSelectedDate(t3));
            }
            clear() {
              let e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
              return this.selectedDates = [], this.rangeDateFrom = false, this.rangeDateTo = false, this.lastSelectedDate = false, this.trigger(i2.eventChangeSelectedDate, { action: i2.actionUnselectDate, silent: e3.silent }), new Promise((e4) => {
                setTimeout(e4);
              });
            }
            show() {
              let { onShow: e3, isMobile: t3 } = this.opts;
              this._cancelScheduledCall(), this.visible || this.hideAnimation || this._createComponents(), this.setPosition(this.opts.position), this.$datepicker.classList.add("-active-"), this.visible = true, e3 && this._scheduleCallAfterTransition(e3), t3 && this._showMobileOverlay();
            }
            hide() {
              let { onHide: e3, isMobile: t3 } = this.opts, i3 = this._hasTransition();
              this.visible = false, this.hideAnimation = true, this.$datepicker.classList.remove("-active-"), this.customHide && this.customHide(), this.elIsInput && this.$el.blur(), this._scheduleCallAfterTransition((t4) => {
                !this.customHide && (t4 && i3 || !t4 && !i3) && this._finishHide(), e3 && e3(t4);
              }), t3 && j2.classList.remove("-active-");
            }
            _triggerOnSelect() {
              let e3 = [], t3 = [], { selectedDates: i3, locale: s3, opts: { onSelect: a3, multipleDates: n3, range: r3 } } = this, o3 = n3 || r3, h3 = "function" == typeof s3.dateFormat;
              i3.length && (e3 = i3.map(g2), t3 = h3 ? n3 ? s3.dateFormat(e3) : e3.map((e4) => s3.dateFormat(e4)) : e3.map((e4) => this.formatDate(e4, s3.dateFormat))), a3({ date: o3 ? e3 : e3[0], formattedDate: o3 ? t3 : t3[0], datepicker: this });
            }
            _handleAlreadySelectedDates(e3, t3) {
              let { selectedDates: i3, rangeDateFrom: s3, rangeDateTo: a3 } = this, { range: n3, toggleSelected: r3 } = this.opts, o3 = i3.length, h3 = "function" == typeof r3 ? r3({ datepicker: this, date: t3 }) : r3, l3 = Boolean(n3 && 1 === o3 && e3), d3 = l3 ? g2(t3) : t3;
              n3 && !h3 && (2 !== o3 && this.selectDate(d3), 2 === o3 && p2(s3, a3)) || (h3 ? this.unselectDate(d3) : this._updateLastSelectedDate(l3 ? d3 : e3));
            }
            _handleUpDownActions(e3, t3) {
              if (!((e3 = b2(e3 || this.focusDate || this.viewDate)) instanceof Date)) return;
              let i3 = "up" === t3 ? this.viewIndex + 1 : this.viewIndex - 1;
              i3 > 2 && (i3 = 2), i3 < 0 && (i3 = 0), this.setViewDate(new Date(e3.getFullYear(), e3.getMonth(), 1)), this.setCurrentView(this.viewIndexes[i3]);
            }
            getCell(e3) {
              let t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : i2.day;
              if (!((e3 = b2(e3)) instanceof Date)) return;
              let { year: s3, month: a3, date: n3 } = h2(e3), r3 = `[data-year="${s3}"]`, o3 = `[data-month="${a3}"]`, l3 = { [i2.day]: `${r3}${o3}[data-date="${n3}"]`, [i2.month]: `${r3}${o3}`, [i2.year]: `${r3}` };
              return this.views[this.currentView] ? this.views[this.currentView].$el.querySelector(l3[t3]) : void 0;
            }
            _showMobileOverlay() {
              j2.classList.add("-active-");
            }
            _hasTransition() {
              return window.getComputedStyle(this.$datepicker).getPropertyValue("transition-duration").split(", ").reduce((e3, t3) => parseFloat(t3) + e3, 0) > 0;
            }
            get shouldUpdateDOM() {
              return this.visible || this.treatAsInline;
            }
            get parsedViewDate() {
              return h2(this.viewDate);
            }
            get currentViewSingular() {
              return this.currentView.slice(0, -1);
            }
            get curDecade() {
              return c2(this.viewDate);
            }
            get viewIndex() {
              return this.viewIndexes.indexOf(this.currentView);
            }
            get isFinalView() {
              return this.currentView === i2.years;
            }
            get hasSelectedDates() {
              return this.selectedDates.length > 0;
            }
            get isMinViewReached() {
              return this.currentView === this.opts.minView || this.currentView === i2.days;
            }
            get $container() {
              return this.$customContainer || P2;
            }
            static replacer(e3, t3, i3) {
              return e3.replace(t3, function(e4, t4, s3, a3) {
                return t4 + i3 + a3;
              });
            }
          }
          var K2;
          return I2(R2, "defaults", s2), I2(R2, "version", "3.5.3"), I2(R2, "defaultGlobalContainerId", "air-datepicker-global-container"), K2 = R2.prototype, Object.assign(K2, N2), t2.default;
        }();
      });
    })(airDatepicker);
    var airDatepickerExports = airDatepicker.exports;
    const AirDatepicker = /* @__PURE__ */ getDefaultExportFromCjs(airDatepickerExports);
    var en$1 = {};
    Object.defineProperty(en$1, "__esModule", {
      value: true
    });
    var default_1$3 = en$1.default = void 0;
    var _default$3 = {
      days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
      daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
      months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
      today: "Today",
      clear: "Clear",
      dateFormat: "MM/dd/yyyy",
      timeFormat: "hh:mm aa",
      firstDay: 0
    };
    default_1$3 = en$1.default = _default$3;
    var fr$1 = {};
    Object.defineProperty(fr$1, "__esModule", {
      value: true
    });
    var default_1$2 = fr$1.default = void 0;
    var _default$2 = {
      days: ["Dimanche", "Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi", "Samedi"],
      daysShort: ["Dim", "Lun", "Mar", "Mer", "Jeu", "Ven", "Sam"],
      daysMin: ["Di", "Lu", "Ma", "Me", "Je", "Ve", "Sa"],
      months: ["Janvier", "Fvrier", "Mars", "Avril", "Mai", "Juin", "Juillet", "Aot", "Septembre", "Octobre", "Novembre", "Dcembre"],
      monthsShort: ["Jan", "Fv", "Mars", "Avr", "Mai", "Juin", "Juil", "Aot", "Sep", "Oct", "Nov", "Dec"],
      today: "Aujourd'hui",
      clear: "Effacer",
      dateFormat: "dd/MM/yyyy",
      timeFormat: "HH:mm",
      firstDay: 1
    };
    default_1$2 = fr$1.default = _default$2;
    var es = {};
    Object.defineProperty(es, "__esModule", {
      value: true
    });
    var default_1$1 = es.default = void 0;
    var _default$1 = {
      days: ["Domingo", "Lunes", "Martes", "Mircoles", "Jueves", "Viernes", "Sbado"],
      daysShort: ["Dom", "Lun", "Mar", "Mie", "Jue", "Vie", "Sab"],
      daysMin: ["Do", "Lu", "Ma", "Mi", "Ju", "Vi", "Sa"],
      months: ["Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"],
      monthsShort: ["Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"],
      today: "Hoy",
      clear: "Limpiar",
      dateFormat: "dd/MM/yyyy",
      timeFormat: "hh:mm aa",
      firstDay: 1
    };
    default_1$1 = es.default = _default$1;
    var pt$2 = {};
    Object.defineProperty(pt$2, "__esModule", {
      value: true
    });
    var default_1 = pt$2.default = void 0;
    var _default = {
      days: ["Domingo", "Segunda", "Tera", "Quarta", "Quinta", "Sexta", "Sbado"],
      daysShort: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sab"],
      daysMin: ["Do", "Se", "Te", "Qa", "Qi", "Sx", "Sa"],
      months: ["Janeiro", "Fevereiro", "Maro", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
      monthsShort: ["Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"],
      today: "Hoje",
      clear: "Limpar",
      dateFormat: "dd/MM/yyyy",
      timeFormat: "HH:mm",
      firstDay: 1
    };
    default_1 = pt$2.default = _default;
    const _sfc_main$11 = {
      __name: "simple-date",
      props: /* @__PURE__ */ mergeModels({
        id: {
          type: String,
          default: null
        },
        dateType: {
          type: String,
          default: "day"
        },
        startDate: {
          type: String,
          default: null
        },
        endDate: {
          type: String,
          default: null
        }
      }, {
        "modelValue": {},
        "modelModifiers": {}
      }),
      emits: ["update:modelValue"],
      setup(__props, { expose: __expose }) {
        __expose();
        const AirDatepicker_locale = {
          "en": default_1$3,
          "fr": default_1$2,
          "sp": default_1$1,
          "pt": default_1
        };
        const props = __props;
        const inputValue = useModel(__props, "modelValue");
        onMounted(() => {
          let options = {
            locale: AirDatepicker_locale[window.ModularForms.Helpers.Locale.getLocale()],
            autoClose: true,
            toggleSelected: false,
            onSelect({ date: date2, formattedDate, datepicker }) {
              inputValue.value = formattedDate;
            },
            buttons: ["clear"]
          };
          if (props.startDate !== null) {
            options.minDate = props.startDate;
          }
          if (props.endDate !== null) {
            options.maxDate = props.endDate;
          }
          if (props.dateType === "day") {
            options.dateFormat = "yyyy-MM-dd";
            if (typeof inputValue.value !== "undefined" && inputValue.value !== null) {
              options.selectedDates = [inputValue.value];
            }
          } else if (props.dateType === "year") {
            options.dateFormat = "yyyy";
            options.view = "years";
            options.minView = "years";
            if (typeof inputValue.value !== "undefined" && inputValue.value !== null) {
              options.selectedDates = [inputValue.value + "-01-01"];
            }
          }
          new AirDatepicker("#" + props.id, options);
        });
        const __returned__ = { AirDatepicker_locale, props, inputValue, onMounted, get AirDatepicker() {
          return AirDatepicker;
        }, get AirDatepicker_locale_en() {
          return default_1$3;
        }, get AirDatepicker_locale_fr() {
          return default_1$2;
        }, get AirDatepicker_locale_sp() {
          return default_1$1;
        }, get AirDatepicker_locale_pt() {
          return default_1;
        } };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$N = ["id", "name"];
    function _sfc_render$11(_ctx, _cache, $props, $setup, $data, $options) {
      return withDirectives((openBlock(), createElementBlock("input", {
        type: "text",
        id: $props.id,
        name: $props.id,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.inputValue = $event),
        class: "field-edit field-date",
        readonly: ""
      }, null, 8, _hoisted_1$N)), [
        [vModelText, $setup.inputValue]
      ]);
    }
    const simpleDate = /* @__PURE__ */ _export_sfc(_sfc_main$11, [["render", _sfc_render$11], ["__scopeId", "data-v-4aced308"], ["__file", "/var/www/html/vendor/andreamarelli/modular-forms/src/resources/assets/js/inputs/simple-date.vue"]]);
    const AutoNumericEnum = {};
    AutoNumericEnum.allowedTagList = [
      "b",
      "caption",
      "cite",
      "code",
      "const",
      "dd",
      "del",
      "div",
      "dfn",
      "dt",
      "em",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "input",
      "ins",
      "kdb",
      "label",
      "li",
      "option",
      "output",
      "p",
      "q",
      "s",
      "sample",
      "span",
      "strong",
      "td",
      "th",
      "u"
    ];
    Object.freeze(AutoNumericEnum.allowedTagList);
    Object.defineProperty(AutoNumericEnum, "allowedTagList", { configurable: false, writable: false });
    AutoNumericEnum.fromCharCodeKeyCode = {
      0: "LaunchCalculator",
      8: "Backspace",
      9: "Tab",
      13: "Enter",
      16: "Shift",
      17: "Ctrl",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      48: "0",
      49: "1",
      50: "2",
      51: "3",
      52: "4",
      53: "5",
      54: "6",
      55: "7",
      56: "8",
      57: "9",
      // 65: 'a',
      // 66: 'b',
      // 67: 'c',
      // 68: 'd',
      // 69: 'e',
      // 70: 'f',
      // 71: 'g',
      // 72: 'h',
      // 73: 'i',
      // 74: 'j',
      // 75: 'k',
      // 76: 'l',
      // 77: 'm',
      // 78: 'n',
      // 79: 'o',
      // 80: 'p',
      // 81: 'q',
      // 82: 'r',
      // 83: 's',
      // 84: 't',
      // 85: 'u',
      // 86: 'v',
      // 87: 'w',
      // 88: 'x',
      // 89: 'y',
      // 90: 'z',
      91: "OS",
      // Note: Firefox and Chrome reports 'OS' instead of 'OSLeft'
      92: "OSRight",
      93: "ContextMenu",
      96: "0",
      97: "1",
      98: "2",
      99: "3",
      100: "4",
      101: "5",
      102: "6",
      103: "7",
      104: "8",
      105: "9",
      106: "*",
      107: "+",
      109: "-",
      // The 'NumpadSubtract' code
      110: ".",
      111: "/",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      173: "-",
      // The 'Minus' sign on Firefox. This is only needed when using the Selenium bot though.
      182: "MyComputer",
      183: "MyCalculator",
      186: ";",
      187: "=",
      188: ",",
      189: "-",
      // The 'Minus' sign on all other browsers
      190: ".",
      191: "/",
      192: "`",
      219: "[",
      220: "\\",
      221: "]",
      222: "'",
      224: "Meta",
      225: "AltGraph"
    };
    Object.freeze(AutoNumericEnum.fromCharCodeKeyCode);
    Object.defineProperty(AutoNumericEnum, "fromCharCodeKeyCode", { configurable: false, writable: false });
    AutoNumericEnum.keyName = {
      // Special values
      Unidentified: "Unidentified",
      AndroidDefault: "AndroidDefault",
      // Modifier keys
      Alt: "Alt",
      AltGr: "AltGraph",
      CapsLock: "CapsLock",
      // Under Chrome, e.key is empty for CapsLock
      Ctrl: "Control",
      Fn: "Fn",
      FnLock: "FnLock",
      Hyper: "Hyper",
      // 'OS' under Firefox
      Meta: "Meta",
      OSLeft: "OS",
      OSRight: "OS",
      Command: "OS",
      NumLock: "NumLock",
      ScrollLock: "ScrollLock",
      Shift: "Shift",
      Super: "Super",
      // 'OS' under Firefox
      Symbol: "Symbol",
      SymbolLock: "SymbolLock",
      // Whitespace keys
      Enter: "Enter",
      Tab: "Tab",
      Space: " ",
      // 'Spacebar' for Firefox <37, and IE9
      // Navigation keys
      LeftArrow: "ArrowLeft",
      // 'Left' for Firefox <=36, and IE9
      UpArrow: "ArrowUp",
      // 'Up' for Firefox <=36, and IE9
      RightArrow: "ArrowRight",
      // 'Right' for Firefox <=36, and IE9
      DownArrow: "ArrowDown",
      // 'Down' for Firefox <=36, and IE9
      End: "End",
      Home: "Home",
      PageUp: "PageUp",
      PageDown: "PageDown",
      // Editing keys
      Backspace: "Backspace",
      Clear: "Clear",
      Copy: "Copy",
      CrSel: "CrSel",
      // 'Crsel' for Firefox <=36, and IE9
      Cut: "Cut",
      Delete: "Delete",
      // 'Del' for Firefox <=36, and IE9
      EraseEof: "EraseEof",
      ExSel: "ExSel",
      // 'Exsel' for Firefox <=36, and IE9
      Insert: "Insert",
      Paste: "Paste",
      Redo: "Redo",
      Undo: "Undo",
      // UI keys
      Accept: "Accept",
      Again: "Again",
      Attn: "Attn",
      // 'Unidentified' for Firefox, Chrome, and IE9 ('KanaMode' when using the Japanese keyboard layout)
      Cancel: "Cancel",
      ContextMenu: "ContextMenu",
      // 'Apps' for Firefox <=36, and IE9
      Esc: "Escape",
      // 'Esc' for Firefox <=36, and IE9
      Execute: "Execute",
      Find: "Find",
      Finish: "Finish",
      // 'Unidentified' for Firefox, Chrome, and IE9 ('Katakana' when using the Japanese keyboard layout)
      Help: "Help",
      Pause: "Pause",
      Play: "Play",
      Props: "Props",
      Select: "Select",
      ZoomIn: "ZoomIn",
      ZoomOut: "ZoomOut",
      // Device keys
      BrightnessDown: "BrightnessDown",
      BrightnessUp: "BrightnessUp",
      Eject: "Eject",
      LogOff: "LogOff",
      Power: "Power",
      PowerOff: "PowerOff",
      PrintScreen: "PrintScreen",
      Hibernate: "Hibernate",
      // 'Unidentified' for Firefox <=37
      Standby: "Standby",
      // 'Unidentified' for Firefox <=36, and IE9
      WakeUp: "WakeUp",
      // IME and composition keys
      Compose: "Compose",
      Dead: "Dead",
      // Function keys
      F1: "F1",
      F2: "F2",
      F3: "F3",
      F4: "F4",
      F5: "F5",
      F6: "F6",
      F7: "F7",
      F8: "F8",
      F9: "F9",
      F10: "F10",
      F11: "F11",
      F12: "F12",
      // Document keys
      Print: "Print",
      // 'Normal' keys
      num0: "0",
      num1: "1",
      num2: "2",
      num3: "3",
      num4: "4",
      num5: "5",
      num6: "6",
      num7: "7",
      num8: "8",
      num9: "9",
      a: "a",
      b: "b",
      c: "c",
      d: "d",
      e: "e",
      f: "f",
      g: "g",
      h: "h",
      i: "i",
      j: "j",
      k: "k",
      l: "l",
      m: "m",
      n: "n",
      o: "o",
      p: "p",
      q: "q",
      r: "r",
      s: "s",
      t: "t",
      u: "u",
      v: "v",
      w: "w",
      x: "x",
      y: "y",
      z: "z",
      A: "A",
      B: "B",
      C: "C",
      D: "D",
      E: "E",
      F: "F",
      G: "G",
      H: "H",
      I: "I",
      J: "J",
      K: "K",
      L: "L",
      M: "M",
      N: "N",
      O: "O",
      P: "P",
      Q: "Q",
      R: "R",
      S: "S",
      T: "T",
      U: "U",
      V: "V",
      W: "W",
      X: "X",
      Y: "Y",
      Z: "Z",
      Semicolon: ";",
      Equal: "=",
      Comma: ",",
      Hyphen: "-",
      Minus: "-",
      Plus: "+",
      Dot: ".",
      Slash: "/",
      Backquote: "`",
      LeftParenthesis: "(",
      RightParenthesis: ")",
      LeftBracket: "[",
      RightBracket: "]",
      Backslash: "\\",
      Quote: "'",
      // Numeric keypad keys
      numpad0: "0",
      numpad1: "1",
      numpad2: "2",
      numpad3: "3",
      numpad4: "4",
      numpad5: "5",
      numpad6: "6",
      numpad7: "7",
      numpad8: "8",
      numpad9: "9",
      NumpadDot: ".",
      NumpadDotAlt: ",",
      // Modern browsers automatically adapt the character sent by this key to the decimal character of the current language
      NumpadMultiply: "*",
      NumpadPlus: "+",
      NumpadMinus: "-",
      NumpadSubtract: "-",
      NumpadSlash: "/",
      NumpadDotObsoleteBrowsers: "Decimal",
      NumpadMultiplyObsoleteBrowsers: "Multiply",
      NumpadPlusObsoleteBrowsers: "Add",
      NumpadMinusObsoleteBrowsers: "Subtract",
      NumpadSlashObsoleteBrowsers: "Divide",
      // Special arrays for quicker tests
      _allFnKeys: ["F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "F10", "F11", "F12"],
      _someNonPrintableKeys: ["Tab", "Enter", "Shift", "ShiftLeft", "ShiftRight", "Control", "ControlLeft", "ControlRight", "Alt", "AltLeft", "AltRight", "Pause", "CapsLock", "Escape"],
      _directionKeys: ["PageUp", "PageDown", "End", "Home", "ArrowDown", "ArrowLeft", "ArrowRight", "ArrowUp"]
    };
    Object.freeze(AutoNumericEnum.keyName._allFnKeys);
    Object.freeze(AutoNumericEnum.keyName._someNonPrintableKeys);
    Object.freeze(AutoNumericEnum.keyName._directionKeys);
    Object.freeze(AutoNumericEnum.keyName);
    Object.defineProperty(AutoNumericEnum, "keyName", { configurable: false, writable: false });
    Object.freeze(AutoNumericEnum);
    class AutoNumericHelper {
      /**
       * Return `true` if the `value` is null
       *
       * @static
       * @param {*} value The value to test
       * @returns {boolean} Return `true` if the `value` is null, FALSE otherwise
       */
      static isNull(value) {
        return value === null;
      }
      /**
       * Return `true` if the `value` is undefined
       *
       * @static
       * @param {*} value The value to test
       * @returns {boolean} Return `true` if the `value` is undefined, FALSE otherwise
       */
      static isUndefined(value) {
        return value === void 0;
      }
      /**
       * Return `true` if the `value` is undefined, null or empty
       *
       * @param {*} value
       * @returns {boolean}
       */
      static isUndefinedOrNullOrEmpty(value) {
        return value === null || value === void 0 || "" === value;
      }
      /**
       * Return `true` if the given parameter is a String
       *
       * @param {*} str
       * @returns {boolean}
       */
      static isString(str) {
        return typeof str === "string" || str instanceof String;
      }
      /**
       * Return `true` if the `value` is an empty string ''
       *
       * @static
       * @param {*} value The value to test
       * @returns {boolean} Return `true` if the `value` is an empty string '', FALSE otherwise
       */
      static isEmptyString(value) {
        return value === "";
      }
      /**
       * Return `true` if the parameter is a boolean
       *
       * @static
       * @param {*} value
       * @returns {boolean}
       */
      static isBoolean(value) {
        return typeof value === "boolean";
      }
      /**
       * Return `true` if the parameter is a string 'true' or 'false'
       *
       * This function accepts any cases for those strings.
       * @param {string} value
       * @returns {boolean}
       */
      static isTrueOrFalseString(value) {
        const lowercaseValue = String(value).toLowerCase();
        return lowercaseValue === "true" || lowercaseValue === "false";
      }
      /**
       * Return `true` if the parameter is an object
       *
       * @param {*} reference
       * @returns {boolean}
       */
      static isObject(reference2) {
        return typeof reference2 === "object" && reference2 !== null && !Array.isArray(reference2);
      }
      /**
       * Return `true` if the given object is empty
       * cf. http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object and http://jsperf.com/empty-object-test
       *
       * @param {object} obj
       * @returns {boolean}
       */
      static isEmptyObj(obj) {
        for (const prop in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, prop)) {
            return false;
          }
        }
        return true;
      }
      /**
       * Return `true` if the parameter is a real number (and not a numeric string).
       *
       * @param {*} n
       * @returns {boolean}
       */
      static isNumberStrict(n2) {
        return typeof n2 === "number";
      }
      /**
       * Return `true` if the parameter is a number (or a number written as a string).
       *
       * @param {*} n
       * @returns {boolean}
       */
      static isNumber(n2) {
        return !this.isArray(n2) && !isNaN(parseFloat(n2)) && isFinite(n2);
      }
      /**
       * Return `true` if the given character is a number (0 to 9)
       *
       * @param {char} char
       * @returns {boolean}
       */
      static isDigit(char) {
        return /\d/.test(char);
      }
      /**
       * Return `true` if the parameter is a number (or a number written as a string).
       * This version also accepts Arabic and Persian numbers.
       *
       * @param {*} n
       * @returns {boolean}
       */
      static isNumberOrArabic(n2) {
        const latinConvertedNumber = this.arabicToLatinNumbers(n2, false, true, true);
        return this.isNumber(latinConvertedNumber);
      }
      /**
       * Return `true` if the parameter is an integer (and not a float).
       *
       * @param {*} n
       * @returns {boolean}
       */
      static isInt(n2) {
        return typeof n2 === "number" && parseFloat(n2) === parseInt(n2, 10) && !isNaN(n2);
      }
      /**
       * Return `true` if the parameter is a function.
       *
       * @param {function} func
       * @returns {boolean}
       */
      static isFunction(func2) {
        return typeof func2 === "function";
      }
      /**
       * Return `true` is the string `str` contains the string `needle`
       * Note: this function does not coerce the parameters types
       *
       * @param {string} str
       * @param {string} needle
       * @returns {boolean}
       */
      static contains(str, needle) {
        if (!this.isString(str) || !this.isString(needle) || str === "" || needle === "") {
          return false;
        }
        return str.indexOf(needle) !== -1;
      }
      /**
       * Return `true` if the `needle` is in the array
       *
       * @param {*} needle
       * @param {Array} array
       * @returns {boolean}
       */
      static isInArray(needle, array2) {
        if (!this.isArray(array2) || array2 === [] || this.isUndefined(needle)) {
          return false;
        }
        return array2.indexOf(needle) !== -1;
      }
      /**
       * Return `true` if the parameter is an Array
       * //TODO Replace this by the default `Array.isArray()` function?
       *
       * @param {*} arr
       * @throws Error
       * @returns {*|boolean}
       */
      static isArray(arr) {
        if (Object.prototype.toString.call([]) === "[object Array]") {
          return Array.isArray(arr) || typeof arr === "object" && Object.prototype.toString.call(arr) === "[object Array]";
        } else {
          throw new Error("toString message changed for Object Array");
        }
      }
      /**
       * Return `true` if the parameter is a DOM element
       * cf. http://stackoverflow.com/a/4754104/2834898
       *
       * @param {*} obj
       * @returns {boolean}
       */
      static isElement(obj) {
        if (typeof Element === "undefined") {
          return false;
        }
        return obj instanceof Element;
      }
      /**
       * Return `true` in the given DOM element is an <input>.
       *
       * @param {HTMLElement|HTMLInputElement} domElement
       * @returns {boolean}
       * @private
       */
      static isInputElement(domElement) {
        return this.isElement(domElement) && domElement.tagName.toLowerCase() === "input";
      }
      /**
       * Return `true` if the parameter is a string that represents a float number, and that number has a decimal part
       *
       * @param {string} str
       * @returns {boolean}
       */
      // static hasDecimals(str) {
      //     const [, decimalPart] = str.split('.');
      //     return !isUndefined(decimalPart);
      // }
      /**
       * Return the number of decimal places if the parameter is a string that represents a float number, and that number has a decimal part.
       *
       * @param {string} str
       * @returns {int}
       */
      static decimalPlaces(str) {
        const [, decimalPart] = str.split(".");
        if (!this.isUndefined(decimalPart)) {
          return decimalPart.length;
        }
        return 0;
      }
      /**
       * Return the index of the first non-zero decimal place in the given value.
       * The index starts after the decimal point, if any, and begins at '1'.
       * If no decimal places are found in the value, this function returns `0`.
       *
       * @example
       * indexFirstNonZeroDecimalPlace('0.00') -> 0
       * indexFirstNonZeroDecimalPlace('1.00') -> 0
       * indexFirstNonZeroDecimalPlace('0.12') -> 1
       * indexFirstNonZeroDecimalPlace('0.1234') -> 1
       * indexFirstNonZeroDecimalPlace('0.01234') -> 2
       * indexFirstNonZeroDecimalPlace('0.001234') -> 3
       * indexFirstNonZeroDecimalPlace('0.0001234') -> 4
       *
       * @param {number} value
       * @returns {Number|number}
       */
      static indexFirstNonZeroDecimalPlace(value) {
        const [, decimalPart] = String(Math.abs(value)).split(".");
        if (this.isUndefined(decimalPart)) {
          return 0;
        }
        let result2 = decimalPart.lastIndexOf("0");
        if (result2 === -1) {
          result2 = 0;
        } else {
          result2 += 2;
        }
        return result2;
      }
      /**
       * Return the code for the key used to generate the given event.
       *
       * @param {Event} event
       * @returns {string|Number}
       */
      static keyCodeNumber(event) {
        return typeof event.which === "undefined" ? event.keyCode : event.which;
      }
      /**
       * Return the character from the event key code.
       * If the KeyboardEvent does not represent a printable character, then the key name is used (ie. 'Meta', 'Shift', 'F1', etc.)
       * @example character(50) => '2'
       *
       * @param {KeyboardEvent} event
       * @returns {string}
       */
      static character(event) {
        let result2;
        if (event.key === "Unidentified" || event.key === void 0 || this.isSeleniumBot()) {
          const keyCode = this.keyCodeNumber(event);
          if (keyCode === 229) {
            return AutoNumericEnum.keyName.AndroidDefault;
          }
          const potentialResult = AutoNumericEnum.fromCharCodeKeyCode[keyCode];
          if (!AutoNumericHelper.isUndefinedOrNullOrEmpty(potentialResult)) {
            result2 = potentialResult;
          } else {
            result2 = String.fromCharCode(keyCode);
          }
        } else {
          switch (event.key) {
            case "Add":
              result2 = AutoNumericEnum.keyName.NumpadPlus;
              break;
            case "Apps":
              result2 = AutoNumericEnum.keyName.ContextMenu;
              break;
            case "Crsel":
              result2 = AutoNumericEnum.keyName.CrSel;
              break;
            case "Decimal":
              if (event.char) {
                result2 = event.char;
              } else {
                result2 = AutoNumericEnum.keyName.NumpadDot;
              }
              break;
            case "Del":
              result2 = AutoNumericEnum.keyName.Delete;
              break;
            case "Divide":
              result2 = AutoNumericEnum.keyName.NumpadSlash;
              break;
            case "Down":
              result2 = AutoNumericEnum.keyName.DownArrow;
              break;
            case "Esc":
              result2 = AutoNumericEnum.keyName.Esc;
              break;
            case "Exsel":
              result2 = AutoNumericEnum.keyName.ExSel;
              break;
            case "Left":
              result2 = AutoNumericEnum.keyName.LeftArrow;
              break;
            case "Meta":
            case "Super":
              result2 = AutoNumericEnum.keyName.OSLeft;
              break;
            case "Multiply":
              result2 = AutoNumericEnum.keyName.NumpadMultiply;
              break;
            case "Right":
              result2 = AutoNumericEnum.keyName.RightArrow;
              break;
            case "Spacebar":
              result2 = AutoNumericEnum.keyName.Space;
              break;
            case "Subtract":
              result2 = AutoNumericEnum.keyName.NumpadMinus;
              break;
            case "Up":
              result2 = AutoNumericEnum.keyName.UpArrow;
              break;
            default:
              result2 = event.key;
          }
        }
        return result2;
      }
      /**
       * Return an object containing the name and version of the current browser.
       * @example `browserVersion()` => { name: 'Firefox', version: '42' }
       * Based on http://stackoverflow.com/a/38080051/2834898
       *
       * @returns {{ name: string, version: string }}
       */
      static browser() {
        const ua = navigator.userAgent;
        let tem;
        let M2 = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
        if (/trident/i.test(M2[1])) {
          tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
          return { name: "ie", version: tem[1] || "" };
        }
        if (M2[1] === "Chrome") {
          tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
          if (tem !== null) {
            return { name: tem[1].replace("OPR", "opera"), version: tem[2] };
          }
        }
        M2 = M2[2] ? [M2[1], M2[2]] : [navigator.appName, navigator.appVersion, "-?"];
        if ((tem = ua.match(/version\/(\d+)/i)) !== null) {
          M2.splice(1, 1, tem[1]);
        }
        return { name: M2[0].toLowerCase(), version: M2[1] };
      }
      /**
       * Check if the browser is controlled by Selenium.
       * Note: This only works within the geckodriver.
       * cf. http://stackoverflow.com/questions/33225947/can-a-website-detect-when-you-are-using-selenium-with-chromedriver
       *
       * @returns {boolean}
       */
      static isSeleniumBot() {
        return window.navigator.webdriver === true;
      }
      /**
       * Return `true` if the given number is negative, or if the given string contains a negative sign :
       * - everywhere in the string (by default), or
       * - on the first character only if the `checkEverywhere` parameter is set to `false`.
       *
       * Note: `-0` is not a negative number since it's equal to `0`.
       *
       * @param {number|string} numberOrNumericString A Number, or a number represented by a string
       * @param {string} negativeSignCharacter The single character that represent the negative sign
       * @param {boolean} checkEverywhere If TRUE, then the negative sign is search everywhere in the numeric string (this is needed for instance if the string is '1234.56-')
       * @returns {boolean}
       */
      static isNegative(numberOrNumericString, negativeSignCharacter = "-", checkEverywhere = true) {
        if (numberOrNumericString === negativeSignCharacter) {
          return true;
        }
        if (numberOrNumericString === "") {
          return false;
        }
        if (AutoNumericHelper.isNumber(numberOrNumericString)) {
          return numberOrNumericString < 0;
        }
        if (checkEverywhere) {
          return this.contains(numberOrNumericString, negativeSignCharacter);
        }
        return this.isNegativeStrict(numberOrNumericString, negativeSignCharacter);
      }
      /**
       * Return `true` if the given string contains a negative sign on the first character (on the far left).
       *
       * @example isNegativeStrict('1234.56')     => false
       * @example isNegativeStrict('1234.56-')    => false
       * @example isNegativeStrict('-1234.56')    => true
       * @example isNegativeStrict('-1,234.56 ') => true
       *
       * @param {string} numericString
       * @param {string} negativeSignCharacter The single character that represent the negative sign
       * @returns {boolean}
       */
      static isNegativeStrict(numericString, negativeSignCharacter = "-") {
        return numericString.charAt(0) === negativeSignCharacter;
      }
      /**
       * Return `true` if the very first character is the opening bracket, and if the rest of the `valueString` also has the closing bracket.
       *
       * @param {string} valueString
       * @param {string} leftBracket
       * @param {string} rightBracket
       * @returns {boolean}
       */
      static isNegativeWithBrackets(valueString, leftBracket, rightBracket) {
        return valueString.charAt(0) === leftBracket && this.contains(valueString, rightBracket);
      }
      /**
       * Return `true` if the formatted or unformatted numeric string represent the value 0 (ie. '0,00 '), or is empty (' ').
       * This works since we test if there are any numbers from 1 to 9 in the string. If there is none, then the number is zero (or the string is empty).
       *
       * @param {string} numericString
       * @returns {boolean}
       */
      static isZeroOrHasNoValue(numericString) {
        return !/[1-9]/g.test(numericString);
      }
      /**
       * Return the negative version of the value (represented as a string) given as a parameter.
       * The numeric string is a valid Javascript number when typecast to a `Number`.
       *
       * @param {string} value
       * @returns {*}
       */
      static setRawNegativeSign(value) {
        if (!this.isNegativeStrict(value, "-")) {
          return `-${value}`;
        }
        return value;
      }
      /**
       * Replace the character at the position `index` in the string `string` by the character(s) `newCharacter`.
       *
       * @param {string} string
       * @param {int} index
       * @param {string} newCharacter
       * @returns {string}
       */
      static replaceCharAt(string2, index, newCharacter) {
        return `${string2.substr(0, index)}${newCharacter}${string2.substr(index + newCharacter.length)}`;
      }
      /**
       * Return the value clamped to the nearest minimum/maximum value, as defined in the settings.
       *
       * @param {string|number} value
       * @param {object} settings
       * @returns {number}
       */
      static clampToRangeLimits(value, settings) {
        return Math.max(settings.minimumValue, Math.min(settings.maximumValue, value));
      }
      /**
       * Return the number of number or dot characters on the left side of the caret, in a formatted number.
       *
       * @param {string} formattedNumberString
       * @param {int} caretPosition This must be a positive integer
       * @param {string} decimalCharacter
       * @returns {number}
       */
      static countNumberCharactersOnTheCaretLeftSide(formattedNumberString, caretPosition, decimalCharacter) {
        const numberDotOrNegativeSign = new RegExp(`[0-9${decimalCharacter}-]`);
        let numberDotAndNegativeSignCount = 0;
        for (let i2 = 0; i2 < caretPosition; i2++) {
          if (numberDotOrNegativeSign.test(formattedNumberString[i2])) {
            numberDotAndNegativeSignCount++;
          }
        }
        return numberDotAndNegativeSignCount;
      }
      /**
       * Walk the `formattedNumberString` from left to right, one char by one, counting the `formattedNumberStringIndex`.
       * If the char is in the `rawNumberString` (starting at index 0), then `rawNumberStringIndex++`, and continue until
       * there is no more characters in `rawNumberString`) or that `rawNumberStringIndex === caretPositionInRawValue`.
       * When you stop, the `formattedNumberStringIndex` is the position where the caret should be set.
       *
       * @example
       * 1234567|89.01   : position 7 (rawNumberString)
       * 123.456.7|89,01 : position 9 (formattedNumberString)
       *
       * @param {string} rawNumberString
       * @param {int} caretPositionInRawValue
       * @param {string} formattedNumberString
       * @param {string} decimalCharacter
       * @returns {*}
       */
      static findCaretPositionInFormattedNumber(rawNumberString, caretPositionInRawValue, formattedNumberString, decimalCharacter) {
        const formattedNumberStringSize = formattedNumberString.length;
        const rawNumberStringSize = rawNumberString.length;
        let formattedNumberStringIndex;
        let rawNumberStringIndex = 0;
        for (formattedNumberStringIndex = 0; formattedNumberStringIndex < formattedNumberStringSize && rawNumberStringIndex < rawNumberStringSize && rawNumberStringIndex < caretPositionInRawValue; formattedNumberStringIndex++) {
          if (rawNumberString[rawNumberStringIndex] === formattedNumberString[formattedNumberStringIndex] || rawNumberString[rawNumberStringIndex] === "." && formattedNumberString[formattedNumberStringIndex] === decimalCharacter) {
            rawNumberStringIndex++;
          }
        }
        return formattedNumberStringIndex;
      }
      /**
       * Count the number of occurrence of the given character, in the given text.
       *
       * @param {string} character
       * @param {string} text
       * @returns {number}
       */
      static countCharInText(character, text2) {
        let charCounter = 0;
        for (let i2 = 0; i2 < text2.length; i2++) {
          if (text2[i2] === character) {
            charCounter++;
          }
        }
        return charCounter;
      }
      /**
       * Return the index that can be used to set the caret position.
       * This takes into account that the position is starting at '0', not 1.
       *
       * @param {int} characterCount
       * @returns {number}
       */
      static convertCharacterCountToIndexPosition(characterCount) {
        return Math.max(characterCount, characterCount - 1);
      }
      /**
       * Cross browser routine for getting selected range/cursor position.
       * Note: this also works with edge cases like contenteditable-enabled elements, and hidden inputs.
       *
       * @param {HTMLInputElement|EventTarget} element
       * @returns {{}}
       */
      static getElementSelection(element) {
        const position = {};
        let isSelectionStartUndefined;
        try {
          isSelectionStartUndefined = this.isUndefined(element.selectionStart);
        } catch (error) {
          isSelectionStartUndefined = false;
        }
        try {
          if (isSelectionStartUndefined) {
            const selection = window.getSelection();
            const selectionInfo = selection.getRangeAt(0);
            position.start = selectionInfo.startOffset;
            position.end = selectionInfo.endOffset;
            position.length = position.end - position.start;
          } else {
            position.start = element.selectionStart;
            position.end = element.selectionEnd;
            position.length = position.end - position.start;
          }
        } catch (error) {
          position.start = 0;
          position.end = 0;
          position.length = 0;
        }
        return position;
      }
      /**
       * Cross browser routine for setting selected range/cursor position
       *
       * @param {HTMLInputElement|EventTarget} element
       * @param {int} start
       * @param {int|null} end
       */
      static setElementSelection(element, start2, end2 = null) {
        if (this.isUndefinedOrNullOrEmpty(end2)) {
          end2 = start2;
        }
        if (this.isInputElement(element)) {
          element.setSelectionRange(start2, end2);
        } else if (!AutoNumericHelper.isNull(element.firstChild)) {
          const range2 = document.createRange();
          range2.setStart(element.firstChild, start2);
          range2.setEnd(element.firstChild, end2);
          const selection = window.getSelection();
          selection.removeAllRanges();
          selection.addRange(range2);
        }
      }
      /**
       * Function that throw error messages
       *
       * @param {string} message
       * @throws
       */
      static throwError(message) {
        throw new Error(message);
      }
      /**
       * Function that display a warning messages, according to the debug level.
       *
       * @param {string} message
       * @param {boolean} showWarning If FALSE, then the warning message is not displayed
       */
      static warning(message, showWarning = true) {
        if (showWarning) {
          console.warn(`Warning: ${message}`);
        }
      }
      /**
       * Return `true` if the given event is an instance of WheelEvent
       *
       * @static
       * @param {event} event The event to test
       * @returns {boolean} Return `true` if the event is an instance of WheelEvent, FALSE otherwise
      */
      static isWheelEvent(event) {
        return event instanceof WheelEvent;
      }
      /**
       * Return `true` if the given event is a wheelup event
       *
       * @param {WheelEvent} wheelEvent
       * @returns {boolean}
       */
      static isWheelUpEvent(wheelEvent) {
        if (!this.isWheelEvent(wheelEvent) || this.isUndefinedOrNullOrEmpty(wheelEvent.deltaY)) {
          this.throwError(`The event passed as a parameter is not a valid wheel event, '${wheelEvent.type}' given.`);
        }
        return wheelEvent.deltaY < 0;
      }
      /**
       * Return `true` if the given event is a wheeldown event
       *
       * @param {WheelEvent} wheelEvent
       * @returns {boolean}
       */
      static isWheelDownEvent(wheelEvent) {
        if (!this.isWheelEvent(wheelEvent) || this.isUndefinedOrNullOrEmpty(wheelEvent.deltaY)) {
          this.throwError(`The event passed as a parameter is not a valid wheel event, '${wheelEvent.type}' given.`);
        }
        return wheelEvent.deltaY > 0;
      }
      /**
       * Return `true` if the given event is an instance of WheelEvent and the deltaY value is equal to zero
       *
       * @param {WheelEvent} wheelEvent The event to test
       * @returns {boolean} Return `true` if the event is an instance of WheelEvent and the deltaY value is equal to zero, FALSE otherwise
       */
      static isWheelEventWithZeroDeltaY(wheelEvent) {
        return this.isWheelEvent(wheelEvent) && !this.isUndefinedOrNullOrEmpty(wheelEvent.deltaY) && wheelEvent.deltaY === 0;
      }
      /**
       * Return the given raw value truncated at the given number of decimal places `decimalPlaces`.
       * This function does not round the value.
       *
       * @example
       * forceDecimalPlaces(123.45678, 0) -> '123.45678'
       * forceDecimalPlaces(123.45678, 1) -> '123.4'
       * forceDecimalPlaces(123.45678, 2) -> '123.45'
       * forceDecimalPlaces(123.45678, 3) -> '123.456'
       *
       * @param {number} value
       * @param {int} decimalPlaces
       * @returns {number|string}
       */
      static forceDecimalPlaces(value, decimalPlaces) {
        const [integerPart, decimalPart] = String(value).split(".");
        if (!decimalPart) {
          return value;
        }
        return `${integerPart}.${decimalPart.substr(0, decimalPlaces)}`;
      }
      /**
       * Return the 'nearest rounded' value, according to the given step size.
       * @example roundToNearest(264789, 10000)) => 260000
       *
       * @param {number} value
       * @param {number} stepPlace
       * @returns {*}
       */
      static roundToNearest(value, stepPlace = 1e3) {
        if (0 === value) {
          return 0;
        }
        if (stepPlace === 0) {
          this.throwError("The `stepPlace` used to round is equal to `0`. This value must not be equal to zero.");
        }
        return Math.round(value / stepPlace) * stepPlace;
      }
      /**
       * Return the 'nearest rounded' value by automatically adding or subtracting the calculated offset to the initial value.
       * This is done without having to pass a step to this function, and based on the size of the given `value`.
       *
       * @example                    Calculated offset
       *           1 ->           1 (1)
       *          14 ->          10 (10)
       *         143 ->         140 (10)
       *       1.278 ->       1.300 (100)
       *      28.456 ->      28.500 (100)
       *     276.345 ->     276.000 (1.000)
       *   4.534.061 ->   4.530.000 (10.000)
       *  66.723.844 ->  66.700.000 (100.000)
       * 257.833.411 -> 258.000.000 (1.000.000)
       *
       *                           Initial   Added   Offset
       * 2 decimalPlacesRawValue : 1.12   -> 2.00   (1)
       * 3 decimalPlacesRawValue : 1.123  -> 2.000  (1)
       *
       * Special case when the `value` to round is between -1 and 1, excluded :
       * @example
       *     Number of             Initial   Result  Calculated
       *     decimal places        value     (add)   offset
       * 2 decimalPlacesRawValue : 0.12   -> 0.13    (0.01) : Math.pow(10, -2)
       * 2 decimalPlacesRawValue : 0.01   -> 0.02    (0.01)
       * 2 decimalPlacesRawValue : 0.00   -> 0.01    (0.01)
       *
       * 3 decimalPlacesRawValue : 0.123  -> 0.133   (0.01)  : Math.pow(10, -2)
       * 3 decimalPlacesRawValue : 0.012  -> 0.013   (0.001) : Math.pow(10, -3)
       * 3 decimalPlacesRawValue : 0.001  -> 0.001   (0.001)
       * 3 decimalPlacesRawValue : 0.000  -> 0.001   (0.001)
       *
       * 4 decimalPlacesRawValue : 0.4123 -> 0.4200  (0.01)   : Math.pow(10, -2)
       * 4 decimalPlacesRawValue : 0.0412 -> 0.0420  (0.001)  : Math.pow(10, -3)
       * 4 decimalPlacesRawValue : 0.0041 -> 0.0042  (0.0001) : Math.pow(10, -4)
       * 4 decimalPlacesRawValue : 0.0004 -> 0.0005  (0.0001)
       * 4 decimalPlacesRawValue : 0.0000 -> 0.0001  (0.0001)
       *
       * @param {number} value
       * @param {boolean} isAddition
       * @param {int} decimalPlacesRawValue The precision needed by the `rawValue`
       * @returns {*}
       */
      static modifyAndRoundToNearestAuto(value, isAddition, decimalPlacesRawValue) {
        value = Number(this.forceDecimalPlaces(value, decimalPlacesRawValue));
        const absValue = Math.abs(value);
        if (absValue >= 0 && absValue < 1) {
          const rawValueMinimumOffset = Math.pow(10, -decimalPlacesRawValue);
          if (value === 0) {
            return isAddition ? rawValueMinimumOffset : -rawValueMinimumOffset;
          }
          let offset2;
          const minimumOffsetFirstDecimalPlaceIndex = decimalPlacesRawValue;
          const indexFirstNonZeroDecimalPlace = this.indexFirstNonZeroDecimalPlace(value);
          if (indexFirstNonZeroDecimalPlace >= minimumOffsetFirstDecimalPlaceIndex - 1) {
            offset2 = rawValueMinimumOffset;
          } else {
            offset2 = Math.pow(10, -(indexFirstNonZeroDecimalPlace + 1));
          }
          let result2;
          if (isAddition) {
            result2 = value + offset2;
          } else {
            result2 = value - offset2;
          }
          return this.roundToNearest(result2, offset2);
        } else {
          value = parseInt(value, 10);
          const lengthValue = Math.abs(value).toString().length;
          let pow;
          switch (lengthValue) {
            case 1:
              pow = 0;
              break;
            case 2:
            case 3:
              pow = 1;
              break;
            case 4:
            case 5:
              pow = 2;
              break;
            default:
              pow = lengthValue - 3;
          }
          const offset2 = Math.pow(10, pow);
          let result2;
          if (isAddition) {
            result2 = value + offset2;
          } else {
            result2 = value - offset2;
          }
          if (result2 <= 10 && result2 >= -10) {
            return result2;
          }
          return this.roundToNearest(result2, offset2);
        }
      }
      /**
       * Return the 'nearest rounded' value automatically by adding the calculated offset to the initial value.
       * This will limit the result to the given number of decimal places `decimalPlacesLimit`.
       *
       * @param {number} value
       * @param {int} decimalPlacesLimit
       * @returns {*}
       */
      static addAndRoundToNearestAuto(value, decimalPlacesLimit) {
        return this.modifyAndRoundToNearestAuto(value, true, decimalPlacesLimit);
      }
      /**
       * Return the 'nearest rounded' value automatically by subtracting the calculated offset to the initial value.
       * This will limit the result to the given number of decimal places `decimalPlacesLimit`.
       *
       * @param {number} value
       * @param {int} decimalPlacesLimit
       * @returns {*}
       */
      static subtractAndRoundToNearestAuto(value, decimalPlacesLimit) {
        return this.modifyAndRoundToNearestAuto(value, false, decimalPlacesLimit);
      }
      /**
       * Take an arabic number as a string and return a javascript number.
       * By default, this function does not try to convert the arabic decimal and thousand separator characters.
       * This returns `NaN` is the conversion is not possible.
       * Based on http://stackoverflow.com/a/17025392/2834898
       *
       * @param {string} arabicNumbers
       * @param {boolean} returnANumber If `true`, return a Number, otherwise return a String
       * @param {boolean} parseDecimalCharacter
       * @param {boolean} parseThousandSeparator
       * @returns {string|number|NaN}
       */
      static arabicToLatinNumbers(arabicNumbers, returnANumber = true, parseDecimalCharacter = false, parseThousandSeparator = false) {
        if (this.isNull(arabicNumbers)) {
          return arabicNumbers;
        }
        let result2 = arabicNumbers.toString();
        if (result2 === "") {
          return arabicNumbers;
        }
        if (result2.match(/[]/g) === null) {
          if (returnANumber) {
            result2 = Number(result2);
          }
          return result2;
        }
        if (parseDecimalCharacter) {
          result2 = result2.replace(//, ".");
        }
        if (parseThousandSeparator) {
          result2 = result2.replace(//g, "");
        }
        result2 = result2.replace(/[]/g, (d2) => d2.charCodeAt(0) - 1632).replace(/[]/g, (d2) => d2.charCodeAt(0) - 1776);
        const resultAsNumber = Number(result2);
        if (isNaN(resultAsNumber)) {
          return resultAsNumber;
        }
        if (returnANumber) {
          result2 = resultAsNumber;
        }
        return result2;
      }
      /**
       * Create a custom event and immediately sent it from the given element.
       * By default, if no element is given, the event is thrown from `document`.
       *
       * @param {string} eventName
       * @param {HTMLElement|HTMLDocument|EventTarget} element
       * @param {object} detail
       * @param {boolean} bubbles Set to `true` if the event must bubble up
       * @param {boolean} cancelable Set to `true` if the event must be cancelable
       */
      static triggerEvent(eventName, element = document, detail = null, bubbles = true, cancelable = true) {
        let event;
        if (window.CustomEvent) {
          event = new CustomEvent(eventName, { detail, bubbles, cancelable });
        } else {
          event = document.createEvent("CustomEvent");
          event.initCustomEvent(eventName, bubbles, cancelable, { detail });
        }
        element.dispatchEvent(event);
      }
      /**
       * Function to parse minimumValue, maximumValue & the input value to prepare for testing to determine if the value falls within the min / max range.
       * Return an object example: minimumValue: "999999999999999.99" returns the following "{s: -1, e: 12, c: Array[15]}".
       *
       * This function is adapted from Big.js https://github.com/MikeMcl/big.js/. Many thanks to Mike.
       *
       * @param {number|string} n A numeric value.
       * @returns {{}}
       */
      static parseStr(n2) {
        const x2 = {};
        let e2;
        let i2;
        let nL;
        let j2;
        if (n2 === 0 && 1 / n2 < 0) {
          n2 = "-0";
        }
        n2 = n2.toString();
        if (this.isNegativeStrict(n2, "-")) {
          n2 = n2.slice(1);
          x2.s = -1;
        } else {
          x2.s = 1;
        }
        e2 = n2.indexOf(".");
        if (e2 > -1) {
          n2 = n2.replace(".", "");
        }
        if (e2 < 0) {
          e2 = n2.length;
        }
        i2 = n2.search(/[1-9]/i) === -1 ? n2.length : n2.search(/[1-9]/i);
        nL = n2.length;
        if (i2 === nL) {
          x2.e = 0;
          x2.c = [0];
        } else {
          for (j2 = nL - 1; n2.charAt(j2) === "0"; j2 -= 1) {
            nL -= 1;
          }
          nL -= 1;
          x2.e = e2 - i2 - 1;
          x2.c = [];
          for (e2 = 0; i2 <= nL; i2 += 1) {
            x2.c[e2] = +n2.charAt(i2);
            e2 += 1;
          }
        }
        return x2;
      }
      /**
       * Function to test if the input value falls with the Min / Max settings.
       * This uses the parsed strings for the above parseStr function.
       *
       * This function is adapted from Big.js https://github.com/MikeMcl/big.js/. Many thanks to Mike.
       *
       * @param {object} y Big number instance
       * @param {object} x Big number instance
       * @returns {*}
       */
      static testMinMax(y2, x2) {
        const xc = x2.c;
        const yc = y2.c;
        let i2 = x2.s;
        let j2 = y2.s;
        let k2 = x2.e;
        let l2 = y2.e;
        if (!xc[0] || !yc[0]) {
          let result3;
          if (!xc[0]) {
            result3 = !yc[0] ? 0 : -j2;
          } else {
            result3 = i2;
          }
          return result3;
        }
        if (i2 !== j2) {
          return i2;
        }
        const xNeg = i2 < 0;
        if (k2 !== l2) {
          return k2 > l2 ^ xNeg ? 1 : -1;
        }
        i2 = -1;
        k2 = xc.length;
        l2 = yc.length;
        j2 = k2 < l2 ? k2 : l2;
        for (i2 += 1; i2 < j2; i2 += 1) {
          if (xc[i2] !== yc[i2]) {
            return xc[i2] > yc[i2] ^ xNeg ? 1 : -1;
          }
        }
        let result2;
        if (k2 === l2) {
          result2 = 0;
        } else {
          result2 = k2 > l2 ^ xNeg ? 1 : -1;
        }
        return result2;
      }
      /**
       * Generate a random string.
       * cf. http://stackoverflow.com/a/8084248/2834898
       *
       * @param {Number} strLength Length of the generated string (in character count)
       * @returns {string}
       */
      static randomString(strLength = 5) {
        return Math.random().toString(36).substr(2, strLength);
      }
      /**
       * Return the DOM element when passed either a DOM element or a selector string.
       *
       * @param {HTMLElement|string} domElementOrSelector
       * @returns {HTMLElement}
       */
      static domElement(domElementOrSelector) {
        let domElement;
        if (AutoNumericHelper.isString(domElementOrSelector)) {
          domElement = document.querySelector(domElementOrSelector);
        } else {
          domElement = domElementOrSelector;
        }
        return domElement;
      }
      /**
       * Retrieve the current element value.
       *
       * @param {HTMLElement|HTMLInputElement|EventTarget} element
       * @returns {number|string|null}
       */
      static getElementValue(element) {
        if (element.tagName.toLowerCase() === "input") {
          return element.value;
        }
        return this.text(element);
      }
      /**
       * Modify the element value directly.
       *
       * @param {HTMLElement|HTMLInputElement} element
       * @param {number|string|null} value
       */
      static setElementValue(element, value = null) {
        if (element.tagName.toLowerCase() === "input") {
          element.value = value;
        } else {
          element.textContent = value;
        }
      }
      /**
       * Set the invalid state for the given element.
       * A custom message can be passed as the second argument.
       * Note: This does not work with contenteditable elements
       *
       * @param {HTMLElement|HTMLInputElement} element
       * @param {string|null} message
       * @throws Error
       */
      static setInvalidState(element, message = "Invalid") {
        if (message === "" || this.isNull(message)) this.throwError("Cannot set the invalid state with an empty message.");
        element.setCustomValidity(message);
      }
      /**
       * Set the valid state for the given element.
       * Note: This does not work with contenteditable elements
       *
       * @param {HTMLElement|HTMLInputElement} element
       */
      static setValidState(element) {
        element.setCustomValidity("");
      }
      /**
       * This clone the given object, and return it.
       * WARNING: This does not do a deep cloning.
       * cf. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Examples
       * //TODO Add a `deep` option to clone object with more than one depth
       *
       * @param {object} obj
       * @returns {object}
       */
      static cloneObject(obj) {
        return Object.assign({}, obj);
      }
      /**
       * Return a 'camelized' version of the given string.
       * By default, this assume that :
       * - the separators are hyphens '-',
       * - the 'data-' string should be removed, and
       * - that the very first word should not be capitalized.
       *
       * @example camelize('data-currency-symbol') => 'currencySymbol'
       *
       * @param {string} str Text to camelize
       * @param {string} separator Character that separate each word
       * @param {boolean} removeData If set to `true`, remove the `data-` part that you can find on some html attributes
       * @param {boolean} skipFirstWord If set to `true`, do not capitalize the very first word
       * @returns {string|null}
       */
      static camelize(str, separator = "-", removeData = true, skipFirstWord = true) {
        if (this.isNull(str)) {
          return null;
        }
        if (removeData) {
          str = str.replace(/^data-/, "");
        }
        const words2 = str.split(separator);
        let result2 = words2.map((word) => `${word.charAt(0).toUpperCase()}${word.slice(1)}`);
        result2 = result2.join("");
        if (skipFirstWord) {
          result2 = `${result2.charAt(0).toLowerCase()}${result2.slice(1)}`;
        }
        return result2;
      }
      /**
       * Return the text component of the given DOM element.
       *
       * @param {Element} domElement
       * @returns {string}
       */
      static text(domElement) {
        const nodeType = domElement.nodeType;
        let result2;
        if (nodeType === Node.ELEMENT_NODE || nodeType === Node.DOCUMENT_NODE || nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          result2 = domElement.textContent;
        } else if (nodeType === Node.TEXT_NODE) {
          result2 = domElement.nodeValue;
        } else {
          result2 = "";
        }
        return result2;
      }
      /**
       * Set the text content of the given DOM element.
       * @param {Element} domElement
       * @param {string} text
       */
      static setText(domElement, text2) {
        const nodeType = domElement.nodeType;
        if (nodeType === Node.ELEMENT_NODE || nodeType === Node.DOCUMENT_NODE || nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          domElement.textContent = text2;
        }
      }
      /**
       * Filter out the given `arr` array with the elements found in `excludedElements`.
       * This returns a new array and does not modify the source.
       * cf. verification here : http://codepen.io/AnotherLinuxUser/pen/XpvrMg?editors=0012
       *
       * @param {Array} arr
       * @param {Array} excludedElements
       * @returns {*|Array.<T>}
       */
      static filterOut(arr, excludedElements) {
        return arr.filter((element) => !this.isInArray(element, excludedElements));
      }
      /**
       * Remove the trailing zeros in the decimal part of a number.
       *
       * @param {string} numericString
       * @returns {*}
       */
      static trimPaddedZerosFromDecimalPlaces(numericString) {
        numericString = String(numericString);
        if (numericString === "") {
          return "";
        }
        const [integerPart, decimalPart] = numericString.split(".");
        if (this.isUndefinedOrNullOrEmpty(decimalPart)) {
          return integerPart;
        }
        const trimmedDecimalPart = decimalPart.replace(/0+$/g, "");
        let result2;
        if (trimmedDecimalPart === "") {
          result2 = integerPart;
        } else {
          result2 = `${integerPart}.${trimmedDecimalPart}`;
        }
        return result2;
      }
      /**
       * Return the top-most hovered item by the mouse cursor.
       *
       * @returns {*}
       */
      static getHoveredElement() {
        const hoveredElements = [...document.querySelectorAll(":hover")];
        return hoveredElements[hoveredElements.length - 1];
      }
      /**
       * Return the given array trimmed to the given length.
       * @example arrayTrim([1, 2, 3, 4], 2) -> [1, 2]
       *
       * @param {Array} array
       * @param {Number} length
       * @returns {*}
       */
      static arrayTrim(array2, length) {
        const arrLength = array2.length;
        if (arrLength === 0 || length > arrLength) {
          return array2;
        }
        if (length < 0) {
          return [];
        }
        array2.length = parseInt(length, 10);
        return array2;
      }
      /**
       * Merge all the given arrays by keeping only unique elements, and return an array with de-duplicated values.
       * cf. http://stackoverflow.com/a/27664971/2834898
       *
       * @param {...array} arrays
       * @returns {[*]}
       */
      static arrayUnique(...arrays) {
        return [...new Set([].concat(...arrays))];
      }
      /**
       * Merge all the given Maps by keeping only unique elements, and return a new Map with de-duplicated keys.
       *
       * @param {...Map} mapObjects
       * @returns {Map}
       */
      static mergeMaps(...mapObjects) {
        return new Map(mapObjects.reduce((as, b2) => as.concat([...b2]), []));
      }
      /**
       * Search the given `value` in the object `obj`, and return the very first key it finds
       *
       * @param {object} obj
       * @param {string|number} value
       * @returns {*|null}
       */
      static objectKeyLookup(obj, value) {
        const result2 = Object.entries(obj).find((array2) => array2[1] === value);
        let key = null;
        if (result2 !== void 0) {
          key = result2[0];
        }
        return key;
      }
      /**
       * Insert the single character `char` in the string `str` at the given position `index`
       *
       * @param {string} str
       * @param {string} char
       * @param {int} index
       * @returns {string}
       */
      static insertAt(str, char, index) {
        str = String(str);
        if (index > str.length) {
          throw new Error(`The given index is out of the string range.`);
        }
        if (char.length !== 1) {
          throw new Error("The given string `char` should be only one character long.");
        }
        if (str === "" && index === 0) {
          return char;
        }
        return `${str.slice(0, index)}${char}${str.slice(index)}`;
      }
      /**
       * Convert the given scientific notation to the 'expanded' decimal notation
       *
       * @example scientificToDecimal('-123.4567e-6') returns '-0.0001234567'
       *
       * @param {number|string} val
       * @returns {number|string}
       */
      static scientificToDecimal(val) {
        const numericValue = Number(val);
        if (isNaN(numericValue)) {
          return NaN;
        }
        val = String(val);
        const isScientific = this.contains(val, "e") || this.contains(val, "E");
        if (!isScientific) {
          return val;
        }
        let [value, exponent] = val.split(/e/i);
        const isNegative = value < 0;
        if (isNegative) {
          value = value.replace("-", "");
        }
        const isNegativeExponent = +exponent < 0;
        if (isNegativeExponent) {
          exponent = exponent.replace("-", "");
        }
        const [int, float] = value.split(/\./);
        let result2;
        if (isNegativeExponent) {
          if (int.length > exponent) {
            result2 = this.insertAt(int, ".", int.length - exponent);
          } else {
            result2 = `0.${"0".repeat(exponent - int.length)}${int}`;
          }
          result2 = `${result2}${float ? float : ""}`;
        } else {
          if (float) {
            value = `${int}${float}`;
            if (exponent < float.length) {
              result2 = this.insertAt(value, ".", +exponent + int.length);
            } else {
              result2 = `${value}${"0".repeat(exponent - float.length)}`;
            }
          } else {
            value = value.replace(".", "");
            result2 = `${value}${"0".repeat(Number(exponent))}`;
          }
        }
        if (isNegative) {
          result2 = `-${result2}`;
        }
        return result2;
      }
    }
    class Evaluator {
      constructor(ast) {
        if (ast === null) {
          throw new Error(`Invalid AST`);
        }
      }
      evaluate(subtree) {
        if (subtree === void 0 || subtree === null) {
          throw new Error(`Invalid AST sub-tree`);
        }
        if (subtree.type === "number") {
          return subtree.value;
        } else if (subtree.type === "unaryMinus") {
          return -this.evaluate(subtree.left);
        } else {
          const left2 = this.evaluate(subtree.left);
          const right2 = this.evaluate(subtree.right);
          switch (subtree.type) {
            case "op_+":
              return Number(left2) + Number(right2);
            case "op_-":
              return left2 - right2;
            case "op_*":
              return left2 * right2;
            case "op_/":
              return left2 / right2;
            default:
              throw new Error(`Invalid operator '${subtree.type}'`);
          }
        }
      }
    }
    class ASTNode {
      /*
      constructor() {
          // this.type = void(0);
          // this.value = 0;
          // this.left = null;
          // this.right = null;
      }
      */
      static createNode(type, left2, right2) {
        const node = new ASTNode();
        node.type = type;
        node.left = left2;
        node.right = right2;
        return node;
      }
      static createUnaryNode(left2) {
        const node = new ASTNode();
        node.type = "unaryMinus";
        node.left = left2;
        node.right = null;
        return node;
      }
      static createLeaf(value) {
        const node = new ASTNode();
        node.type = "number";
        node.value = value;
        return node;
      }
    }
    class Token {
      constructor(type, value, symbol) {
        this.type = type;
        this.value = value;
        this.symbol = symbol;
      }
    }
    let Lexer$1 = class Lexer {
      constructor(text2) {
        this.text = text2;
        this.textLength = text2.length;
        this.index = 0;
        this.token = new Token("Error", 0, 0);
      }
      /**
       * Ignore white spaces and increment the index count until a non-space character is found
       * @private
       */
      _skipSpaces() {
        while (this.text[this.index] === " " && this.index <= this.textLength) {
          this.index++;
        }
      }
      /**
       * Return the current index
       *
       * @returns {number}
       */
      getIndex() {
        return this.index;
      }
      /**
       * Return the next token object
       *
       * @param {string} decimalCharacter The decimal character to use in the float numbers
       * @returns {Token}
       */
      getNextToken(decimalCharacter = ".") {
        this._skipSpaces();
        if (this.textLength === this.index) {
          this.token.type = "EOT";
          return this.token;
        }
        if (AutoNumericHelper.isDigit(this.text[this.index])) {
          this.token.type = "num";
          this.token.value = this._getNumber(decimalCharacter);
          return this.token;
        }
        this.token.type = "Error";
        switch (this.text[this.index]) {
          case "+":
            this.token.type = "+";
            break;
          case "-":
            this.token.type = "-";
            break;
          case "*":
            this.token.type = "*";
            break;
          case "/":
            this.token.type = "/";
            break;
          case "(":
            this.token.type = "(";
            break;
          case ")":
            this.token.type = ")";
            break;
        }
        if (this.token.type !== "Error") {
          this.token.symbol = this.text[this.index];
          this.index++;
        } else {
          throw new Error(`Unexpected token '${this.token.symbol}' at position '${this.token.index}' in the token function`);
        }
        return this.token;
      }
      /**
       * Return the integer or float number starting from the `this.index` string index
       *
       * @param {string} decimalCharacter The decimal character to use in the float numbers
       *
       * @returns {string}
       * @private
       */
      _getNumber(decimalCharacter) {
        this._skipSpaces();
        const startIndex = this.index;
        while (this.index <= this.textLength && AutoNumericHelper.isDigit(this.text[this.index])) {
          this.index++;
        }
        if (this.text[this.index] === decimalCharacter) {
          this.index++;
        }
        while (this.index <= this.textLength && AutoNumericHelper.isDigit(this.text[this.index])) {
          this.index++;
        }
        if (this.index === startIndex) {
          throw new Error(`No number has been found while it was expected`);
        }
        return this.text.substring(startIndex, this.index).replace(decimalCharacter, ".");
      }
    };
    let Parser$1 = class Parser {
      /**
       * Parse the given string, and generate an abstract syntax tree (AST) from the math expression
       *
       * @param {string} text
       * @param {string} customDecimalCharacter The custom decimal character to use in floats
       * @returns {ASTNode}
       */
      constructor(text2, customDecimalCharacter = ".") {
        this.text = text2;
        this.decimalCharacter = customDecimalCharacter;
        this.lexer = new Lexer$1(text2);
        this.token = this.lexer.getNextToken(this.decimalCharacter);
        return this._exp();
      }
      _exp() {
        const termNode = this._term();
        const exprNode = this._moreExp();
        return ASTNode.createNode("op_+", termNode, exprNode);
      }
      _moreExp() {
        let termNode;
        let exprNode;
        switch (this.token.type) {
          case "+":
            this.token = this.lexer.getNextToken(this.decimalCharacter);
            termNode = this._term();
            exprNode = this._moreExp();
            return ASTNode.createNode("op_+", exprNode, termNode);
          case "-":
            this.token = this.lexer.getNextToken(this.decimalCharacter);
            termNode = this._term();
            exprNode = this._moreExp();
            return ASTNode.createNode("op_-", exprNode, termNode);
        }
        return ASTNode.createLeaf(0);
      }
      _term() {
        const factorNode = this._factor();
        const termsNode = this._moreTerms();
        return ASTNode.createNode("op_*", factorNode, termsNode);
      }
      _moreTerms() {
        let factorNode;
        let termsNode;
        switch (this.token.type) {
          case "*":
            this.token = this.lexer.getNextToken(this.decimalCharacter);
            factorNode = this._factor();
            termsNode = this._moreTerms();
            return ASTNode.createNode("op_*", termsNode, factorNode);
          case "/":
            this.token = this.lexer.getNextToken(this.decimalCharacter);
            factorNode = this._factor();
            termsNode = this._moreTerms();
            return ASTNode.createNode("op_/", termsNode, factorNode);
        }
        return ASTNode.createLeaf(1);
      }
      _factor() {
        let expression;
        let factor;
        let value;
        switch (this.token.type) {
          case "num":
            value = this.token.value;
            this.token = this.lexer.getNextToken(this.decimalCharacter);
            return ASTNode.createLeaf(value);
          case "-":
            this.token = this.lexer.getNextToken(this.decimalCharacter);
            factor = this._factor();
            return ASTNode.createUnaryNode(factor);
          case "(":
            this.token = this.lexer.getNextToken(this.decimalCharacter);
            expression = this._exp();
            this._match(")");
            return expression;
          default: {
            throw new Error(`Unexpected token '${this.token.symbol}' with type '${this.token.type}' at position '${this.token.index}' in the factor function`);
          }
        }
      }
      _match(expected) {
        const index = this.lexer.getIndex() - 1;
        if (this.text[index] === expected) {
          this.token = this.lexer.getNextToken(this.decimalCharacter);
        } else {
          throw new Error(`Unexpected token '${this.token.symbol}' at position '${index}' in the match function`);
        }
      }
    };
    /**
     *               AutoNumeric.js
     *
     * @version      4.10.7
     * @date         2024-10-14 UTC 01:11
     *
     * @authors      2016-2024 Alexandre Bonneau <alexandre.bonneau@linuxfr.eu>
     *               2009-2016 Bob Knothe <bob.knothe@gmail.com>
     * @contributors Sokolov Yura and others, cf. AUTHORS
     * @copyright    Alexandre Bonneau & Robert J. Knothe
     * @since        2009-08-09
     *
     * @summary      AutoNumeric is a standalone Javascript library
     *               that provides live *as-you-type* formatting for
     *               international numbers and currencies.
     *
     * @link         http://autonumeric.org
     * @docs         https://docs.autonumeric.org
     *
     *               Note : Some functions are borrowed from big.js
     * @see          https://github.com/MikeMcl/big.js/
     *
     * Please report any bugs to https://github.com/autoNumeric/autoNumeric
     *
     * @license      Released under the MIT License
     * @link         http://www.opensource.org/licenses/mit-license.php
     *
     * Permission is hereby granted, free of charge, to any person
     * obtaining a copy of this software and associated documentation
     * files (the "Software"), to deal in the Software without
     * restriction, including without limitation the rights to use,
     * copy, modify, merge, publish, distribute, sub license, and/or sell
     * copies of the Software, and to permit persons to whom the
     * Software is furnished to do so, subject to the following
     * conditions:
     *
     * The above copyright notice and this permission notice shall be
     * included in all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
     * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
     * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
     * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
     * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
     * OTHER DEALINGS IN THE SOFTWARE.
     */
    const _AutoNumeric = class _AutoNumeric {
      /**
       * Return the autoNumeric version number (for debugging purpose)
       *
       * @returns {string}
       */
      static version() {
        return "4.10.6";
      }
      /**
       * Initialize the AutoNumeric object onto the given DOM element, and attach the settings and related event listeners to it.
       * The options passed as a parameter is an object that contains the settings (i.e. {digitGroupSeparator: ".", decimalCharacter: ",", currencySymbol: ' '})
       *
       * @example
       * anElement = new AutoNumeric(domElement); // With the default options
       * anElement = new AutoNumeric(domElement, { options }); // With one option object
       * anElement = new AutoNumeric(domElement, 'euroPos'); // With a named pre-defined string
       * anElement = new AutoNumeric(domElement, [{ options1 }, 'euroPos', { options2 }]); // With multiple option objects (the latest option overwriting the previous ones)
       * anElement = new AutoNumeric(domElement, null, { options }); // With one option object, and a failed initial value
       * anElement = new AutoNumeric(domElement).french(); // With one pre-defined language object
       * anElement = new AutoNumeric(domElement).french({ options });// With one pre-defined language object and additional options that will override the defaults
       *
       * // ...or init and set the value in one call :
       * anElement = new AutoNumeric(domElement, 12345.789); // With the default options, and an initial value
       * anElement = new AutoNumeric(domElement, 12345.789, { options });
       * anElement = new AutoNumeric(domElement, '12345.789', { options });
       * anElement = new AutoNumeric(domElement, 12345.789, 'euroPos');
       * anElement = new AutoNumeric(domElement, 12345.789, [{ options1 }, 'euroPos', { options2 }]);
       * anElement = new AutoNumeric(domElement, 12345.789).french({ options });
       * anElement = new AutoNumeric(domElement, 12345.789, { options }).french({ options }); // Not really helpful, but possible
       *
       * // The AutoNumeric constructor class can also accept a string as a css selector. Under the hood this use `QuerySelector` and limit itself to only the first element it finds.
       * anElement = new AutoNumeric('.myCssClass > input');
       * anElement = new AutoNumeric('.myCssClass > input', { options });
       * anElement = new AutoNumeric('.myCssClass > input', 'euroPos');
       * anElement = new AutoNumeric('.myCssClass > input', [{ options1 }, 'euroPos', { options2 }]);
       * anElement = new AutoNumeric('.myCssClass > input', 12345.789);
       * anElement = new AutoNumeric('.myCssClass > input', 12345.789, { options });
       * anElement = new AutoNumeric('.myCssClass > input', 12345.789, 'euroPos');
       * anElement = new AutoNumeric('.myCssClass > input', 12345.789, [{ options1 }, 'euroPos', { options2 }]);
       * anElement = new AutoNumeric('.myCssClass > input', null, { options }); // With a failed initial value
       * anElement = new AutoNumeric('.myCssClass > input', 12345.789).french({ options });
       *
       * @param {object|Array|number|string} arg1
       * @param {object|Array|number|string|null} arg2
       * @param {object|Array|number|string|null} arg3
       * @throws
       */
      constructor(arg1 = null, arg2 = null, arg3 = null) {
        const { domElement, initialValue, userOptions } = _AutoNumeric._setArgumentsValues(arg1, arg2, arg3);
        this.domElement = domElement;
        this.defaultRawValue = "";
        this._setSettings(userOptions, false);
        this._checkElement();
        this.savedCancellableValue = null;
        this.historyTable = [];
        this.historyTableIndex = -1;
        this.onGoingRedo = false;
        this.parentForm = this._getParentForm();
        if (!this.runOnce && this.settings.formatOnPageLoad) {
          this._formatDefaultValueOnPageLoad(initialValue);
        } else {
          let valueToSet;
          if (AutoNumericHelper.isNull(initialValue)) {
            switch (this.settings.emptyInputBehavior) {
              case _AutoNumeric.options.emptyInputBehavior.min:
                valueToSet = this.settings.minimumValue;
                break;
              case _AutoNumeric.options.emptyInputBehavior.max:
                valueToSet = this.settings.maximumValue;
                break;
              case _AutoNumeric.options.emptyInputBehavior.zero:
                valueToSet = "0";
                break;
              case _AutoNumeric.options.emptyInputBehavior.focus:
              case _AutoNumeric.options.emptyInputBehavior.press:
              case _AutoNumeric.options.emptyInputBehavior.always:
                valueToSet = "";
                break;
              case _AutoNumeric.options.emptyInputBehavior.null:
                valueToSet = null;
                break;
              default:
                valueToSet = this.settings.emptyInputBehavior;
            }
          } else {
            valueToSet = initialValue;
          }
          this._setElementAndRawValue(valueToSet);
        }
        this.runOnce = true;
        this.hasEventListeners = false;
        if (this.isInputElement || this.isContentEditable) {
          if (!this.settings.noEventListeners) {
            this._createEventListeners();
          }
          this._setWritePermissions(true);
        }
        this._saveInitialValues(initialValue);
        this.storageNamePrefix = "AUTO_";
        this._setPersistentStorageName();
        this.validState = true;
        this.isFocused = false;
        this.isWheelEvent = false;
        this.isDropEvent = false;
        this.isEditing = false;
        this.rawValueOnFocus = void 0;
        this.internalModification = false;
        this.attributeToWatch = this._getAttributeToWatch();
        this.getterSetter = Object.getOwnPropertyDescriptor(this.domElement.__proto__, this.attributeToWatch);
        this._addWatcher();
        if (this.settings.createLocalList) {
          this._createLocalList();
        }
        this.constructor._addToGlobalList(this);
        this.global = {
          /**
           * Set the same given element value for each element in the local AutoNumeric element list, and format those elements immediately
           *
           * @param {number|string} newValue The value must be a number or a numeric string
           * @param {object} options A settings object that will override the current settings. Note: the update is done only if the `newValue` is defined.
           */
          set: (newValue, options = null) => {
            this.autoNumericLocalList.forEach((aNObject) => {
              aNObject.set(newValue, options);
            });
          },
          /**
           * Set the value given value directly as the DOM element value, without formatting it beforehand.
           * This sets the same unformatted value for each element in the local AutoNumeric element list.
           *
           * @param {number|string} value
           * @param {object} options
           */
          setUnformatted: (value, options = null) => {
            this.autoNumericLocalList.forEach((aNObject) => {
              aNObject.setUnformatted(value, options);
            });
          },
          /**
           * This is an alias of the `getNumericString()` function, and should not be used anymore.
           *
           * @param {function|null} callback If a callback is passed, then the result is passed to it as its first argument, and the AutoNumeric object has its second
           * @returns {Array<string>}
           * @deprecated
           */
          get: (callback = null) => {
            const result2 = [];
            this.autoNumericLocalList.forEach((aNObject) => {
              result2.push(aNObject.get());
            });
            this._executeCallback(result2, callback);
            return result2;
          },
          /**
           * Return an array of the unformatted values (as a string) of each AutoNumeric element of the local AutoNumeric element list
           *
           * @param {function|null} callback If a callback is passed, then the result is passed to it as its first argument, and the AutoNumeric object has its second
           * @returns {Array<string>}
           */
          getNumericString: (callback = null) => {
            const result2 = [];
            this.autoNumericLocalList.forEach((aNObject) => {
              result2.push(aNObject.getNumericString());
            });
            this._executeCallback(result2, callback);
            return result2;
          },
          /**
           * Return an array of the current formatted values (as a string) of each AutoNumeric element of the local AutoNumeric element list
           *
           * @param {function|null} callback If a callback is passed, then the result is passed to it as its first argument, and the AutoNumeric object has its second
           * @returns {Array<string>}
           */
          getFormatted: (callback = null) => {
            const result2 = [];
            this.autoNumericLocalList.forEach((aNObject) => {
              result2.push(aNObject.getFormatted());
            });
            this._executeCallback(result2, callback);
            return result2;
          },
          /**
           * Return an array of the element unformatted values (as a real Javascript number), for each element of the local AutoNumeric element list
           *
           * @param {function|null} callback If a callback is passed, then the result is passed to it as its first argument, and the AutoNumeric object has its second
           * @returns {Array<number>}
           */
          getNumber: (callback = null) => {
            const result2 = [];
            this.autoNumericLocalList.forEach((aNObject) => {
              result2.push(aNObject.getNumber());
            });
            this._executeCallback(result2, callback);
            return result2;
          },
          /**
           * Returns the unformatted values (following the `outputFormat` setting) of each element of the local AutoNumeric element list into an array
           *
           * @param {function|null} callback If a callback is passed, then the result is passed to it as its first argument, and the AutoNumeric object has its second
           * @returns {Array<string>}
           */
          getLocalized: (callback = null) => {
            const result2 = [];
            this.autoNumericLocalList.forEach((aNObject) => {
              result2.push(aNObject.getLocalized());
            });
            this._executeCallback(result2, callback);
            return result2;
          },
          /**
           * Force each element of the local AutoNumeric element list to reformat its value
           */
          reformat: () => {
            this.autoNumericLocalList.forEach((aNObject) => {
              aNObject.reformat();
            });
          },
          /**
           * Remove the formatting and keep only the raw unformatted value (as a numericString) in each element of the local AutoNumeric element list
           */
          unformat: () => {
            this.autoNumericLocalList.forEach((aNObject) => {
              aNObject.unformat();
            });
          },
          /**
           * Remove the formatting and keep only the localized unformatted value in the element, with the option to override the default outputFormat if needed
           *
           * @param {null|string} forcedOutputFormat If set to something different from `null`, then this is used as an overriding outputFormat option
           */
          unformatLocalized: (forcedOutputFormat = null) => {
            this.autoNumericLocalList.forEach((aNObject) => {
              aNObject.unformatLocalized(forcedOutputFormat);
            });
          },
          /**
           * Updates the AutoNumeric settings, and immediately format the elements accordingly, for each element of the local AutoNumeric element list
           *
           * @param {object} newOptions This can be either one or more option objects
           */
          update: (...newOptions) => {
            this.autoNumericLocalList.forEach((aNObject) => {
              aNObject.update(...newOptions);
            });
          },
          /**
           * Return `true` if *all* the autoNumeric-managed elements are pristine, if their raw value hasn't changed.
           * By default, this returns `true` if the raw unformatted value is still the same even if the formatted one has changed (due to a configuration update for instance).
           *
           * @param {boolean} checkOnlyRawValue If set to `true`, the pristine value is done on the raw unformatted value, not the formatted one. If set to `false`, this also checks that the formatted value hasn't changed.
           * @returns {boolean}
           */
          isPristine: (checkOnlyRawValue = true) => {
            let isPristine = true;
            this.autoNumericLocalList.forEach((aNObject) => {
              if (isPristine && !aNObject.isPristine(checkOnlyRawValue)) {
                isPristine = false;
              }
            });
            return isPristine;
          },
          /**
           * Execute the `clear()` method on each AutoNumeric object in the local AutoNumeric element list
           *
           * @param {boolean} forceClearAll
           */
          clear: (forceClearAll = false) => {
            this.autoNumericLocalList.forEach((aNObject) => {
              aNObject.clear(forceClearAll);
            });
          },
          /**
           * Execute the `remove()` method on each AutoNumeric object in the local AutoNumeric element list
           */
          remove: () => {
            this.autoNumericLocalList.forEach((aNObject) => {
              aNObject.remove();
            });
          },
          /**
           * Execute the `wipe()` method on each AutoNumeric object in the local AutoNumeric element list
           */
          wipe: () => {
            this.autoNumericLocalList.forEach((aNObject) => {
              aNObject.wipe();
            });
          },
          /**
           * Execute the `nuke()` method on each AutoNumeric object in the local AutoNumeric element list
           */
          nuke: () => {
            this.autoNumericLocalList.forEach((aNObject) => {
              aNObject.nuke();
            });
          },
          /**
           * Return `true` if the given AutoNumeric object (or DOM element) is in the local AutoNumeric element list
           *
           * @param {HTMLElement|HTMLInputElement|AutoNumeric} domElementOrAutoNumericObject
           * @returns {*}
           */
          has: (domElementOrAutoNumericObject) => {
            let result2;
            if (domElementOrAutoNumericObject instanceof _AutoNumeric) {
              result2 = this.autoNumericLocalList.has(domElementOrAutoNumericObject.node());
            } else {
              result2 = this.autoNumericLocalList.has(domElementOrAutoNumericObject);
            }
            return result2;
          },
          /**
           * Add an existing AutoNumeric object (or DOM element) to the local AutoNumeric element list, using the DOM element as the key.
           * This manages the case where `addObject` is used on an AutoNumeric object that already has multiple elements in its local list.
           *
           * @param {HTMLElement|HTMLInputElement|AutoNumeric} domElementOrAutoNumericObject
           */
          addObject: (domElementOrAutoNumericObject) => {
            let domElement2;
            let otherAutoNumericObject;
            if (domElementOrAutoNumericObject instanceof _AutoNumeric) {
              domElement2 = domElementOrAutoNumericObject.node();
              otherAutoNumericObject = domElementOrAutoNumericObject;
            } else {
              domElement2 = domElementOrAutoNumericObject;
              otherAutoNumericObject = _AutoNumeric.getAutoNumericElement(domElement2);
            }
            if (!this._hasLocalList()) {
              this._createLocalList();
            }
            let otherANLocalList = otherAutoNumericObject._getLocalList();
            if (otherANLocalList.size === 0) {
              otherAutoNumericObject._createLocalList();
              otherANLocalList = otherAutoNumericObject._getLocalList();
            }
            let mergedLocalLists;
            if (otherANLocalList instanceof Map) {
              mergedLocalLists = AutoNumericHelper.mergeMaps(this._getLocalList(), otherANLocalList);
            } else {
              this._addToLocalList(domElement2, otherAutoNumericObject);
              mergedLocalLists = this._getLocalList();
            }
            mergedLocalLists.forEach((aNObject) => {
              aNObject._setLocalList(mergedLocalLists);
            });
          },
          /**
           * Remove the given AutoNumeric object (or DOM element) from the local AutoNumeric element list, using the DOM element as the key.
           * If this function attempts to remove the current AutoNumeric object from the local list, a warning is shown, but the deletion is still done.
           *
           * Special cases :
           * - If the current object removes itself, then it's removed from the shared local list, then a new empty local list is used/created
           * - If another object remove this object, then a local list with only this object is used/created
           *
           * @param {HTMLElement|HTMLInputElement|AutoNumeric} domElementOrAutoNumericObject
           * @param {boolean} keepCurrentANObject If set to `false`, then the function will also remove the current AutoNumeric object if asked, otherwise it will ignore it and print a warning message
           */
          removeObject: (domElementOrAutoNumericObject, keepCurrentANObject = false) => {
            let domElement2;
            let otherAutoNumericObject;
            if (domElementOrAutoNumericObject instanceof _AutoNumeric) {
              domElement2 = domElementOrAutoNumericObject.node();
              otherAutoNumericObject = domElementOrAutoNumericObject;
            } else {
              domElement2 = domElementOrAutoNumericObject;
              otherAutoNumericObject = _AutoNumeric.getAutoNumericElement(domElement2);
            }
            const initialCompleteLocalList = this.autoNumericLocalList;
            this.autoNumericLocalList.delete(domElement2);
            initialCompleteLocalList.forEach((aNObject) => {
              aNObject._setLocalList(this.autoNumericLocalList);
            });
            if (!keepCurrentANObject && domElement2 === this.node()) {
              otherAutoNumericObject._setLocalList(/* @__PURE__ */ new Map());
            } else {
              otherAutoNumericObject._createLocalList();
            }
          },
          /**
           * Remove all elements from the shared list, effectively emptying it.
           * This is the equivalent of calling `detach()` on each of its elements.
           *
           * @param {boolean} keepEachANObjectInItsOwnList If set to `true`, then instead of completely emptying the local list of each AutoNumeric objects, each one of those keeps itself in its own local list
           */
          empty: (keepEachANObjectInItsOwnList = false) => {
            const initialCompleteLocalList = this.autoNumericLocalList;
            initialCompleteLocalList.forEach((aNObject) => {
              if (keepEachANObjectInItsOwnList) {
                aNObject._createLocalList();
              } else {
                aNObject._setLocalList(/* @__PURE__ */ new Map());
              }
            });
          },
          /**
           * Return an array containing all the AutoNumeric DOM elements that have been initialized by each other
           *
           * @returns {Array<HTMLElement>}
           */
          elements: () => {
            const result2 = [];
            this.autoNumericLocalList.forEach((aNObject) => {
              result2.push(aNObject.node());
            });
            return result2;
          },
          /**
           * Return the `Map` object directly
           * @returns {Map}
           */
          getList: () => this.autoNumericLocalList,
          /**
           * Return the number of element in the local AutoNumeric element list
           * @returns {number}
           */
          size: () => this.autoNumericLocalList.size
        };
        this.options = {
          /**
           * Reset any options set previously, by overwriting them with the default settings
           *
           * @returns {AutoNumeric}
           */
          reset: () => {
            this.settings = { rawValue: this.defaultRawValue };
            this.update(_AutoNumeric.defaultSettings);
            return this;
          },
          allowDecimalPadding: (allowDecimalPadding) => {
            this.update({ allowDecimalPadding });
            return this;
          },
          alwaysAllowDecimalCharacter: (alwaysAllowDecimalCharacter) => {
            this.update({ alwaysAllowDecimalCharacter });
            return this;
          },
          caretPositionOnFocus: (caretPositionOnFocus) => {
            this.settings.caretPositionOnFocus = caretPositionOnFocus;
            return this;
          },
          createLocalList: (createLocalList) => {
            this.settings.createLocalList = createLocalList;
            if (this.settings.createLocalList) {
              if (!this._hasLocalList()) {
                this._createLocalList();
              }
            } else {
              this._deleteLocalList();
            }
            return this;
          },
          currencySymbol: (currencySymbol) => {
            this.update({ currencySymbol });
            return this;
          },
          currencySymbolPlacement: (currencySymbolPlacement) => {
            this.update({ currencySymbolPlacement });
            return this;
          },
          decimalCharacter: (decimalCharacter) => {
            this.update({ decimalCharacter });
            return this;
          },
          decimalCharacterAlternative: (decimalCharacterAlternative) => {
            this.settings.decimalCharacterAlternative = decimalCharacterAlternative;
            return this;
          },
          /**
           * Update the decimal places globally, which means this override any previously set number of decimal shown on focus, on blur, or in the raw value.
           *
           * @param {int} decimalPlaces
           * @returns {AutoNumeric}
           */
          decimalPlaces: (decimalPlaces) => {
            AutoNumericHelper.warning("Using `options.decimalPlaces()` instead of calling the specific `options.decimalPlacesRawValue()`, `options.decimalPlacesShownOnFocus()` and `options.decimalPlacesShownOnBlur()` methods will reset those options.\nPlease call the specific methods if you do not want to reset those.", this.settings.showWarnings);
            this.update({ decimalPlaces });
            return this;
          },
          decimalPlacesRawValue: (decimalPlacesRawValue) => {
            this.update({ decimalPlacesRawValue });
            return this;
          },
          decimalPlacesShownOnBlur: (decimalPlacesShownOnBlur) => {
            this.update({ decimalPlacesShownOnBlur });
            return this;
          },
          decimalPlacesShownOnFocus: (decimalPlacesShownOnFocus) => {
            this.update({ decimalPlacesShownOnFocus });
            return this;
          },
          defaultValueOverride: (defaultValueOverride) => {
            this.update({ defaultValueOverride });
            return this;
          },
          digitalGroupSpacing: (digitalGroupSpacing) => {
            this.update({ digitalGroupSpacing });
            return this;
          },
          digitGroupSeparator: (digitGroupSeparator) => {
            this.update({ digitGroupSeparator });
            return this;
          },
          divisorWhenUnfocused: (divisorWhenUnfocused) => {
            this.update({ divisorWhenUnfocused });
            return this;
          },
          emptyInputBehavior: (emptyInputBehavior) => {
            if (this.rawValue === null && emptyInputBehavior !== _AutoNumeric.options.emptyInputBehavior.null) {
              AutoNumericHelper.warning(`You are trying to modify the \`emptyInputBehavior\` option to something different than \`'null'\` (${emptyInputBehavior}), but the element raw value is currently set to \`null\`. This would result in an invalid \`rawValue\`. In order to fix that, the element value has been changed to the empty string \`''\`.`, this.settings.showWarnings);
              this.rawValue = "";
            }
            this.update({ emptyInputBehavior });
            return this;
          },
          eventBubbles: (eventBubbles) => {
            this.settings.eventBubbles = eventBubbles;
            return this;
          },
          eventIsCancelable: (eventIsCancelable) => {
            this.settings.eventIsCancelable = eventIsCancelable;
            return this;
          },
          failOnUnknownOption: (failOnUnknownOption) => {
            this.settings.failOnUnknownOption = failOnUnknownOption;
            return this;
          },
          formatOnPageLoad: (formatOnPageLoad) => {
            this.settings.formatOnPageLoad = formatOnPageLoad;
            return this;
          },
          formulaMode: (formulaMode) => {
            this.settings.formulaMode = formulaMode;
            return this;
          },
          historySize: (historySize) => {
            this.settings.historySize = historySize;
            return this;
          },
          invalidClass: (invalidClass) => {
            this.settings.invalidClass = invalidClass;
            return this;
          },
          isCancellable: (isCancellable) => {
            this.settings.isCancellable = isCancellable;
            return this;
          },
          leadingZero: (leadingZero) => {
            this.update({ leadingZero });
            return this;
          },
          maximumValue: (maximumValue) => {
            this.update({ maximumValue });
            return this;
          },
          minimumValue: (minimumValue) => {
            this.update({ minimumValue });
            return this;
          },
          modifyValueOnUpDownArrow: (modifyValueOnUpDownArrow) => {
            this.settings.modifyValueOnUpDownArrow = modifyValueOnUpDownArrow;
            return this;
          },
          modifyValueOnWheel: (modifyValueOnWheel) => {
            this.settings.modifyValueOnWheel = modifyValueOnWheel;
            return this;
          },
          negativeBracketsTypeOnBlur: (negativeBracketsTypeOnBlur) => {
            this.update({ negativeBracketsTypeOnBlur });
            return this;
          },
          negativePositiveSignPlacement: (negativePositiveSignPlacement) => {
            this.update({ negativePositiveSignPlacement });
            return this;
          },
          negativeSignCharacter: (negativeSignCharacter) => {
            this.update({ negativeSignCharacter });
            return this;
          },
          negativePositiveSignBehavior: (negativePositiveSignBehavior) => {
            this.settings.negativePositiveSignBehavior = negativePositiveSignBehavior;
            return this;
          },
          noEventListeners: (noEventListeners) => {
            if (noEventListeners === _AutoNumeric.options.noEventListeners.noEvents && this.settings.noEventListeners === _AutoNumeric.options.noEventListeners.addEvents) {
              this._removeEventListeners();
            }
            this.update({ noEventListeners });
            return this;
          },
          onInvalidPaste: (onInvalidPaste) => {
            this.settings.onInvalidPaste = onInvalidPaste;
            return this;
          },
          outputFormat: (outputFormat) => {
            this.settings.outputFormat = outputFormat;
            return this;
          },
          overrideMinMaxLimits: (overrideMinMaxLimits) => {
            this.update({ overrideMinMaxLimits });
            return this;
          },
          positiveSignCharacter: (positiveSignCharacter) => {
            this.update({ positiveSignCharacter });
            return this;
          },
          rawValueDivisor: (rawValueDivisor) => {
            this.update({ rawValueDivisor });
            return this;
          },
          readOnly: (readOnly) => {
            this.settings.readOnly = readOnly;
            this._setWritePermissions();
            return this;
          },
          roundingMethod: (roundingMethod) => {
            this.update({ roundingMethod });
            return this;
          },
          saveValueToSessionStorage: (saveValueToSessionStorage) => {
            this.update({ saveValueToSessionStorage });
            return this;
          },
          symbolWhenUnfocused: (symbolWhenUnfocused) => {
            this.update({ symbolWhenUnfocused });
            return this;
          },
          selectNumberOnly: (selectNumberOnly) => {
            this.settings.selectNumberOnly = selectNumberOnly;
            return this;
          },
          selectOnFocus: (selectOnFocus) => {
            this.settings.selectOnFocus = selectOnFocus;
            return this;
          },
          serializeSpaces: (serializeSpaces) => {
            this.settings.serializeSpaces = serializeSpaces;
            return this;
          },
          showOnlyNumbersOnFocus: (showOnlyNumbersOnFocus) => {
            this.update({ showOnlyNumbersOnFocus });
            return this;
          },
          showPositiveSign: (showPositiveSign) => {
            this.update({ showPositiveSign });
            return this;
          },
          showWarnings: (showWarnings) => {
            this.settings.showWarnings = showWarnings;
            return this;
          },
          styleRules: (styleRules) => {
            this.update({ styleRules });
            return this;
          },
          suffixText: (suffixText) => {
            this.update({ suffixText });
            return this;
          },
          unformatOnHover: (unformatOnHover) => {
            this.settings.unformatOnHover = unformatOnHover;
            return this;
          },
          unformatOnSubmit: (unformatOnSubmit) => {
            this.settings.unformatOnSubmit = unformatOnSubmit;
            return this;
          },
          upDownStep: (upDownStep) => {
            this.settings.upDownStep = upDownStep;
            return this;
          },
          valuesToStrings: (valuesToStrings) => {
            this.update({ valuesToStrings });
            return this;
          },
          watchExternalChanges: (watchExternalChanges) => {
            this.update({ watchExternalChanges });
            return this;
          },
          wheelOn: (wheelOn) => {
            this.settings.wheelOn = wheelOn;
            return this;
          },
          wheelStep: (wheelStep) => {
            this.settings.wheelStep = wheelStep;
            return this;
          }
        };
        this._triggerEvent(_AutoNumeric.events.initialized, this.domElement, {
          newValue: AutoNumericHelper.getElementValue(this.domElement),
          newRawValue: this.rawValue,
          error: null,
          aNElement: this
        });
      }
      /**
       * Take the parameters given to the AutoNumeric object, and output the three variables that are needed to finish initializing it :
       * - domElement : The target DOM element
       * - initialValue : The initial value, or `null` if none is given
       * - userOptions : The option object
       *
       * @param {object|Array|number|string} arg1
       * @param {object|Array|number|string|null} arg2
       * @param {object|Array|number|string|null} arg3
       * @returns {{domElement: *, initialValue: *, userOptions: *}}
       * @throws
       * @private
       */
      static _setArgumentsValues(arg1, arg2, arg3) {
        if (AutoNumericHelper.isNull(arg1)) {
          AutoNumericHelper.throwError("At least one valid parameter is needed in order to initialize an AutoNumeric object");
        }
        const isArg1Element = AutoNumericHelper.isElement(arg1);
        const isArg1String = AutoNumericHelper.isString(arg1);
        const isArg2Object = AutoNumericHelper.isObject(arg2);
        const isArg2Array = Array.isArray(arg2) && arg2.length > 0;
        const isArg2Number = AutoNumericHelper.isNumberOrArabic(arg2) || arg2 === "";
        const isArg2PreDefinedOptionName = this._isPreDefinedOptionValid(arg2);
        const isArg2Null = AutoNumericHelper.isNull(arg2);
        const isArg2EmptyString = AutoNumericHelper.isEmptyString(arg2);
        const isArg3Object = AutoNumericHelper.isObject(arg3);
        const isArg3Array = Array.isArray(arg3) && arg3.length > 0;
        const isArg3Null = AutoNumericHelper.isNull(arg3);
        const isArg3PreDefinedOptionName = this._isPreDefinedOptionValid(arg3);
        let domElement;
        let userOptions;
        let initialValue;
        if (isArg1Element && isArg2Null && isArg3Null) {
          domElement = arg1;
          initialValue = null;
          userOptions = null;
        } else if (isArg1Element && isArg2Number && isArg3Null) {
          domElement = arg1;
          initialValue = arg2;
          userOptions = null;
        } else if (isArg1Element && isArg2Object && isArg3Null) {
          domElement = arg1;
          initialValue = null;
          userOptions = arg2;
        } else if (isArg1Element && isArg2PreDefinedOptionName && isArg3Null) {
          domElement = arg1;
          initialValue = null;
          userOptions = this._getOptionObject(arg2);
        } else if (isArg1Element && isArg2Array && isArg3Null) {
          domElement = arg1;
          initialValue = null;
          userOptions = this.mergeOptions(arg2);
        } else if (isArg1Element && (isArg2Null || isArg2EmptyString) && isArg3Object) {
          domElement = arg1;
          initialValue = null;
          userOptions = arg3;
        } else if (isArg1Element && (isArg2Null || isArg2EmptyString) && isArg3Array) {
          domElement = arg1;
          initialValue = null;
          userOptions = this.mergeOptions(arg3);
        } else if (isArg1String && isArg2Null && isArg3Null) {
          domElement = document.querySelector(arg1);
          initialValue = null;
          userOptions = null;
        } else if (isArg1String && isArg2Object && isArg3Null) {
          domElement = document.querySelector(arg1);
          initialValue = null;
          userOptions = arg2;
        } else if (isArg1String && isArg2PreDefinedOptionName && isArg3Null) {
          domElement = document.querySelector(arg1);
          initialValue = null;
          userOptions = this._getOptionObject(arg2);
        } else if (isArg1String && isArg2Array && isArg3Null) {
          domElement = document.querySelector(arg1);
          initialValue = null;
          userOptions = this.mergeOptions(arg2);
        } else if (isArg1String && (isArg2Null || isArg2EmptyString) && isArg3Object) {
          domElement = document.querySelector(arg1);
          initialValue = null;
          userOptions = arg3;
        } else if (isArg1String && (isArg2Null || isArg2EmptyString) && isArg3Array) {
          domElement = document.querySelector(arg1);
          initialValue = null;
          userOptions = this.mergeOptions(arg3);
        } else if (isArg1String && isArg2Number && isArg3Null) {
          domElement = document.querySelector(arg1);
          initialValue = arg2;
          userOptions = null;
        } else if (isArg1String && isArg2Number && isArg3Object) {
          domElement = document.querySelector(arg1);
          initialValue = arg2;
          userOptions = arg3;
        } else if (isArg1String && isArg2Number && isArg3PreDefinedOptionName) {
          domElement = document.querySelector(arg1);
          initialValue = arg2;
          userOptions = this._getOptionObject(arg3);
        } else if (isArg1String && isArg2Number && isArg3Array) {
          domElement = document.querySelector(arg1);
          initialValue = arg2;
          userOptions = this.mergeOptions(arg3);
        } else if (isArg1Element && isArg2Number && isArg3Object) {
          domElement = arg1;
          initialValue = arg2;
          userOptions = arg3;
        } else if (isArg1Element && isArg2Number && isArg3PreDefinedOptionName) {
          domElement = arg1;
          initialValue = arg2;
          userOptions = this._getOptionObject(arg3);
        } else if (isArg1Element && isArg2Number && isArg3Array) {
          domElement = arg1;
          initialValue = arg2;
          userOptions = this.mergeOptions(arg3);
        } else {
          AutoNumericHelper.throwError(`The parameters given to the AutoNumeric object are not valid, '${arg1}', '${arg2}' and '${arg3}' given.`);
        }
        if (AutoNumericHelper.isNull(domElement)) {
          AutoNumericHelper.throwError(`The selector '${arg1}' did not select any valid DOM element. Please check on which element you called AutoNumeric.`);
        }
        return { domElement, initialValue, userOptions };
      }
      /**
       * Merge the option objects found in the given array `optionsArray`.
       * If a `string` is found, then we try to get the related pre-defined option using that string as its name.
       * When merging the options, the latest option overwrite any previously set. This allows to fine tune a pre-defined option for instance.
       *
       * @param {Array<object|string>} optionsArray
       * @returns {{}}
       */
      static mergeOptions(optionsArray) {
        const mergedOptions = {};
        optionsArray.forEach((optionObjectOrPredefinedOptionString) => {
          Object.assign(mergedOptions, this._getOptionObject(optionObjectOrPredefinedOptionString));
        });
        return mergedOptions;
      }
      /**
       * Return `true` if the given pre-defined option name is an attribute of the `AutoNumeric.predefinedOptions` object
       *
       * @param {string} preDefinedOptionName
       * @returns {boolean}
       * @private
       */
      static _isPreDefinedOptionValid(preDefinedOptionName) {
        return Object.prototype.hasOwnProperty.call(_AutoNumeric.predefinedOptions, preDefinedOptionName);
      }
      /**
       * Return an option object based on the given parameter.
       * If `optionObjectOrPredefinedName` is as string, then we retrieve the pre-defined option object, if it's an object, we use it as is.
       *
       * @param {object|string} optionObjectOrPredefinedName
       * @returns {object}
       */
      static _getOptionObject(optionObjectOrPredefinedName) {
        let options;
        if (AutoNumericHelper.isString(optionObjectOrPredefinedName)) {
          options = _AutoNumeric.getPredefinedOptions()[optionObjectOrPredefinedName];
          if (options === void 0 || options === null) {
            AutoNumericHelper.warning(`The given pre-defined option [${optionObjectOrPredefinedName}] is not recognized by autoNumeric. Please check that pre-defined option name.`, true);
          }
        } else {
          options = optionObjectOrPredefinedName;
        }
        return options;
      }
      /**
       * Save the initial element values for later use in the pristine test.
       * Those values are :
       * - the html attribute (i.e. <input value='42'>), and
       * - the script `value` (i.e. `let domElement.value`)
       *
       * @param {null|number|string} initialValue
       * @private
       */
      _saveInitialValues(initialValue) {
        this.initialValueHtmlAttribute = AutoNumericHelper.scientificToDecimal(this.domElement.getAttribute("value"));
        if (AutoNumericHelper.isNull(this.initialValueHtmlAttribute)) {
          this.initialValueHtmlAttribute = "";
        }
        this.initialValue = initialValue;
        if (AutoNumericHelper.isNull(this.initialValue)) {
          this.initialValue = "";
        }
      }
      /**
       * Generate all the event listeners for the given DOM element
       * @private
       */
      _createEventListeners() {
        this.formulaMode = false;
        this._onFocusInFunc = (e2) => {
          this._onFocusIn(e2);
        };
        this._onFocusInAndMouseEnterFunc = (e2) => {
          this._onFocusInAndMouseEnter(e2);
        };
        this._onFocusFunc = () => {
          this._onFocus();
        };
        this._onKeydownFunc = (e2) => {
          this._onKeydown(e2);
        };
        this._onKeypressFunc = (e2) => {
          this._onKeypress(e2);
        };
        this._onKeyupFunc = (e2) => {
          this._onKeyup(e2);
        };
        this._onFocusOutAndMouseLeaveFunc = (e2) => {
          this._onFocusOutAndMouseLeave(e2);
        };
        this._onPasteFunc = (e2) => {
          this._onPaste(e2);
        };
        this._onWheelFunc = (e2) => {
          this._onWheel(e2);
        };
        this._onDropFunc = (e2) => {
          this._onDrop(e2);
        };
        this._onKeydownGlobalFunc = (e2) => {
          this._onKeydownGlobal(e2);
        };
        this._onKeyupGlobalFunc = (e2) => {
          this._onKeyupGlobal(e2);
        };
        this.domElement.addEventListener("focusin", this._onFocusInFunc, false);
        this.domElement.addEventListener("focus", this._onFocusInAndMouseEnterFunc, false);
        this.domElement.addEventListener("focus", this._onFocusFunc, false);
        this.domElement.addEventListener("mouseenter", this._onFocusInAndMouseEnterFunc, false);
        this.domElement.addEventListener("keydown", this._onKeydownFunc, false);
        this.domElement.addEventListener("keypress", this._onKeypressFunc, false);
        this.domElement.addEventListener("keyup", this._onKeyupFunc, false);
        this.domElement.addEventListener("blur", this._onFocusOutAndMouseLeaveFunc, false);
        this.domElement.addEventListener("mouseleave", this._onFocusOutAndMouseLeaveFunc, false);
        this.domElement.addEventListener("paste", this._onPasteFunc, false);
        this.domElement.addEventListener("wheel", this._onWheelFunc, false);
        this.domElement.addEventListener("drop", this._onDropFunc, false);
        this._setupFormListener();
        this.hasEventListeners = true;
        if (!_AutoNumeric._doesGlobalListExists()) {
          document.addEventListener("keydown", this._onKeydownGlobalFunc, false);
          document.addEventListener("keyup", this._onKeyupGlobalFunc, false);
        }
      }
      /**
       * Remove all the autoNumeric-related event listeners for the given DOM element
       * @private
       */
      _removeEventListeners() {
        this.domElement.removeEventListener("focusin", this._onFocusInFunc, false);
        this.domElement.removeEventListener("focus", this._onFocusInAndMouseEnterFunc, false);
        this.domElement.removeEventListener("focus", this._onFocusFunc, false);
        this.domElement.removeEventListener("mouseenter", this._onFocusInAndMouseEnterFunc, false);
        this.domElement.removeEventListener("blur", this._onFocusOutAndMouseLeaveFunc, false);
        this.domElement.removeEventListener("mouseleave", this._onFocusOutAndMouseLeaveFunc, false);
        this.domElement.removeEventListener("keydown", this._onKeydownFunc, false);
        this.domElement.removeEventListener("keypress", this._onKeypressFunc, false);
        this.domElement.removeEventListener("keyup", this._onKeyupFunc, false);
        this.domElement.removeEventListener("paste", this._onPasteFunc, false);
        this.domElement.removeEventListener("wheel", this._onWheelFunc, false);
        this.domElement.removeEventListener("drop", this._onDropFunc, false);
        this._removeFormListener();
        this.hasEventListeners = false;
        document.removeEventListener("keydown", this._onKeydownGlobalFunc, false);
        document.removeEventListener("keyup", this._onKeyupGlobalFunc, false);
      }
      /**
       * Toggle the event listeners according to the `noEventListeners` option, if those were not activated/deactivated before
       * @private
       */
      _updateEventListeners() {
        if (!this.settings.noEventListeners && !this.hasEventListeners) {
          this._createEventListeners();
        }
        if (this.settings.noEventListeners && this.hasEventListeners) {
          this._removeEventListeners();
        }
      }
      /**
       * Mark the parent <form> so that other AutoNumeric object will not add more listeners.
       * Add a counter so that when removing the AutoNumeric object, we only remove the submit listener if that count is equal to 0.
       * Also keep a reference to the 'submit' event handler function to be able to remove that handler later if the `_removeFormListener()` function is called from another AutoNumeric object.
       *
       * @private
       */
      _setupFormListener() {
        if (!AutoNumericHelper.isNull(this.parentForm)) {
          this._onFormSubmitFunc = () => {
            this._onFormSubmit();
          };
          this._onFormResetFunc = () => {
            this._onFormReset();
          };
          if (this._hasParentFormCounter()) {
            this._incrementParentFormCounter();
          } else {
            this._initializeFormCounterToOne();
            this.parentForm.addEventListener("submit", this._onFormSubmitFunc, false);
            this.parentForm.addEventListener("reset", this._onFormResetFunc, false);
            this._storeFormHandlerFunction();
          }
        }
      }
      /**
       * Remove the form 'submit' event listener, as well as the `dataset` info (`anCount` and `anFormHandler`) from the parent form, only when there are only one AutoNumeric child element left in that <form>.
       * Otherwise, decrement the `anCount`.
       *
       * @private
       */
      _removeFormListener() {
        if (!AutoNumericHelper.isNull(this.parentForm)) {
          const anCount = this._getParentFormCounter();
          if (anCount === 1) {
            this.parentForm.removeEventListener("submit", this._getFormHandlerFunction().submitFn, false);
            this.parentForm.removeEventListener("reset", this._getFormHandlerFunction().resetFn, false);
            this._removeFormDataSetInfo();
          } else if (anCount > 1) {
            this._decrementParentFormCounter();
          } else {
            AutoNumericHelper.throwError(`The AutoNumeric object count on the form is incoherent.`);
          }
        }
      }
      /**
       * Return `true` if the parent form has the form counter attribute
       *
       * @returns {boolean}
       * @private
       */
      _hasParentFormCounter() {
        return "anCount" in this.parentForm.dataset;
      }
      /**
       * Return the count of AutoNumeric form children
       *
       * @returns {number}
       * @private
       */
      _getParentFormCounter() {
        return Number(this.parentForm.dataset.anCount);
      }
      /**
       * Set the count of AutoNumeric form children to 1 for the given form element, or if none are passed, the current `this.parentForm` one.
       *
       * @param {HTMLFormElement|null} formElement
       * @private
       */
      _initializeFormCounterToOne(formElement = null) {
        this._getFormElement(formElement).dataset.anCount = 1;
      }
      /**
       * Increment the AutoNumeric form children count for the given form element, or if none are passed, the current `this.parentForm` one.
       *
       * @param {HTMLFormElement|null} formElement
       * @private
       */
      _incrementParentFormCounter(formElement = null) {
        this._getFormElement(formElement).dataset.anCount++;
      }
      /**
       * Decrement the AutoNumeric form children count for the current `this.parentForm` form element.
       *
       * @private
       */
      _decrementParentFormCounter() {
        this.parentForm.dataset.anCount--;
      }
      /**
       * Return `true` if the global form handler list exists on the `window` object.
       *
       * @returns {boolean}
       * @private
       */
      static _doesFormHandlerListExists() {
        const type = typeof window.aNFormHandlerMap;
        return type !== "undefined" && type === "object";
      }
      /**
       * Create the global form handler list on the `window` object.
       *
       * @private
       */
      static _createFormHandlerList() {
        window.aNFormHandlerMap = /* @__PURE__ */ new Map();
      }
      /**
       * Return `true` if the given form element, or if none are passed, the current `this.parentForm` one has a form handler name.
       *
       * @param {HTMLFormElement|null} formElement
       * @returns {boolean}
       * @private
       */
      _hasFormHandlerFunction(formElement = null) {
        return "anFormHandler" in this._getFormElement(formElement).dataset;
      }
      /**
       * Return the given form element, or defaults to `this.parentForm` if no argument is passed.
       *
       * @param {HTMLFormElement|null} formElement
       * @returns {*}
       * @private
       */
      _getFormElement(formElement = null) {
        let formElementToUse;
        if (!AutoNumericHelper.isNull(formElement)) {
          formElementToUse = formElement;
        } else {
          formElementToUse = this.parentForm;
        }
        return formElementToUse;
      }
      /**
       * Generate a form handler unique name and store it in the global form handler list.
       * This also save that name in the dataset of the given form element.
       *
       * @param {HTMLFormElement|null} formElement
       * @private
       */
      _storeFormHandlerFunction(formElement = null) {
        if (!this.constructor._doesFormHandlerListExists()) {
          this.constructor._createFormHandlerList();
        }
        const formHandlerName = AutoNumericHelper.randomString();
        this._getFormElement(formElement).dataset.anFormHandler = formHandlerName;
        window.aNFormHandlerMap.set(formHandlerName, { submitFn: this._onFormSubmitFunc, resetFn: this._onFormResetFunc });
      }
      /**
       * Return the form handler key name from the parent form element, for the global form handler list.
       *
       * @returns {string|*}
       * @private
       */
      _getFormHandlerKey() {
        if (!this._hasFormHandlerFunction()) {
          AutoNumericHelper.throwError(`Unable to retrieve the form handler name`);
        }
        const formHandlerName = this.parentForm.dataset.anFormHandler;
        if (formHandlerName === "") {
          AutoNumericHelper.throwError(`The form handler name is invalid`);
        }
        return formHandlerName;
      }
      /**
       * Return the 'submit' event handler function used for the parent form.
       *
       * @returns {function}
       * @private
       */
      _getFormHandlerFunction() {
        const formHandlerName = this._getFormHandlerKey();
        return window.aNFormHandlerMap.get(formHandlerName);
      }
      /**
       * Remove the dataset attributes `data-an-count` and `data-an-form-handler` from the parent form element.
       *
       * @private
       */
      _removeFormDataSetInfo() {
        this._decrementParentFormCounter();
        window.aNFormHandlerMap.delete(this._getFormHandlerKey());
        this.parentForm.removeAttribute("data-an-count");
        this.parentForm.removeAttribute("data-an-form-handler");
      }
      /**
       * Set the DOM element write permissions according to the current settings, by setting the `readonly` or `contenteditable` attributes depending on its tag type.
       * If the `useHtmlAttribute` parameter is set to `true`, then the `readonly` html attribute is used and has precedence over the `readOnly` option to set the element as read-only.
       *
       * @param {boolean} useHtmlAttribute If set to `true`, then the write permissions are set by taking into account the html 'readonly' attribute, even if the `readOnly` option is set to false
       * @private
       */
      _setWritePermissions(useHtmlAttribute = false) {
        if (useHtmlAttribute && this.domElement.readOnly || this.settings.readOnly) {
          this._setReadOnly();
        } else {
          this._setReadWrite();
        }
      }
      /**
       * Set the element to be read-only.
       * If the DOM element tag is not an `input`, then it `contenteditable` attribute is set to `false`.
       *
       * @private
       */
      _setReadOnly() {
        if (this.isInputElement) {
          this.domElement.readOnly = true;
        } else {
          this.domElement.setAttribute("contenteditable", false);
        }
      }
      /**
       * Set the element to be read-write.
       *
       * @private
       */
      _setReadWrite() {
        if (this.isInputElement) {
          this.domElement.readOnly = false;
        } else {
          this.domElement.setAttribute("contenteditable", true);
        }
      }
      /**
       * Add a watcher so that any external change to the AutoNumeric-managed element would be detected.
       * As soon as such change is detected, AutoNumeric then tries to `set()` the value so that it gets formatted and stored in the history.
       * //XXX For now, this only works when watching the `value` attribute, not the `textContent` one
       * @private
       */
      _addWatcher() {
        if (!AutoNumericHelper.isUndefined(this.getterSetter)) {
          const { set: setter, get: getter } = this.getterSetter;
          Object.defineProperty(this.domElement, this.attributeToWatch, {
            configurable: true,
            // This is needed in some rare cases
            get: () => getter.call(this.domElement),
            set: (val) => {
              setter.call(this.domElement, val);
              if (this.settings.watchExternalChanges && !this.internalModification) {
                this.set(val);
              }
            }
          });
        }
      }
      /**
       * Remove the watcher on the AutoNumeric-managed element
       * Note: This needs to be called when the AutoNumeric element is 'removed', otherwise the getter/setter stays on the DOM element and that can lead to problem if the user initialize another AutoNumeric object on it.
       * @private
       */
      _removeWatcher() {
        if (!AutoNumericHelper.isUndefined(this.getterSetter)) {
          const { set: setter, get: getter } = this.getterSetter;
          Object.defineProperty(this.domElement, this.attributeToWatch, {
            configurable: true,
            // This is needed in some rare cases
            get: () => getter.call(this.domElement),
            set: (val) => {
              setter.call(this.domElement, val);
            }
          });
        }
      }
      /**
       * Return the name of the object attribute that store the current formatted data in the DOM element.
       *
       * @returns {string}
       * @private
       */
      _getAttributeToWatch() {
        let attributeToWatch;
        if (this.isInputElement) {
          attributeToWatch = "value";
        } else {
          const nodeType = this.domElement.nodeType;
          if (nodeType === Node.ELEMENT_NODE || nodeType === Node.DOCUMENT_NODE || nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
            attributeToWatch = "textContent";
          } else if (nodeType === Node.TEXT_NODE) {
            attributeToWatch = "nodeValue";
          }
        }
        return attributeToWatch;
      }
      /**
       * Save the current raw value into the history table, along with the selection information.
       *
       * If the user has done some undos and tries to enter:
       * - a new and different number than the 'next' state, this drops the rest of the history table
       * - the very same number that result in the same rawValue as the 'next' state, we only move the history table pointer to the next state
       *
       * @private
       */
      _historyTableAdd() {
        const isEmptyHistoryTable = this.historyTable.length === 0;
        if (isEmptyHistoryTable || this.rawValue !== this._historyTableCurrentValueUsed()) {
          let addNewHistoryState = true;
          if (!isEmptyHistoryTable) {
            const nextHistoryStateIndex = this.historyTableIndex + 1;
            if (nextHistoryStateIndex < this.historyTable.length && this.rawValue === this.historyTable[nextHistoryStateIndex].value) {
              addNewHistoryState = false;
            } else {
              AutoNumericHelper.arrayTrim(this.historyTable, this.historyTableIndex + 1);
            }
          }
          this.historyTableIndex++;
          if (addNewHistoryState) {
            const selection = AutoNumericHelper.getElementSelection(this.domElement);
            this.selectionStart = selection.start;
            this.selectionEnd = selection.end;
            this.historyTable.push({
              // Save the rawValue and selection start/end
              value: this.rawValue,
              // The selection for this element is temporary, and will be updated when the next history state will be recorded.
              // That way, we are always sure we save the last caret or selection positions just before the value is changed. Otherwise, we would only save those positions when the value is first changed, and would not take into account that the user could move the caret around afterward.
              // For instance, this is needed if the user change the element value, and immediately undo it ; if he then does a redo, he'll see the value and the right selection
              // To sum up; The selection position are not always +1 character, since it could also be '2' if a group separator is added when entering one character. That's why the current history state caret/selection position is updated on each `keyup` event.
              start: this.selectionStart + 1,
              // Here we add one since the user added one character too
              end: this.selectionEnd + 1
            });
            if (this.historyTable.length > 1) {
              this.historyTable[this.historyTableIndex - 1].start = this.selectionStart;
              this.historyTable[this.historyTableIndex - 1].end = this.selectionEnd;
            }
          }
          if (this.historyTable.length > this.settings.historySize) {
            this._historyTableForget();
          }
        }
      }
      /**
       * Debug function for the history table
       * @private
       */
      /*
      _debugHistoryTable() {
          let i = 0;
          let mark;
          this.historyTable.forEach(history => {
              if (this.historyTableIndex === i) {
                  mark = '> ';
              } else {
                  mark = '';
              }
              console.log(`${mark}${i++}: ${history.value} ${history.start}|${history.end} [onGoingRedo: ${this.onGoingRedo}]`); //DEBUG
          });
      }
      */
      /**
       * 'Undo' or 'Redo' the last/next user entry in the history table.
       * This does not modify the history table, only the pointer to the current state.
       *
       * @param {boolean} undo If set to `true`, then this function does an 'Undo', otherwise it does a 'Redo'
       * @private
       */
      _historyTableUndoOrRedo(undo2 = true) {
        let check2;
        if (undo2) {
          check2 = this.historyTableIndex > 0;
          if (check2) {
            this.historyTableIndex--;
          }
        } else {
          check2 = this.historyTableIndex + 1 < this.historyTable.length;
          if (check2) {
            this.historyTableIndex++;
          }
        }
        if (check2) {
          const undoInfo = this.historyTable[this.historyTableIndex];
          this.set(undoInfo.value, null, false);
          AutoNumericHelper.setElementSelection(this.domElement, undoInfo.start, undoInfo.end);
        }
      }
      /**
       * 'Undo' the last user entry by going back one entry in the history table.
       * This keeps the following entries in order to allow for a 'redo'.
       * This does not modify the history table, only the pointer to the current state.
       * @private
       */
      _historyTableUndo() {
        this._historyTableUndoOrRedo(true);
      }
      /**
       * 'Redo' the next user entry in the history table.
       * This does not modify the history table, only the pointer to the current state.
       * @private
       */
      _historyTableRedo() {
        this._historyTableUndoOrRedo(false);
      }
      /**
       * Reset the history table to its initial state, and select the value.
       * @private
       */
      /*
      resetHistoryTable() { //FIXME Test this
          this.set(this.rawValue, null, false);
          this.select();
          const selection = AutoNumericHelper.getElementSelection(this.domElement);
          this.historyTableIndex = 0;
          this.historyTable = [{
              // Save the rawValue and selection start/end
              value: this.rawValue,
              start: selection.start,
              end  : selection.end,
          }];
      }
      */
      /**
       * Make the history table forget its first N elements, shifting its indexes in the process.
       * `N` being given as the `numberOfEntriesToForget` parameter.
       *
       * @param {Number} numberOfEntriesToForget
       * @returns {object|Array<object>} The discarded objects, in an Array.
       * @private
       */
      _historyTableForget(numberOfEntriesToForget = 1) {
        const shiftedAway = [];
        for (let i2 = 0; i2 < numberOfEntriesToForget; i2++) {
          shiftedAway.push(this.historyTable.shift());
          this.historyTableIndex--;
          if (this.historyTableIndex < 0) {
            this.historyTableIndex = 0;
          }
        }
        if (shiftedAway.length === 1) {
          return shiftedAway[0];
        }
        return shiftedAway;
      }
      /**
       * Return the currently used value from the history table.
       *
       * @returns {string|number}
       * @private
       */
      _historyTableCurrentValueUsed() {
        let indexToUse = this.historyTableIndex;
        if (indexToUse < 0) {
          indexToUse = 0;
        }
        let result2;
        if (AutoNumericHelper.isUndefinedOrNullOrEmpty(this.historyTable[indexToUse])) {
          result2 = "";
        } else {
          result2 = this.historyTable[indexToUse].value;
        }
        return result2;
      }
      /**
       * Parse the `styleRules` option and run the test for each given rules, either pre-defined ones like `positive`, `negative` and `ranges`, or user defined callbacks within the `userDefined` attribute.
       * @private
       */
      _parseStyleRules() {
        if (AutoNumericHelper.isUndefinedOrNullOrEmpty(this.settings.styleRules) || this.rawValue === "") {
          return;
        }
        if (!AutoNumericHelper.isUndefinedOrNullOrEmpty(this.settings.styleRules.positive)) {
          if (this.rawValue >= 0) {
            this._addCSSClass(this.settings.styleRules.positive);
          } else {
            this._removeCSSClass(this.settings.styleRules.positive);
          }
        }
        if (!AutoNumericHelper.isUndefinedOrNullOrEmpty(this.settings.styleRules.negative)) {
          if (this.rawValue < 0) {
            this._addCSSClass(this.settings.styleRules.negative);
          } else {
            this._removeCSSClass(this.settings.styleRules.negative);
          }
        }
        if (!AutoNumericHelper.isUndefinedOrNullOrEmpty(this.settings.styleRules.ranges) && this.settings.styleRules.ranges.length !== 0) {
          this.settings.styleRules.ranges.forEach((range2) => {
            if (this.rawValue >= range2.min && this.rawValue < range2.max) {
              this._addCSSClass(range2.class);
            } else {
              this._removeCSSClass(range2.class);
            }
          });
        }
        if (!AutoNumericHelper.isUndefinedOrNullOrEmpty(this.settings.styleRules.userDefined) && this.settings.styleRules.userDefined.length !== 0) {
          this.settings.styleRules.userDefined.forEach((userObject) => {
            if (AutoNumericHelper.isFunction(userObject.callback)) {
              if (AutoNumericHelper.isString(userObject.classes)) {
                if (userObject.callback(this.rawValue)) {
                  this._addCSSClass(userObject.classes);
                } else {
                  this._removeCSSClass(userObject.classes);
                }
              } else if (AutoNumericHelper.isArray(userObject.classes)) {
                if (userObject.classes.length === 2) {
                  if (userObject.callback(this.rawValue)) {
                    this._addCSSClass(userObject.classes[0]);
                    this._removeCSSClass(userObject.classes[1]);
                  } else {
                    this._removeCSSClass(userObject.classes[0]);
                    this._addCSSClass(userObject.classes[1]);
                  }
                } else if (userObject.classes.length > 2) {
                  const callbackResult = userObject.callback(this.rawValue);
                  if (AutoNumericHelper.isArray(callbackResult)) {
                    userObject.classes.forEach((userClass, index) => {
                      if (AutoNumericHelper.isInArray(index, callbackResult)) {
                        this._addCSSClass(userClass);
                      } else {
                        this._removeCSSClass(userClass);
                      }
                    });
                  } else if (AutoNumericHelper.isInt(callbackResult)) {
                    userObject.classes.forEach((userClass, index) => {
                      if (index === callbackResult) {
                        this._addCSSClass(userClass);
                      } else {
                        this._removeCSSClass(userClass);
                      }
                    });
                  } else if (AutoNumericHelper.isNull(callbackResult)) {
                    userObject.classes.forEach((userClass) => {
                      this._removeCSSClass(userClass);
                    });
                  } else {
                    AutoNumericHelper.throwError(`The callback result is not an array nor a valid array index, ${typeof callbackResult} given.`);
                  }
                } else {
                  AutoNumericHelper.throwError("The classes attribute is not valid for the `styleRules` option.");
                }
              } else if (AutoNumericHelper.isUndefinedOrNullOrEmpty(userObject.classes)) {
                userObject.callback(this);
              } else {
                AutoNumericHelper.throwError("The callback/classes structure is not valid for the `styleRules` option.");
              }
            } else {
              AutoNumericHelper.warning(`The given \`styleRules\` callback is not a function, ${typeof userObject.callback} given.`, this.settings.showWarnings);
            }
          });
        }
      }
      /**
       * Add the given CSS class to the DOM element.
       *
       * @param {string} cssClassName
       * @private
       */
      _addCSSClass(cssClassName) {
        this.domElement.classList.add(cssClassName);
      }
      /**
       * Remove the given CSS class from the DOM element.
       *
       * @param {string} cssClassName
       * @private
       */
      _removeCSSClass(cssClassName) {
        this.domElement.classList.remove(cssClassName);
      }
      // Those are the public function available on each autoNumeric-managed element
      /**
       * Method that updates the AutoNumeric settings, and immediately format the element accordingly.
       * The options passed as parameter(s) is either one or many objects that each contains some settings, i.e. :
       * {
       *     digitGroupSeparator: ".",
       *     decimalCharacter: ",",
       *     currencySymbol: ' ',
       * }
       * If multiple options are passed, the latter overwrite the previous ones.
       *
       * Note: If the new settings are not validated, or the call to `set()` fails, then the previous valid settings are reverted back to.
       *
       * @example anElement.update({ options }) // Updates the settings
       * @example anElement.update({ options1 }, { options2 }) // Updates the settings with multiple option objects
       * @example anElement.update([{ options1 }, { options2 }]) // Updates the settings with multiple option objects in a single array
       *
       * @param {object|string|array} newOptions
       * @returns {AutoNumeric}
       */
      update(...newOptions) {
        if (Array.isArray(newOptions) && Array.isArray(newOptions[0])) {
          newOptions = newOptions[0];
        }
        const originalSettings = AutoNumericHelper.cloneObject(this.settings);
        const numericString = this.rawValue;
        let optionsToUse = {};
        if (AutoNumericHelper.isUndefinedOrNullOrEmpty(newOptions) || newOptions.length === 0) {
          optionsToUse = null;
        } else if (newOptions.length >= 1) {
          newOptions.forEach((optionObject) => {
            if (this.constructor._isPreDefinedOptionValid(optionObject)) {
              optionObject = this.constructor._getOptionObject(optionObject);
            }
            Object.assign(optionsToUse, optionObject);
          });
        }
        try {
          this._setSettings(optionsToUse, true);
          this._setWritePermissions();
          this._updateEventListeners();
          this.set(numericString);
        } catch (error) {
          this._setSettings(originalSettings, true);
          AutoNumericHelper.throwError(`Unable to update the settings, those are invalid: [${error}]`);
          return this;
        }
        return this;
      }
      /**
       * Return the options object containing all the current autoNumeric settings in effect.
       * You can then directly access each option by using its name : `anElement.getSettings().optionNameAutoCompleted`.
       *
       * @example
       * anElement.getSettings()
       * anElement.getSettings().decimalCharacter // Return the decimalCharacter setting as a string - any valid option name can be used
       *
       * @returns {object}
       */
      getSettings() {
        return this.settings;
      }
      /**
       * Set the given element value, and format it immediately.
       * Additionally, this `set()` method can accept options that will be merged into the current AutoNumeric element, taking precedence over any previous settings.
       *
       * @example anElement.set('12345.67') // Formats the value
       * @example anElement.set(12345.67) // Formats the value
       * @example anElement.set(12345.67, { decimalCharacter : ',' }) // Update the settings and formats the value in one go
       * @example anElement.northAmerican().set('$12,345.67') // Set an already formatted value (this does not _exactly_ respect the currency symbol/negative placements, but only remove all non-numbers characters, according to the ones given in the settings)
       * @example anElement.set(null) // Set the rawValue and element value to `null`
       *
       * @param {number|string|null} newValue The value must be a Number, a numeric string or `null` (if `emptyInputBehavior` is set to `'null'`)
       * @param {object} options A settings object that will override the current settings. Note: the update is done only if the `newValue` is defined.
       * @param {boolean} saveChangeToHistory If set to `true`, then the change is recorded in the history table
       * @returns {AutoNumeric}
       * @throws
       */
      set(newValue, options = null, saveChangeToHistory = true) {
        if (AutoNumericHelper.isUndefined(newValue)) {
          AutoNumericHelper.warning(`You are trying to set an 'undefined' value ; an error could have occurred.`, this.settings.showWarnings);
          return this;
        }
        if (!AutoNumericHelper.isNull(options)) {
          this._setSettings(options, true);
        }
        if (newValue === null && this.settings.emptyInputBehavior !== _AutoNumeric.options.emptyInputBehavior.null) {
          AutoNumericHelper.warning(`You are trying to set the \`null\` value while the \`emptyInputBehavior\` option is set to ${this.settings.emptyInputBehavior}. If you want to be able to set the \`null\` value, you need to change the 'emptyInputBehavior' option to \`'null'\`.`, this.settings.showWarnings);
          return this;
        }
        let value;
        if (newValue === null) {
          this._setElementAndRawValue(null, null, saveChangeToHistory);
          this._saveValueToPersistentStorage();
          return this;
        }
        value = this.constructor._toNumericValue(newValue, this.settings);
        if (isNaN(Number(value))) {
          AutoNumericHelper.warning(`The value you are trying to set results in \`NaN\`. The element value is set to the empty string instead.`, this.settings.showWarnings);
          this.setValue("", saveChangeToHistory);
          return this;
        }
        if (value === "") {
          switch (this.settings.emptyInputBehavior) {
            case _AutoNumeric.options.emptyInputBehavior.zero:
              value = 0;
              break;
            case _AutoNumeric.options.emptyInputBehavior.min:
              value = this.settings.minimumValue;
              break;
            case _AutoNumeric.options.emptyInputBehavior.max:
              value = this.settings.maximumValue;
              break;
            default:
              if (AutoNumericHelper.isNumber(this.settings.emptyInputBehavior)) {
                value = Number(this.settings.emptyInputBehavior);
              }
          }
        }
        if (value !== "") {
          const [minTest, maxTest] = this.constructor._checkIfInRangeWithOverrideOption(value, this.settings);
          if (minTest && maxTest && this.settings.valuesToStrings && this._checkValuesToStrings(value)) {
            this._setElementAndRawValue(this.settings.valuesToStrings[value], value, saveChangeToHistory);
            this._saveValueToPersistentStorage();
            return this;
          }
          const isZero = AutoNumericHelper.isZeroOrHasNoValue(value);
          if (isZero) {
            value = "0";
          }
          if (minTest && maxTest) {
            let forcedRawValue = this.constructor._roundRawValue(value, this.settings);
            forcedRawValue = this._trimLeadingAndTrailingZeros(forcedRawValue.replace(this.settings.decimalCharacter, "."));
            value = this._getRawValueToFormat(value);
            if (this.isFocused) {
              value = this.constructor._roundFormattedValueShownOnFocus(value, this.settings);
            } else {
              if (this.settings.divisorWhenUnfocused) {
                value = value / this.settings.divisorWhenUnfocused;
                value = value.toString();
              }
              value = this.constructor._roundFormattedValueShownOnBlur(value, this.settings);
            }
            value = this.constructor._modifyNegativeSignAndDecimalCharacterForFormattedValue(value, this.settings);
            value = this.constructor._addGroupSeparators(value, this.settings, this.isFocused, this.rawValue, forcedRawValue);
            if (!this.isFocused && this.settings.symbolWhenUnfocused) {
              value = `${value}${this.settings.symbolWhenUnfocused}`;
            }
            if (this.settings.decimalPlacesShownOnFocus || this.settings.divisorWhenUnfocused) {
              this._saveValueToPersistentStorage();
            }
            this._setElementAndRawValue(value, forcedRawValue, saveChangeToHistory);
            this._setValidOrInvalidState(forcedRawValue);
            return this;
          } else {
            this._triggerRangeEvents(minTest, maxTest);
            AutoNumericHelper.throwError(`The value [${value}] being set falls outside of the minimumValue [${this.settings.minimumValue}] and maximumValue [${this.settings.maximumValue}] range set for this element`);
            this._removeValueFromPersistentStorage();
            this.setValue("", saveChangeToHistory);
            return this;
          }
        } else {
          let result2;
          if (this.settings.emptyInputBehavior === _AutoNumeric.options.emptyInputBehavior.always) {
            result2 = this.settings.currencySymbol;
          } else {
            result2 = "";
          }
          this._setElementAndRawValue(result2, "", saveChangeToHistory);
          return this;
        }
      }
      /**
       * Set the given value directly as the DOM element value, without formatting it beforehand.
       * You can also set the value and update the setting in one go (the value will again not be formatted immediately).
       *
       * @param {number|string} value
       * @param {object} options
       * @returns {AutoNumeric}
       * @throws
       */
      setUnformatted(value, options = null) {
        if (value === null || AutoNumericHelper.isUndefined(value)) {
          return this;
        }
        if (!AutoNumericHelper.isNull(options)) {
          this._setSettings(options, true);
        }
        const strippedValue = this.constructor._removeBrackets(value, this.settings);
        const normalizedValue = this.constructor._stripAllNonNumberCharacters(strippedValue, this.settings, true, this.isFocused);
        if (!AutoNumericHelper.isNumber(normalizedValue)) {
          AutoNumericHelper.throwError(`The value is not a valid one, it's not a numeric string nor a recognized currency.`);
        }
        if (this.constructor._isWithinRangeWithOverrideOption(normalizedValue, this.settings)) {
          this.setValue(value);
        } else {
          AutoNumericHelper.throwError(`The value is out of the range limits [${this.settings.minimumValue}, ${this.settings.maximumValue}].`);
        }
        return this;
      }
      /**
       * Set the given value directly as the DOM element value, without formatting it beforehand, and without checking its validity.
       * This also updates the `rawValue` with the given `newValue`, without checking it too ; if it's not formatted like a number recognized by Javascript, this *will* likely make other AutoNumeric methods fail.
       *
       * @param {string|number|null} newValue The new value to set on the element
       * @param {boolean} saveChangeToHistory If set to `true`, then the change is recorded in the history array, otherwise it is not
       * @returns {AutoNumeric}
       */
      setValue(newValue, saveChangeToHistory = true) {
        this._setElementAndRawValue(newValue, saveChangeToHistory);
        return this;
      }
      /**
       * Save the raw value inside the AutoNumeric object.
       *
       * @param {number|string|null} rawValue The numeric value as understood by Javascript like a `Number`
       * @param {boolean} saveChangeToHistory If set to `true`, then the change is recorded in the history array, otherwise it is not
       * @private
       */
      _setRawValue(rawValue, saveChangeToHistory = true) {
        if (this.rawValue !== rawValue) {
          const oldRawValue = this.rawValue;
          this.rawValue = rawValue;
          if (!AutoNumericHelper.isNull(this.settings.rawValueDivisor) && this.settings.rawValueDivisor !== 0 && // Only divide if the `rawValueDivisor` option is set
          rawValue !== "" && rawValue !== null && // Do not modify the `rawValue` if it's an empty string or null
          this._isUserManuallyEditingTheValue()) {
            this.rawValue /= this.settings.rawValueDivisor;
          }
          this._triggerEvent(_AutoNumeric.events.rawValueModified, this.domElement, {
            oldRawValue,
            newRawValue: this.rawValue,
            isPristine: this.isPristine(true),
            error: null,
            aNElement: this
          });
          this._parseStyleRules();
          if (saveChangeToHistory) {
            window.requestAnimationFrame(() => this._historyTableAdd());
          }
        }
      }
      /**
       * Set the given value on the DOM element, without affecting the `rawValue`.
       * This sends an 'autoNumeric:formatted' event if the new value is different from the old one.
       *
       * @param {number|string} newElementValue
       * @param {boolean} sendFormattedEvent If set to `true`, then the `AutoNumeric.events.formatted` event is sent if the value has changed
       * @returns {AutoNumeric}
       * @private
       */
      _setElementValue(newElementValue, sendFormattedEvent = true) {
        const oldElementValue = AutoNumericHelper.getElementValue(this.domElement);
        if (newElementValue !== oldElementValue) {
          this.internalModification = true;
          AutoNumericHelper.setElementValue(this.domElement, newElementValue);
          this.internalModification = false;
          if (sendFormattedEvent) {
            this._triggerEvent(_AutoNumeric.events.formatted, this.domElement, {
              oldValue: oldElementValue,
              newValue: newElementValue,
              oldRawValue: this.rawValue,
              newRawValue: this.rawValue,
              isPristine: this.isPristine(false),
              error: null,
              aNElement: this
            });
          }
        }
        return this;
      }
      /**
       * Set the given value on the DOM element, and the raw value on `this.rawValue`, if both are given.
       * If only one value is given, then both the DOM element value and the raw value are set with that value.
       * The third argument `saveChangeToHistory` defines if the change should be recorded in the history array.
       * Note: if the second argument `rawValue` is a boolean, we consider that is really is the `saveChangeToHistory` argument.
       *
       * @param {number|string|null} newElementValue
       * @param {number|string|null|boolean} rawValue
       * @param {boolean} saveChangeToHistory
       * @returns {AutoNumeric}
       * @private
       */
      _setElementAndRawValue(newElementValue, rawValue = null, saveChangeToHistory = true) {
        if (AutoNumericHelper.isNull(rawValue)) {
          rawValue = newElementValue;
        } else if (AutoNumericHelper.isBoolean(rawValue)) {
          saveChangeToHistory = rawValue;
          rawValue = newElementValue;
        }
        this._setElementValue(newElementValue);
        this._setRawValue(rawValue, saveChangeToHistory);
        return this;
      }
      /**
       * Return the multiplied raw value with the `rawValueDivisor`.
       * This is used to display different values between the raw and formatted values.
       *
       * @param {number|string|null} rawValue The numeric value as understood by Javascript like a `Number`
       * @returns {number|string|null}
       * @private
       */
      _getRawValueToFormat(rawValue) {
        let rawValueForTheElementValue;
        if (!AutoNumericHelper.isNull(this.settings.rawValueDivisor) && this.settings.rawValueDivisor !== 0 && // Only multiply if the `rawValueDivisor` option is set
        rawValue !== "" && rawValue !== null) {
          rawValueForTheElementValue = rawValue * this.settings.rawValueDivisor;
        } else {
          rawValueForTheElementValue = rawValue;
        }
        return rawValueForTheElementValue;
      }
      /**
       * Check if the given value has a corresponding key in the `valuesToStrings` option object.
       *
       * @param {number|string} value
       * @returns {boolean} Returns `true` if such a key is found.
       * @private
       */
      _checkValuesToStrings(value) {
        return this.constructor._checkValuesToStringsArray(value, this.valuesToStringsKeys);
      }
      /**
       * Check if the given value has a corresponding key in the `stringsArray` array.
       *
       * @param {number|string} key
       * @param {array} stringsArray Array where the `key` is checked against its keys
       * @returns {boolean} Returns `true` if such a key is found.
       * @private
       */
      static _checkValuesToStringsArray(key, stringsArray) {
        return AutoNumericHelper.isInArray(String(key), stringsArray);
      }
      /**
       * Static helper for checking if the given `key` is found in the settings' `valuesToStrings` option object.
       *
       * @param {number|string} key
       * @param {object} settings
       * @returns {boolean}
       * @private
       */
      static _checkValuesToStringsSettings(key, settings) {
        return this._checkValuesToStringsArray(key, Object.keys(settings.valuesToStrings));
      }
      /**
       * Static helper for checking if the given `value` is found in the settings' `valuesToStrings` option object.
       *
       * @param {number|string} value
       * @param {object} settings
       * @returns {boolean}
       * @private
       */
      static _checkStringsToValuesSettings(value, settings) {
        return this._checkValuesToStringsArray(value, Object.values(settings.valuesToStrings));
      }
      /**
       * Return `true` if the user is currently modifying the element value manually.
       *
       * @returns {boolean}
       * @private
       */
      _isUserManuallyEditingTheValue() {
        return this.isFocused && this.isEditing || this.isDropEvent;
      }
      /**
       * Execute the given callback function using the given result as its first parameter, and the AutoNumeric object as its second.
       *
       * @param {number|string|Array|null} result
       * @param {function|null} callback If a callback is passed, then the result is passed to it as its first argument, and the AutoNumeric object has its second
       * @private
       */
      _executeCallback(result2, callback) {
        if (!AutoNumericHelper.isNull(callback) && AutoNumericHelper.isFunction(callback)) {
          callback(result2, this);
        }
      }
      /**
       * Trigger the given event on the given element with the given detail.
       * This takes into account the `eventBubbles` and `eventIsCancelable` options.
       *
       * @param {string} eventName
       * @param {HTMLElement|HTMLDocument|EventTarget} element
       * @param {object} detail
       * @private
       */
      _triggerEvent(eventName, element = document, detail = null) {
        AutoNumericHelper.triggerEvent(eventName, element, detail, this.settings.eventBubbles, this.settings.eventIsCancelable);
      }
      /**
       * Alias of the `getNumericString()` function.
       * Developers should use one of the more explicit function names to get what they want :
       * - a numeric string : `getNumericString()`
       * - a formatted string : `getFormatted()`
       * - a number : `getNumber()`, or
       * - a localized numeric string : `getLocalized()`
       *
       * @usage anElement.get();
       *
       * @param {function|null} callback If a callback is passed, then the result is passed to it as its first argument, and the AutoNumeric object has its second
       *
       * @deprecated
       * @returns {string|null}
       */
      get(callback = null) {
        return this.getNumericString(callback);
      }
      /**
       * Return the unformatted value as a string.
       * This can also return `null` if `rawValue` is null.
       *
       * @usage anElement.getNumericString();
       *
       * @param {function|null} callback If a callback is passed, then the result is passed to it as its first argument, and the AutoNumeric object has its second
       *
       * @returns {string|null}
       */
      getNumericString(callback = null) {
        let result2;
        if (AutoNumericHelper.isNull(this.rawValue)) {
          result2 = null;
        } else {
          result2 = AutoNumericHelper.trimPaddedZerosFromDecimalPlaces(this.rawValue);
        }
        this._executeCallback(result2, callback);
        return result2;
      }
      /**
       * Return the current formatted value of the AutoNumeric element as a string
       *
       * @usage anElement.getFormatted()
       *
       * @param {function|null} callback If a callback is passed, then the result is passed to it as its first argument, and the AutoNumeric object has its second
       *
       * @returns {string}
       */
      getFormatted(callback = null) {
        if (!("value" in this.domElement || "textContent" in this.domElement)) {
          AutoNumericHelper.throwError("Unable to get the formatted string from the element.");
        }
        const result2 = AutoNumericHelper.getElementValue(this.domElement);
        this._executeCallback(result2, callback);
        return result2;
      }
      /**
       * Return the element unformatted value as a real Javascript number.
       * Warning: This can lead to precision problems with big numbers that should be stored as strings.
       *
       * @usage anElement.getNumber()
       *
       * @param {function|null} callback If a callback is passed, then the result is passed to it as its first argument, and the AutoNumeric object has its second
       *
       * @returns {number|null}
       */
      getNumber(callback = null) {
        let result2;
        if (this.rawValue === null) {
          result2 = null;
        } else {
          result2 = this.constructor._toLocale(this.getNumericString(), "number", this.settings);
        }
        this._executeCallback(result2, callback);
        return result2;
      }
      /**
       * Returns the unformatted value, but following the `outputFormat` setting, which means the output can either be :
       * - a string (that could or could not represent a number (i.e. "12345,67-")), or
       * - a plain number (if the setting 'number' is used).
       *
       * By default, the returned values are an ISO numeric string "1234.56" or "-1234.56" where the decimal character is a period.
       * Check the "outputFormat" option definition for more details.
       *
       * @usage anElement.getLocalized();
       *
       * @param {null|string|function} forcedOutputFormat If set to something different from `null`, then this is used as an overriding outputFormat option
       * @param {function|null} callback If a callback is passed, then the result is passed to it as its first argument, and the AutoNumeric object has its second
       *
       * @returns {*}
       */
      getLocalized(forcedOutputFormat = null, callback = null) {
        if (AutoNumericHelper.isFunction(forcedOutputFormat) && AutoNumericHelper.isNull(callback)) {
          callback = forcedOutputFormat;
          forcedOutputFormat = null;
        }
        let value;
        if (AutoNumericHelper.isEmptyString(this.rawValue)) {
          value = "";
        } else {
          value = "" + Number(this.rawValue);
        }
        if (value !== "" && Number(value) === 0 && this.settings.leadingZero !== _AutoNumeric.options.leadingZero.keep) {
          value = "0";
        }
        let outputFormatToUse;
        if (AutoNumericHelper.isNull(forcedOutputFormat)) {
          outputFormatToUse = this.settings.outputFormat;
        } else {
          outputFormatToUse = forcedOutputFormat;
        }
        const result2 = this.constructor._toLocale(value, outputFormatToUse, this.settings);
        this._executeCallback(result2, callback);
        return result2;
      }
      /**
       * Force the element to reformat its value again (just in case the formatting has been lost).
       * This can be used right after a form submission for instance (after a previous call to `unformat`).
       *
       * @example anElement.reformat()
       *
       * @returns {AutoNumeric}
       */
      reformat() {
        this.set(this.rawValue);
        return this;
      }
      /**
       * Remove the formatting and keep only the raw unformatted value in the element (as a numericString)
       * Note: this is loosely based on the previous 'unSet()' function
       *
       * By default, values are returned as ISO numeric strings (i.e. "1234.56" or "-1234.56"), where the decimal character is a period.
       * @example anElement.unformat()
       *
       * @returns {AutoNumeric}
       */
      unformat() {
        this._setElementValue(this.getNumericString());
        return this;
      }
      /**
       * Remove the formatting and keep only the localized unformatted value in the element, with the option to override the default outputFormat if needed
       *
       * Locale formats are supported "1234.56-" or "1234,56" or "-1234,56 or "1234,56-", or even plain numbers.
       * Take a look at the `outputFormat` option definition in the default settings for more details.
       *
       * @param {null|string} forcedOutputFormat If set to something different from `null`, then this is used as an overriding outputFormat option
       * @returns {AutoNumeric}
       */
      unformatLocalized(forcedOutputFormat = null) {
        this._setElementValue(this.getLocalized(forcedOutputFormat));
        return this;
      }
      /**
       * Return `true` if the current value is the same as when the element got initialized.
       * Note: By default, this returns `true` if the raw unformatted value is still the same even if the formatted one has changed (due to a configuration update for instance).
       * In order to test if the formatted value is the same (which means neither the raw value nor the settings have been changed), then you must pass `false` as its argument.
       *
       * @param {boolean} checkOnlyRawValue If set to `true`, the pristine value is done on the raw unformatted value, not the formatted one.  If set to `false`, this also checks that the formatted value hasn't changed.
       * @returns {boolean}
       */
      isPristine(checkOnlyRawValue = true) {
        let result2;
        if (checkOnlyRawValue) {
          result2 = this.initialValue === this.getNumericString();
        } else {
          result2 = this.initialValueHtmlAttribute === this.getFormatted();
        }
        return result2;
      }
      /**
       * Select the formatted element content, based on the `selectNumberOnly` option
       *
       * @returns {AutoNumeric}
       */
      select() {
        if (this.settings.selectNumberOnly) {
          this.selectNumber();
        } else {
          this._defaultSelectAll();
        }
        return this;
      }
      /**
       * Select the whole element content (including the currency symbol).
       * @private
       */
      _defaultSelectAll() {
        AutoNumericHelper.setElementSelection(this.domElement, 0, AutoNumericHelper.getElementValue(this.domElement).length);
      }
      /**
       * Select only the numbers in the formatted element content, leaving out the currency symbol, whatever the value of the `selectNumberOnly` option
       *
       * @returns {AutoNumeric}
       */
      selectNumber() {
        const unformattedValue = AutoNumericHelper.getElementValue(this.domElement);
        const valueLen = unformattedValue.length;
        const currencySymbolSize = this.settings.currencySymbol.length;
        const currencySymbolPlacement = this.settings.currencySymbolPlacement;
        const negLen = !AutoNumericHelper.isNegative(unformattedValue, this.settings.negativeSignCharacter) ? 0 : 1;
        const suffixTextLen = this.settings.suffixText.length;
        let start2;
        if (currencySymbolPlacement === _AutoNumeric.options.currencySymbolPlacement.suffix) {
          start2 = 0;
        } else if (this.settings.negativePositiveSignPlacement === _AutoNumeric.options.negativePositiveSignPlacement.left && negLen === 1 && currencySymbolSize > 0) {
          start2 = currencySymbolSize + 1;
        } else {
          start2 = currencySymbolSize;
        }
        let end2;
        if (currencySymbolPlacement === _AutoNumeric.options.currencySymbolPlacement.prefix) {
          end2 = valueLen - suffixTextLen;
        } else {
          switch (this.settings.negativePositiveSignPlacement) {
            case _AutoNumeric.options.negativePositiveSignPlacement.left:
              end2 = valueLen - (suffixTextLen + currencySymbolSize);
              break;
            case _AutoNumeric.options.negativePositiveSignPlacement.right:
              if (currencySymbolSize > 0) {
                end2 = valueLen - (currencySymbolSize + negLen + suffixTextLen);
              } else {
                end2 = valueLen - (currencySymbolSize + suffixTextLen);
              }
              break;
            default:
              end2 = valueLen - (currencySymbolSize + suffixTextLen);
          }
        }
        AutoNumericHelper.setElementSelection(this.domElement, start2, end2);
        return this;
      }
      /**
       * Select only the integer part in the formatted element content, whatever the value of `selectNumberOnly`
       *
       * @returns {AutoNumeric}
       */
      selectInteger() {
        let start2 = 0;
        const isPositive = this.rawValue >= 0;
        if (this.settings.currencySymbolPlacement === _AutoNumeric.options.currencySymbolPlacement.prefix || this.settings.currencySymbolPlacement === _AutoNumeric.options.currencySymbolPlacement.suffix && (this.settings.negativePositiveSignPlacement === _AutoNumeric.options.negativePositiveSignPlacement.prefix || this.settings.negativePositiveSignPlacement === _AutoNumeric.options.negativePositiveSignPlacement.none)) {
          if (this.settings.showPositiveSign && isPositive || // This only exclude the positive sign from being selected
          !isPositive && this.settings.currencySymbolPlacement === _AutoNumeric.options.currencySymbolPlacement.prefix && this.settings.negativePositiveSignPlacement === _AutoNumeric.options.negativePositiveSignPlacement.left) {
            start2 = start2 + 1;
          }
        }
        if (this.settings.currencySymbolPlacement === _AutoNumeric.options.currencySymbolPlacement.prefix) {
          start2 = start2 + this.settings.currencySymbol.length;
        }
        const elementValue = AutoNumericHelper.getElementValue(this.domElement);
        let end2 = elementValue.indexOf(this.settings.decimalCharacter);
        if (end2 === -1) {
          if (this.settings.currencySymbolPlacement === _AutoNumeric.options.currencySymbolPlacement.suffix) {
            end2 = elementValue.length - this.settings.currencySymbol.length;
          } else {
            end2 = elementValue.length;
          }
          if (!isPositive && (this.settings.negativePositiveSignPlacement === _AutoNumeric.options.negativePositiveSignPlacement.suffix || this.settings.currencySymbolPlacement === _AutoNumeric.options.currencySymbolPlacement.suffix)) {
            end2 = end2 - 1;
          }
          end2 = end2 - this.settings.suffixText.length;
        }
        AutoNumericHelper.setElementSelection(this.domElement, start2, end2);
        return this;
      }
      /**
       * Select only the decimal part in the formatted element content, whatever the value of `selectNumberOnly`
       * Multiple cases are possible :
       * +1.234,57suffixText
       *
       *  +1.234,57suffixText
       * + 1.234,57suffixText
       *  1.234,57+suffixText
       *
       * 1.234,57+ suffixText
       * 1.234,57 +suffixText
       * +1.234,57 suffixText
       *
       * @returns {AutoNumeric}
       */
      selectDecimal() {
        let start2 = AutoNumericHelper.getElementValue(this.domElement).indexOf(this.settings.decimalCharacter);
        let end2;
        if (start2 === -1) {
          start2 = 0;
          end2 = 0;
        } else {
          start2 = start2 + 1;
          let decimalCount;
          if (this.isFocused) {
            decimalCount = this.settings.decimalPlacesShownOnFocus;
          } else {
            decimalCount = this.settings.decimalPlacesShownOnBlur;
          }
          end2 = start2 + Number(decimalCount);
        }
        AutoNumericHelper.setElementSelection(this.domElement, start2, end2);
        return this;
      }
      /**
       * Return the DOM element reference of the autoNumeric-managed element
       *
       * @returns {HTMLElement|HTMLInputElement}
       */
      node() {
        return this.domElement;
      }
      /**
       * Return the DOM element reference of the parent node of the autoNumeric-managed element
       *
       * @returns {HTMLElement|HTMLInputElement|Node}
       */
      parent() {
        return this.domElement.parentNode;
      }
      /**
       * Detach the current AutoNumeric element from the shared local 'init' list.
       * This means any changes made on that local shared list will not be transmitted to that element anymore.
       * Note : The user can provide another AutoNumeric element, and detach this one instead of the current one.
       *
       * @param {AutoNumeric} otherAnElement
       * @returns {AutoNumeric}
       */
      detach(otherAnElement = null) {
        let domElementToDetach;
        if (!AutoNumericHelper.isNull(otherAnElement)) {
          domElementToDetach = otherAnElement.node();
        } else {
          domElementToDetach = this.domElement;
        }
        this._removeFromLocalList(domElementToDetach);
        return this;
      }
      /**
       * Attach the given AutoNumeric element to the shared local 'init' list.
       * When doing that, by default the DOM content is left untouched.
       * The user can force a reformat with the new shared list options by passing a second argument to `true`.
       *
       * @param {AutoNumeric} otherAnElement
       * @param {boolean} reFormat
       * @returns {AutoNumeric}
       */
      attach(otherAnElement, reFormat = true) {
        this._addToLocalList(otherAnElement.node());
        if (reFormat) {
          otherAnElement.update(this.settings);
        }
        return this;
      }
      /**
       * Format and return the given value, or set the formatted value into the given DOM element if one is passed as an argument.
       * By default, this use the current element settings.
       * The user can override any option of its choosing by passing an option object.
       *
       * @param {number|HTMLElement|HTMLInputElement} valueOrElement
       * @param {null|object} optionOverride
       * @returns {string|null}
       */
      formatOther(valueOrElement, optionOverride = null) {
        return this._formatOrUnformatOther(true, valueOrElement, optionOverride);
      }
      /**
           * Unformat and return the raw numeric string corresponding to the given value, or directly set the unformatted value into the given DOM element if one is passed as an argument.
           * By default, this use the current element settings.
           * The user can override any option of its choosing by passing an option object.
      
           * @param {string|HTMLElement|HTMLInputElement} stringOrElement
           * @param {null|object} optionOverride
           * @returns {string|null}
           */
      unformatOther(stringOrElement, optionOverride = null) {
        return this._formatOrUnformatOther(false, stringOrElement, optionOverride);
      }
      /**
       * Method that either format or unformat the value of another element.
       *
       * - Format and return the given value, or set the formatted value into the given DOM element if one is passed as an argument.
       * - Unformat and return the raw numeric string corresponding to the given value, or directly set the unformatted value into the given DOM element if one is passed as an argument.
       *
       * By default, this use the current element settings.
       * The user can override any option of its choosing by passing an option object.
       *
       * @param {boolean} isFormatting If set to `true`, then the method formats, otherwise if set to `false`, it unformats
       * @param {number|string|HTMLElement|HTMLInputElement} valueOrStringOrElement
       * @param {null|object} optionOverride
       * @returns {string|null}
       * @private
       */
      _formatOrUnformatOther(isFormatting, valueOrStringOrElement, optionOverride = null) {
        let settingsToUse;
        if (!AutoNumericHelper.isNull(optionOverride)) {
          settingsToUse = this._cloneAndMergeSettings(optionOverride);
        } else {
          settingsToUse = this.settings;
        }
        let result2;
        if (AutoNumericHelper.isElement(valueOrStringOrElement)) {
          const elementValue = AutoNumericHelper.getElementValue(valueOrStringOrElement);
          if (isFormatting) {
            result2 = _AutoNumeric.format(elementValue, settingsToUse);
          } else {
            result2 = _AutoNumeric.unformat(elementValue, settingsToUse);
          }
          AutoNumericHelper.setElementValue(valueOrStringOrElement, result2);
          return null;
        }
        if (isFormatting) {
          result2 = _AutoNumeric.format(valueOrStringOrElement, settingsToUse);
        } else {
          result2 = _AutoNumeric.unformat(valueOrStringOrElement, settingsToUse);
        }
        return result2;
      }
      /**
       * Use the current AutoNumeric element settings to initialize the DOM element(s) given as a parameter.
       * Doing so will *link* the AutoNumeric elements together since they will share the same local AutoNumeric element list.
       * (cf. prototype pattern : https://en.wikipedia.org/wiki/Prototype_pattern)
       *
       * You can `init` either a single DOM element (in that case an AutoNumeric object will be returned), or an array of DOM elements or a string that will be used as a CSS selector. In the latter cases, an array of AutoNumeric objects will then be returned (or an empty array if nothing gets selected by the CSS selector).
       *
       * Use case : Once you have an AutoNumeric element already setup correctly with the right options, you can use it as many times you want to initialize as many other DOM elements as needed.
       * Note : this works only on elements that can be managed by autoNumeric.
       *
       * @param {HTMLElement|HTMLInputElement|Array<HTMLElement|HTMLInputElement>|string} domElementOrArrayOrString
       * @param {boolean} attached If set to `false`, then the newly generated AutoNumeric element will not share the same local element list
       * @returns {AutoNumeric|[AutoNumeric]}
       */
      init(domElementOrArrayOrString, attached = true) {
        let returnASingleAutoNumericObject = false;
        let domElementsArray = [];
        if (AutoNumericHelper.isString(domElementOrArrayOrString)) {
          domElementsArray = [...document.querySelectorAll(domElementOrArrayOrString)];
        } else if (AutoNumericHelper.isElement(domElementOrArrayOrString)) {
          domElementsArray.push(domElementOrArrayOrString);
          returnASingleAutoNumericObject = true;
        } else if (AutoNumericHelper.isArray(domElementOrArrayOrString)) {
          domElementsArray = domElementOrArrayOrString;
        } else {
          AutoNumericHelper.throwError(`The given parameters to the 'init' function are invalid.`);
        }
        if (domElementsArray.length === 0) {
          AutoNumericHelper.warning(`No valid DOM elements were given hence no AutoNumeric object were instantiated.`, true);
          return [];
        }
        const currentLocalList = this._getLocalList();
        const autoNumericObjectsArray = [];
        domElementsArray.forEach((domElement) => {
          const originalCreateLocalListSetting = this.settings.createLocalList;
          if (attached) {
            this.settings.createLocalList = false;
          }
          const newAutoNumericElement = new _AutoNumeric(domElement, AutoNumericHelper.getElementValue(domElement), this.settings);
          if (attached) {
            newAutoNumericElement._setLocalList(currentLocalList);
            this._addToLocalList(domElement, newAutoNumericElement);
            this.settings.createLocalList = originalCreateLocalListSetting;
          }
          autoNumericObjectsArray.push(newAutoNumericElement);
        });
        if (returnASingleAutoNumericObject) {
          return autoNumericObjectsArray[0];
        }
        return autoNumericObjectsArray;
      }
      /**
       * Reset the element value either to the empty string '', or the currency sign, depending on the `emptyInputBehavior` option value.
       * If you set the `forceClearAll` argument to `true`, then the `emptyInputBehavior` option is overridden and the whole input is clear, including any currency sign.
       *
       * @param {boolean} forceClearAll
       * @returns {AutoNumeric}
       */
      clear(forceClearAll = false) {
        if (forceClearAll) {
          const temporaryForcedOptions = {
            emptyInputBehavior: _AutoNumeric.options.emptyInputBehavior.focus
          };
          this.set("", temporaryForcedOptions);
        } else {
          this.set("");
        }
        return this;
      }
      /**
       * Remove the autoNumeric data and event listeners from the element, but keep the element content intact.
       * This also clears the value from sessionStorage (or cookie, depending on browser supports).
       * Note: this does not remove the formatting.
       *
       * @example anElement.remove()
       */
      remove() {
        this._removeValueFromPersistentStorage();
        this._removeEventListeners();
        this._removeWatcher();
        this._removeFromLocalList(this.domElement);
        this.constructor._removeFromGlobalList(this);
      }
      /**
       * Remove the autoNumeric data and event listeners from the element, and reset its value to the empty string ''.
       * This also clears the value from sessionStorage (or cookie, depending on browser supports).
       *
       * @example anElement.wipe()
       */
      wipe() {
        this._setElementValue("", false);
        this.remove();
      }
      /**
       * Remove the autoNumeric data and event listeners from the element, and delete the DOM element altogether
       */
      nuke() {
        this.remove();
        this.domElement.parentNode.removeChild(this.domElement);
      }
      // Special functions that really work on the parent <form> element, instead of the <input> element itself
      /**
       * Return a reference to the parent <form> element if it exists, otherwise return `null`.
       * If the parent form element as already been found, this directly return a reference to it.
       * However, you can force AutoNumeric to search again for its reference by passing `true` as a parameter to this method.
       * This method updates the `this.parentForm` attribute.
       *
       * In either case, whenever a new parent form is set for the current AutoNumeric element, we make sure to update the anCount and anFormHandler attributes on both the old form and the new one (for instance in case the user moved the input elements with `appendChild()` since AutoNumeric cannot not detect that).
       *
       * @param {boolean} forceSearch If set to `true`, the parent form is searched again, even if `this.parentForm` is already set.
       *
       * @returns {HTMLFormElement|null}
       */
      form(forceSearch = false) {
        if (forceSearch || AutoNumericHelper.isUndefinedOrNullOrEmpty(this.parentForm)) {
          const newParentForm = this._getParentForm();
          if (!AutoNumericHelper.isNull(newParentForm) && newParentForm !== this.parentForm) {
            const oldANChildren = this._getFormAutoNumericChildren(this.parentForm);
            this.parentForm.dataset.anCount = oldANChildren.length;
            if (this._hasFormHandlerFunction(newParentForm)) {
              this._incrementParentFormCounter(newParentForm);
            } else {
              this._storeFormHandlerFunction(newParentForm);
              this._initializeFormCounterToOne(newParentForm);
            }
          }
          this.parentForm = newParentForm;
        }
        return this.parentForm;
      }
      /**
       * Returns an array of the AutoNumeric-managed elements for the given form element is passed, otherwise for the current `this.parentForm` element.
       * This search for <input> elements, as well as contenteditable non-input tag ones. This also search for elements outside the `form` elements.
       *
       * @param {HTMLFormElement|null} formElement
       *
       * @returns {Array.<HTMLInputElement>}
       * @private
       */
      _getFormAutoNumericChildren(formElement) {
        const inputElementsList = [...formElement.elements];
        const nonInputContentEditableElementsList = this._getContenteditableElements(formElement);
        const elementsList = AutoNumericHelper.arrayUnique(inputElementsList, nonInputContentEditableElementsList);
        return elementsList.filter((element) => this.constructor.isManagedByAutoNumeric(element));
      }
      /**
       * Returns an array of the non-input contenteditable elements linked to the given form element.
       * Two types of elements are possible, either located inside the form element, or outside.
       * For the outside elements, this only works if the form element has a defined id and that id is referenced on the non-input element as the `form` attribute.
       * If no elements can be found, then an empty array is returned.
       *
       * @param {HTMLFormElement|null} formElement
       *
       * @returns {Array.<HTMLInputElement>}
       * @private
       */
      _getContenteditableElements(formElement) {
        if (AutoNumericHelper.isUndefinedOrNullOrEmpty(formElement) || !formElement.hasAttribute("id")) {
          return [];
        }
        const elementsInside = [...formElement.querySelectorAll("[contenteditable=true]")];
        const elementsOutside = [...document.querySelectorAll(`*:not(input)[form=${formElement.getAttribute("id")}][contenteditable=true]`)];
        return AutoNumericHelper.arrayUnique(elementsInside, elementsOutside);
      }
      /**
       * Returns a reference to the parent <form> element if it exists, otherwise return `null`.
       *
       * @returns {HTMLFormElement|null}
       * @private
       */
      _getParentForm() {
        if (!AutoNumericHelper.isUndefined(this.domElement.form)) return this.domElement.form;
        if (this.domElement.tagName.toLowerCase() === "body") {
          return null;
        }
        let node = this.domElement;
        let tagName;
        do {
          node = node.parentNode;
          if (AutoNumericHelper.isNull(node)) {
            return null;
          }
          if (node.tagName) {
            tagName = node.tagName.toLowerCase();
          } else {
            tagName = "";
          }
          if (tagName === "body") {
            break;
          }
        } while (tagName !== "form");
        if (tagName === "form") {
          return node;
        } else {
          return null;
        }
      }
      /**
       * Return a string in standard URL-encoded notation with the form input values being unformatted.
       * This string can be used as a query for instance.
       *
       * @returns {string}
       */
      formNumericString() {
        return this.constructor._serializeNumericString(this.form(), this.settings.serializeSpaces);
      }
      /**
       * Return a string in standard URL-encoded notation with the form input values being formatted.
       *
       * @returns {string}
       */
      formFormatted() {
        return this.constructor._serializeFormatted(this.form(), this.settings.serializeSpaces);
      }
      /**
       * Return a string in standard URL-encoded notation with the form input values, with localized values.
       * The default output format can be overridden by passing the option as a parameter.
       *
       * @param {null|string} forcedOutputFormat If set to something different from `null`, then this is used as an overriding outputFormat option
       * @returns {string}
       */
      formLocalized(forcedOutputFormat = null) {
        let outputFormatToUse;
        if (AutoNumericHelper.isNull(forcedOutputFormat)) {
          outputFormatToUse = this.settings.outputFormat;
        } else {
          outputFormatToUse = forcedOutputFormat;
        }
        return this.constructor._serializeLocalized(this.form(), this.settings.serializeSpaces, outputFormatToUse);
      }
      /**
       * Return an array containing an object for each form <input> element.
       * Those objects are of the following structure `{ name: foo, value: '42' }`, where the `name` is the DOM element name, and the `value` is an unformatted numeric string.
       *
       * @returns {Array}
       */
      formArrayNumericString() {
        return this.constructor._serializeNumericStringArray(this.form(), this.settings.serializeSpaces);
      }
      /**
       * Return an array containing an object for each form <input> element.
       * Those objects are of the following structure `{ name: foo, value: '42' }`, where the `name` is the DOM element name, and the `value` is the formatted string.
       *
       * @returns {Array}
       */
      formArrayFormatted() {
        return this.constructor._serializeFormattedArray(this.form(), this.settings.serializeSpaces);
      }
      /**
       * Return an array containing an object for each form <input> element.
       * Those objects are of the following structure `{ name: foo, value: '42' }`, where the `name` is the DOM element name, and the `value` is the localized numeric string.
       *
       * @param {null|string} forcedOutputFormat If set to something different from `null`, then this is used as an overriding outputFormat option
       * @returns {Array}
       */
      formArrayLocalized(forcedOutputFormat = null) {
        let outputFormatToUse;
        if (AutoNumericHelper.isNull(forcedOutputFormat)) {
          outputFormatToUse = this.settings.outputFormat;
        } else {
          outputFormatToUse = forcedOutputFormat;
        }
        return this.constructor._serializeLocalizedArray(this.form(), this.settings.serializeSpaces, outputFormatToUse);
      }
      /**
       * Return a JSON string containing an object representing the form input values.
       * This is based on the result of the `formArrayNumericString()` function.
       *
       * @returns {string}
       */
      formJsonNumericString() {
        return JSON.stringify(this.formArrayNumericString());
      }
      /**
       * Return a JSON string containing an object representing the form input values.
       * This is based on the result of the `formArrayFormatted()` function.
       *
       * @returns {string}
       */
      formJsonFormatted() {
        return JSON.stringify(this.formArrayFormatted());
      }
      /**
       * Return a JSON string containing an object representing the form input values.
       * This is based on the result of the `formArrayLocalized()` function.
       *
       * @param {null|string} forcedOutputFormat If set to something different from `null`, then this is used as an overriding outputFormat option
       * @returns {string}
       */
      formJsonLocalized(forcedOutputFormat = null) {
        return JSON.stringify(this.formArrayLocalized(forcedOutputFormat));
      }
      /**
       * Unformat all the autoNumeric-managed elements that are a child of the parent <form> element of this DOM element, to numeric strings
       *
       * @returns {AutoNumeric}
       */
      formUnformat() {
        const inputs = this.constructor._getChildANInputElement(this.form());
        inputs.forEach((input) => {
          _AutoNumeric.getAutoNumericElement(input).unformat();
        });
        return this;
      }
      /**
       * Unformat all the autoNumeric-managed elements that are a child of the parent <form> element of this DOM element, to localized strings
       *
       * @returns {AutoNumeric}
       */
      formUnformatLocalized() {
        const inputs = this.constructor._getChildANInputElement(this.form());
        inputs.forEach((input) => {
          _AutoNumeric.getAutoNumericElement(input).unformatLocalized();
        });
        return this;
      }
      /**
       * Reformat all the autoNumeric-managed elements that are a child of the parent <form> element of this DOM element
       *
       * @returns {AutoNumeric}
       */
      formReformat() {
        const inputs = this.constructor._getChildANInputElement(this.form());
        inputs.forEach((input) => {
          _AutoNumeric.getAutoNumericElement(input).reformat();
        });
        return this;
      }
      /**
       * Convert the input values to numeric strings, submit the form, then reformat those back.
       * The function can either take a callback, or not. If it doesn't, the default `form.submit()` function will be called.
       * Otherwise, it runs `callback(value)` with `value` being equal to the result of `formNumericString()`.
       *
       * @param {function|null} callback
       * @returns {AutoNumeric}
       */
      formSubmitNumericString(callback = null) {
        if (AutoNumericHelper.isNull(callback)) {
          this.formUnformat();
          this.form().submit();
          this.formReformat();
        } else if (AutoNumericHelper.isFunction(callback)) {
          callback(this.formNumericString());
        } else {
          AutoNumericHelper.throwError(`The given callback is not a function.`);
        }
        return this;
      }
      /**
       * Submit the form with the current formatted values.
       * The function can either take a callback, or not. If it doesn't, the default `form.submit()` function will be called.
       * Otherwise, it runs `callback(value)` with `value` being equal to the result of `formFormatted()`.
       *
       * @param {function|null} callback
       * @returns {AutoNumeric}
       */
      formSubmitFormatted(callback = null) {
        if (AutoNumericHelper.isNull(callback)) {
          this.form().submit();
        } else if (AutoNumericHelper.isFunction(callback)) {
          callback(this.formFormatted());
        } else {
          AutoNumericHelper.throwError(`The given callback is not a function.`);
        }
        return this;
      }
      /**
       * Convert the input values to localized strings, submit the form, then reformat those back.
       * The function can either take a callback, or not. If it doesn't, the default `form.submit()` function will be called.
       * Otherwise, it runs `callback(value)` with `value` being equal to the result of `formLocalized()`.
       *
       * @param {null|string} forcedOutputFormat If set to something different from `null`, then this is used as an overriding outputFormat option
       * @param {function|null} callback
       * @returns {AutoNumeric}
       */
      formSubmitLocalized(forcedOutputFormat = null, callback = null) {
        if (AutoNumericHelper.isNull(callback)) {
          this.formUnformatLocalized();
          this.form().submit();
          this.formReformat();
        } else if (AutoNumericHelper.isFunction(callback)) {
          callback(this.formLocalized(forcedOutputFormat));
        } else {
          AutoNumericHelper.throwError(`The given callback is not a function.`);
        }
        return this;
      }
      /**
       * Generate an array of numeric strings from the `<input>` elements, and pass it to the given callback.
       * Under the hood, the array is generated via a call to `formArrayNumericString()`.
       *
       * @param {function} callback
       * @returns {AutoNumeric}
       */
      formSubmitArrayNumericString(callback) {
        if (AutoNumericHelper.isFunction(callback)) {
          callback(this.formArrayNumericString());
        } else {
          AutoNumericHelper.throwError(`The given callback is not a function.`);
        }
        return this;
      }
      /**
       * Generate an array of the current formatted values from the `<input>` elements, and pass it to the given callback.
       * Under the hood, the array is generated via a call to `formArrayFormatted()`.
       *
       * @param {function} callback
       * @returns {AutoNumeric}
       */
      formSubmitArrayFormatted(callback) {
        if (AutoNumericHelper.isFunction(callback)) {
          callback(this.formArrayFormatted());
        } else {
          AutoNumericHelper.throwError(`The given callback is not a function.`);
        }
        return this;
      }
      /**
       * Generate an array of localized strings from the `<input>` elements, and pass it to the given callback.
       * Under the hood, the array is generated via a call to `formArrayLocalized()`.
       *
       * @param {function} callback
       * @param {null|string} forcedOutputFormat If set to something different from `null`, then this is used as an overriding outputFormat option
       * @returns {AutoNumeric}
       */
      formSubmitArrayLocalized(callback, forcedOutputFormat = null) {
        if (AutoNumericHelper.isFunction(callback)) {
          callback(this.formArrayLocalized(forcedOutputFormat));
        } else {
          AutoNumericHelper.throwError(`The given callback is not a function.`);
        }
        return this;
      }
      /**
       * Generate a JSON string with the numeric strings values from the `<input>` elements, and pass it to the given callback.
       * Under the hood, the array is generated via a call to `formJsonNumericString()`.
       *
       * @param {function} callback
       * @returns {AutoNumeric}
       */
      formSubmitJsonNumericString(callback) {
        if (AutoNumericHelper.isFunction(callback)) {
          callback(this.formJsonNumericString());
        } else {
          AutoNumericHelper.throwError(`The given callback is not a function.`);
        }
        return this;
      }
      /**
       * Generate a JSON string with the current formatted values from the `<input>` elements, and pass it to the given callback.
       * Under the hood, the array is generated via a call to `formJsonFormatted()`.
       *
       * @param {function} callback
       * @returns {AutoNumeric}
       */
      formSubmitJsonFormatted(callback) {
        if (AutoNumericHelper.isFunction(callback)) {
          callback(this.formJsonFormatted());
        } else {
          AutoNumericHelper.throwError(`The given callback is not a function.`);
        }
        return this;
      }
      /**
       * Generate a JSON string with the localized strings values from the `<input>` elements, and pass it to the given callback.
       * Under the hood, the array is generated via a call to `formJsonLocalized()`.
       *
       * @param {function} callback
       * @param {null|string} forcedOutputFormat If set to something different from `null`, then this is used as an overriding outputFormat option
       * @returns {AutoNumeric}
       */
      formSubmitJsonLocalized(callback, forcedOutputFormat = null) {
        if (AutoNumericHelper.isFunction(callback)) {
          callback(this.formJsonLocalized(forcedOutputFormat));
        } else {
          AutoNumericHelper.throwError(`The given callback is not a function.`);
        }
        return this;
      }
      /**
       * Unformat the given AutoNumeric element, and update the `hoveredWithAlt` variable.
       *
       * @param {AutoNumeric} anElement
       * @private
       */
      static _unformatAltHovered(anElement) {
        anElement.hoveredWithAlt = true;
        anElement.unformat();
      }
      /**
       * Reformat the given AutoNumeric element, and update the `hoveredWithAlt` variable.
       *
       * @param {AutoNumeric} anElement
       * @private
       */
      static _reformatAltHovered(anElement) {
        anElement.hoveredWithAlt = false;
        anElement.reformat();
      }
      /**
       * Return an array of autoNumeric elements, child of the <form> element passed as a parameter.
       *
       * @param {HTMLElement} formNode
       * @returns {Array}
       * @private
       */
      static _getChildANInputElement(formNode) {
        const inputList = formNode.getElementsByTagName("input");
        const autoNumericInputs = [];
        const inputElements = Array.prototype.slice.call(inputList, 0);
        inputElements.forEach((input) => {
          if (this.test(input)) {
            autoNumericInputs.push(input);
          }
        });
        return autoNumericInputs;
      }
      // Static methods
      /**
       * Test if the given DOM element, or the element selected by the given selector string is already managed by AutoNumeric (if it has been initialized on the current page).
       *
       * @param {HTMLElement|string} domElementOrSelector Accepts either directly a DOM element to test, or a string selector (that will return one and only one element, if any)
       * @returns {boolean}
       */
      static test(domElementOrSelector) {
        return this._isInGlobalList(AutoNumericHelper.domElement(domElementOrSelector));
      }
      /**
       * Create a WeakMap with the given name.
       *
       * @param {string} weakMapName
       * @private
       */
      static _createWeakMap(weakMapName) {
        window[weakMapName] = /* @__PURE__ */ new WeakMap();
      }
      /**
       * Create a list of all the AutoNumeric elements that are initialized on the current page.
       * This is needed in order to determine if a given dom element is already managed by autoNumeric.
       * This uses a WeakMap in order to limit potential garbage collection problems.
       * (cf. my tests on http://codepen.io/AnotherLinuxUser/pen/pRQGaM?editors=1011)
       * @private
       */
      static _createGlobalList() {
        this.autoNumericGlobalListName = "autoNumericGlobalList";
        this._createWeakMap(this.autoNumericGlobalListName);
      }
      /**
       * Return `true` if the global AutoNumeric element list exists.
       *
       * @returns {boolean}
       * @private
       */
      static _doesGlobalListExists() {
        const type = typeof window[this.autoNumericGlobalListName];
        return type !== "undefined" && type === "object";
      }
      /**
       * Add the given object to the global AutoNumeric element list.
       *
       * @param {AutoNumeric} autoNumericObject
       * @private
       */
      static _addToGlobalList(autoNumericObject) {
        if (!this._doesGlobalListExists()) {
          this._createGlobalList();
        }
        const domElement = autoNumericObject.node();
        if (this._isInGlobalList(domElement)) {
          if (this._getFromGlobalList(domElement) === this) {
            return;
          } else {
            AutoNumericHelper.warning(`A reference to the DOM element you just initialized already exists in the global AutoNumeric element list. Please make sure to not initialize the same DOM element multiple times.`, autoNumericObject.getSettings().showWarnings);
          }
        }
        window[this.autoNumericGlobalListName].set(domElement, autoNumericObject);
      }
      /**
       * Remove the given object from the global AutoNumeric element list.
       *
       * @param {AutoNumeric} autoNumericObject
       * @private
       */
      static _removeFromGlobalList(autoNumericObject) {
        if (this._doesGlobalListExists()) {
          window[this.autoNumericGlobalListName].delete(autoNumericObject.node());
        }
      }
      /**
       * Return the value associated to the key `domElement` passed as a parameter.
       * The value is the AutoNumeric object that manages the DOM element `domElement`.
       *
       * @param {HTMLElement|HTMLInputElement} domElement
       * @returns {null|AutoNumeric}
       * @private
       */
      static _getFromGlobalList(domElement) {
        if (this._doesGlobalListExists()) {
          return window[this.autoNumericGlobalListName].get(domElement);
        }
        return null;
      }
      /**
       * Check if the given DOM element is in the global AutoNumeric element list.
       *
       * @param {HTMLElement|HTMLInputElement} domElement
       * @returns {boolean}
       * @private
       */
      static _isInGlobalList(domElement) {
        if (!this._doesGlobalListExists()) {
          return false;
        }
        return window[this.autoNumericGlobalListName].has(domElement);
      }
      /**
       * Create a `Map` that will store all the autoNumeric elements that are initialized from this current element.
       * @private
       */
      _createLocalList() {
        this.autoNumericLocalList = /* @__PURE__ */ new Map();
        this._addToLocalList(this.domElement);
      }
      /**
       * In some rare cases, you could want to delete the local list generated during the element initialization (in order to use another one instead for instance).
       * @private
       */
      _deleteLocalList() {
        delete this.autoNumericLocalList;
      }
      /**
       * Set the local list with the given Map object.
       *
       * @param {Map} localList
       * @private
       */
      _setLocalList(localList) {
        this.autoNumericLocalList = localList;
      }
      /**
       * Return the local list Map object.
       *
       * @returns {*|Map}
       * @private
       */
      _getLocalList() {
        return this.autoNumericLocalList;
      }
      /**
       * Return `true` if the AutoNumeric object has a local list defined already and has at least one element in it (itself usually).
       *
       * @returns {boolean}
       * @private
       */
      _hasLocalList() {
        return this.autoNumericLocalList instanceof Map && this.autoNumericLocalList.size !== 0;
      }
      /**
       * Add the given object to the local autoNumeric element list.
       * Note: in order to keep a coherent list, we only add DOM elements in it, not the autoNumeric object.
       *
       * @param {HTMLElement|HTMLInputElement} domElement
       * @param {AutoNumeric} autoNumericObject A reference to the AutoNumeric object that manage the given DOM element
       * @throws
       * @private
       */
      _addToLocalList(domElement, autoNumericObject = null) {
        if (AutoNumericHelper.isNull(autoNumericObject)) {
          autoNumericObject = this;
        }
        if (!AutoNumericHelper.isUndefined(this.autoNumericLocalList)) {
          this.autoNumericLocalList.set(domElement, autoNumericObject);
        } else {
          AutoNumericHelper.throwError(`The local list provided does not exists when trying to add an element. [${this.autoNumericLocalList}] given.`);
        }
      }
      /**
       * Remove the given object from the local autoNumeric element list.
       *
       * @param {HTMLElement|HTMLInputElement} domElement
       * @private
       */
      _removeFromLocalList(domElement) {
        if (!AutoNumericHelper.isUndefined(this.autoNumericLocalList)) {
          this.autoNumericLocalList.delete(domElement);
        } else if (this.settings.createLocalList) {
          AutoNumericHelper.throwError(`The local list provided does not exists when trying to remove an element. [${this.autoNumericLocalList}] given.`);
        }
      }
      /**
       * Merge the `newSettings` given as parameters into the current element settings.
       *
       * WARNING: Using `Object.assign()` here means the merge is not recursive and only one depth is merged.
       * cf. http://stackoverflow.com/a/39188108/2834898
       * cf. tests on http://codepen.io/AnotherLinuxUser/pen/KaJORq?editors=0011
       *
       * @param {object} newSettings
       * @private
       */
      _mergeSettings(...newSettings) {
        Object.assign(this.settings, ...newSettings);
      }
      /**
       * Return a new object with the current element settings merged with the new settings.
       *
       * @param {object} newSettings
       * @returns {object}
       * @private
       */
      _cloneAndMergeSettings(...newSettings) {
        const result2 = {};
        Object.assign(result2, this.settings, ...newSettings);
        return result2;
      }
      /**
       * Validate the given option object.
       * If the options are valid, this function returns nothing, otherwise if the options are invalid, this function throws an error.
       *
       * This tests if the options are not conflicting and are well formatted.
       * This function is lenient since it only tests the settings properties ; it ignores any other properties the options object could have.
       *
       * @param {*} userOptions
       * @param {Boolean} shouldExtendDefaultOptions If `true`, then this function will extend the `userOptions` passed by the user, with the default options.
       * @param {object|null} originalOptions The user can pass the original options (and not the one that are generated from the default settings and the various usability corrections), in order to add compatibility and conflicts checks.
       * @throws Error This throws if the `userOptions` are not valid
       */
      static validate(userOptions, shouldExtendDefaultOptions = true, originalOptions = null) {
        if (AutoNumericHelper.isUndefinedOrNullOrEmpty(userOptions) || !AutoNumericHelper.isObject(userOptions)) {
          AutoNumericHelper.throwError(`The userOptions are invalid ; it should be a valid object, [${userOptions}] given.`);
        }
        const isOriginalOptionAnObject = AutoNumericHelper.isObject(originalOptions);
        if (!isOriginalOptionAnObject && !AutoNumericHelper.isNull(originalOptions)) {
          AutoNumericHelper.throwError(`The 'originalOptions' parameter is invalid ; it should either be a valid option object or \`null\`, [${userOptions}] given.`);
        }
        if (!AutoNumericHelper.isNull(userOptions)) {
          this._convertOldOptionsToNewOnes(userOptions);
        }
        let options;
        if (shouldExtendDefaultOptions) {
          options = Object.assign({}, this.getDefaultConfig(), userOptions);
        } else {
          options = userOptions;
        }
        if (!AutoNumericHelper.isTrueOrFalseString(options.showWarnings) && !AutoNumericHelper.isBoolean(options.showWarnings)) {
          AutoNumericHelper.throwError(`The debug option 'showWarnings' is invalid ; it should be either 'true' or 'false', [${options.showWarnings}] given.`);
        }
        const testPositiveInteger = /^[0-9]+$/;
        const testNumericalCharacters = /[0-9]+/;
        const testFloatOrIntegerAndPossibleNegativeSign = /^-?[0-9]+(\.?[0-9]+)?$/;
        const testPositiveFloatOrInteger = /^[0-9]+(\.?[0-9]+)?$/;
        if (!AutoNumericHelper.isTrueOrFalseString(options.allowDecimalPadding) && !AutoNumericHelper.isBoolean(options.allowDecimalPadding) && options.allowDecimalPadding !== _AutoNumeric.options.allowDecimalPadding.floats && !(AutoNumericHelper.isNumber(options.allowDecimalPadding) && options.allowDecimalPadding > 0)) {
          AutoNumericHelper.throwError(`The decimal padding option 'allowDecimalPadding' is invalid ; it should either be \`false\`, \`true\`, \`'floats'\` or a positive integer superior to 0, [${options.allowDecimalPadding}] given.`);
        }
        if (AutoNumericHelper.isNumber(options.allowDecimalPadding) && options.allowDecimalPadding > options.decimalPlaces) {
          AutoNumericHelper.warning(`Setting 'allowDecimalPadding' to a number [${options.allowDecimalPadding}] superior to the current 'decimalPlaces' settings [${options.decimalPlaces}] is useless, since the padding will not be shown.`, options.showWarnings);
        }
        if ((options.allowDecimalPadding === _AutoNumeric.options.allowDecimalPadding.never || options.allowDecimalPadding === "false") && (options.decimalPlaces !== _AutoNumeric.options.decimalPlaces.none || options.decimalPlacesShownOnBlur !== _AutoNumeric.options.decimalPlacesShownOnBlur.none || options.decimalPlacesShownOnFocus !== _AutoNumeric.options.decimalPlacesShownOnFocus.none)) {
          AutoNumericHelper.warning(`Setting 'allowDecimalPadding' to [${options.allowDecimalPadding}] will override the current 'decimalPlaces*' settings [${options.decimalPlaces}, ${options.decimalPlacesShownOnBlur} and ${options.decimalPlacesShownOnFocus}].`, options.showWarnings);
        }
        if (!AutoNumericHelper.isTrueOrFalseString(options.alwaysAllowDecimalCharacter) && !AutoNumericHelper.isBoolean(options.alwaysAllowDecimalCharacter)) {
          AutoNumericHelper.throwError(`The option 'alwaysAllowDecimalCharacter' is invalid ; it should either be \`true\` or \`false\`, [${options.alwaysAllowDecimalCharacter}] given.`);
        }
        if (!AutoNumericHelper.isNull(options.caretPositionOnFocus) && !AutoNumericHelper.isInArray(options.caretPositionOnFocus, [
          _AutoNumeric.options.caretPositionOnFocus.start,
          _AutoNumeric.options.caretPositionOnFocus.end,
          _AutoNumeric.options.caretPositionOnFocus.decimalLeft,
          _AutoNumeric.options.caretPositionOnFocus.decimalRight
        ])) {
          AutoNumericHelper.throwError(`The display on empty string option 'caretPositionOnFocus' is invalid ; it should either be \`null\`, 'focus', 'press', 'always' or 'zero', [${options.caretPositionOnFocus}] given.`);
        }
        let optionsToUse;
        if (isOriginalOptionAnObject) {
          optionsToUse = originalOptions;
        } else {
          optionsToUse = this._correctCaretPositionOnFocusAndSelectOnFocusOptions(userOptions);
        }
        if (!AutoNumericHelper.isNull(optionsToUse) && (optionsToUse.caretPositionOnFocus !== _AutoNumeric.options.caretPositionOnFocus.doNoForceCaretPosition && optionsToUse.selectOnFocus === _AutoNumeric.options.selectOnFocus.select)) {
          AutoNumericHelper.warning(`The 'selectOnFocus' option is set to 'select', which is in conflict with the 'caretPositionOnFocus' which is set to '${optionsToUse.caretPositionOnFocus}'. As a result, if this has been called when instantiating an AutoNumeric object, the 'selectOnFocus' option is forced to 'doNotSelect'.`, options.showWarnings);
        }
        if (!AutoNumericHelper.isInArray(options.digitGroupSeparator, [
          _AutoNumeric.options.digitGroupSeparator.comma,
          _AutoNumeric.options.digitGroupSeparator.dot,
          _AutoNumeric.options.digitGroupSeparator.normalSpace,
          _AutoNumeric.options.digitGroupSeparator.thinSpace,
          _AutoNumeric.options.digitGroupSeparator.narrowNoBreakSpace,
          _AutoNumeric.options.digitGroupSeparator.noBreakSpace,
          _AutoNumeric.options.digitGroupSeparator.noSeparator,
          _AutoNumeric.options.digitGroupSeparator.apostrophe,
          _AutoNumeric.options.digitGroupSeparator.arabicThousandsSeparator,
          _AutoNumeric.options.digitGroupSeparator.dotAbove,
          _AutoNumeric.options.digitGroupSeparator.privateUseTwo
        ])) {
          AutoNumericHelper.throwError(`The thousand separator character option 'digitGroupSeparator' is invalid ; it should be ',', '.', '', '', "'", '', ' ', '', '', '' or empty (''), [${options.digitGroupSeparator}] given.`);
        }
        if (!AutoNumericHelper.isTrueOrFalseString(options.showOnlyNumbersOnFocus) && !AutoNumericHelper.isBoolean(options.showOnlyNumbersOnFocus)) {
          AutoNumericHelper.throwError(`The 'showOnlyNumbersOnFocus' option is invalid ; it should be either 'true' or 'false', [${options.showOnlyNumbersOnFocus}] given.`);
        }
        if (!AutoNumericHelper.isInArray(options.digitalGroupSpacing, [
          _AutoNumeric.options.digitalGroupSpacing.two,
          _AutoNumeric.options.digitalGroupSpacing.twoThree,
          _AutoNumeric.options.digitalGroupSpacing.twoScaled,
          _AutoNumeric.options.digitalGroupSpacing.three,
          _AutoNumeric.options.digitalGroupSpacing.four
        ]) && !(options.digitalGroupSpacing >= 2 && options.digitalGroupSpacing <= 4)) {
          AutoNumericHelper.throwError(`The grouping separator option for thousands 'digitalGroupSpacing' is invalid ; it should be '2', '2t', '2s', '3', or '4', [${options.digitalGroupSpacing}] given.`);
        }
        if (!AutoNumericHelper.isInArray(options.decimalCharacter, [
          _AutoNumeric.options.decimalCharacter.comma,
          _AutoNumeric.options.decimalCharacter.dot,
          _AutoNumeric.options.decimalCharacter.middleDot,
          _AutoNumeric.options.decimalCharacter.arabicDecimalSeparator,
          _AutoNumeric.options.decimalCharacter.decimalSeparatorKeySymbol
        ])) {
          AutoNumericHelper.throwError(`The decimal separator character option 'decimalCharacter' is invalid ; it should be '.', ',', '', '' or '', [${options.decimalCharacter}] given.`);
        }
        if (options.decimalCharacter === options.digitGroupSeparator) {
          AutoNumericHelper.throwError(`autoNumeric will not function properly when the decimal character 'decimalCharacter' [${options.decimalCharacter}] and the thousand separator 'digitGroupSeparator' [${options.digitGroupSeparator}] are the same character.`);
        }
        if (!AutoNumericHelper.isNull(options.decimalCharacterAlternative) && !AutoNumericHelper.isString(options.decimalCharacterAlternative)) {
          AutoNumericHelper.throwError(`The alternate decimal separator character option 'decimalCharacterAlternative' is invalid ; it should be a string, [${options.decimalCharacterAlternative}] given.`);
        }
        if (options.currencySymbol !== "" && !AutoNumericHelper.isString(options.currencySymbol)) {
          AutoNumericHelper.throwError(`The currency symbol option 'currencySymbol' is invalid ; it should be a string, [${options.currencySymbol}] given.`);
        }
        if (!AutoNumericHelper.isInArray(options.currencySymbolPlacement, [
          _AutoNumeric.options.currencySymbolPlacement.prefix,
          _AutoNumeric.options.currencySymbolPlacement.suffix
        ])) {
          AutoNumericHelper.throwError(`The placement of the currency sign option 'currencySymbolPlacement' is invalid ; it should either be 'p' (prefix) or 's' (suffix), [${options.currencySymbolPlacement}] given.`);
        }
        if (!AutoNumericHelper.isInArray(options.negativePositiveSignPlacement, [
          _AutoNumeric.options.negativePositiveSignPlacement.prefix,
          _AutoNumeric.options.negativePositiveSignPlacement.suffix,
          _AutoNumeric.options.negativePositiveSignPlacement.left,
          _AutoNumeric.options.negativePositiveSignPlacement.right,
          _AutoNumeric.options.negativePositiveSignPlacement.none
        ])) {
          AutoNumericHelper.throwError(`The placement of the negative sign option 'negativePositiveSignPlacement' is invalid ; it should either be 'p' (prefix), 's' (suffix), 'l' (left), 'r' (right) or 'null', [${options.negativePositiveSignPlacement}] given.`);
        }
        if (!AutoNumericHelper.isTrueOrFalseString(options.showPositiveSign) && !AutoNumericHelper.isBoolean(options.showPositiveSign)) {
          AutoNumericHelper.throwError(`The show positive sign option 'showPositiveSign' is invalid ; it should be either 'true' or 'false', [${options.showPositiveSign}] given.`);
        }
        if (!AutoNumericHelper.isString(options.suffixText) || options.suffixText !== "" && (AutoNumericHelper.isNegative(options.suffixText, options.negativeSignCharacter) || testNumericalCharacters.test(options.suffixText))) {
          AutoNumericHelper.throwError(`The additional suffix option 'suffixText' is invalid ; it should not contains the negative sign '${options.negativeSignCharacter}' nor any numerical characters, [${options.suffixText}] given.`);
        }
        if (!AutoNumericHelper.isString(options.negativeSignCharacter) || options.negativeSignCharacter.length !== 1 || AutoNumericHelper.isUndefinedOrNullOrEmpty(options.negativeSignCharacter) || testNumericalCharacters.test(options.negativeSignCharacter)) {
          AutoNumericHelper.throwError(`The negative sign character option 'negativeSignCharacter' is invalid ; it should be a single character, and cannot be any numerical characters, [${options.negativeSignCharacter}] given.`);
        }
        if (!AutoNumericHelper.isString(options.positiveSignCharacter) || options.positiveSignCharacter.length !== 1 || AutoNumericHelper.isUndefinedOrNullOrEmpty(options.positiveSignCharacter) || testNumericalCharacters.test(options.positiveSignCharacter)) {
          AutoNumericHelper.throwError(`The positive sign character option 'positiveSignCharacter' is invalid ; it should be a single character, and cannot be any numerical characters, [${options.positiveSignCharacter}] given.
If you want to show the positive sign character, you need to set the \`showPositiveSign\` option to \`true\`.`);
        }
        if (options.negativeSignCharacter === options.positiveSignCharacter) {
          AutoNumericHelper.throwError(`The positive 'positiveSignCharacter' and negative 'negativeSignCharacter' sign characters cannot be identical ; [${options.negativeSignCharacter}] given.`);
        }
        if (!AutoNumericHelper.isTrueOrFalseString(options.negativePositiveSignBehavior) && !AutoNumericHelper.isBoolean(options.negativePositiveSignBehavior)) {
          AutoNumericHelper.throwError(`The option 'negativePositiveSignBehavior' is invalid ; it should be either 'true' or 'false', [${options.negativePositiveSignBehavior}] given.`);
        }
        const [leftBracket, rightBracket] = AutoNumericHelper.isNull(options.negativeBracketsTypeOnBlur) ? ["", ""] : options.negativeBracketsTypeOnBlur.split(",");
        if (AutoNumericHelper.contains(options.digitGroupSeparator, options.negativeSignCharacter) || AutoNumericHelper.contains(options.decimalCharacter, options.negativeSignCharacter) || AutoNumericHelper.contains(options.decimalCharacterAlternative, options.negativeSignCharacter) || AutoNumericHelper.contains(leftBracket, options.negativeSignCharacter) || AutoNumericHelper.contains(rightBracket, options.negativeSignCharacter) || AutoNumericHelper.contains(options.suffixText, options.negativeSignCharacter)) {
          AutoNumericHelper.throwError(`The negative sign character option 'negativeSignCharacter' is invalid ; it should not be equal or a part of the digit separator, the decimal character, the decimal character alternative, the negative brackets or the suffix text, [${options.negativeSignCharacter}] given.`);
        }
        if (AutoNumericHelper.contains(options.digitGroupSeparator, options.positiveSignCharacter) || AutoNumericHelper.contains(options.decimalCharacter, options.positiveSignCharacter) || AutoNumericHelper.contains(options.decimalCharacterAlternative, options.positiveSignCharacter) || AutoNumericHelper.contains(leftBracket, options.positiveSignCharacter) || AutoNumericHelper.contains(rightBracket, options.positiveSignCharacter) || AutoNumericHelper.contains(options.suffixText, options.positiveSignCharacter)) {
          AutoNumericHelper.throwError(`The positive sign character option 'positiveSignCharacter' is invalid ; it should not be equal or a part of the digit separator, the decimal character, the decimal character alternative, the negative brackets or the suffix text, [${options.positiveSignCharacter}] given.`);
        }
        if (!AutoNumericHelper.isNull(options.overrideMinMaxLimits) && !AutoNumericHelper.isInArray(options.overrideMinMaxLimits, [
          _AutoNumeric.options.overrideMinMaxLimits.ceiling,
          _AutoNumeric.options.overrideMinMaxLimits.floor,
          _AutoNumeric.options.overrideMinMaxLimits.ignore,
          _AutoNumeric.options.overrideMinMaxLimits.invalid
        ])) {
          AutoNumericHelper.throwError(`The override min & max limits option 'overrideMinMaxLimits' is invalid ; it should either be 'ceiling', 'floor', 'ignore' or 'invalid', [${options.overrideMinMaxLimits}] given.`);
        }
        if (options.overrideMinMaxLimits !== _AutoNumeric.options.overrideMinMaxLimits.invalid && options.overrideMinMaxLimits !== _AutoNumeric.options.overrideMinMaxLimits.ignore && (options.minimumValue > 0 || options.maximumValue < 0)) {
          AutoNumericHelper.warning(`You've set a \`minimumValue\` or a \`maximumValue\` excluding the value \`0\`. AutoNumeric will force the users to always have a valid value in the input, hence preventing them to clear the field. If you want to allow for temporary invalid values (i.e. out-of-range), you should use the 'invalid' option for the 'overrideMinMaxLimits' setting.`);
        }
        if (!AutoNumericHelper.isString(options.maximumValue) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.maximumValue)) {
          AutoNumericHelper.throwError(`The maximum possible value option 'maximumValue' is invalid ; it should be a string that represents a positive or negative number, [${options.maximumValue}] given.`);
        }
        if (!AutoNumericHelper.isString(options.minimumValue) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.minimumValue)) {
          AutoNumericHelper.throwError(`The minimum possible value option 'minimumValue' is invalid ; it should be a string that represents a positive or negative number, [${options.minimumValue}] given.`);
        }
        if (parseFloat(options.minimumValue) > parseFloat(options.maximumValue)) {
          AutoNumericHelper.throwError(`The minimum possible value option is greater than the maximum possible value option ; 'minimumValue' [${options.minimumValue}] should be smaller than 'maximumValue' [${options.maximumValue}].`);
        }
        if (!(AutoNumericHelper.isInt(options.decimalPlaces) && options.decimalPlaces >= 0 || // If integer option
        AutoNumericHelper.isString(options.decimalPlaces) && testPositiveInteger.test(options.decimalPlaces))) {
          AutoNumericHelper.throwError(`The number of decimal places option 'decimalPlaces' is invalid ; it should be a positive integer, [${options.decimalPlaces}] given.`);
        }
        if (!(AutoNumericHelper.isNull(options.decimalPlacesRawValue) || AutoNumericHelper.isInt(options.decimalPlacesRawValue) && options.decimalPlacesRawValue >= 0 || // If integer option
        AutoNumericHelper.isString(options.decimalPlacesRawValue) && testPositiveInteger.test(options.decimalPlacesRawValue))) {
          AutoNumericHelper.throwError(`The number of decimal places for the raw value option 'decimalPlacesRawValue' is invalid ; it should be a positive integer or \`null\`, [${options.decimalPlacesRawValue}] given.`);
        }
        this._validateDecimalPlacesRawValue(options);
        if (!AutoNumericHelper.isNull(options.decimalPlacesShownOnFocus) && !testPositiveInteger.test(String(options.decimalPlacesShownOnFocus))) {
          AutoNumericHelper.throwError(`The number of expanded decimal places option 'decimalPlacesShownOnFocus' is invalid ; it should be a positive integer or \`null\`, [${options.decimalPlacesShownOnFocus}] given.`);
        }
        if (!AutoNumericHelper.isNull(options.decimalPlacesShownOnFocus) && Number(options.decimalPlaces) > Number(options.decimalPlacesShownOnFocus)) {
          AutoNumericHelper.warning(`The extended decimal places 'decimalPlacesShownOnFocus' [${options.decimalPlacesShownOnFocus}] should be greater than the 'decimalPlaces' [${options.decimalPlaces}] value. Currently, this will limit the ability of your user to manually change some of the decimal places. Do you really want to do that?`, options.showWarnings);
        }
        if (!AutoNumericHelper.isNull(options.divisorWhenUnfocused) && !testPositiveFloatOrInteger.test(options.divisorWhenUnfocused) || options.divisorWhenUnfocused === 0 || options.divisorWhenUnfocused === "0" || options.divisorWhenUnfocused === 1 || options.divisorWhenUnfocused === "1") {
          AutoNumericHelper.throwError(`The divisor option 'divisorWhenUnfocused' is invalid ; it should be a positive number higher than one, preferably an integer, [${options.divisorWhenUnfocused}] given.`);
        }
        if (!AutoNumericHelper.isNull(options.decimalPlacesShownOnBlur) && !testPositiveInteger.test(options.decimalPlacesShownOnBlur)) {
          AutoNumericHelper.throwError(`The number of decimals shown when unfocused option 'decimalPlacesShownOnBlur' is invalid ; it should be a positive integer or \`null\`, [${options.decimalPlacesShownOnBlur}] given.`);
        }
        if (!AutoNumericHelper.isNull(options.symbolWhenUnfocused) && !AutoNumericHelper.isString(options.symbolWhenUnfocused)) {
          AutoNumericHelper.throwError(`The symbol to show when unfocused option 'symbolWhenUnfocused' is invalid ; it should be a string, [${options.symbolWhenUnfocused}] given.`);
        }
        if (!AutoNumericHelper.isTrueOrFalseString(options.saveValueToSessionStorage) && !AutoNumericHelper.isBoolean(options.saveValueToSessionStorage)) {
          AutoNumericHelper.throwError(`The save to session storage option 'saveValueToSessionStorage' is invalid ; it should be either 'true' or 'false', [${options.saveValueToSessionStorage}] given.`);
        }
        if (!AutoNumericHelper.isInArray(options.onInvalidPaste, [
          _AutoNumeric.options.onInvalidPaste.error,
          _AutoNumeric.options.onInvalidPaste.ignore,
          _AutoNumeric.options.onInvalidPaste.clamp,
          _AutoNumeric.options.onInvalidPaste.truncate,
          _AutoNumeric.options.onInvalidPaste.replace
        ])) {
          AutoNumericHelper.throwError(`The paste behavior option 'onInvalidPaste' is invalid ; it should either be 'error', 'ignore', 'clamp', 'truncate' or 'replace' (cf. documentation), [${options.onInvalidPaste}] given.`);
        }
        if (!AutoNumericHelper.isInArray(options.roundingMethod, [
          _AutoNumeric.options.roundingMethod.halfUpSymmetric,
          _AutoNumeric.options.roundingMethod.halfUpAsymmetric,
          _AutoNumeric.options.roundingMethod.halfDownSymmetric,
          _AutoNumeric.options.roundingMethod.halfDownAsymmetric,
          _AutoNumeric.options.roundingMethod.halfEvenBankersRounding,
          _AutoNumeric.options.roundingMethod.upRoundAwayFromZero,
          _AutoNumeric.options.roundingMethod.downRoundTowardZero,
          _AutoNumeric.options.roundingMethod.toCeilingTowardPositiveInfinity,
          _AutoNumeric.options.roundingMethod.toFloorTowardNegativeInfinity,
          _AutoNumeric.options.roundingMethod.toNearest05,
          _AutoNumeric.options.roundingMethod.toNearest05Alt,
          _AutoNumeric.options.roundingMethod.upToNext05,
          _AutoNumeric.options.roundingMethod.downToNext05
        ])) {
          AutoNumericHelper.throwError(`The rounding method option 'roundingMethod' is invalid ; it should either be 'S', 'A', 's', 'a', 'B', 'U', 'D', 'C', 'F', 'N05', 'CHF', 'U05' or 'D05' (cf. documentation), [${options.roundingMethod}] given.`);
        }
        if (!AutoNumericHelper.isNull(options.negativeBracketsTypeOnBlur) && !AutoNumericHelper.isInArray(options.negativeBracketsTypeOnBlur, [
          _AutoNumeric.options.negativeBracketsTypeOnBlur.parentheses,
          _AutoNumeric.options.negativeBracketsTypeOnBlur.brackets,
          _AutoNumeric.options.negativeBracketsTypeOnBlur.chevrons,
          _AutoNumeric.options.negativeBracketsTypeOnBlur.curlyBraces,
          _AutoNumeric.options.negativeBracketsTypeOnBlur.angleBrackets,
          _AutoNumeric.options.negativeBracketsTypeOnBlur.japaneseQuotationMarks,
          _AutoNumeric.options.negativeBracketsTypeOnBlur.halfBrackets,
          _AutoNumeric.options.negativeBracketsTypeOnBlur.whiteSquareBrackets,
          _AutoNumeric.options.negativeBracketsTypeOnBlur.quotationMarks,
          _AutoNumeric.options.negativeBracketsTypeOnBlur.guillemets
        ])) {
          AutoNumericHelper.throwError(`The brackets for negative values option 'negativeBracketsTypeOnBlur' is invalid ; it should either be '(,)', '[,]', '<,>', '{,}', ',', ',', ',', ',', ',' or ',', [${options.negativeBracketsTypeOnBlur}] given.`);
        }
        if (!(AutoNumericHelper.isString(options.emptyInputBehavior) || AutoNumericHelper.isNumber(options.emptyInputBehavior)) || !(AutoNumericHelper.isInArray(options.emptyInputBehavior, [
          _AutoNumeric.options.emptyInputBehavior.focus,
          _AutoNumeric.options.emptyInputBehavior.press,
          _AutoNumeric.options.emptyInputBehavior.always,
          _AutoNumeric.options.emptyInputBehavior.min,
          _AutoNumeric.options.emptyInputBehavior.max,
          _AutoNumeric.options.emptyInputBehavior.zero,
          _AutoNumeric.options.emptyInputBehavior.null
        ]) || testFloatOrIntegerAndPossibleNegativeSign.test(options.emptyInputBehavior))) {
          AutoNumericHelper.throwError(`The display on empty string option 'emptyInputBehavior' is invalid ; it should either be 'focus', 'press', 'always', 'min', 'max', 'zero', 'null', a number, or a string that represents a number, [${options.emptyInputBehavior}] given.`);
        }
        if (options.emptyInputBehavior === _AutoNumeric.options.emptyInputBehavior.zero && (options.minimumValue > 0 || options.maximumValue < 0)) {
          AutoNumericHelper.throwError(`The 'emptyInputBehavior' option is set to 'zero', but this value is outside of the range defined by 'minimumValue' and 'maximumValue' [${options.minimumValue}, ${options.maximumValue}].`);
        }
        if (testFloatOrIntegerAndPossibleNegativeSign.test(String(options.emptyInputBehavior))) {
          if (!this._isWithinRangeWithOverrideOption(options.emptyInputBehavior, options)) {
            AutoNumericHelper.throwError(`The 'emptyInputBehavior' option is set to a number or a string that represents a number, but its value [${options.emptyInputBehavior}] is outside of the range defined by the 'minimumValue' and 'maximumValue' options [${options.minimumValue}, ${options.maximumValue}].`);
          }
        }
        if (!AutoNumericHelper.isTrueOrFalseString(options.eventBubbles) && !AutoNumericHelper.isBoolean(options.eventBubbles)) {
          AutoNumericHelper.throwError(`The event bubbles option 'eventBubbles' is invalid ; it should be either 'true' or 'false', [${options.eventBubbles}] given.`);
        }
        if (!AutoNumericHelper.isTrueOrFalseString(options.eventIsCancelable) && !AutoNumericHelper.isBoolean(options.eventIsCancelable)) {
          AutoNumericHelper.throwError(`The event is cancelable option 'eventIsCancelable' is invalid ; it should be either 'true' or 'false', [${options.eventIsCancelable}] given.`);
        }
        if (AutoNumericHelper.isBoolean(options.invalidClass) || !/^-?[_a-zA-Z]+[_a-zA-Z0-9-]*$/.test(options.invalidClass)) {
          AutoNumericHelper.throwError(`The name of the 'invalidClass' option is not a valid CSS class name ; it should not be empty, and should follow the '^-?[_a-zA-Z]+[_a-zA-Z0-9-]*$' regex, [${options.invalidClass}] given.`);
        }
        if (!AutoNumericHelper.isInArray(options.leadingZero, [
          _AutoNumeric.options.leadingZero.allow,
          _AutoNumeric.options.leadingZero.deny,
          _AutoNumeric.options.leadingZero.keep
        ])) {
          AutoNumericHelper.throwError(`The leading zero behavior option 'leadingZero' is invalid ; it should either be 'allow', 'deny' or 'keep', [${options.leadingZero}] given.`);
        }
        if (!AutoNumericHelper.isTrueOrFalseString(options.formatOnPageLoad) && !AutoNumericHelper.isBoolean(options.formatOnPageLoad)) {
          AutoNumericHelper.throwError(`The format on initialization option 'formatOnPageLoad' is invalid ; it should be either 'true' or 'false', [${options.formatOnPageLoad}] given.`);
        }
        if (!AutoNumericHelper.isTrueOrFalseString(options.formulaMode) && !AutoNumericHelper.isBoolean(options.formulaMode)) {
          AutoNumericHelper.throwError(`The formula mode option 'formulaMode' is invalid ; it should be either 'true' or 'false', [${options.formulaMode}] given.`);
        }
        if (!testPositiveInteger.test(options.historySize) || options.historySize === 0) {
          AutoNumericHelper.throwError(`The history size option 'historySize' is invalid ; it should be a positive integer, [${options.historySize}] given.`);
        }
        if (!AutoNumericHelper.isTrueOrFalseString(options.selectNumberOnly) && !AutoNumericHelper.isBoolean(options.selectNumberOnly)) {
          AutoNumericHelper.throwError(`The select number only option 'selectNumberOnly' is invalid ; it should be either 'true' or 'false', [${options.selectNumberOnly}] given.`);
        }
        if (!AutoNumericHelper.isTrueOrFalseString(options.selectOnFocus) && !AutoNumericHelper.isBoolean(options.selectOnFocus)) {
          AutoNumericHelper.throwError(`The select on focus option 'selectOnFocus' is invalid ; it should be either 'true' or 'false', [${options.selectOnFocus}] given.`);
        }
        if (!AutoNumericHelper.isNull(options.defaultValueOverride) && (options.defaultValueOverride !== "" && !testFloatOrIntegerAndPossibleNegativeSign.test(options.defaultValueOverride))) {
          AutoNumericHelper.throwError(`The unformatted default value option 'defaultValueOverride' is invalid ; it should be a string that represents a positive or negative number, [${options.defaultValueOverride}] given.`);
        }
        if (!AutoNumericHelper.isTrueOrFalseString(options.unformatOnSubmit) && !AutoNumericHelper.isBoolean(options.unformatOnSubmit)) {
          AutoNumericHelper.throwError(`The remove formatting on submit option 'unformatOnSubmit' is invalid ; it should be either 'true' or 'false', [${options.unformatOnSubmit}] given.`);
        }
        if (!AutoNumericHelper.isNull(options.valuesToStrings) && !AutoNumericHelper.isObject(options.valuesToStrings)) {
          AutoNumericHelper.throwError(`The option 'valuesToStrings' is invalid ; it should be an object, ideally with 'key -> value' entries, [${options.valuesToStrings}] given.`);
        }
        if (!AutoNumericHelper.isNull(options.outputFormat) && !AutoNumericHelper.isInArray(options.outputFormat, [
          _AutoNumeric.options.outputFormat.string,
          _AutoNumeric.options.outputFormat.number,
          _AutoNumeric.options.outputFormat.dot,
          _AutoNumeric.options.outputFormat.negativeDot,
          _AutoNumeric.options.outputFormat.comma,
          _AutoNumeric.options.outputFormat.negativeComma,
          _AutoNumeric.options.outputFormat.dotNegative,
          _AutoNumeric.options.outputFormat.commaNegative
        ])) {
          AutoNumericHelper.throwError(`The custom locale format option 'outputFormat' is invalid ; it should either be null, 'string', 'number', '.', '-.', ',', '-,', '.-' or ',-', [${options.outputFormat}] given.`);
        }
        if (!AutoNumericHelper.isTrueOrFalseString(options.isCancellable) && !AutoNumericHelper.isBoolean(options.isCancellable)) {
          AutoNumericHelper.throwError(`The cancellable behavior option 'isCancellable' is invalid ; it should be either 'true' or 'false', [${options.isCancellable}] given.`);
        }
        if (!AutoNumericHelper.isTrueOrFalseString(options.modifyValueOnUpDownArrow) && !AutoNumericHelper.isBoolean(options.modifyValueOnUpDownArrow)) {
          AutoNumericHelper.throwError(`The increment/decrement on up and down arrow keys 'modifyValueOnUpDownArrow' is invalid ; it should be either 'true' or 'false', [${options.modifyValueOnUpDownArrow}] given.`);
        }
        if (!AutoNumericHelper.isTrueOrFalseString(options.modifyValueOnWheel) && !AutoNumericHelper.isBoolean(options.modifyValueOnWheel)) {
          AutoNumericHelper.throwError(`The increment/decrement on mouse wheel option 'modifyValueOnWheel' is invalid ; it should be either 'true' or 'false', [${options.modifyValueOnWheel}] given.`);
        }
        if (!AutoNumericHelper.isTrueOrFalseString(options.watchExternalChanges) && !AutoNumericHelper.isBoolean(options.watchExternalChanges)) {
          AutoNumericHelper.throwError(`The option 'watchExternalChanges' is invalid ; it should be either 'true' or 'false', [${options.watchExternalChanges}] given.`);
        }
        if (!AutoNumericHelper.isInArray(options.wheelOn, [
          _AutoNumeric.options.wheelOn.focus,
          _AutoNumeric.options.wheelOn.hover
        ])) {
          AutoNumericHelper.throwError(`The wheel behavior option 'wheelOn' is invalid ; it should either be 'focus' or 'hover', [${options.wheelOn}] given.`);
        }
        if (!(AutoNumericHelper.isString(options.upDownStep) || AutoNumericHelper.isNumber(options.upDownStep)) || options.upDownStep !== "progressive" && !testPositiveFloatOrInteger.test(options.upDownStep) || Number(options.upDownStep) === 0) {
          AutoNumericHelper.throwError(`The up/down arrow step value option 'upDownStep' is invalid ; it should either be the string 'progressive', or a number or a string that represents a positive number (excluding zero), [${options.upDownStep}] given.`);
        }
        if (!(AutoNumericHelper.isString(options.wheelStep) || AutoNumericHelper.isNumber(options.wheelStep)) || options.wheelStep !== "progressive" && !testPositiveFloatOrInteger.test(options.wheelStep) || Number(options.wheelStep) === 0) {
          AutoNumericHelper.throwError(`The wheel step value option 'wheelStep' is invalid ; it should either be the string 'progressive', or a number or a string that represents a positive number (excluding zero), [${options.wheelStep}] given.`);
        }
        if (!AutoNumericHelper.isInArray(options.serializeSpaces, [
          _AutoNumeric.options.serializeSpaces.plus,
          _AutoNumeric.options.serializeSpaces.percent
        ])) {
          AutoNumericHelper.throwError(`The space replacement character option 'serializeSpaces' is invalid ; it should either be '+' or '%20', [${options.serializeSpaces}] given.`);
        }
        if (!AutoNumericHelper.isTrueOrFalseString(options.noEventListeners) && !AutoNumericHelper.isBoolean(options.noEventListeners)) {
          AutoNumericHelper.throwError(`The option 'noEventListeners' that prevent the creation of event listeners is invalid ; it should be either 'true' or 'false', [${options.noEventListeners}] given.`);
        }
        if (!AutoNumericHelper.isNull(options.styleRules) && !(AutoNumericHelper.isObject(options.styleRules) && (Object.prototype.hasOwnProperty.call(options.styleRules, "positive") || Object.prototype.hasOwnProperty.call(options.styleRules, "negative") || Object.prototype.hasOwnProperty.call(options.styleRules, "ranges") || Object.prototype.hasOwnProperty.call(options.styleRules, "userDefined")))) {
          AutoNumericHelper.throwError(`The option 'styleRules' is invalid ; it should be a correctly structured object, with one or more 'positive', 'negative', 'ranges' or 'userDefined' attributes, [${options.styleRules}] given.`);
        }
        if (!AutoNumericHelper.isNull(options.styleRules) && Object.prototype.hasOwnProperty.call(options.styleRules, "userDefined") && !AutoNumericHelper.isNull(options.styleRules.userDefined)) {
          options.styleRules.userDefined.forEach((rule) => {
            if (Object.prototype.hasOwnProperty.call(rule, "callback") && !AutoNumericHelper.isFunction(rule.callback)) {
              AutoNumericHelper.throwError(`The callback defined in the \`userDefined\` attribute is not a function, ${typeof rule.callback} given.`);
            }
          });
        }
        if (!AutoNumericHelper.isNull(options.rawValueDivisor) && !testPositiveFloatOrInteger.test(options.rawValueDivisor) || options.rawValueDivisor === 0 || options.rawValueDivisor === "0" || options.rawValueDivisor === 1 || options.rawValueDivisor === "1") {
          AutoNumericHelper.throwError(`The raw value divisor option 'rawValueDivisor' is invalid ; it should be a positive number higher than one, preferably an integer, [${options.rawValueDivisor}] given.`);
        }
        if (!AutoNumericHelper.isTrueOrFalseString(options.readOnly) && !AutoNumericHelper.isBoolean(options.readOnly)) {
          AutoNumericHelper.throwError(`The option 'readOnly' is invalid ; it should be either 'true' or 'false', [${options.readOnly}] given.`);
        }
        if (!AutoNumericHelper.isTrueOrFalseString(options.unformatOnHover) && !AutoNumericHelper.isBoolean(options.unformatOnHover)) {
          AutoNumericHelper.throwError(`The option 'unformatOnHover' is invalid ; it should be either 'true' or 'false', [${options.unformatOnHover}] given.`);
        }
        if (!AutoNumericHelper.isTrueOrFalseString(options.failOnUnknownOption) && !AutoNumericHelper.isBoolean(options.failOnUnknownOption)) {
          AutoNumericHelper.throwError(`The debug option 'failOnUnknownOption' is invalid ; it should be either 'true' or 'false', [${options.failOnUnknownOption}] given.`);
        }
        if (!AutoNumericHelper.isTrueOrFalseString(options.createLocalList) && !AutoNumericHelper.isBoolean(options.createLocalList)) {
          AutoNumericHelper.throwError(`The debug option 'createLocalList' is invalid ; it should be either 'true' or 'false', [${options.createLocalList}] given.`);
        }
      }
      /**
       * Check the `decimalPlaces*` options and output the relevant warnings if some of those will get overwritten during the initialization or settings update.
       *
       * @param {object} options
       * @private
       */
      static _validateDecimalPlacesRawValue(options) {
        if (!AutoNumericHelper.isNull(options.decimalPlacesRawValue)) {
          if (options.decimalPlacesRawValue < options.decimalPlaces) {
            AutoNumericHelper.warning(`The number of decimal places to store in the raw value [${options.decimalPlacesRawValue}] is lower than the ones to display [${options.decimalPlaces}]. This will likely confuse your users.
To solve that, you'd need to either set \`decimalPlacesRawValue\` to \`null\`, or set a number of decimal places for the raw value equal of bigger than \`decimalPlaces\`.`, options.showWarnings);
          }
          if (options.decimalPlacesRawValue < options.decimalPlacesShownOnFocus) {
            AutoNumericHelper.warning(`The number of decimal places to store in the raw value [${options.decimalPlacesRawValue}] is lower than the ones shown on focus [${options.decimalPlacesShownOnFocus}]. This will likely confuse your users.
To solve that, you'd need to either set \`decimalPlacesRawValue\` to \`null\`, or set a number of decimal places for the raw value equal of bigger than \`decimalPlacesShownOnFocus\`.`, options.showWarnings);
          }
          if (options.decimalPlacesRawValue < options.decimalPlacesShownOnBlur) {
            AutoNumericHelper.warning(`The number of decimal places to store in the raw value [${options.decimalPlacesRawValue}] is lower than the ones shown when unfocused [${options.decimalPlacesShownOnBlur}]. This will likely confuse your users.
To solve that, you'd need to either set \`decimalPlacesRawValue\` to \`null\`, or set a number of decimal places for the raw value equal of bigger than \`decimalPlacesShownOnBlur\`.`, options.showWarnings);
          }
        }
      }
      /**
       * Return `true` if the settings/options are valid, `false` otherwise.
       *
       * @param {object} options
       * @returns {boolean}
       */
      static areSettingsValid(options) {
        let isValid2 = true;
        try {
          this.validate(options, true);
        } catch (error) {
          isValid2 = false;
        }
        return isValid2;
      }
      /**
       * Return the default autoNumeric settings.
       *
       * @returns {object}
       */
      static getDefaultConfig() {
        return _AutoNumeric.defaultSettings;
      }
      /**
       * Return all the predefined language options in one object.
       * You can also access a specific language object directly by using `AutoNumeric.getPredefinedOptions().French` for instance.
       *
       * @returns {object}
       */
      static getPredefinedOptions() {
        return _AutoNumeric.predefinedOptions;
      }
      /**
       * Analyse the given array `options` and return a single 'merged' option objet.
       * `options` can be `null`, or an array of an option objects, or an array containing another array of option objects / strings (pre-defined option names)
       *
       * @param {null|Array<object|string|Array<string|object>>} options
       * @returns {null|object}
       * @private
       */
      static _generateOptionsObjectFromOptionsArray(options) {
        let optionsResult;
        if (AutoNumericHelper.isUndefinedOrNullOrEmpty(options) || options.length === 0) {
          optionsResult = null;
        } else {
          optionsResult = {};
          if (options.length === 1 && Array.isArray(options[0])) {
            options[0].forEach((optionObject) => {
              Object.assign(optionsResult, this._getOptionObject(optionObject));
            });
          } else if (options.length >= 1) {
            options.forEach((optionObject) => {
              Object.assign(optionsResult, this._getOptionObject(optionObject));
            });
          }
        }
        return optionsResult;
      }
      /**
       * Format the given number (or numeric string) with the given options. This returns the formatted value as a string.
       * This can also format the given DOM element value with the given options and returns the formatted value as a string.
       * Note : This function does *not* update that element value with the newly formatted value.
       * This basically allows to get the formatted value without first having to initialize an AutoNumeric object.
       *
       * @param {number|string|HTMLElement|HTMLInputElement} numericStringOrDomElement A number, or a string that represent a javascript number, or a DOM element
       * @param {object|null} options Multiple objects can be passed, the latter overwriting the settings from the former ones
       * @returns {string|null}
       */
      static format(numericStringOrDomElement, ...options) {
        if (AutoNumericHelper.isUndefined(numericStringOrDomElement) || numericStringOrDomElement === null) {
          return null;
        }
        let value;
        if (AutoNumericHelper.isElement(numericStringOrDomElement)) {
          value = AutoNumericHelper.getElementValue(numericStringOrDomElement);
        } else {
          value = numericStringOrDomElement;
        }
        if (!AutoNumericHelper.isString(value) && !AutoNumericHelper.isNumber(value)) {
          AutoNumericHelper.throwError(`The value "${value}" being "set" is not numeric and therefore cannot be used appropriately.`);
        }
        const optionsToUse = this._generateOptionsObjectFromOptionsArray(options);
        const settings = Object.assign({}, this.getDefaultConfig(), optionsToUse);
        settings.isNegativeSignAllowed = value < 0;
        settings.isPositiveSignAllowed = value >= 0;
        this._setBrackets(settings);
        const regex = {};
        this._cachesUsualRegularExpressions(settings, regex);
        let valueString = this._toNumericValue(value, settings);
        if (isNaN(Number(valueString))) {
          AutoNumericHelper.throwError(`The value [${valueString}] that you are trying to format is not a recognized number.`);
        }
        if (!this._isWithinRangeWithOverrideOption(valueString, settings)) {
          AutoNumericHelper.triggerEvent(_AutoNumeric.events.formatted, document, {
            oldValue: null,
            newValue: null,
            oldRawValue: null,
            newRawValue: null,
            isPristine: null,
            error: "Range test failed",
            aNElement: null
          }, true, true);
          AutoNumericHelper.throwError(`The value [${valueString}] being set falls outside of the minimumValue [${settings.minimumValue}] and maximumValue [${settings.maximumValue}] range set for this element`);
        }
        if (settings.valuesToStrings && this._checkValuesToStringsSettings(value, settings)) {
          return settings.valuesToStrings[value];
        }
        this._correctNegativePositiveSignPlacementOption(settings);
        this._calculateDecimalPlacesOnInit(settings);
        if (!AutoNumericHelper.isUndefinedOrNullOrEmpty(settings.rawValueDivisor) && settings.rawValueDivisor !== 0 && // Only divide if the `rawValueDivisor` option is set
        valueString !== "" && valueString !== null) {
          valueString *= settings.rawValueDivisor;
        }
        valueString = this._roundFormattedValueShownOnFocus(valueString, settings);
        valueString = this._modifyNegativeSignAndDecimalCharacterForFormattedValue(valueString, settings);
        valueString = this._addGroupSeparators(valueString, settings, false, valueString);
        return valueString;
      }
      /**
       * Format the given DOM element value, and set the resulting value back as the element value.
       *
       * @param {HTMLElement|HTMLInputElement} domElement
       * @param {object} options
       * @returns {string|null}
       */
      static formatAndSet(domElement, options = null) {
        const formattedValue = this.format(domElement, options);
        AutoNumericHelper.setElementValue(domElement, formattedValue);
        return formattedValue;
      }
      /**
       * Unformat the given formatted string with the given options. This returns a numeric string.
       * It can also unformat the given DOM element value with the given options and returns the unformatted numeric string.
       * Note: This does *not* update that element value.
       * This basically allows to get the unformatted value without first having to initialize an AutoNumeric object.
       *
       * @param {string|number|HTMLElement|HTMLInputElement} numericStringOrDomElement A number, or a string that represent a javascript number, or a DOM element
       * @param {object|null} options Multiple objects can be passed, the latter overwriting the settings from the former ones
       * @returns {string|number|NaN}
       */
      static unformat(numericStringOrDomElement, ...options) {
        if (AutoNumericHelper.isNumberStrict(numericStringOrDomElement)) {
          return numericStringOrDomElement;
        }
        let value;
        if (AutoNumericHelper.isElement(numericStringOrDomElement)) {
          value = AutoNumericHelper.getElementValue(numericStringOrDomElement);
        } else {
          value = numericStringOrDomElement;
        }
        if (value === "") {
          return "";
        }
        if (AutoNumericHelper.isUndefined(value) || value === null) {
          return null;
        }
        if (AutoNumericHelper.isArray(value) || AutoNumericHelper.isObject(value)) {
          AutoNumericHelper.throwError(`A number or a string representing a number is needed to be able to unformat it, [${value}] given.`);
        }
        const optionsToUse = this._generateOptionsObjectFromOptionsArray(options);
        const settings = Object.assign({}, this.getDefaultConfig(), optionsToUse);
        settings.isNegativeSignAllowed = false;
        settings.isPositiveSignAllowed = true;
        value = value.toString();
        if (settings.valuesToStrings && this._checkStringsToValuesSettings(value, settings)) {
          return AutoNumericHelper.objectKeyLookup(settings.valuesToStrings, value);
        }
        if (AutoNumericHelper.isNegative(value, settings.negativeSignCharacter)) {
          settings.isNegativeSignAllowed = true;
          settings.isPositiveSignAllowed = false;
        } else if (!AutoNumericHelper.isNull(settings.negativeBracketsTypeOnBlur)) {
          [settings.firstBracket, settings.lastBracket] = settings.negativeBracketsTypeOnBlur.split(",");
          if (value.charAt(0) === settings.firstBracket && value.charAt(value.length - 1) === settings.lastBracket) {
            settings.isNegativeSignAllowed = true;
            settings.isPositiveSignAllowed = false;
            value = this._removeBrackets(value, settings, false);
          }
        }
        value = this._convertToNumericString(value, settings);
        if (AutoNumericHelper.isNumber(Number(value))) {
          value = AutoNumericHelper.scientificToDecimal(value);
        }
        const unwantedCharacters = new RegExp(`[^+-0123456789.]`, "gi");
        if (unwantedCharacters.test(value)) {
          return NaN;
        }
        this._correctNegativePositiveSignPlacementOption(settings);
        if (settings.decimalPlacesRawValue) {
          settings.originalDecimalPlacesRawValue = settings.decimalPlacesRawValue;
        } else {
          settings.originalDecimalPlacesRawValue = settings.decimalPlaces;
        }
        this._calculateDecimalPlacesOnInit(settings);
        if (!AutoNumericHelper.isUndefinedOrNullOrEmpty(settings.rawValueDivisor) && settings.rawValueDivisor !== 0 && // Only divide if the `rawValueDivisor` option is set
        value !== "" && value !== null) {
          value /= settings.rawValueDivisor;
        }
        value = this._roundRawValue(value, settings);
        value = value.replace(settings.decimalCharacter, ".");
        value = this._toLocale(value, settings.outputFormat, settings);
        return value;
      }
      /**
       * Unformat the given DOM element value, and set the resulting value back as the element value.
       *
       * @param {HTMLElement|HTMLInputElement} domElement
       * @param {object} options
       * @returns {*}
       */
      static unformatAndSet(domElement, options = null) {
        const unformattedValue = this.unformat(domElement, options);
        AutoNumericHelper.setElementValue(domElement, unformattedValue);
        return unformattedValue;
      }
      /**
       * Unformat and localize the given formatted string with the given options. This returns a numeric string.
       * It can also unformat and localize the given DOM element value with the given options and returns the unformatted numeric string.
       * Note: This does *not* update that element value.
       * This basically allows to get the localized value without first having to initialize an AutoNumeric object.
       *
       * @param {string|number|HTMLElement|HTMLInputElement} numericStringOrDomElement
       * @param {object} settings
       * @returns {*}
       */
      static localize(numericStringOrDomElement, settings = null) {
        let value;
        if (AutoNumericHelper.isElement(numericStringOrDomElement)) {
          value = AutoNumericHelper.getElementValue(numericStringOrDomElement);
        } else {
          value = numericStringOrDomElement;
        }
        if (value === "") {
          return "";
        }
        if (AutoNumericHelper.isNull(settings)) {
          settings = _AutoNumeric.defaultSettings;
        }
        value = this.unformat(value, settings);
        if (Number(value) === 0 && settings.leadingZero !== _AutoNumeric.options.leadingZero.keep) {
          value = "0";
        }
        let outputFormatToUse;
        if (AutoNumericHelper.isNull(settings)) {
          outputFormatToUse = settings.outputFormat;
        } else {
          outputFormatToUse = _AutoNumeric.defaultSettings.outputFormat;
        }
        return this._toLocale(value, outputFormatToUse, settings);
      }
      static localizeAndSet(domElement, options = null) {
        const localizedValue = this.localize(domElement, options);
        AutoNumericHelper.setElementValue(domElement, localizedValue);
        return localizedValue;
      }
      /**
       * Return `true` if the given DOM element has an AutoNumeric object that manages it.
       * This function also accepts a selector string.
       *
       * @param {HTMLElement|string} domElementOrSelector Accepts either directly a DOM element to test, or a string selector (that will return one and only one element, if any)
       * @returns {boolean}
       */
      static isManagedByAutoNumeric(domElementOrSelector) {
        return this._isInGlobalList(AutoNumericHelper.domElement(domElementOrSelector));
      }
      /**
       * Return the AutoNumeric object that manages the given DOM element.
       * This function also accepts a selector string.
       *
       * @param {HTMLElement|string} domElementOrSelector Accepts either directly a DOM element to test, or a string selector (that will return one and only one element, if any)
       * @returns {null|AutoNumeric}
       */
      static getAutoNumericElement(domElementOrSelector) {
        const domElement = AutoNumericHelper.domElement(domElementOrSelector);
        if (!this.isManagedByAutoNumeric(domElement)) {
          return null;
        }
        return this._getFromGlobalList(domElement);
      }
      /**
       * Set the given element value, and format it immediately.
       * Return `null` if no AutoNumeric object is found, else, return the AutoNumeric object.
       *
       * @param {HTMLElement|string} domElementOrSelector Either a DOM element reference, or a selector string can be used
       * @param {number|string|null} newValue The value must be a Number, a numeric string or `null` (if `emptyInputBehavior` is set to `'null'`)
       * @param {object} options A settings object that will override the current settings. Note: the update is done only if the `newValue` is defined.
       * @param {boolean} saveChangeToHistory If set to `true`, then the change is recorded in the history table
       * @returns {AutoNumeric|null}
       */
      static set(domElementOrSelector, newValue, options = null, saveChangeToHistory = true) {
        const domElement = AutoNumericHelper.domElement(domElementOrSelector);
        if (!this.isManagedByAutoNumeric(domElement)) {
          let showWarnings;
          if (!AutoNumericHelper.isNull(options) && Object.prototype.hasOwnProperty.call(options, "showWarnings")) {
            showWarnings = options.showWarnings;
          } else {
            showWarnings = true;
          }
          AutoNumericHelper.warning(`Impossible to find an AutoNumeric object for the given DOM element or selector.`, showWarnings);
          return null;
        }
        return this.getAutoNumericElement(domElement).set(newValue, options, saveChangeToHistory);
      }
      /**
       * Return the unformatted value as a string from the given DOM element or query selector.
       * This can also return `null` if `rawValue` is null.
       *
       * @param {HTMLElement|string} domElementOrSelector
       * @param {function|null} callback
       * @returns {string|null}
       */
      static getNumericString(domElementOrSelector, callback = null) {
        return this._get(domElementOrSelector, "getNumericString", callback);
      }
      /**
       * Return the current formatted value of the AutoNumeric element as a string, from the given DOM element or query selector.
       *
       * @param {HTMLElement|string} domElementOrSelector
       * @param {function|null} callback
       * @returns {string}
       */
      static getFormatted(domElementOrSelector, callback = null) {
        return this._get(domElementOrSelector, "getFormatted", callback);
      }
      /**
       * Return the element unformatted value as a real Javascript number, from the given DOM element or query selector.
       * Warning: This can lead to precision problems with big numbers that should be stored as strings.
       *
       * @param {HTMLElement|string} domElementOrSelector
       * @param {function|null} callback
       * @returns {number|null}
       */
      static getNumber(domElementOrSelector, callback = null) {
        return this._get(domElementOrSelector, "getNumber", callback);
      }
      /**
       * DRY the code between the static `get*` functions
       *
       * @param {HTMLElement|string} domElementOrSelector
       * @param {string} getFunction The name of the non-static `get*` function as a string
       * @param {function|null} callback
       * @returns {*}
       * @private
       */
      static _get(domElementOrSelector, getFunction, callback = null) {
        const domElement = AutoNumericHelper.domElement(domElementOrSelector);
        if (!this.isManagedByAutoNumeric(domElement)) {
          AutoNumericHelper.throwError(`Impossible to find an AutoNumeric object for the given DOM element or selector.`);
        }
        return this.getAutoNumericElement(domElement)[getFunction](callback);
      }
      /**
       * Returns the unformatted value following the `outputFormat` setting, from the given DOM element or query selector.
       * See the non-static `getLocalized()` method documentation for more details.
       *
       * @param {HTMLElement|string} domElementOrSelector
       * @param {null|string|function} forcedOutputFormat
       * @param {function|null} callback
       * @returns {*}
       */
      static getLocalized(domElementOrSelector, forcedOutputFormat = null, callback = null) {
        const domElement = AutoNumericHelper.domElement(domElementOrSelector);
        if (!this.isManagedByAutoNumeric(domElement)) {
          AutoNumericHelper.throwError(`Impossible to find an AutoNumeric object for the given DOM element or selector.`);
        }
        return this.getAutoNumericElement(domElement).getLocalized(forcedOutputFormat, callback);
      }
      // Pre-defined options can be called to update the current default options with their specificities
      //XXX A better way would be to not initialize first, but that's not possible since `new` is called first and we do not pass the language options (i.e. `French`) to the constructor
      /**
       * Update the AutoNumeric object with the predefined options, and possibly some option overrides.
       *
       * @param {object} predefinedOption
       * @param {object} optionOverride
       * @private
       * @returns {AutoNumeric}
       */
      _updatePredefinedOptions(predefinedOption, optionOverride = null) {
        if (!AutoNumericHelper.isNull(optionOverride)) {
          this._mergeSettings(predefinedOption, optionOverride);
          this.update(this.settings);
        } else {
          this.update(predefinedOption);
        }
        return this;
      }
      /**
       * Update the settings to use the French pre-defined language options.
       * Those pre-defined options can be overridden by passing an option object as a parameter.
       *
       * @param {object} optionOverride
       * @returns {AutoNumeric}
       */
      french(optionOverride = null) {
        this._updatePredefinedOptions(_AutoNumeric.getPredefinedOptions().French, optionOverride);
        return this;
      }
      /**
       * Update the settings to use the North American pre-defined language options.
       * Those pre-defined options can be overridden by passing an option object as a parameter.
       *
       * @param {object} optionOverride
       * @returns {AutoNumeric}
       */
      northAmerican(optionOverride = null) {
        this._updatePredefinedOptions(_AutoNumeric.getPredefinedOptions().NorthAmerican, optionOverride);
        return this;
      }
      /**
       * Update the settings to use the British pre-defined language options.
       * Those pre-defined options can be overridden by passing an option object as a parameter.
       *
       * @param {object} optionOverride
       * @returns {AutoNumeric}
       */
      british(optionOverride = null) {
        this._updatePredefinedOptions(_AutoNumeric.getPredefinedOptions().British, optionOverride);
        return this;
      }
      /**
       * Update the settings to use the Swiss pre-defined language options.
       * Those pre-defined options can be overridden by passing an option object as a parameter.
       *
       * @param {object} optionOverride
       * @returns {AutoNumeric}
       */
      swiss(optionOverride = null) {
        this._updatePredefinedOptions(_AutoNumeric.getPredefinedOptions().Swiss, optionOverride);
        return this;
      }
      /**
       * Update the settings to use the Japanese pre-defined language options.
       * Those pre-defined options can be overridden by passing an option object as a parameter.
       *
       * @param {object} optionOverride
       * @returns {AutoNumeric}
       */
      japanese(optionOverride = null) {
        this._updatePredefinedOptions(_AutoNumeric.getPredefinedOptions().Japanese, optionOverride);
        return this;
      }
      /**
       * Update the settings to use the Spanish pre-defined language options.
       * Those pre-defined options can be overridden by passing an option object as a parameter.
       *
       * @param {object} optionOverride
       * @returns {AutoNumeric}
       */
      spanish(optionOverride = null) {
        this._updatePredefinedOptions(_AutoNumeric.getPredefinedOptions().Spanish, optionOverride);
        return this;
      }
      /**
       * Update the settings to use the Chinese pre-defined language options.
       * Those pre-defined options can be overridden by passing an option object as a parameter.
       *
       * @param {object} optionOverride
       * @returns {AutoNumeric}
       */
      chinese(optionOverride = null) {
        this._updatePredefinedOptions(_AutoNumeric.getPredefinedOptions().Chinese, optionOverride);
        return this;
      }
      /**
       * Update the settings to use the Brazilian pre-defined language options.
       * Those pre-defined options can be overridden by passing an option object as a parameter.
       *
       * @param {object} optionOverride
       * @returns {AutoNumeric}
       */
      brazilian(optionOverride = null) {
        this._updatePredefinedOptions(_AutoNumeric.getPredefinedOptions().Brazilian, optionOverride);
        return this;
      }
      // Internal private functions
      /**
       * Run any callbacks found in the settings object in order to set the settings value back.
       * Any parameter can have a callback defined.
       * The callback takes the current AutoNumeric element as the first argument, and the key name as the second.
       * @example callback(this, 'currencySymbol')
       */
      _runCallbacksFoundInTheSettingsObject() {
        for (const key in this.settings) {
          if (Object.prototype.hasOwnProperty.call(this.settings, key)) {
            const value = this.settings[key];
            if (typeof value === "function") {
              this.settings[key] = value(this, key);
            } else {
              let htmlAttribute = "";
              if (key in this.domElement.dataset) {
                htmlAttribute = this.domElement.dataset[key];
              }
              htmlAttribute = AutoNumericHelper.camelize(htmlAttribute);
              if (typeof this.settings[htmlAttribute] === "function") {
                this.settings[key] = htmlAttribute(this, key);
              }
            }
          }
        }
      }
      /**
       * Keep track if the settings configuration leads to a trailing negative sign (only when the raw value is negative), so we do not have to test the settings values every time we need to know that.
       * `isTrailingNegative` is set to `true` if the settings result in a trailing negative character, `false` otherwise.
       * Note: This returns `true` even if the raw value is positive.
       * @private
       */
      _setTrailingNegativeSignInfo() {
        this.isTrailingNegative = this.settings.currencySymbolPlacement === _AutoNumeric.options.currencySymbolPlacement.prefix && this.settings.negativePositiveSignPlacement === _AutoNumeric.options.negativePositiveSignPlacement.suffix || this.settings.currencySymbolPlacement === _AutoNumeric.options.currencySymbolPlacement.suffix && (this.settings.negativePositiveSignPlacement === _AutoNumeric.options.negativePositiveSignPlacement.left || this.settings.negativePositiveSignPlacement === _AutoNumeric.options.negativePositiveSignPlacement.right);
      }
      /**
       * Strip all the unwanted non-number characters.
       * However, it does not reorder the localized negative sign.
       *
       * @param {string} s
       * @param {object} settings
       * @param {boolean} stripZeros If set to `false`, then the leading zero(s) are not stripped, otherwise if set to `true`, the `leadingZero` option is followed
       * @param {boolean} isFocused If the element is focused, then this is `true`
       * @returns {string}
       * @private
       */
      static _stripAllNonNumberCharacters(s2, settings, stripZeros, isFocused) {
        return this._stripAllNonNumberCharactersExceptCustomDecimalChar(s2, settings, stripZeros, isFocused).replace(settings.decimalCharacter, ".");
      }
      /**
       * Strip all unwanted non-number characters except the custom decimal character.
       *
       * It converts the custom negative sign and removes the positive sign (custom or not).
       * This keeps :
       * - the numbers,
       * - the normal negative sign '-' if any,
       * - and the *custom* decimal character.
       *
       * @param {string} s
       * @param {object} settings
       * @param {boolean} stripZeros If set to `false`, then the leading zero(s) are not stripped, otherwise if set to `true`, the `leadingZero` option is followed
       * @param {boolean} isFocused If the element is focused, then this is `true`
       * @returns {string|*}
       */
      static _stripAllNonNumberCharactersExceptCustomDecimalChar(s2, settings, stripZeros, isFocused) {
        s2 = this._normalizeCurrencySuffixAndNegativeSignCharacters(s2, settings);
        s2 = s2.replace(settings.allowedAutoStrip, "");
        const m2 = s2.match(settings.numRegAutoStrip);
        s2 = m2 ? [m2[1], m2[2], m2[3]].join("") : "";
        if (settings.leadingZero === _AutoNumeric.options.leadingZero.allow || settings.leadingZero === _AutoNumeric.options.leadingZero.keep) {
          let negativeSign = "";
          const [integerPart, decimalPart] = s2.split(settings.decimalCharacter);
          let modifiedIntegerPart = integerPart;
          if (AutoNumericHelper.contains(modifiedIntegerPart, settings.negativeSignCharacter)) {
            negativeSign = settings.negativeSignCharacter;
            modifiedIntegerPart = modifiedIntegerPart.replace(settings.negativeSignCharacter, "");
          }
          if (negativeSign === "" && modifiedIntegerPart.length > settings.mIntPos && modifiedIntegerPart.charAt(0) === "0") {
            modifiedIntegerPart = modifiedIntegerPart.slice(1);
          }
          if (negativeSign !== "" && modifiedIntegerPart.length > settings.mIntNeg && modifiedIntegerPart.charAt(0) === "0") {
            modifiedIntegerPart = modifiedIntegerPart.slice(1);
          }
          s2 = `${negativeSign}${modifiedIntegerPart}${AutoNumericHelper.isUndefined(decimalPart) ? "" : settings.decimalCharacter + decimalPart}`;
        }
        if (stripZeros && settings.leadingZero === _AutoNumeric.options.leadingZero.deny || !isFocused && settings.leadingZero === _AutoNumeric.options.leadingZero.allow) {
          s2 = s2.replace(settings.stripReg, "$1$2");
        }
        return s2;
      }
      /**
       * Sets or removes brackets on negative values, depending on the focus state, which is passed as `isFocused`.
       * The focus state is 'stored' in that object property.
       *
       * @param {string} value
       * @param {object} settings
       * @param {boolean} isFocused
       * @returns {*}
       */
      static _toggleNegativeBracket(value, settings, isFocused) {
        let result2;
        if (isFocused) {
          result2 = this._removeBrackets(value, settings);
        } else {
          result2 = this._addBrackets(value, settings);
        }
        return result2;
      }
      /**
       * Add the bracket types specified in the `settings` object, to the given string `value`.
       *
       * @param {string} value
       * @param {object} settings
       * @returns {string}
       * @private
       */
      static _addBrackets(value, settings) {
        if (AutoNumericHelper.isNull(settings.negativeBracketsTypeOnBlur)) {
          return value;
        }
        return `${settings.firstBracket}${value.replace(settings.negativeSignCharacter, "")}${settings.lastBracket}`;
      }
      /**
       * Remove the bracket types specified in the `settings` object, from the given string `value`.
       *
       * @param {string} value
       * @param {object} settings
       * @param {boolean} rearrangeSignsAndValueOrder If set to `true`, then only the brackets are remove and a negative sign is added, without reordering the negative sign, currency symbol and value according to the settings.
       * @returns {string}
       * @private
       */
      static _removeBrackets(value, settings, rearrangeSignsAndValueOrder = true) {
        let result2;
        if (!AutoNumericHelper.isNull(settings.negativeBracketsTypeOnBlur) && value.charAt(0) === settings.firstBracket) {
          result2 = value.replace(settings.firstBracket, "");
          result2 = result2.replace(settings.lastBracket, "");
          if (rearrangeSignsAndValueOrder) {
            result2 = result2.replace(settings.currencySymbol, "");
            result2 = this._mergeCurrencySignNegativePositiveSignAndValue(result2, settings, true, false);
          } else {
            result2 = `${settings.negativeSignCharacter}${result2}`;
          }
        } else {
          result2 = value;
        }
        return result2;
      }
      /**
       * Analyze the `negativeBracketsTypeOnBlur` options and keep track of the first and last bracket characters to use.
       *
       * @param {object} settings
       * @private
       */
      static _setBrackets(settings) {
        if (AutoNumericHelper.isNull(settings.negativeBracketsTypeOnBlur)) {
          settings.firstBracket = "";
          settings.lastBracket = "";
        } else {
          const [firstBracket, lastBracket] = settings.negativeBracketsTypeOnBlur.split(",");
          settings.firstBracket = firstBracket;
          settings.lastBracket = lastBracket;
        }
      }
      /**
       * Return a number as a numeric string that can be typecast to a Number that Javascript will understand.
       *
       * This function returns the given string by stripping:
       * - the currency sign (currencySymbol),
       * - the grouping separators (digitalGroupSpacing),
       * - the suffix text (suffixText),
       * - the positive sign (positiveSignCharacter),
       * - the brackets if any,
       * - by replacing the negative sign character with a hyphen,
       * - and by replacing the decimal character (decimalCharacter) by a dot.
       *
       * Lastly, it also put the negative sign back to its normal position if needed.
       * Bonus; it converts any arabic numbers found to the latin ones.
       *
       * @param {string} s
       * @param {object} settings
       * @returns {string|void|*}
       */
      static _convertToNumericString(s2, settings) {
        s2 = this._removeBrackets(s2, settings, false);
        s2 = this._normalizeCurrencySuffixAndNegativeSignCharacters(s2, settings);
        s2 = s2.replace(new RegExp(`[${settings.digitGroupSeparator}]`, "g"), "");
        if (settings.decimalCharacter !== ".") {
          s2 = s2.replace(settings.decimalCharacter, ".");
        }
        if (AutoNumericHelper.isNegative(s2) && s2.lastIndexOf("-") === s2.length - 1) {
          s2 = s2.replace("-", "");
          s2 = `-${s2}`;
        }
        if (settings.showPositiveSign) {
          s2 = s2.replace(settings.positiveSignCharacter, "");
        }
        const convertToNumber = settings.leadingZero !== _AutoNumeric.options.leadingZero.keep;
        const temp = AutoNumericHelper.arabicToLatinNumbers(s2, convertToNumber, false, false);
        if (!isNaN(temp)) {
          s2 = temp.toString();
        }
        return s2;
      }
      /**
       * Removes the currency symbol and the suffix text from the given string, and replace the custom negative sign with a hyphen.
       *
       * @param {string} s
       * @param {object} settings
       * @returns {string | *}
       * @private
       */
      static _normalizeCurrencySuffixAndNegativeSignCharacters(s2, settings) {
        s2 = String(s2);
        if (settings.currencySymbol !== _AutoNumeric.options.currencySymbol.none) {
          s2 = s2.replace(settings.currencySymbol, "");
        }
        if (settings.suffixText !== _AutoNumeric.options.suffixText.none) {
          s2 = s2.replace(settings.suffixText, "");
        }
        if (settings.negativeSignCharacter !== _AutoNumeric.options.negativeSignCharacter.hyphen) {
          s2 = s2.replace(settings.negativeSignCharacter, "-");
        }
        return s2;
      }
      /**
       * Converts the ISO numeric string to the locale decimal and minus sign placement.
       * See the "outputFormat" option definition for more details.
       * Note: If the `outputFormat` is set to a number, the custom `negativeSignCharacter` is ignored.
       *
       * @param {string|null} value The unformatted value
       * @param {string|null} locale
       * @param {object} settings
       * @returns {*}
       */
      static _toLocale(value, locale, settings) {
        if (AutoNumericHelper.isNull(locale) || locale === _AutoNumeric.options.outputFormat.string) {
          return value;
        }
        let result2;
        switch (locale) {
          case _AutoNumeric.options.outputFormat.number:
            result2 = Number(value);
            break;
          case _AutoNumeric.options.outputFormat.dotNegative:
            result2 = AutoNumericHelper.isNegative(value) ? value.replace("-", "") + "-" : value;
            break;
          case _AutoNumeric.options.outputFormat.comma:
          case _AutoNumeric.options.outputFormat.negativeComma:
            result2 = value.replace(".", ",");
            break;
          case _AutoNumeric.options.outputFormat.commaNegative:
            result2 = value.replace(".", ",");
            result2 = AutoNumericHelper.isNegative(result2) ? result2.replace("-", "") + "-" : result2;
            break;
          case _AutoNumeric.options.outputFormat.dot:
          case _AutoNumeric.options.outputFormat.negativeDot:
            result2 = value;
            break;
          default:
            AutoNumericHelper.throwError(`The given outputFormat [${locale}] option is not recognized.`);
        }
        if (locale !== _AutoNumeric.options.outputFormat.number && settings.negativeSignCharacter !== "-") {
          result2 = result2.replace("-", settings.negativeSignCharacter);
        }
        return result2;
      }
      /**
       * Modify the negative sign and the decimal character of the given string value to a hyphen (-) and a dot (.) in order to make that value 'typecastable' to a real number.
       *
       * @param {string} s The formatted value
       * @returns {string} The value with the 'normal' minus sign and decimal character
       */
      _modifyNegativeSignAndDecimalCharacterForRawValue(s2) {
        if (this.settings.decimalCharacter !== ".") {
          s2 = s2.replace(this.settings.decimalCharacter, ".");
        }
        if (this.settings.negativeSignCharacter !== "-" && this.settings.isNegativeSignAllowed) {
          s2 = s2.replace(this.settings.negativeSignCharacter, "-");
        }
        if (!s2.match(/\d/)) {
          s2 += "0";
        }
        return s2;
      }
      /**
       * Modify the negative sign and the decimal character to use those defined in the settings.
       *
       * @param {string} s
       * @param {object} settings
       * @returns {string}
       */
      static _modifyNegativeSignAndDecimalCharacterForFormattedValue(s2, settings) {
        if (settings.negativeSignCharacter !== "-") {
          s2 = s2.replace("-", settings.negativeSignCharacter);
        }
        if (settings.decimalCharacter !== ".") {
          s2 = s2.replace(".", settings.decimalCharacter);
        }
        return s2;
      }
      /**
       * Return `true` if the given value is empty or is equal to the negative sign character defined in the given settings.
       *
       * @param {string} value
       * @param {object} settings
       * @returns {boolean}
       * @private
       */
      static _isElementValueEmptyOrOnlyTheNegativeSign(value, settings) {
        return value === "" || value === settings.negativeSignCharacter;
      }
      /**
       * Return the value with the currency symbol and the suffix text ordered according to the given settings.
       *
       * @param {string} value
       * @param {object} settings
       * @param {boolean} signOnEmpty
       * @returns {*}
       * @private
       */
      static _orderValueCurrencySymbolAndSuffixText(value, settings, signOnEmpty) {
        let result2;
        if (settings.emptyInputBehavior === _AutoNumeric.options.emptyInputBehavior.always || signOnEmpty) {
          switch (settings.negativePositiveSignPlacement) {
            case _AutoNumeric.options.negativePositiveSignPlacement.left:
            case _AutoNumeric.options.negativePositiveSignPlacement.prefix:
            case _AutoNumeric.options.negativePositiveSignPlacement.none:
              result2 = value + settings.currencySymbol + settings.suffixText;
              break;
            default:
              result2 = settings.currencySymbol + value + settings.suffixText;
          }
        } else {
          result2 = value;
        }
        return result2;
      }
      /**
       * Modify the input value by adding the group separators, as defined in the settings, and the negative brackets if needed.
       *
       * @param {string} inputValue The formatted value (i.e. with the `decimalCharacter` defined in the settings, not the raw value)
       * @param {object} settings
       * @param {boolean} isFocused
       * @param {number|string|null} currentRawValue The object current raw value (`this.rawValue`)
       * @param {number|string|null} forcedRawValue If this is set, then this rawValue is used instead of the one passed through the `settings` object. This is useful is some very specific cases where we need to set the raw value *after* settings the formatted value, using the `_addGroupSeparators()` method.
       * @returns {*}
       */
      static _addGroupSeparators(inputValue, settings, isFocused, currentRawValue, forcedRawValue = null) {
        let isValueNegative;
        if (!AutoNumericHelper.isNull(forcedRawValue)) {
          isValueNegative = forcedRawValue < 0;
        } else {
          isValueNegative = AutoNumericHelper.isNegative(inputValue, settings.negativeSignCharacter) || AutoNumericHelper.isNegativeWithBrackets(inputValue, settings.firstBracket, settings.lastBracket);
        }
        inputValue = this._stripAllNonNumberCharactersExceptCustomDecimalChar(inputValue, settings, false, isFocused);
        if (this._isElementValueEmptyOrOnlyTheNegativeSign(inputValue, settings)) {
          return this._orderValueCurrencySymbolAndSuffixText(inputValue, settings, true);
        }
        const isZeroOrHasNoValue = AutoNumericHelper.isZeroOrHasNoValue(inputValue);
        if (isValueNegative) {
          inputValue = inputValue.replace("-", "");
        }
        let [integerPart, decimalPart] = inputValue.split(settings.decimalCharacter);
        if (settings.decimalCharacterAlternative && AutoNumericHelper.isUndefined(decimalPart)) {
          [integerPart, decimalPart] = inputValue.split(settings.decimalCharacterAlternative);
        }
        if (settings.digitGroupSeparator !== "") {
          settings.digitalGroupSpacing = settings.digitalGroupSpacing.toString();
          let digitalGroup;
          switch (settings.digitalGroupSpacing) {
            case _AutoNumeric.options.digitalGroupSpacing.twoThree:
              digitalGroup = /(\d)((\d)(\d{2}?)+)$/;
              break;
            case _AutoNumeric.options.digitalGroupSpacing.twoScaled:
              digitalGroup = /(\d)((?:\d{2}){0,2}\d{3}(?:(?:\d{2}){2}\d{3})*?)$/;
              break;
            case _AutoNumeric.options.digitalGroupSpacing.two:
            case _AutoNumeric.options.digitalGroupSpacing.three:
            case _AutoNumeric.options.digitalGroupSpacing.four:
            default:
              digitalGroup = new RegExp(`(\\d)((\\d{${settings.digitalGroupSpacing}}?)+)$`);
          }
          while (digitalGroup.test(integerPart)) {
            integerPart = integerPart.replace(digitalGroup, `$1${settings.digitGroupSeparator}$2`);
          }
        }
        let decimalPlacesToRoundTo;
        if (isFocused) {
          decimalPlacesToRoundTo = settings.decimalPlacesShownOnFocus;
        } else {
          decimalPlacesToRoundTo = settings.decimalPlacesShownOnBlur;
        }
        if (decimalPlacesToRoundTo !== 0 && !AutoNumericHelper.isUndefined(decimalPart)) {
          if (decimalPart.length > decimalPlacesToRoundTo) {
            decimalPart = decimalPart.substring(0, decimalPlacesToRoundTo);
          }
          inputValue = `${integerPart}${settings.decimalCharacter}${decimalPart}`;
        } else {
          inputValue = integerPart;
        }
        inputValue = _AutoNumeric._mergeCurrencySignNegativePositiveSignAndValue(inputValue, settings, isValueNegative, isZeroOrHasNoValue);
        if (AutoNumericHelper.isNull(forcedRawValue)) {
          forcedRawValue = currentRawValue;
        }
        if (settings.negativeBracketsTypeOnBlur !== null && (forcedRawValue < 0 || AutoNumericHelper.isNegativeStrict(inputValue, settings.negativeSignCharacter))) {
          inputValue = this._toggleNegativeBracket(inputValue, settings, isFocused);
        }
        let result2;
        if (settings.suffixText) {
          result2 = `${inputValue}${settings.suffixText}`;
        } else {
          result2 = inputValue;
        }
        return result2;
      }
      /**
       * Return a semi-formatted string where the input value, the negative or positive sign, and the currency symbol are stitched together at the right positions, using the options set in the `settings` object.
       * Note : the `inputValue` is usually not a numeric string since the grouping symbols are already added to it at this point.
       *
       * @param {string} inputValue
       * @param {object} settings
       * @param {boolean} isValueNegative
       * @param {boolean} isZeroOrHasNoValue
       * @returns {*}
       * @throws
       * @private
       */
      static _mergeCurrencySignNegativePositiveSignAndValue(inputValue, settings, isValueNegative, isZeroOrHasNoValue) {
        let signToUse = "";
        if (isValueNegative) {
          signToUse = settings.negativeSignCharacter;
        } else if (settings.showPositiveSign && !isZeroOrHasNoValue) {
          signToUse = settings.positiveSignCharacter;
        }
        let result2;
        if (settings.currencySymbolPlacement === _AutoNumeric.options.currencySymbolPlacement.prefix) {
          if (settings.negativePositiveSignPlacement !== _AutoNumeric.options.negativePositiveSignPlacement.none && (isValueNegative || !isValueNegative && settings.showPositiveSign && !isZeroOrHasNoValue)) {
            switch (settings.negativePositiveSignPlacement) {
              case _AutoNumeric.options.negativePositiveSignPlacement.prefix:
              case _AutoNumeric.options.negativePositiveSignPlacement.left:
                result2 = `${signToUse}${settings.currencySymbol}${inputValue}`;
                break;
              case _AutoNumeric.options.negativePositiveSignPlacement.right:
                result2 = `${settings.currencySymbol}${signToUse}${inputValue}`;
                break;
              case _AutoNumeric.options.negativePositiveSignPlacement.suffix:
                result2 = `${settings.currencySymbol}${inputValue}${signToUse}`;
                break;
            }
          } else {
            result2 = settings.currencySymbol + inputValue;
          }
        } else if (settings.currencySymbolPlacement === _AutoNumeric.options.currencySymbolPlacement.suffix) {
          if (settings.negativePositiveSignPlacement !== _AutoNumeric.options.negativePositiveSignPlacement.none && (isValueNegative || !isValueNegative && settings.showPositiveSign && !isZeroOrHasNoValue)) {
            switch (settings.negativePositiveSignPlacement) {
              case _AutoNumeric.options.negativePositiveSignPlacement.suffix:
              case _AutoNumeric.options.negativePositiveSignPlacement.right:
                result2 = `${inputValue}${settings.currencySymbol}${signToUse}`;
                break;
              case _AutoNumeric.options.negativePositiveSignPlacement.left:
                result2 = `${inputValue}${signToUse}${settings.currencySymbol}`;
                break;
              case _AutoNumeric.options.negativePositiveSignPlacement.prefix:
                result2 = `${signToUse}${inputValue}${settings.currencySymbol}`;
                break;
            }
          } else {
            result2 = inputValue + settings.currencySymbol;
          }
        }
        return result2;
      }
      /**
       * Calculate where to put the caret position on focus if the element content is not selected.
       * This calculation is affected by the `caretPositionOnFocus` option which can be either `null`, `'start'`, `'end'`, `'decimalLeft'` or 'decimalRight'`, and will decide where to put the caret (on the left or right of the value or the decimal character, respectively) :
       * - `null` : the caret position is not forced
       * - `'start'` : the caret is positioned on the left hand side of the value
       * - `'end'` : the caret is positioned on the right hand side of the value
       * - `'decimalLeft'` : the caret is positioned on the left side of the decimal character
       * - `'decimalRight'` : the caret is positioned on the right side of the decimal character
       *
       * @param {string} value The formatted string stripped of the currency symbol and negative/positive sign
       * @returns {number}
       * @throws
       * @private
       */
      _initialCaretPosition(value) {
        if (AutoNumericHelper.isNull(this.settings.caretPositionOnFocus) && this.settings.selectOnFocus === _AutoNumeric.options.selectOnFocus.doNotSelect) {
          AutoNumericHelper.throwError("`_initialCaretPosition()` should never be called when the `caretPositionOnFocus` option is `null`.");
        }
        const isValueNegative = this.rawValue < 0;
        const isZeroOrHasNoValue = AutoNumericHelper.isZeroOrHasNoValue(value);
        const totalLength = value.length;
        let valueSize = 0;
        let integerSize = 0;
        let hasDecimalChar = false;
        let offsetDecimalChar = 0;
        if (this.settings.caretPositionOnFocus !== _AutoNumeric.options.caretPositionOnFocus.start) {
          value = value.replace(this.settings.negativeSignCharacter, "");
          value = value.replace(this.settings.positiveSignCharacter, "");
          value = value.replace(this.settings.currencySymbol, "");
          valueSize = value.length;
          hasDecimalChar = AutoNumericHelper.contains(value, this.settings.decimalCharacter);
          if (this.settings.caretPositionOnFocus === _AutoNumeric.options.caretPositionOnFocus.decimalLeft || this.settings.caretPositionOnFocus === _AutoNumeric.options.caretPositionOnFocus.decimalRight) {
            if (hasDecimalChar) {
              integerSize = value.indexOf(this.settings.decimalCharacter);
              offsetDecimalChar = this.settings.decimalCharacter.length;
            } else {
              integerSize = valueSize;
              offsetDecimalChar = 0;
            }
          }
        }
        let signToUse = "";
        if (isValueNegative) {
          signToUse = this.settings.negativeSignCharacter;
        } else if (this.settings.showPositiveSign && !isZeroOrHasNoValue) {
          signToUse = this.settings.positiveSignCharacter;
        }
        const positiveNegativeSignSize = signToUse.length;
        const currencySymbolSize = this.settings.currencySymbol.length;
        let caretPosition;
        if (this.settings.currencySymbolPlacement === _AutoNumeric.options.currencySymbolPlacement.prefix) {
          if (this.settings.caretPositionOnFocus === _AutoNumeric.options.caretPositionOnFocus.start) {
            if (this.settings.negativePositiveSignPlacement !== _AutoNumeric.options.negativePositiveSignPlacement.none && (isValueNegative || !isValueNegative && this.settings.showPositiveSign && !isZeroOrHasNoValue)) {
              switch (this.settings.negativePositiveSignPlacement) {
                case _AutoNumeric.options.negativePositiveSignPlacement.prefix:
                case _AutoNumeric.options.negativePositiveSignPlacement.left:
                case _AutoNumeric.options.negativePositiveSignPlacement.right:
                  caretPosition = positiveNegativeSignSize + currencySymbolSize;
                  break;
                case _AutoNumeric.options.negativePositiveSignPlacement.suffix:
                  caretPosition = currencySymbolSize;
                  break;
              }
            } else {
              caretPosition = currencySymbolSize;
            }
          } else if (this.settings.caretPositionOnFocus === _AutoNumeric.options.caretPositionOnFocus.end) {
            if (this.settings.negativePositiveSignPlacement !== _AutoNumeric.options.negativePositiveSignPlacement.none && (isValueNegative || !isValueNegative && this.settings.showPositiveSign && !isZeroOrHasNoValue)) {
              switch (this.settings.negativePositiveSignPlacement) {
                case _AutoNumeric.options.negativePositiveSignPlacement.prefix:
                case _AutoNumeric.options.negativePositiveSignPlacement.left:
                case _AutoNumeric.options.negativePositiveSignPlacement.right:
                  caretPosition = totalLength;
                  break;
                case _AutoNumeric.options.negativePositiveSignPlacement.suffix:
                  caretPosition = currencySymbolSize + valueSize;
                  break;
              }
            } else {
              caretPosition = totalLength;
            }
          } else if (this.settings.caretPositionOnFocus === _AutoNumeric.options.caretPositionOnFocus.decimalLeft) {
            if (this.settings.negativePositiveSignPlacement !== _AutoNumeric.options.negativePositiveSignPlacement.none && (isValueNegative || !isValueNegative && this.settings.showPositiveSign && !isZeroOrHasNoValue)) {
              switch (this.settings.negativePositiveSignPlacement) {
                case _AutoNumeric.options.negativePositiveSignPlacement.prefix:
                case _AutoNumeric.options.negativePositiveSignPlacement.left:
                case _AutoNumeric.options.negativePositiveSignPlacement.right:
                  caretPosition = positiveNegativeSignSize + currencySymbolSize + integerSize;
                  break;
                case _AutoNumeric.options.negativePositiveSignPlacement.suffix:
                  caretPosition = currencySymbolSize + integerSize;
                  break;
              }
            } else {
              caretPosition = currencySymbolSize + integerSize;
            }
          } else if (this.settings.caretPositionOnFocus === _AutoNumeric.options.caretPositionOnFocus.decimalRight) {
            if (this.settings.negativePositiveSignPlacement !== _AutoNumeric.options.negativePositiveSignPlacement.none && (isValueNegative || !isValueNegative && this.settings.showPositiveSign && !isZeroOrHasNoValue)) {
              switch (this.settings.negativePositiveSignPlacement) {
                case _AutoNumeric.options.negativePositiveSignPlacement.prefix:
                case _AutoNumeric.options.negativePositiveSignPlacement.left:
                case _AutoNumeric.options.negativePositiveSignPlacement.right:
                  caretPosition = positiveNegativeSignSize + currencySymbolSize + integerSize + offsetDecimalChar;
                  break;
                case _AutoNumeric.options.negativePositiveSignPlacement.suffix:
                  caretPosition = currencySymbolSize + integerSize + offsetDecimalChar;
                  break;
              }
            } else {
              caretPosition = currencySymbolSize + integerSize + offsetDecimalChar;
            }
          }
        } else if (this.settings.currencySymbolPlacement === _AutoNumeric.options.currencySymbolPlacement.suffix) {
          if (this.settings.caretPositionOnFocus === _AutoNumeric.options.caretPositionOnFocus.start) {
            if (this.settings.negativePositiveSignPlacement !== _AutoNumeric.options.negativePositiveSignPlacement.none && (isValueNegative || !isValueNegative && this.settings.showPositiveSign && !isZeroOrHasNoValue)) {
              switch (this.settings.negativePositiveSignPlacement) {
                case _AutoNumeric.options.negativePositiveSignPlacement.suffix:
                case _AutoNumeric.options.negativePositiveSignPlacement.right:
                case _AutoNumeric.options.negativePositiveSignPlacement.left:
                  caretPosition = 0;
                  break;
                case _AutoNumeric.options.negativePositiveSignPlacement.prefix:
                  caretPosition = positiveNegativeSignSize;
                  break;
              }
            } else {
              caretPosition = 0;
            }
          } else if (this.settings.caretPositionOnFocus === _AutoNumeric.options.caretPositionOnFocus.end) {
            if (this.settings.negativePositiveSignPlacement !== _AutoNumeric.options.negativePositiveSignPlacement.none && (isValueNegative || !isValueNegative && this.settings.showPositiveSign && !isZeroOrHasNoValue)) {
              switch (this.settings.negativePositiveSignPlacement) {
                case _AutoNumeric.options.negativePositiveSignPlacement.suffix:
                case _AutoNumeric.options.negativePositiveSignPlacement.right:
                case _AutoNumeric.options.negativePositiveSignPlacement.left:
                  caretPosition = valueSize;
                  break;
                case _AutoNumeric.options.negativePositiveSignPlacement.prefix:
                  caretPosition = positiveNegativeSignSize + valueSize;
                  break;
              }
            } else {
              caretPosition = valueSize;
            }
          } else if (this.settings.caretPositionOnFocus === _AutoNumeric.options.caretPositionOnFocus.decimalLeft) {
            if (this.settings.negativePositiveSignPlacement !== _AutoNumeric.options.negativePositiveSignPlacement.none && (isValueNegative || !isValueNegative && this.settings.showPositiveSign && !isZeroOrHasNoValue)) {
              switch (this.settings.negativePositiveSignPlacement) {
                case _AutoNumeric.options.negativePositiveSignPlacement.suffix:
                case _AutoNumeric.options.negativePositiveSignPlacement.right:
                case _AutoNumeric.options.negativePositiveSignPlacement.left:
                  caretPosition = integerSize;
                  break;
                case _AutoNumeric.options.negativePositiveSignPlacement.prefix:
                  caretPosition = positiveNegativeSignSize + integerSize;
                  break;
              }
            } else {
              caretPosition = integerSize;
            }
          } else if (this.settings.caretPositionOnFocus === _AutoNumeric.options.caretPositionOnFocus.decimalRight) {
            if (this.settings.negativePositiveSignPlacement !== _AutoNumeric.options.negativePositiveSignPlacement.none && (isValueNegative || !isValueNegative && this.settings.showPositiveSign && !isZeroOrHasNoValue)) {
              switch (this.settings.negativePositiveSignPlacement) {
                case _AutoNumeric.options.negativePositiveSignPlacement.suffix:
                case _AutoNumeric.options.negativePositiveSignPlacement.right:
                case _AutoNumeric.options.negativePositiveSignPlacement.left:
                  caretPosition = integerSize + offsetDecimalChar;
                  break;
                case _AutoNumeric.options.negativePositiveSignPlacement.prefix:
                  caretPosition = positiveNegativeSignSize + integerSize + offsetDecimalChar;
                  break;
              }
            } else {
              caretPosition = integerSize + offsetDecimalChar;
            }
          }
        }
        return caretPosition;
      }
      /**
       * Truncate the trailing zeroes to the given number of decimal places
       *
       * @param {string} roundedInputValue
       * @param {int} decimalPlacesNeeded The number of decimal places to keep
       * @returns {string}
       */
      static _truncateZeros(roundedInputValue, decimalPlacesNeeded) {
        let regex;
        switch (decimalPlacesNeeded) {
          case 0:
            regex = /(\.(?:\d*[1-9])?)0*$/;
            break;
          case 1:
            regex = /(\.\d(?:\d*[1-9])?)0*$/;
            break;
          default:
            regex = new RegExp(`(\\.\\d{${decimalPlacesNeeded}}(?:\\d*[1-9])?)0*`);
        }
        roundedInputValue = roundedInputValue.replace(regex, "$1");
        if (decimalPlacesNeeded === 0) {
          roundedInputValue = roundedInputValue.replace(/\.$/, "");
        }
        return roundedInputValue;
      }
      /**
       * Round the given `value` with the number of decimal places to keep for the raw value.
       *
       * @param {string|null} value An unformatted numeric value
       * @param {object} settings
       * @returns {*}
       * @private
       */
      static _roundRawValue(value, settings) {
        return this._roundValue(value, settings, settings.decimalPlacesRawValue);
      }
      /**
       * Round the given `value` with the number of decimal places to show for the element if focused.
       *
       * @param {string|null} value An unformatted numeric value
       * @param {object} settings
       * @returns {*}
       * @private
       */
      static _roundFormattedValueShownOnFocus(value, settings) {
        return this._roundValue(value, settings, Number(settings.decimalPlacesShownOnFocus));
      }
      /**
       * Round the given `value` with the number of decimal places to show for the element if unfocused.
       *
       * @param {string|null} value An unformatted numeric value
       * @param {object} settings
       * @returns {*}
       * @private
       */
      static _roundFormattedValueShownOnBlur(value, settings) {
        return this._roundValue(value, settings, Number(settings.decimalPlacesShownOnBlur));
      }
      /**
       * Round the given `value` with the number of decimal places to show for the element based on the value of isFocused.
       *
       * @param {string|null} value An unformatted numeric value
       * @param {object} settings
       * @param {boolean} isFocused
       * @returns {*}
       * @private
       */
      static _roundFormattedValueShownOnFocusOrBlur(value, settings, isFocused) {
        if (isFocused) {
          return this._roundFormattedValueShownOnFocus(value, settings);
        } else {
          return this._roundFormattedValueShownOnBlur(value, settings);
        }
      }
      /**
       * Round the input value using the rounding method defined in the settings.
       * This function accepts multiple rounding methods. See the documentation for more details about those.
       *
       * Note : This is handled as text since JavaScript math functions can return inaccurate values.
       *
       * @param {string|null} inputValue An unformatted numeric value
       * @param {object} settings
       * @param {int} decimalPlacesToRoundTo
       * @returns {*}
       */
      static _roundValue(inputValue, settings, decimalPlacesToRoundTo) {
        if (AutoNumericHelper.isNull(inputValue)) {
          return inputValue;
        }
        inputValue = inputValue === "" ? "0" : inputValue.toString();
        if (settings.roundingMethod === _AutoNumeric.options.roundingMethod.toNearest05 || settings.roundingMethod === _AutoNumeric.options.roundingMethod.toNearest05Alt || settings.roundingMethod === _AutoNumeric.options.roundingMethod.upToNext05 || settings.roundingMethod === _AutoNumeric.options.roundingMethod.downToNext05) {
          return this._roundCloseTo05(inputValue, settings);
        }
        const [negativeSign, preparedValue] = _AutoNumeric._prepareValueForRounding(inputValue, settings);
        inputValue = preparedValue;
        const decimalCharacterPosition = inputValue.lastIndexOf(".");
        const inputValueHasNoDot = decimalCharacterPosition === -1;
        const [integerPart, decimalPart] = inputValue.split(".");
        const hasDecimals = decimalPart > 0;
        if (!hasDecimals && (settings.allowDecimalPadding === _AutoNumeric.options.allowDecimalPadding.never || settings.allowDecimalPadding === _AutoNumeric.options.allowDecimalPadding.floats)) {
          return Number(inputValue) === 0 ? integerPart : `${negativeSign}${integerPart}`;
        }
        let temporaryDecimalPlacesOverride;
        if (settings.allowDecimalPadding === _AutoNumeric.options.allowDecimalPadding.always || settings.allowDecimalPadding === _AutoNumeric.options.allowDecimalPadding.floats) {
          temporaryDecimalPlacesOverride = decimalPlacesToRoundTo;
        } else if (settings.allowDecimalPadding > 0) {
          temporaryDecimalPlacesOverride = settings.allowDecimalPadding;
        } else {
          temporaryDecimalPlacesOverride = 0;
        }
        const decimalPositionToUse = inputValueHasNoDot ? inputValue.length - 1 : decimalCharacterPosition;
        let checkDecimalPlaces = inputValue.length - 1 - decimalPositionToUse;
        let inputValueRounded = "";
        if (checkDecimalPlaces <= decimalPlacesToRoundTo) {
          inputValueRounded = inputValue;
          if (checkDecimalPlaces < temporaryDecimalPlacesOverride) {
            if (inputValueHasNoDot) {
              inputValueRounded = `${inputValueRounded}${settings.decimalCharacter}`;
            }
            let zeros = "000000";
            while (checkDecimalPlaces < temporaryDecimalPlacesOverride) {
              zeros = zeros.substring(0, temporaryDecimalPlacesOverride - checkDecimalPlaces);
              inputValueRounded += zeros;
              checkDecimalPlaces += zeros.length;
            }
          } else if (checkDecimalPlaces > temporaryDecimalPlacesOverride) {
            inputValueRounded = this._truncateZeros(inputValueRounded, temporaryDecimalPlacesOverride);
          } else if (checkDecimalPlaces === 0 && temporaryDecimalPlacesOverride === 0) {
            inputValueRounded = inputValueRounded.replace(/\.$/, "");
          }
          return Number(inputValueRounded) === 0 ? inputValueRounded : `${negativeSign}${inputValueRounded}`;
        }
        let roundedStrLength;
        if (inputValueHasNoDot) {
          roundedStrLength = decimalPlacesToRoundTo - 1;
        } else {
          roundedStrLength = Number(decimalPlacesToRoundTo) + Number(decimalCharacterPosition);
        }
        const lastDigit = Number(inputValue.charAt(roundedStrLength + 1));
        let inputValueArray = inputValue.substring(0, roundedStrLength + 1).split("");
        let odd;
        if (inputValue.charAt(roundedStrLength) === ".") {
          odd = inputValue.charAt(roundedStrLength - 1) % 2;
        } else {
          odd = inputValue.charAt(roundedStrLength) % 2;
        }
        if (this._shouldRoundUp(lastDigit, settings, negativeSign, odd)) {
          for (let i2 = inputValueArray.length - 1; i2 >= 0; i2 -= 1) {
            if (inputValueArray[i2] !== ".") {
              inputValueArray[i2] = +inputValueArray[i2] + 1;
              if (inputValueArray[i2] < 10) {
                break;
              }
              if (i2 > 0) {
                inputValueArray[i2] = "0";
              }
            }
          }
        }
        inputValueArray = inputValueArray.slice(0, roundedStrLength + 1);
        inputValueRounded = this._truncateZeros(inputValueArray.join(""), temporaryDecimalPlacesOverride);
        return Number(inputValueRounded) === 0 ? inputValueRounded : `${negativeSign}${inputValueRounded}`;
      }
      /**
       * Round the `value` when the rounding method deals with '.05'
       *
       * @param {string} value
       * @param {object} settings
       * @returns {string}
       * @private
       */
      static _roundCloseTo05(value, settings) {
        switch (settings.roundingMethod) {
          case _AutoNumeric.options.roundingMethod.toNearest05:
          case _AutoNumeric.options.roundingMethod.toNearest05Alt:
            value = (Math.round(value * 20) / 20).toString();
            break;
          case _AutoNumeric.options.roundingMethod.upToNext05:
            value = (Math.ceil(value * 20) / 20).toString();
            break;
          default:
            value = (Math.floor(value * 20) / 20).toString();
        }
        let result2;
        if (!AutoNumericHelper.contains(value, ".")) {
          result2 = value + ".00";
        } else if (value.length - value.indexOf(".") < 3) {
          result2 = value + "0";
        } else {
          result2 = value;
        }
        return result2;
      }
      /**
       * Modify the given `value` in order to make it usable for the rest of the rounding function.
       * This convert the `value` to a positive one, trim any leading zeros and make sure it does not start with a leading dot.
       *
       * @param {string} value The unformatted value
       * @param {object} settings
       * @returns {[string, string]}
       * @private
       */
      static _prepareValueForRounding(value, settings) {
        let negativeSign = "";
        if (AutoNumericHelper.isNegativeStrict(value, "-")) {
          negativeSign = "-";
          value = value.replace("-", "");
        }
        if (!value.match(/^\d/)) {
          value = `0${value}`;
        }
        if (Number(value) === 0) {
          negativeSign = "";
        }
        if (Number(value) > 0 && settings.leadingZero !== _AutoNumeric.options.leadingZero.keep || value.length > 0 && settings.leadingZero === _AutoNumeric.options.leadingZero.allow) {
          value = value.replace(/^0*(\d)/, "$1");
        }
        return [negativeSign, value];
      }
      /**
       * Return `true` if a round up should be done given the last digit, the settings and other information about the value.
       *
       * @param {number} lastDigit
       * @param {object} settings
       * @param {string} negativeSign This variable comes from `_prepareValueForRounding()`, which return `'-'` if the initial value was negative
       * @param {number} odd
       * @returns {boolean}
       * @private
       */
      static _shouldRoundUp(lastDigit, settings, negativeSign, odd) {
        return lastDigit > 4 && settings.roundingMethod === _AutoNumeric.options.roundingMethod.halfUpSymmetric || // Round half up symmetric
        lastDigit > 4 && settings.roundingMethod === _AutoNumeric.options.roundingMethod.halfUpAsymmetric && negativeSign === "" || // Round half up asymmetric positive values
        lastDigit > 5 && settings.roundingMethod === _AutoNumeric.options.roundingMethod.halfUpAsymmetric && negativeSign === "-" || // Round half up asymmetric negative values
        lastDigit > 5 && settings.roundingMethod === _AutoNumeric.options.roundingMethod.halfDownSymmetric || // Round half down symmetric
        lastDigit > 5 && settings.roundingMethod === _AutoNumeric.options.roundingMethod.halfDownAsymmetric && negativeSign === "" || // Round half down asymmetric positive values
        lastDigit > 4 && settings.roundingMethod === _AutoNumeric.options.roundingMethod.halfDownAsymmetric && negativeSign === "-" || // Round half down asymmetric negative values
        lastDigit > 5 && settings.roundingMethod === _AutoNumeric.options.roundingMethod.halfEvenBankersRounding || lastDigit === 5 && settings.roundingMethod === _AutoNumeric.options.roundingMethod.halfEvenBankersRounding && odd === 1 || lastDigit > 0 && settings.roundingMethod === _AutoNumeric.options.roundingMethod.toCeilingTowardPositiveInfinity && negativeSign === "" || lastDigit > 0 && settings.roundingMethod === _AutoNumeric.options.roundingMethod.toFloorTowardNegativeInfinity && negativeSign === "-" || lastDigit > 0 && settings.roundingMethod === _AutoNumeric.options.roundingMethod.upRoundAwayFromZero;
      }
      /**
       * Truncates the decimal part of a number to the given number of decimal places `decimalPlacesToRoundTo`.
       *
       * @param {string} value
       * @param {object} settings
       * @param {boolean} isPaste
       * @param {int} decimalPlacesToRoundTo
       * @returns {*}
       */
      static _truncateDecimalPlaces(value, settings, isPaste, decimalPlacesToRoundTo) {
        if (isPaste) {
          value = this._roundFormattedValueShownOnFocus(value, settings);
        }
        const [integerPart, decimalPart] = value.split(settings.decimalCharacter);
        if (decimalPart && decimalPart.length > decimalPlacesToRoundTo) {
          if (decimalPlacesToRoundTo > 0) {
            const modifiedDecimalPart = decimalPart.substring(0, decimalPlacesToRoundTo);
            value = `${integerPart}${settings.decimalCharacter}${modifiedDecimalPart}`;
          } else {
            value = integerPart;
          }
        }
        return value;
      }
      /**
       * Check if the given value is within the `minimumValue` and `maximumValue` range, while using the override options set with `overrideMinMaxLimits`.
       * The minimum and maximum limit test results are returned in an array like `[isMinimumLimitRespected, isMaximumLimitRespected]`.
       *
       * @param {string} value
       * @param {object} settings
       * @returns {[boolean, boolean]}
       */
      static _checkIfInRangeWithOverrideOption(value, settings) {
        if (AutoNumericHelper.isNull(value) && settings.emptyInputBehavior === _AutoNumeric.options.emptyInputBehavior.null || // When the `null` value is accepted as the `rawValue`, the limits are ignored
        settings.overrideMinMaxLimits === _AutoNumeric.options.overrideMinMaxLimits.ignore || settings.overrideMinMaxLimits === _AutoNumeric.options.overrideMinMaxLimits.invalid) {
          return [true, true];
        }
        value = value.toString();
        value = value.replace(",", ".");
        const minParse = AutoNumericHelper.parseStr(settings.minimumValue);
        const maxParse = AutoNumericHelper.parseStr(settings.maximumValue);
        const valParse = AutoNumericHelper.parseStr(value);
        let result2;
        switch (settings.overrideMinMaxLimits) {
          case _AutoNumeric.options.overrideMinMaxLimits.floor:
            result2 = [AutoNumericHelper.testMinMax(minParse, valParse) > -1, true];
            break;
          case _AutoNumeric.options.overrideMinMaxLimits.ceiling:
            result2 = [true, AutoNumericHelper.testMinMax(maxParse, valParse) < 1];
            break;
          default:
            result2 = [AutoNumericHelper.testMinMax(minParse, valParse) > -1, AutoNumericHelper.testMinMax(maxParse, valParse) < 1];
        }
        return result2;
      }
      /**
       * Returns `true` if the given value is within the `minimumValue` and `maximumValue` limits, while using the override options set with `overrideMinMaxLimits`, `false` otherwise
       *
       * @param {string} value
       * @param {object} settings
       * @returns {boolean}
       * @private
       */
      static _isWithinRangeWithOverrideOption(value, settings) {
        const [minTest, maxTest] = this._checkIfInRangeWithOverrideOption(value, settings);
        return minTest && maxTest;
      }
      /**
       * Helper function that prepares the value string for the min/max test
       *
       * @param {string} value
       * @returns {{}}
       * @private
       */
      static _cleanValueForRangeParse(value) {
        value = value.toString().replace(",", ".");
        return AutoNumericHelper.parseStr(value);
      }
      /**
       * Returns `true` is the value is superior or equal to the `minimumValue` limit, discarding any override options
       *
       * @param {string} value
       * @param {object} settings
       * @returns {boolean}
       * @private
       */
      static _isMinimumRangeRespected(value, settings) {
        return AutoNumericHelper.testMinMax(AutoNumericHelper.parseStr(settings.minimumValue), this._cleanValueForRangeParse(value)) > -1;
      }
      /**
       * Returns `true` is the value is inferior or equal to the `maximumValue` limit, discarding any override options
       *
       * @param {string} value
       * @param {object} settings
       * @returns {boolean}
       * @private
       */
      static _isMaximumRangeRespected(value, settings) {
        return AutoNumericHelper.testMinMax(AutoNumericHelper.parseStr(settings.maximumValue), this._cleanValueForRangeParse(value)) < 1;
      }
      /**
       * Helper function that triggers the range events if they are needed
       *
       * @param {boolean} minTest
       * @param {boolean} maxTest
       * @private
       */
      _triggerRangeEvents(minTest, maxTest) {
        if (!minTest) {
          this._triggerEvent(_AutoNumeric.events.minRangeExceeded, this.domElement);
        }
        if (!maxTest) {
          this._triggerEvent(_AutoNumeric.events.maxRangeExceeded, this.domElement);
        }
      }
      /**
       * Set the invalid state on the AutoNumeric element.
       * If the element is not an input, and therefore a contenteditable-enabled element, its validity state cannot be changed.
       * In that case, the invalid css class defined with the `settings.invalidClass` option is added to the element.
       * The 'autoNumeric:invalidValue' event is always sent when this function is called.
       *
       * @private
       */
      _setInvalidState() {
        if (this.isInputElement) {
          AutoNumericHelper.setInvalidState(this.domElement);
        } else {
          this._addCSSClass(this.settings.invalidClass);
        }
        this._triggerEvent(_AutoNumeric.events.invalidValue, this.domElement);
        this.validState = false;
      }
      /**
       * Set the valid state on the AutoNumeric element.
       * If the element is not an input, and therefore a contenteditable-enabled element, its validity state cannot be changed.
       * In that case, the invalid css class defined with the `settings.invalidClass` option is removed.
       * The 'autoNumeric:correctedValue' event is sent if the element state is invalid when this is called.
       *
       * @private
       */
      _setValidState() {
        if (this.isInputElement) {
          AutoNumericHelper.setValidState(this.domElement);
        } else {
          this._removeCSSClass(this.settings.invalidClass);
        }
        if (!this.validState) {
          this._triggerEvent(_AutoNumeric.events.correctedValue, this.domElement);
        }
        this.validState = true;
      }
      /**
       * Sets the valid or invalid state on the DOM element, if the value is within the range set by the minimum and maximum value
       *
       * @param {string} value
       * @private
       */
      _setValidOrInvalidState(value) {
        if (this.settings.overrideMinMaxLimits === _AutoNumeric.options.overrideMinMaxLimits.invalid) {
          const minRangeOk = this.constructor._isMinimumRangeRespected(value, this.settings);
          const maxRangeOk = this.constructor._isMaximumRangeRespected(value, this.settings);
          if (minRangeOk && maxRangeOk) {
            this._setValidState();
          } else {
            this._setInvalidState();
          }
          this._triggerRangeEvents(minRangeOk, maxRangeOk);
        }
      }
      /**
       * Original settings saved for use when the `decimalPlacesShownOnFocus` and `showOnlyNumbersOnFocus` options are used.
       * Those original settings are used exclusively in the `focusin` and `focusout` event handlers.
       */
      _keepAnOriginalSettingsCopy() {
        this.originalDigitGroupSeparator = this.settings.digitGroupSeparator;
        this.originalCurrencySymbol = this.settings.currencySymbol;
        this.originalSuffixText = this.settings.suffixText;
      }
      /**
       * Removes any zeros in excess in the front and back of the given `value`, according to the `settings`.
       * This also manages the cases where the decimal point is on the far left or far right of the `value`.
       *
       * @param {string} value
       * @returns {string|null}
       */
      _trimLeadingAndTrailingZeros(value) {
        if (value === "" || value === null) {
          return value;
        }
        if (this.settings.leadingZero !== _AutoNumeric.options.leadingZero.keep) {
          if (Number(value) === 0) {
            return "0";
          }
          value = value.replace(/^(-)?0+(?=\d)/g, "$1");
        }
        if (AutoNumericHelper.contains(value, ".")) {
          value = value.replace(/(\.[0-9]*?)0+$/, "$1");
        }
        value = value.replace(/\.$/, "");
        return value;
      }
      /**
       * Generate the name for the persistent stored data variable
       * @private
       */
      _setPersistentStorageName() {
        if (this.settings.saveValueToSessionStorage) {
          if (this.domElement.name !== "" && !AutoNumericHelper.isUndefined(this.domElement.name)) {
            this.rawValueStorageName = `${this.storageNamePrefix}${decodeURIComponent(this.domElement.name)}`;
          } else {
            this.rawValueStorageName = `${this.storageNamePrefix}${this.domElement.id}`;
          }
        }
      }
      /**
       * Save the raw Value into sessionStorage or a cookie depending on what the browser is supporting.
       * @private
       */
      _saveValueToPersistentStorage() {
        if (this.settings.saveValueToSessionStorage) {
          sessionStorage.setItem(this.rawValueStorageName, this.rawValue);
        }
      }
      /**
       * Retrieve the raw value from sessionStorage or the cookie depending on what the browser is supporting.
       *
       * @returns {*}
       * @private
       */
      _getValueFromPersistentStorage() {
        if (this.settings.saveValueToSessionStorage) {
          return sessionStorage.getItem(this.rawValueStorageName);
        }
        AutoNumericHelper.warning("`_getValueFromPersistentStorage()` is called but `settings.saveValueToSessionStorage` is false. There must be an error that needs fixing.", this.settings.showWarnings);
        return null;
      }
      /**
       * Remove the raw value data from sessionStorage or the cookie depending on what the browser is supporting.
       * @private
       */
      _removeValueFromPersistentStorage() {
        if (this.settings.saveValueToSessionStorage) {
          sessionStorage.removeItem(this.rawValueStorageName);
        }
      }
      /**
       * Get the default value from the html `value` attribute.
       * Return the empty string if such attribute is not found.
       *
       * @param {HTMLElement} domElement
       *
       * @returns {string}
       * @private
       */
      _getDefaultValue(domElement) {
        const value = domElement.getAttribute("value");
        if (AutoNumericHelper.isNull(value)) {
          return "";
        }
        return value;
      }
      /**
       * Handler for 'focusin' and 'mouseenter' events
       * On focusin, multiple things happens :
       * - If `Alt` is pressed, unformat
       * - Remove the separators if `showOnlyNumbersOnFocus` is set
       * - Depending on `emptyInputBehavior`, reformat the empty formatted value
       * - Display the correct number of decimal places (on focus/blur)
       * - Place the caret correctly if the element is empty
       *
       * Note: On focusin, the `rawValue` is never changed. Only the formatted value can be modified.
       *
       * @param {KeyboardEvent|MouseEvent} e
       * @private
       */
      _onFocusInAndMouseEnter(e2) {
        this.isEditing = false;
        if (!this.formulaMode && this.settings.unformatOnHover && e2.type === "mouseenter" && e2.altKey) {
          this.constructor._unformatAltHovered(this);
          return;
        }
        if (e2.type === "focus") {
          this.isFocused = true;
          this.rawValueOnFocus = this.rawValue;
        }
        if (e2.type === "focus" && this.settings.unformatOnHover && this.hoveredWithAlt) {
          this.constructor._reformatAltHovered(this);
        }
        if (e2.type === "focus" || e2.type === "mouseenter" && !this.isFocused) {
          let elementValueToSet = null;
          if (this.settings.emptyInputBehavior === _AutoNumeric.options.emptyInputBehavior.focus && this.rawValue < 0 && this.settings.negativeBracketsTypeOnBlur !== null && this.settings.isNegativeSignAllowed) {
            elementValueToSet = this.constructor._removeBrackets(AutoNumericHelper.getElementValue(this.domElement), this.settings);
          }
          const rawValueToFormat = this._getRawValueToFormat(this.rawValue);
          if (rawValueToFormat !== "") {
            const roundedValue = this.constructor._roundFormattedValueShownOnFocusOrBlur(rawValueToFormat, this.settings, this.isFocused);
            if (this.settings.showOnlyNumbersOnFocus === _AutoNumeric.options.showOnlyNumbersOnFocus.onlyNumbers) {
              this.settings.digitGroupSeparator = "";
              this.settings.currencySymbol = "";
              this.settings.suffixText = "";
              elementValueToSet = roundedValue.replace(".", this.settings.decimalCharacter);
            } else {
              let formattedValue;
              if (AutoNumericHelper.isNull(roundedValue)) {
                formattedValue = "";
              } else {
                formattedValue = this.constructor._addGroupSeparators(roundedValue.replace(".", this.settings.decimalCharacter), this.settings, this.isFocused, rawValueToFormat);
              }
              elementValueToSet = formattedValue;
            }
          }
          if (AutoNumericHelper.isNull(elementValueToSet)) {
            this.valueOnFocus = "";
          } else {
            this.valueOnFocus = elementValueToSet;
          }
          this.lastVal = this.valueOnFocus;
          const isEmptyValue = this.constructor._isElementValueEmptyOrOnlyTheNegativeSign(this.valueOnFocus, this.settings);
          const orderedValue = this.constructor._orderValueCurrencySymbolAndSuffixText(this.valueOnFocus, this.settings, true);
          const orderedValueTest = isEmptyValue && orderedValue !== "" && this.settings.emptyInputBehavior === _AutoNumeric.options.emptyInputBehavior.focus;
          if (orderedValueTest) {
            elementValueToSet = orderedValue;
          }
          if (!AutoNumericHelper.isNull(elementValueToSet)) {
            this._setElementValue(elementValueToSet);
          }
          if (orderedValueTest && orderedValue === this.settings.currencySymbol && this.settings.currencySymbolPlacement === _AutoNumeric.options.currencySymbolPlacement.suffix) {
            AutoNumericHelper.setElementSelection(e2.target, 0);
          }
        }
      }
      /**
       * Handler for the 'focus' event.
       * We update the info of the focused state in the `this.isFocused` variable when the element gets focused.
       * @private
       */
      _onFocus() {
        if (this.settings.isCancellable) {
          this._saveCancellableValue();
        }
      }
      /**
       * Handler for the 'focusin' event.
       * This is called before the 'focus' event, and is necessary to change the selection on focus under Firefox for instance.
       *
       * @param {Event} e
       * @private
       */
      _onFocusIn(e2) {
        if (this.settings.selectOnFocus) {
          this.select();
        } else {
          if (!AutoNumericHelper.isNull(this.settings.caretPositionOnFocus)) {
            AutoNumericHelper.setElementSelection(e2.target, this._initialCaretPosition(AutoNumericHelper.getElementValue(this.domElement)));
          }
        }
      }
      /**
       * Enter the special 'formula mode' where users can enter a math expression that will be evaluated on blur and `enter`
       * @private
       */
      _enterFormulaMode() {
        if (this.settings.formulaMode) {
          this.formulaMode = true;
          AutoNumericHelper.setElementValue(this.domElement, "=");
          AutoNumericHelper.setElementSelection(this.domElement, 1);
        }
      }
      /**
       * Exit the formula mode
       * Tries to parse and evaluate the math expression, then `set()` the result if it's correct, otherwise reformat with the previous `rawValue`
       * @private
       */
      _exitFormulaMode() {
        let formula = AutoNumericHelper.getElementValue(this.domElement);
        formula = formula.replace(/^\s*=/, "");
        let result2;
        try {
          const ast = new Parser$1(formula, this.settings.decimalCharacter);
          result2 = new Evaluator().evaluate(ast);
        } catch (e2) {
          this._triggerEvent(_AutoNumeric.events.invalidFormula, this.domElement, {
            formula,
            aNElement: this
          });
          this.reformat();
          this.formulaMode = false;
          return;
        }
        this._triggerEvent(_AutoNumeric.events.validFormula, this.domElement, {
          formula,
          result: result2,
          aNElement: this
        });
        this.set(result2);
        this.formulaMode = false;
      }
      /**
       * Returns `true` if the non-printable key is accepted in formula mode
       *
       * @returns {boolean}
       * @private
       */
      _acceptNonPrintableKeysInFormulaMode() {
        return this.eventKey === AutoNumericEnum.keyName.Backspace || this.eventKey === AutoNumericEnum.keyName.Delete || this.eventKey === AutoNumericEnum.keyName.LeftArrow || this.eventKey === AutoNumericEnum.keyName.RightArrow || this.eventKey === AutoNumericEnum.keyName.Home || this.eventKey === AutoNumericEnum.keyName.End;
      }
      /**
       * Handler for 'keydown' events.
       * The user just started pushing any key, hence one event is sent.
       *
       * Note :
       * By default a 'normal' input output those events in the right order when inputting a character key (i.e. 'a') :
       * - keydown
       * - keypress
       * - input
       * - keyup
       *
       * ...when inputting a modifier key (i.e. 'ctrl') :
       * - keydown
       * - keyup
       *
       * If 'delete' or 'backspace' are entered 'normally', the following events are sent :
       * - keydown
       * - input
       * - keyup
       *
       * If 'delete' or 'backspace' are entered continuously (with the key still pressed), the following events are sent :
       * - keydown
       * - input
       * [- keydown
       * - input] x times
       * - keyup
       *
       * If 'enter' is entered and the value has not changed, the following events are sent :
       * - keydown
       * - keypress
       * - keyup
       *
       * If 'enter' is entered and the value has been changed, the following events are sent :
       * - keydown
       * - keypress
       * - change
       * - keyup
       *
       * When a paste is done, the following events are sent :
       * - input (if paste is done with the mouse)
       *
       * - keydown (if paste is done with ctrl+v)
       * - keydown
       * - input
       * - keyup
       * - keyup
       *
       * @param {KeyboardEvent} e
       */
      _onKeydown(e2) {
        this.formatted = false;
        this.isEditing = true;
        if (!this.formulaMode && !this.isFocused && this.settings.unformatOnHover && e2.altKey && this.domElement === AutoNumericHelper.getHoveredElement()) {
          this.constructor._unformatAltHovered(this);
          return;
        }
        this._updateEventKeyInfo(e2);
        this.keydownEventCounter += 1;
        if (this.keydownEventCounter === 1) {
          this.initialValueOnFirstKeydown = AutoNumericHelper.getElementValue(e2.target);
          this.initialRawValueOnFirstKeydown = this.rawValue;
        }
        if (this.formulaMode) {
          if (this.eventKey === AutoNumericEnum.keyName.Esc) {
            this.formulaMode = false;
            this.reformat();
            return;
          }
          if (this.eventKey === AutoNumericEnum.keyName.Enter) {
            this._exitFormulaMode();
            return;
          }
          if (this._acceptNonPrintableKeysInFormulaMode()) {
            return;
          }
        } else {
          if (this.eventKey === AutoNumericEnum.keyName.Equal) {
            this._enterFormulaMode();
            return;
          }
          if (this.settings.modifyValueOnUpDownArrow && (this.eventKey === AutoNumericEnum.keyName.UpArrow || this.eventKey === AutoNumericEnum.keyName.DownArrow)) {
            this.upDownArrowAction(e2);
            return;
          }
        }
        if (this.domElement.readOnly || this.settings.readOnly || this.domElement.disabled) {
          this.processed = true;
          return;
        }
        if (this.eventKey === AutoNumericEnum.keyName.Esc) {
          e2.preventDefault();
          if (this.settings.isCancellable) {
            if (this.rawValue !== this.savedCancellableValue) {
              this.set(this.savedCancellableValue);
              this._triggerEvent(_AutoNumeric.events.native.input, e2.target);
            }
          }
          this.select();
        }
        let targetValue = AutoNumericHelper.getElementValue(e2.target);
        if (this.eventKey === AutoNumericEnum.keyName.Enter && this.rawValue !== this.rawValueOnFocus) {
          this._triggerEvent(_AutoNumeric.events.native.change, e2.target);
          this.valueOnFocus = targetValue;
          this.rawValueOnFocus = this.rawValue;
          if (this.settings.isCancellable) {
            this._saveCancellableValue();
          }
        }
        this._updateInternalProperties(e2);
        if (this._processNonPrintableKeysAndShortcuts(e2)) {
          this.processed = true;
          return;
        }
        if (this.eventKey === AutoNumericEnum.keyName.Backspace || this.eventKey === AutoNumericEnum.keyName.Delete) {
          const isDeletionAllowed = this._processCharacterDeletion(e2);
          this.processed = true;
          if (!isDeletionAllowed) {
            e2.preventDefault();
            return;
          }
          this._formatValue(e2);
          targetValue = AutoNumericHelper.getElementValue(e2.target);
          if (targetValue !== this.lastVal && this.throwInput) {
            this._triggerEvent(_AutoNumeric.events.native.input, e2.target);
            e2.preventDefault();
          }
          this.lastVal = targetValue;
          this.throwInput = true;
        }
      }
      /**
       * Handler for 'keypress' events.
       * The user is still pressing the key, which will output a character (i.e. '2') continuously until he releases the key.
       * Note: 'keypress' events are not sent for delete keys like Backspace/Delete.
       *
       * @param {KeyboardEvent} e
       */
      _onKeypress(e2) {
        if (this.formulaMode) {
          if (this._acceptNonPrintableKeysInFormulaMode()) {
            return;
          }
          if (this.settings.formulaChars.test(this.eventKey)) {
            return;
          } else {
            e2.preventDefault();
          }
          return;
        }
        if (this.eventKey === AutoNumericEnum.keyName.Insert) {
          return;
        }
        const processed = this.processed;
        this._updateInternalProperties(e2);
        if (this._processNonPrintableKeysAndShortcuts(e2)) {
          return;
        }
        if (processed) {
          e2.preventDefault();
          return;
        }
        const isCharacterInsertionAllowed = this._processCharacterInsertion();
        if (isCharacterInsertionAllowed) {
          this._formatValue(e2);
          const targetValue = AutoNumericHelper.getElementValue(e2.target);
          if (targetValue !== this.lastVal && this.throwInput) {
            this._triggerEvent(_AutoNumeric.events.native.input, e2.target);
            e2.preventDefault();
          } else {
            if ((this.eventKey === this.settings.decimalCharacter || this.eventKey === this.settings.decimalCharacterAlternative) && AutoNumericHelper.getElementSelection(e2.target).start === AutoNumericHelper.getElementSelection(e2.target).end && AutoNumericHelper.getElementSelection(e2.target).start === targetValue.indexOf(this.settings.decimalCharacter)) {
              const position = AutoNumericHelper.getElementSelection(e2.target).start + 1;
              AutoNumericHelper.setElementSelection(e2.target, position);
            }
            e2.preventDefault();
          }
          this.lastVal = AutoNumericHelper.getElementValue(e2.target);
          this.throwInput = true;
          this._setValidOrInvalidState(this.rawValue);
          return;
        }
        e2.preventDefault();
      }
      /**
       * Handler for 'keyup' events.
       * The user just released any key, hence one event is sent.
       *
       * @param {KeyboardEvent} e
       */
      _onKeyup(e2) {
        this.isEditing = false;
        this.keydownEventCounter = 0;
        if (this.formulaMode) {
          return;
        }
        if (this.settings.isCancellable && this.eventKey === AutoNumericEnum.keyName.Esc) {
          e2.preventDefault();
          return;
        }
        this._updateEventKeyInfo(e2);
        if (this.eventKey === AutoNumericEnum.keyName.Z || this.eventKey === AutoNumericEnum.keyName.z) {
          if (e2.ctrlKey && e2.shiftKey) {
            e2.preventDefault();
            this._historyTableRedo();
            this._triggerEvent(_AutoNumeric.events.native.input, e2.target);
            this.onGoingRedo = true;
            return;
          } else if (e2.ctrlKey && !e2.shiftKey) {
            if (this.onGoingRedo) {
              this.onGoingRedo = false;
            } else {
              e2.preventDefault();
              this._historyTableUndo();
              this._triggerEvent(_AutoNumeric.events.native.input, e2.target);
              return;
            }
          }
        } else if ((this.eventKey === AutoNumericEnum.keyName.Y || this.eventKey === AutoNumericEnum.keyName.y) && e2.ctrlKey) {
          e2.preventDefault();
          this._historyTableRedo();
          this._triggerEvent(_AutoNumeric.events.native.input, e2.target);
          this.onGoingRedo = true;
          return;
        }
        if (this.onGoingRedo && (e2.ctrlKey || e2.shiftKey)) {
          this.onGoingRedo = false;
        }
        if ((e2.ctrlKey || e2.metaKey) && (this.eventKey === AutoNumericEnum.keyName.X || this.eventKey === AutoNumericEnum.keyName.x)) {
          const caretPosition = AutoNumericHelper.getElementSelection(this.domElement).start;
          const cutNumber = this.constructor._toNumericValue(AutoNumericHelper.getElementValue(e2.target), this.settings);
          this.set(cutNumber);
          this._setCaretPosition(caretPosition);
        }
        if (this.eventKey === AutoNumericEnum.keyName.Alt && this.settings.unformatOnHover && this.hoveredWithAlt) {
          this.constructor._reformatAltHovered(this);
          return;
        }
        if ((e2.ctrlKey || e2.metaKey) && (this.eventKey === AutoNumericEnum.keyName.Backspace || this.eventKey === AutoNumericEnum.keyName.Delete)) {
          const targetValue2 = AutoNumericHelper.getElementValue(e2.target);
          this._setRawValue(this._formatOrUnformatOther(false, targetValue2));
          return;
        }
        this._updateInternalProperties(e2);
        const skip = this._processNonPrintableKeysAndShortcuts(e2);
        delete this.valuePartsBeforePaste;
        const targetValue = AutoNumericHelper.getElementValue(e2.target);
        if (skip || targetValue === "" && this.initialValueOnFirstKeydown === "") {
          return;
        }
        if (targetValue === this.settings.currencySymbol) {
          if (this.settings.currencySymbolPlacement === _AutoNumeric.options.currencySymbolPlacement.suffix) {
            AutoNumericHelper.setElementSelection(e2.target, 0);
          } else {
            AutoNumericHelper.setElementSelection(e2.target, this.settings.currencySymbol.length);
          }
        } else if (this.eventKey === AutoNumericEnum.keyName.Tab) {
          AutoNumericHelper.setElementSelection(e2.target, 0, targetValue.length);
        }
        if (targetValue === this.settings.suffixText || this.rawValue === "" && this.settings.currencySymbol !== "" && this.settings.suffixText !== "") {
          AutoNumericHelper.setElementSelection(e2.target, 0);
        }
        if (this.settings.decimalPlacesShownOnFocus !== null) {
          this._saveValueToPersistentStorage();
        }
        if (!this.formatted) {
          this._formatValue(e2);
        }
        this._setValidOrInvalidState(this.rawValue);
        this._saveRawValueForAndroid();
        if (targetValue !== this.initialValueOnFirstKeydown) {
          this._triggerEvent(_AutoNumeric.events.formatted, e2.target, {
            oldValue: this.initialValueOnFirstKeydown,
            newValue: targetValue,
            oldRawValue: this.initialRawValueOnFirstKeydown,
            newRawValue: this.rawValue,
            isPristine: this.isPristine(false),
            error: null,
            aNElement: this
          });
        }
        if (this.historyTable.length > 1) {
          const selection = AutoNumericHelper.getElementSelection(this.domElement);
          this.selectionStart = selection.start;
          this.selectionEnd = selection.end;
          this.historyTable[this.historyTableIndex].start = this.selectionStart;
          this.historyTable[this.historyTableIndex].end = this.selectionEnd;
        }
      }
      /**
       * On Android Chrome, the `rawValue` is not updated when the user changes the input value.
       * This function updates the `rawValue` accordingly.
       * @private
       */
      _saveRawValueForAndroid() {
        if (this.eventKey === AutoNumericEnum.keyName.AndroidDefault) {
          let normalizedValue = this.constructor._stripAllNonNumberCharactersExceptCustomDecimalChar(this.getFormatted(), this.settings, true, this.isFocused);
          normalizedValue = this.constructor._convertToNumericString(normalizedValue, this.settings);
          this._setRawValue(normalizedValue);
        }
      }
      /**
       * Handler for 'focusout' events
       * On focusout, multiple things happens :
       * - The element value is formatted back if the `Alt` key was pressed,
       * - The element value is formatted back if `showOnlyNumbersOnFocus` was set to only show numbers,
       * - The element value is multiplied by `rawValueDivisor` on `blur`
       *
       * Note: On focusout, the `rawValue` is never changed. Only the formatted value can be modified.
       *
       * @param {Event} e
       */
      _onFocusOutAndMouseLeave(e2) {
        this.isEditing = false;
        if (e2.type === "mouseleave" && this.formulaMode) {
          return;
        }
        if (this.settings.unformatOnHover && e2.type === "mouseleave" && this.hoveredWithAlt) {
          this.constructor._reformatAltHovered(this);
          return;
        }
        if (e2.type === "mouseleave" && !this.isFocused || e2.type === "blur") {
          if (e2.type === "blur" && this.formulaMode) {
            this._exitFormulaMode();
          }
          this._saveValueToPersistentStorage();
          if (this.settings.showOnlyNumbersOnFocus === _AutoNumeric.options.showOnlyNumbersOnFocus.onlyNumbers) {
            this.settings.digitGroupSeparator = this.originalDigitGroupSeparator;
            this.settings.currencySymbol = this.originalCurrencySymbol;
            this.settings.suffixText = this.originalSuffixText;
          }
          const rawValueToFormat = this._getRawValueToFormat(this.rawValue);
          const isRawValueNull = AutoNumericHelper.isNull(rawValueToFormat);
          const [minTest, maxTest] = this.constructor._checkIfInRangeWithOverrideOption(rawValueToFormat, this.settings);
          let elementValueIsAlreadySet = false;
          if (rawValueToFormat !== "" && !isRawValueNull) {
            this._triggerRangeEvents(minTest, maxTest);
            if (this.settings.valuesToStrings && this._checkValuesToStrings(rawValueToFormat)) {
              this._setElementValue(this.settings.valuesToStrings[rawValueToFormat]);
              elementValueIsAlreadySet = true;
            }
          }
          if (!elementValueIsAlreadySet) {
            let value;
            if (isRawValueNull || rawValueToFormat === "") {
              value = rawValueToFormat;
            } else {
              value = String(rawValueToFormat);
            }
            if (rawValueToFormat !== "" && !isRawValueNull) {
              if (minTest && maxTest && !this.constructor._isElementValueEmptyOrOnlyTheNegativeSign(rawValueToFormat, this.settings)) {
                value = this._modifyNegativeSignAndDecimalCharacterForRawValue(value);
                if (this.settings.divisorWhenUnfocused && !AutoNumericHelper.isNull(value)) {
                  value = value / this.settings.divisorWhenUnfocused;
                  value = value.toString();
                }
                value = this.constructor._roundFormattedValueShownOnBlur(value, this.settings);
                value = this.constructor._modifyNegativeSignAndDecimalCharacterForFormattedValue(value, this.settings);
              } else {
                this._triggerRangeEvents(minTest, maxTest);
              }
            } else if (rawValueToFormat === "") {
              switch (this.settings.emptyInputBehavior) {
                case _AutoNumeric.options.emptyInputBehavior.zero:
                  this._setRawValue("0");
                  value = this.constructor._roundValue("0", this.settings, 0);
                  break;
                case _AutoNumeric.options.emptyInputBehavior.min:
                  this._setRawValue(this.settings.minimumValue);
                  value = this.constructor._roundFormattedValueShownOnFocusOrBlur(this.settings.minimumValue, this.settings, this.isFocused);
                  break;
                case _AutoNumeric.options.emptyInputBehavior.max:
                  this._setRawValue(this.settings.maximumValue);
                  value = this.constructor._roundFormattedValueShownOnFocusOrBlur(this.settings.maximumValue, this.settings, this.isFocused);
                  break;
                default:
                  if (AutoNumericHelper.isNumber(this.settings.emptyInputBehavior)) {
                    this._setRawValue(this.settings.emptyInputBehavior);
                    value = this.constructor._roundFormattedValueShownOnFocusOrBlur(this.settings.emptyInputBehavior, this.settings, this.isFocused);
                  }
              }
            }
            let groupedValue = this.constructor._orderValueCurrencySymbolAndSuffixText(value, this.settings, false);
            if (!(this.constructor._isElementValueEmptyOrOnlyTheNegativeSign(value, this.settings) || isRawValueNull && this.settings.emptyInputBehavior === _AutoNumeric.options.emptyInputBehavior.null)) {
              groupedValue = this.constructor._addGroupSeparators(value, this.settings, false, rawValueToFormat);
            }
            if (groupedValue !== rawValueToFormat || rawValueToFormat === "" || // This make sure we get rid on any currency symbol or suffix that might have been added on focus
            this.settings.allowDecimalPadding === _AutoNumeric.options.allowDecimalPadding.never || this.settings.allowDecimalPadding === _AutoNumeric.options.allowDecimalPadding.floats) {
              if (this.settings.symbolWhenUnfocused && rawValueToFormat !== "" && rawValueToFormat !== null) {
                groupedValue = `${groupedValue}${this.settings.symbolWhenUnfocused}`;
              }
              this._setElementValue(groupedValue);
            }
          }
          this._setValidOrInvalidState(this.rawValue);
          if (e2.type === "blur") {
            this._onBlur(e2);
          }
        }
      }
      /**
       * Handler for 'paste' event
       *
       * @param {Event|ClipboardEvent} e
       */
      _onPaste(e2) {
        e2.preventDefault();
        if (this.settings.readOnly || this.domElement.readOnly || this.domElement.disabled) {
          return;
        }
        let rawPastedText;
        if (e2.clipboardData && e2.clipboardData.getData) {
          rawPastedText = e2.clipboardData.getData("text/plain");
        } else {
          AutoNumericHelper.throwError("Unable to retrieve the pasted value. Please use a modern browser (i.e. Firefox or Chromium).");
        }
        let eventTarget;
        if (!e2.target.tagName) {
          eventTarget = e2.explicitOriginalTarget;
        } else {
          eventTarget = e2.target;
        }
        const initialFormattedValue = AutoNumericHelper.getElementValue(eventTarget);
        const selectionStart = eventTarget.selectionStart || 0;
        const selectionEnd = eventTarget.selectionEnd || 0;
        const selectionSize = selectionEnd - selectionStart;
        if (selectionSize === initialFormattedValue.length) {
          const untranslatedPastedText2 = this._preparePastedText(rawPastedText);
          const pastedRawValue = AutoNumericHelper.arabicToLatinNumbers(untranslatedPastedText2, false, false, false);
          if (pastedRawValue === "." || pastedRawValue === "" || pastedRawValue !== "." && !AutoNumericHelper.isNumber(pastedRawValue)) {
            this.formatted = true;
            if (this.settings.onInvalidPaste === _AutoNumeric.options.onInvalidPaste.error) {
              AutoNumericHelper.throwError(`The pasted value '${rawPastedText}' is not a valid paste content.`);
            }
            return;
          }
          this.set(pastedRawValue);
          this.formatted = true;
          this._triggerEvent(_AutoNumeric.events.native.input, eventTarget);
          return;
        }
        const isPasteNegative = AutoNumericHelper.isNegativeStrict(rawPastedText, this.settings.negativeSignCharacter);
        if (isPasteNegative) {
          rawPastedText = rawPastedText.slice(1, rawPastedText.length);
        }
        const untranslatedPastedText = this._preparePastedText(rawPastedText);
        let pastedText;
        if (untranslatedPastedText === ".") {
          pastedText = ".";
        } else {
          pastedText = AutoNumericHelper.arabicToLatinNumbers(untranslatedPastedText, false, false, false);
        }
        if (pastedText !== "." && (!AutoNumericHelper.isNumber(pastedText) || pastedText === "")) {
          this.formatted = true;
          if (this.settings.onInvalidPaste === _AutoNumeric.options.onInvalidPaste.error) {
            AutoNumericHelper.throwError(`The pasted value '${rawPastedText}' is not a valid paste content.`);
          }
          return;
        }
        let caretPositionOnInitialTextAfterPasting;
        let isInitialValueNegative = AutoNumericHelper.isNegativeStrict(this.getNumericString(), this.settings.negativeSignCharacter);
        let isPasteNegativeAndInitialValueIsPositive;
        let result2;
        if (isPasteNegative && !isInitialValueNegative) {
          isInitialValueNegative = true;
          isPasteNegativeAndInitialValueIsPositive = true;
        } else {
          isPasteNegativeAndInitialValueIsPositive = false;
        }
        const leftFormattedPart = initialFormattedValue.slice(0, selectionStart);
        const rightFormattedPart = initialFormattedValue.slice(selectionEnd, initialFormattedValue.length);
        if (selectionStart !== selectionEnd) {
          result2 = this._preparePastedText(leftFormattedPart + rightFormattedPart);
        } else {
          result2 = this._preparePastedText(initialFormattedValue);
        }
        if (isInitialValueNegative) {
          result2 = AutoNumericHelper.setRawNegativeSign(result2);
        }
        caretPositionOnInitialTextAfterPasting = AutoNumericHelper.convertCharacterCountToIndexPosition(AutoNumericHelper.countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, this.settings.decimalCharacter));
        if (isPasteNegativeAndInitialValueIsPositive) {
          caretPositionOnInitialTextAfterPasting++;
        }
        let leftPart = result2.slice(0, caretPositionOnInitialTextAfterPasting);
        let rightPart = result2.slice(caretPositionOnInitialTextAfterPasting, result2.length);
        let leftPartContainedADot = false;
        if (pastedText === ".") {
          if (AutoNumericHelper.contains(leftPart, ".")) {
            leftPartContainedADot = true;
            leftPart = leftPart.replace(".", "");
          }
          rightPart = rightPart.replace(".", "");
        }
        let negativePasteOnNegativeNumber = false;
        if (leftPart === "" && rightPart === "-") {
          leftPart = "-";
          rightPart = "";
          negativePasteOnNegativeNumber = true;
        }
        switch (this.settings.onInvalidPaste) {
          case _AutoNumeric.options.onInvalidPaste.truncate:
          case _AutoNumeric.options.onInvalidPaste.replace:
            const minParse = AutoNumericHelper.parseStr(this.settings.minimumValue);
            const maxParse = AutoNumericHelper.parseStr(this.settings.maximumValue);
            let lastGoodKnownResult = result2;
            let pastedTextIndex = 0;
            let modifiedLeftPart = leftPart;
            while (pastedTextIndex < pastedText.length) {
              modifiedLeftPart += pastedText[pastedTextIndex];
              result2 = modifiedLeftPart + rightPart;
              if (!this.constructor._checkIfInRange(result2, minParse, maxParse)) {
                break;
              }
              lastGoodKnownResult = result2;
              pastedTextIndex++;
            }
            caretPositionOnInitialTextAfterPasting += pastedTextIndex;
            if (negativePasteOnNegativeNumber) caretPositionOnInitialTextAfterPasting++;
            if (this.settings.onInvalidPaste === _AutoNumeric.options.onInvalidPaste.truncate) {
              result2 = lastGoodKnownResult;
              if (leftPartContainedADot) {
                caretPositionOnInitialTextAfterPasting--;
              }
              break;
            }
            let lastGoodKnownResultIndex = caretPositionOnInitialTextAfterPasting;
            const lastGoodKnownResultSize = lastGoodKnownResult.length;
            while (pastedTextIndex < pastedText.length && lastGoodKnownResultIndex < lastGoodKnownResultSize) {
              if (lastGoodKnownResult[lastGoodKnownResultIndex] === ".") {
                lastGoodKnownResultIndex++;
                continue;
              }
              result2 = AutoNumericHelper.replaceCharAt(lastGoodKnownResult, lastGoodKnownResultIndex, pastedText[pastedTextIndex]);
              if (!this.constructor._checkIfInRange(result2, minParse, maxParse)) {
                break;
              }
              lastGoodKnownResult = result2;
              pastedTextIndex++;
              lastGoodKnownResultIndex++;
            }
            caretPositionOnInitialTextAfterPasting = lastGoodKnownResultIndex;
            if (leftPartContainedADot) {
              caretPositionOnInitialTextAfterPasting--;
            }
            result2 = lastGoodKnownResult;
            break;
          case _AutoNumeric.options.onInvalidPaste.error:
          case _AutoNumeric.options.onInvalidPaste.ignore:
          case _AutoNumeric.options.onInvalidPaste.clamp:
          default:
            result2 = `${leftPart}${pastedText}${rightPart}`;
            if (selectionStart === selectionEnd) {
              const indexWherePastedTextHasBeenInserted = AutoNumericHelper.convertCharacterCountToIndexPosition(AutoNumericHelper.countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, this.settings.decimalCharacter));
              caretPositionOnInitialTextAfterPasting = indexWherePastedTextHasBeenInserted + pastedText.length;
            } else if (rightPart === "") {
              caretPositionOnInitialTextAfterPasting = AutoNumericHelper.convertCharacterCountToIndexPosition(AutoNumericHelper.countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, this.settings.decimalCharacter)) + pastedText.length;
              if (negativePasteOnNegativeNumber) caretPositionOnInitialTextAfterPasting++;
            } else {
              const indexSelectionEndInRawValue = AutoNumericHelper.convertCharacterCountToIndexPosition(AutoNumericHelper.countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionEnd, this.settings.decimalCharacter));
              const selectedText = AutoNumericHelper.getElementValue(eventTarget).slice(selectionStart, selectionEnd);
              caretPositionOnInitialTextAfterPasting = indexSelectionEndInRawValue - selectionSize + AutoNumericHelper.countCharInText(this.settings.digitGroupSeparator, selectedText) + pastedText.length;
            }
            if (isPasteNegativeAndInitialValueIsPositive) {
              caretPositionOnInitialTextAfterPasting++;
            }
            if (leftPartContainedADot) {
              caretPositionOnInitialTextAfterPasting--;
            }
        }
        if (!AutoNumericHelper.isNumber(result2) || result2 === "") {
          if (this.settings.onInvalidPaste === _AutoNumeric.options.onInvalidPaste.error) {
            AutoNumericHelper.throwError(`The pasted value '${rawPastedText}' would result into an invalid content '${result2}'.`);
          }
          return;
        }
        let valueHasBeenSet = false;
        let valueHasBeenClamped = false;
        try {
          this.set(result2);
          valueHasBeenSet = true;
        } catch (error) {
          let clampedValue;
          switch (this.settings.onInvalidPaste) {
            case _AutoNumeric.options.onInvalidPaste.clamp:
              clampedValue = AutoNumericHelper.clampToRangeLimits(result2, this.settings);
              try {
                this.set(clampedValue);
              } catch (error2) {
                AutoNumericHelper.throwError(`Fatal error: Unable to set the clamped value '${clampedValue}'.`);
              }
              valueHasBeenClamped = true;
              valueHasBeenSet = true;
              result2 = clampedValue;
              break;
            case _AutoNumeric.options.onInvalidPaste.error:
            case _AutoNumeric.options.onInvalidPaste.truncate:
            case _AutoNumeric.options.onInvalidPaste.replace:
              AutoNumericHelper.throwError(`The pasted value '${rawPastedText}' results in a value '${result2}' that is outside of the minimum [${this.settings.minimumValue}] and maximum [${this.settings.maximumValue}] value range.`);
            case _AutoNumeric.options.onInvalidPaste.ignore:
            default:
              return;
          }
        }
        const targetValue = AutoNumericHelper.getElementValue(eventTarget);
        let caretPositionInFormattedNumber;
        if (valueHasBeenSet) {
          switch (this.settings.onInvalidPaste) {
            case _AutoNumeric.options.onInvalidPaste.clamp:
              if (valueHasBeenClamped) {
                if (this.settings.currencySymbolPlacement === _AutoNumeric.options.currencySymbolPlacement.suffix) {
                  AutoNumericHelper.setElementSelection(eventTarget, targetValue.length - this.settings.currencySymbol.length);
                } else {
                  AutoNumericHelper.setElementSelection(eventTarget, targetValue.length);
                }
                break;
              }
            case _AutoNumeric.options.onInvalidPaste.error:
            case _AutoNumeric.options.onInvalidPaste.ignore:
            case _AutoNumeric.options.onInvalidPaste.truncate:
            case _AutoNumeric.options.onInvalidPaste.replace:
            default:
              caretPositionInFormattedNumber = AutoNumericHelper.findCaretPositionInFormattedNumber(result2, caretPositionOnInitialTextAfterPasting, targetValue, this.settings.decimalCharacter);
              AutoNumericHelper.setElementSelection(eventTarget, caretPositionInFormattedNumber);
          }
        }
        if (valueHasBeenSet && initialFormattedValue !== targetValue) {
          this._triggerEvent(_AutoNumeric.events.native.input, eventTarget);
        }
      }
      /**
       * When focusing out of the input, we check if the value has changed, and if it has, then we send a `change` event (since the native one would have been prevented by `e.preventDefault()` called in the other event listeners).
       * We also update the info of the focused state in the `this.isFocused` variable.
       *
       * @param {Event} e
       */
      _onBlur(e2) {
        this.isFocused = false;
        this.isEditing = false;
        if (AutoNumericHelper.trimPaddedZerosFromDecimalPlaces(this.rawValue) !== AutoNumericHelper.trimPaddedZerosFromDecimalPlaces(this.rawValueOnFocus)) {
          this._triggerEvent(_AutoNumeric.events.native.change, e2.target);
        }
        this.rawValueOnFocus = void 0;
      }
      /**
       * Helper function that DRY the similar behaviors of the mousewheel and up/down arrow keys, which increment/decrement the element value, either by a fixed value, or using the 'progressive' heuristic
       *
       * @param {WheelEvent|KeyboardEvent} e The `wheel` or keyboard event
       * @param {boolean} isUp Defines if the event should increment the value
       * @param {boolean} isDown Defines if the event should decrement the value
       * @param {string|number} step The step to be applied to the increment/decrement action
       * @private
       */
      _wheelAndUpDownActions(e2, isUp, isDown, step) {
        const selectionStart = e2.target.selectionStart || 0;
        const selectionEnd = e2.target.selectionEnd || 0;
        const currentUnformattedValue = this.rawValue;
        let result2;
        if (AutoNumericHelper.isUndefinedOrNullOrEmpty(currentUnformattedValue)) {
          if (this.settings.minimumValue > 0 || this.settings.maximumValue < 0) {
            if (isUp) {
              result2 = this.settings.minimumValue;
            } else {
              result2 = this.settings.maximumValue;
            }
          } else {
            result2 = 0;
          }
        } else {
          result2 = currentUnformattedValue;
        }
        result2 = +result2;
        if (AutoNumericHelper.isNumber(step)) {
          const stepToUse = +step;
          if (isUp) {
            result2 += stepToUse;
          } else if (isDown) {
            result2 -= stepToUse;
          }
        } else {
          if (isUp) {
            result2 = AutoNumericHelper.addAndRoundToNearestAuto(result2, this.settings.decimalPlacesRawValue);
          } else if (isDown) {
            result2 = AutoNumericHelper.subtractAndRoundToNearestAuto(result2, this.settings.decimalPlacesRawValue);
          }
        }
        result2 = AutoNumericHelper.clampToRangeLimits(result2, this.settings);
        if (result2 !== +currentUnformattedValue) {
          this.set(result2);
          this._triggerEvent(_AutoNumeric.events.native.input, e2.target);
        }
        e2.preventDefault();
        this._setSelection(selectionStart, selectionEnd);
      }
      /**
       * Handler for up and down arrow keys
       * Increment or decrement the element value according to the `upDownStep` option chosen
       *
       * @param {KeyboardEvent} e
       */
      upDownArrowAction(e2) {
        if (this.formulaMode || this.settings.readOnly || this.domElement.readOnly || this.domElement.disabled) {
          return;
        }
        let isUp = false;
        let isDown = false;
        if (this.eventKey === AutoNumericEnum.keyName.UpArrow) {
          isUp = true;
        } else if (this.eventKey === AutoNumericEnum.keyName.DownArrow) {
          isDown = true;
        } else {
          AutoNumericHelper.throwError("Something has gone wrong since neither an Up or Down arrow key is detected, but the function was still called!");
        }
        this._wheelAndUpDownActions(e2, isUp, isDown, this.settings.upDownStep);
      }
      /**
       * Handler for 'wheel' event
       *
       * @param {WheelEvent} e
       */
      _onWheel(e2) {
        if (this.formulaMode) {
          return;
        }
        if (this.settings.readOnly || this.domElement.readOnly || this.domElement.disabled) {
          return;
        }
        if (this.settings.modifyValueOnWheel) {
          if (this.settings.wheelOn === _AutoNumeric.options.wheelOn.focus) {
            if (this.isFocused) {
              if (!e2.shiftKey) {
                this.wheelAction(e2);
              }
            } else if (e2.shiftKey) {
              this.wheelAction(e2);
            }
          } else if (this.settings.wheelOn === _AutoNumeric.options.wheelOn.hover) {
            if (!e2.shiftKey) {
              this.wheelAction(e2);
            } else {
              e2.preventDefault();
              window.scrollBy(0, AutoNumericHelper.isNegativeStrict(String(e2.deltaY)) ? -50 : 50);
            }
          } else {
            AutoNumericHelper.throwError("Unknown `wheelOn` option.");
          }
        }
      }
      /**
       * Increment or decrement the element value according to the `wheelStep` option chosen
       *
       * @param {WheelEvent} e The `wheel` event
       */
      wheelAction(e2) {
        this.isWheelEvent = true;
        let isUp = false;
        let isDown = false;
        let isDeltaYZero = false;
        if (AutoNumericHelper.isWheelUpEvent(e2)) {
          isUp = true;
        } else if (AutoNumericHelper.isWheelDownEvent(e2)) {
          isDown = true;
        } else if (AutoNumericHelper.isWheelEventWithZeroDeltaY(e2)) {
          isDeltaYZero = true;
        } else {
          AutoNumericHelper.throwError(`The event is not a 'wheel' event.`);
        }
        if (!isDeltaYZero) {
          this._wheelAndUpDownActions(e2, isUp, isDown, this.settings.wheelStep);
        }
        this.isWheelEvent = false;
      }
      /**
       * Handler for 'drop' event
       *
       * @param {DragEvent} e
       */
      _onDrop(e2) {
        if (this.formulaMode) {
          return;
        }
        this.isDropEvent = true;
        e2.preventDefault();
        const droppedText = e2.dataTransfer.getData("text/plain");
        const cleanedValue = this.unformatOther(droppedText);
        const previousValue = this.rawValue;
        this.set(cleanedValue);
        this.isDropEvent = false;
        const newValue = this.constructor._toNumericValue(cleanedValue, this.settings);
        if (!isNaN(Number(newValue))) {
          if (AutoNumericHelper.trimPaddedZerosFromDecimalPlaces(previousValue) !== AutoNumericHelper.trimPaddedZerosFromDecimalPlaces(newValue)) {
            this._triggerEvent(_AutoNumeric.events.native.change, this.domElement);
          }
        }
      }
      /**
       * Handler for 'submit' events happening on the parent <form> element.
       * If `unformatOnSubmit` is set to `true`, the element value is first unformatted before the form is submitted.
       *
       * @returns {boolean}
       */
      _onFormSubmit() {
        const inputElements = this._getFormAutoNumericChildren(this.parentForm);
        const aNElements = inputElements.map((aNElement) => this.constructor.getAutoNumericElement(aNElement));
        aNElements.forEach((aNElement) => aNElement._unformatOnSubmit());
        return true;
      }
      /**
       * Handler for 'reset' events caught on the parent <form> element.
       * When such event is detected, then every child AutoNumeric elements must format their default value that the browser is forcing upon them.
       *
       * @private
       */
      _onFormReset() {
        const inputElements = this._getFormAutoNumericChildren(this.parentForm);
        const aNElements = inputElements.map((aNElement) => this.constructor.getAutoNumericElement(aNElement));
        aNElements.forEach((aNElement) => {
          const val = this._getDefaultValue(aNElement.node());
          setTimeout(() => aNElement.set(val), 0);
        });
      }
      /**
       * Unformat the element value according to the `unformatOnSubmit` option
       *
       * @private
       */
      _unformatOnSubmit() {
        if (this.settings.unformatOnSubmit) {
          this._setElementValue(this.rawValue);
        }
      }
      /**
       * Listen for the `alt` key keydown event globally, and if the event is caught, unformat the AutoNumeric element that is hovered by the mouse.
       *
       * @param {KeyboardEvent} e
       * @private
       */
      _onKeydownGlobal(e2) {
        if (AutoNumericHelper.character(e2) === AutoNumericEnum.keyName.Alt) {
          const hoveredElement = AutoNumericHelper.getHoveredElement();
          if (_AutoNumeric.isManagedByAutoNumeric(hoveredElement)) {
            const anElement = _AutoNumeric.getAutoNumericElement(hoveredElement);
            if (!anElement.formulaMode && anElement.settings.unformatOnHover) {
              this.constructor._unformatAltHovered(anElement);
            }
          }
        }
      }
      /**
       * Listen for the `alt` key keyup event globally, and if the event is caught, reformat the AutoNumeric element that is hovered by the mouse.
       *
       * @param {KeyboardEvent} e
       * @private
       */
      _onKeyupGlobal(e2) {
        if (AutoNumericHelper.character(e2) === AutoNumericEnum.keyName.Alt) {
          const hoveredElement = AutoNumericHelper.getHoveredElement();
          if (_AutoNumeric.isManagedByAutoNumeric(hoveredElement)) {
            const anElement = _AutoNumeric.getAutoNumericElement(hoveredElement);
            if (anElement.formulaMode || !anElement.settings.unformatOnHover) {
              return;
            }
            this.constructor._reformatAltHovered(anElement);
          }
        }
      }
      /**
       * Return `true` if the DOM element is supported by autoNumeric.
       * A supported element is an element whitelisted in the `allowedTagList`.
       *
       * @returns {boolean}
       * @private
       */
      _isElementTagSupported() {
        if (!AutoNumericHelper.isElement(this.domElement)) {
          AutoNumericHelper.throwError(`The DOM element is not valid, ${this.domElement} given.`);
        }
        return AutoNumericHelper.isInArray(this.domElement.tagName.toLowerCase(), this.allowedTagList);
      }
      /**
       * Return `true` in the DOM element is an <input>.
       *
       * @returns {boolean}
       * @private
       */
      _isInputElement() {
        return this.domElement.tagName.toLowerCase() === "input";
      }
      /**
       * Return `true` if the input type is supported by AutoNumeric
       *
       * @returns {boolean}
       * @throws
       */
      _isInputTypeSupported() {
        return this.domElement.type === "text" || this.domElement.type === "hidden" || this.domElement.type === "tel" || AutoNumericHelper.isUndefinedOrNullOrEmpty(this.domElement.type);
      }
      /**
       * Check if the DOM element is supported by autoNumeric.
       * A supported element is either an <input> element with the correct 'type' attribute, or a tag whitelisted in the `allowedTagList` array.
       * If the check fails, this method throws.
       * This function also sets the info `this.isInputElement` which keep tracks if the DOM element is an <input> or not, and the `this.isContentEditable` if the element has the `contenteditable` attribute set to `true` initially.
       *
       * @throws
       * @private
       */
      _checkElement() {
        const currentElementTag = this.domElement.tagName.toLowerCase();
        if (!this._isElementTagSupported()) {
          AutoNumericHelper.throwError(`The <${currentElementTag}> tag is not supported by autoNumeric`);
        }
        if (this._isInputElement()) {
          if (!this._isInputTypeSupported()) {
            AutoNumericHelper.throwError(`The input type "${this.domElement.type}" is not supported by autoNumeric`);
          }
          this.isInputElement = true;
        } else {
          this.isInputElement = false;
          this.isContentEditable = this._isContentEditable(this.domElement);
        }
      }
      /**
       * Returns `true` if the given DOM element is a contenteditable one (set to `true`)
       *
       * @param {HTMLElement} domElement
       * @returns {boolean}
       */
      _isContentEditable(domElement) {
        return domElement.hasAttribute("contenteditable") && domElement.getAttribute("contenteditable") === "true";
      }
      /**
       * Formats the default value on page load.
       * This is called only if the `formatOnPageLoad` option is set to `true`.
       *
       * @param {number|string|null} forcedInitialValue The value that should be used for initialization, in place on the eventual html one
       */
      _formatDefaultValueOnPageLoad(forcedInitialValue = null) {
        let setValue = true;
        let currentValue;
        if (!AutoNumericHelper.isNull(forcedInitialValue)) {
          currentValue = forcedInitialValue;
        } else {
          currentValue = AutoNumericHelper.getElementValue(this.domElement).trim();
          this.domElement.setAttribute("value", currentValue);
        }
        if (this.isInputElement || this.isContentEditable) {
          const unLocalizedCurrentValue = this.constructor._toNumericValue(currentValue, this.settings);
          if (!this.domElement.hasAttribute("value") || this.domElement.getAttribute("value") === "") {
            if (!isNaN(Number(unLocalizedCurrentValue)) && Infinity !== unLocalizedCurrentValue) {
              this.set(unLocalizedCurrentValue);
              setValue = false;
            } else {
              AutoNumericHelper.throwError(`The value [${currentValue}] used in the input is not a valid value autoNumeric can work with.`);
            }
          } else {
            if (this.settings.defaultValueOverride !== null && this.settings.defaultValueOverride.toString() !== currentValue || this.settings.defaultValueOverride === null && currentValue !== "" && currentValue !== this.domElement.getAttribute("value") || currentValue !== "" && this.domElement.getAttribute("type") === "hidden" && !AutoNumericHelper.isNumber(unLocalizedCurrentValue)) {
              if (this.settings.saveValueToSessionStorage && (this.settings.decimalPlacesShownOnFocus !== null || this.settings.divisorWhenUnfocused)) {
                this._setRawValue(this._getValueFromPersistentStorage());
              }
              if (!this.settings.saveValueToSessionStorage) {
                const toStrip = this.constructor._removeBrackets(currentValue, this.settings);
                if ((this.settings.negativePositiveSignPlacement === _AutoNumeric.options.negativePositiveSignPlacement.suffix || this.settings.negativePositiveSignPlacement !== _AutoNumeric.options.negativePositiveSignPlacement.prefix && this.settings.currencySymbolPlacement === _AutoNumeric.options.currencySymbolPlacement.suffix) && this.settings.negativeSignCharacter !== "" && AutoNumericHelper.isNegative(currentValue, this.settings.negativeSignCharacter)) {
                  this._setRawValue(`-${this.constructor._stripAllNonNumberCharacters(toStrip, this.settings, true, this.isFocused)}`);
                } else {
                  this._setRawValue(this.constructor._stripAllNonNumberCharacters(toStrip, this.settings, true, this.isFocused));
                }
              }
              setValue = false;
            }
          }
          if (currentValue === "") {
            switch (this.settings.emptyInputBehavior) {
              case _AutoNumeric.options.emptyInputBehavior.focus:
              case _AutoNumeric.options.emptyInputBehavior.press:
                break;
              case _AutoNumeric.options.emptyInputBehavior.always:
                this._setElementValue(this.settings.currencySymbol);
                break;
              case _AutoNumeric.options.emptyInputBehavior.min:
                this.set(this.settings.minimumValue);
                break;
              case _AutoNumeric.options.emptyInputBehavior.max:
                this.set(this.settings.maximumValue);
                break;
              case _AutoNumeric.options.emptyInputBehavior.zero:
                this.set("0");
                break;
              case _AutoNumeric.options.emptyInputBehavior.null:
                this.set(null);
                break;
              default:
                this.set(this.settings.emptyInputBehavior);
            }
          } else if (setValue && currentValue === this.domElement.getAttribute("value")) {
            this.set(currentValue);
          }
        } else if (this.settings.defaultValueOverride === null || this.settings.defaultValueOverride === currentValue) {
          this.set(currentValue);
        }
      }
      /**
       * Enhance the user experience by modifying the default `negativePositiveSignPlacement` option depending on `currencySymbol` and `currencySymbolPlacement`.
       *
       * If the user has not set the placement of the negative sign (`negativePositiveSignPlacement`), but has set a currency symbol (`currencySymbol`),
       * then we modify the default value of `negativePositiveSignPlacement` in order to keep the resulting output logical by default :
       * - "$-1,234.56" instead of "-$1,234.56" ({currencySymbol: "$", negativePositiveSignPlacement: "r"})
       * - "-1,234.56$" instead of "1,234.56-$" ({currencySymbol: "$", currencySymbolPlacement: "s", negativePositiveSignPlacement: "p"})
       *
       * @param {object} settings
       */
      static _correctNegativePositiveSignPlacementOption(settings) {
        if (!AutoNumericHelper.isNull(settings.negativePositiveSignPlacement)) {
          return;
        }
        if (!AutoNumericHelper.isUndefined(settings) && AutoNumericHelper.isUndefinedOrNullOrEmpty(settings.negativePositiveSignPlacement) && !AutoNumericHelper.isUndefinedOrNullOrEmpty(settings.currencySymbol)) {
          switch (settings.currencySymbolPlacement) {
            case _AutoNumeric.options.currencySymbolPlacement.suffix:
              settings.negativePositiveSignPlacement = _AutoNumeric.options.negativePositiveSignPlacement.prefix;
              break;
            case _AutoNumeric.options.currencySymbolPlacement.prefix:
              settings.negativePositiveSignPlacement = _AutoNumeric.options.negativePositiveSignPlacement.left;
              break;
          }
        } else {
          settings.negativePositiveSignPlacement = _AutoNumeric.options.negativePositiveSignPlacement.left;
        }
      }
      /**
       * Correct the `caretPositionOnFocus` and `selectOnFocus` options, since setting both leads to a conflict.
       * This method directly modifies the `options` object passed as a parameter, then returns it.
       * It returns `null` if the given option is `null`.
       *
       * @param {object} options The options passed as an argument by the user
       * @returns {object|null}
       * @private
       */
      static _correctCaretPositionOnFocusAndSelectOnFocusOptions(options) {
        if (AutoNumericHelper.isNull(options)) {
          return null;
        }
        if (!AutoNumericHelper.isUndefinedOrNullOrEmpty(options.caretPositionOnFocus) && AutoNumericHelper.isUndefinedOrNullOrEmpty(options.selectOnFocus)) {
          options.selectOnFocus = _AutoNumeric.options.selectOnFocus.doNotSelect;
        }
        if (AutoNumericHelper.isUndefinedOrNullOrEmpty(options.caretPositionOnFocus) && !AutoNumericHelper.isUndefinedOrNullOrEmpty(options.selectOnFocus) && options.selectOnFocus === _AutoNumeric.options.selectOnFocus.select) {
          options.caretPositionOnFocus = _AutoNumeric.options.caretPositionOnFocus.doNoForceCaretPosition;
        }
        return options;
      }
      /**
       * Calculate the number de decimal places to be used by the AutoNumeric object, for each of its state, and for its formatted and raw value.
       * By default, the `rawValue` precision is the same as the formatted value one.
       *
       * This method is called during the AutoNumeric object initialization. This assumes some internal variable state.
       *
       * This method set the following options accordingly to their own value and the mandatory `decimalPlaces` option:
       * - decimalPlacesRawValue     (nullable)
       * - decimalPlacesShownOnBlur  (nullable)
       * - decimalPlacesShownOnFocus (nullable)
       *
       * Note: the `decimalPlaces` option is only used here and only serve to define those three previous options value.
       * AutoNumeric will then *only* use `decimalPlacesRawValue`, `decimalPlacesShownOnBlur` and `decimalPlacesShownOnFocus` from there.
       *
       * This method directly modifies the `settings` object passed as a parameter.
       *
       * @param {object} settings This is an object with the new settings to use.
       * @private
       */
      static _calculateDecimalPlacesOnInit(settings) {
        this._validateDecimalPlacesRawValue(settings);
        if (settings.decimalPlacesShownOnFocus === _AutoNumeric.options.decimalPlacesShownOnFocus.useDefault) {
          settings.decimalPlacesShownOnFocus = settings.decimalPlaces;
        }
        if (settings.decimalPlacesShownOnBlur === _AutoNumeric.options.decimalPlacesShownOnBlur.useDefault) {
          settings.decimalPlacesShownOnBlur = settings.decimalPlaces;
        }
        if (settings.decimalPlacesRawValue === _AutoNumeric.options.decimalPlacesRawValue.useDefault) {
          settings.decimalPlacesRawValue = settings.decimalPlaces;
        }
        let additionalDecimalPlacesRawValue = 0;
        if (settings.rawValueDivisor && settings.rawValueDivisor !== _AutoNumeric.options.rawValueDivisor.none) {
          additionalDecimalPlacesRawValue = String(settings.rawValueDivisor).length - 1;
          if (additionalDecimalPlacesRawValue < 0) {
            additionalDecimalPlacesRawValue = 0;
          }
        }
        settings.decimalPlacesRawValue = Math.max(
          Math.max(settings.decimalPlacesShownOnBlur, settings.decimalPlacesShownOnFocus) + additionalDecimalPlacesRawValue,
          Number(settings.originalDecimalPlacesRawValue) + additionalDecimalPlacesRawValue
        );
      }
      /**
       * Recalculate the number de decimal places to be used by the AutoNumeric object, for each of its state, and for its formatted and raw value.
       * By default, the `rawValue` precision is the same as the formatted value one.
       *
       * This method is close to the one called during initialization, `_calculateDecimalPlacesOnInit()`, but with slight difference so that the `decimalPlaces*` options are correctly updated as needed.
       *
       * This methods set the following options accordingly to their own value and the mandatory `decimalPlaces` option:
       * - decimalPlacesRawValue     (nullable)
       * - decimalPlacesShownOnBlur  (nullable)
       * - decimalPlacesShownOnFocus (nullable)
       *
       * Note: the `decimalPlaces` option is only used here and only serve to define those three previous options value.
       * AutoNumeric will then *only* use `decimalPlacesRawValue`, `decimalPlacesShownOnBlur` and `decimalPlacesShownOnFocus` from there.
       *
       * This methods directly modifies the `settings` object passed as a parameter.
       *
       * @param {object} settings This is an object with the new settings to use.
       * @param {object} currentSettings This is the current settings (`this.settings`) used by the element.
       * @private
       */
      static _calculateDecimalPlacesOnUpdate(settings, currentSettings = null) {
        this._validateDecimalPlacesRawValue(settings);
        if (AutoNumericHelper.isNull(currentSettings)) {
          AutoNumericHelper.throwError(`When updating the settings, the previous ones should be passed as an argument.`);
        }
        const decimalPlacesInOptions = "decimalPlaces" in settings;
        if (!(decimalPlacesInOptions || "decimalPlacesRawValue" in settings || "decimalPlacesShownOnFocus" in settings || "decimalPlacesShownOnBlur" in settings || "rawValueDivisor" in settings)) {
          return;
        }
        if (decimalPlacesInOptions) {
          if (!("decimalPlacesShownOnFocus" in settings) || settings.decimalPlacesShownOnFocus === _AutoNumeric.options.decimalPlacesShownOnFocus.useDefault) {
            settings.decimalPlacesShownOnFocus = settings.decimalPlaces;
          }
          if (!("decimalPlacesShownOnBlur" in settings) || settings.decimalPlacesShownOnBlur === _AutoNumeric.options.decimalPlacesShownOnBlur.useDefault) {
            settings.decimalPlacesShownOnBlur = settings.decimalPlaces;
          }
          if (!("decimalPlacesRawValue" in settings) || settings.decimalPlacesRawValue === _AutoNumeric.options.decimalPlacesRawValue.useDefault) {
            settings.decimalPlacesRawValue = settings.decimalPlaces;
          }
        } else {
          if (AutoNumericHelper.isUndefined(settings.decimalPlacesShownOnFocus)) {
            settings.decimalPlacesShownOnFocus = currentSettings.decimalPlacesShownOnFocus;
          }
          if (AutoNumericHelper.isUndefined(settings.decimalPlacesShownOnBlur)) {
            settings.decimalPlacesShownOnBlur = currentSettings.decimalPlacesShownOnBlur;
          }
        }
        let additionalDecimalPlacesRawValue = 0;
        if (settings.rawValueDivisor && settings.rawValueDivisor !== _AutoNumeric.options.rawValueDivisor.none) {
          additionalDecimalPlacesRawValue = String(settings.rawValueDivisor).length - 1;
          if (additionalDecimalPlacesRawValue < 0) {
            additionalDecimalPlacesRawValue = 0;
          }
        }
        if (!settings.decimalPlaces && !settings.decimalPlacesRawValue) {
          settings.decimalPlacesRawValue = Math.max(
            Math.max(settings.decimalPlacesShownOnBlur, settings.decimalPlacesShownOnFocus) + additionalDecimalPlacesRawValue,
            Number(currentSettings.originalDecimalPlacesRawValue) + additionalDecimalPlacesRawValue
          );
        } else {
          settings.decimalPlacesRawValue = Math.max(
            Math.max(settings.decimalPlacesShownOnBlur, settings.decimalPlacesShownOnFocus) + additionalDecimalPlacesRawValue,
            Number(settings.decimalPlacesRawValue) + additionalDecimalPlacesRawValue
          );
        }
      }
      /**
       * Analyze and save the minimumValue and maximumValue integer size for later uses
       * @private
       */
      _calculateVMinAndVMaxIntegerSizes() {
        let [maximumValueIntegerPart] = this.settings.maximumValue.toString().split(".");
        let [minimumValueIntegerPart] = !this.settings.minimumValue && this.settings.minimumValue !== 0 ? [] : this.settings.minimumValue.toString().split(".");
        maximumValueIntegerPart = maximumValueIntegerPart.replace(this.settings.negativeSignCharacter, "");
        minimumValueIntegerPart = minimumValueIntegerPart.replace(this.settings.negativeSignCharacter, "");
        this.settings.mIntPos = Math.max(maximumValueIntegerPart.length, 1);
        this.settings.mIntNeg = Math.max(minimumValueIntegerPart.length, 1);
      }
      /**
       * Calculate once what are the `valuesToStrings` option keys.
       * @private
       */
      _calculateValuesToStringsKeys() {
        if (this.settings.valuesToStrings) {
          this.valuesToStringsKeys = Object.keys(this.settings.valuesToStrings);
        } else {
          this.valuesToStringsKeys = [];
        }
      }
      /**
       * Caches regular expressions for _stripAllNonNumberCharactersExceptCustomDecimalChar
       *
       * @param {object} settings
       * @param {object} regex
       */
      static _cachesUsualRegularExpressions(settings, regex) {
        let negativeSignReg;
        if (settings.negativeSignCharacter !== _AutoNumeric.options.negativeSignCharacter.hyphen) {
          negativeSignReg = `([-\\${settings.negativeSignCharacter}]?)`;
        } else {
          negativeSignReg = "(-?)";
        }
        regex.aNegRegAutoStrip = negativeSignReg;
        settings.allowedAutoStrip = new RegExp(`[^-0123456789\\${settings.decimalCharacter}]`, "g");
        settings.numRegAutoStrip = new RegExp(`${negativeSignReg}(?:\\${settings.decimalCharacter}?([0-9]+\\${settings.decimalCharacter}[0-9]+)|([0-9]*(?:\\${settings.decimalCharacter}[0-9]*)?))`);
        settings.stripReg = new RegExp(`^${regex.aNegRegAutoStrip}0*([0-9])`);
        settings.formulaChars = new RegExp(`[0-9${settings.decimalCharacter}+\\-*/() ]`);
      }
      /**
       * Modify the user settings to make them 'exploitable' later.
       */
      _transformOptionsValuesToDefaultTypes() {
        for (const key in this.settings) {
          if (Object.prototype.hasOwnProperty.call(this.settings, key)) {
            const value = this.settings[key];
            if (value === "true" || value === "false") {
              this.settings[key] = value === "true";
            }
            if (typeof value === "number") {
              this.settings[key] = value.toString();
            }
          }
        }
      }
      /**
       * Convert the old settings options name to new ones.
       *
       * @param {object} options
       */
      static _convertOldOptionsToNewOnes(options) {
        const oldOptionsConverter = {
          // Old option names, with their corresponding new names
          aSep: "digitGroupSeparator",
          nSep: "showOnlyNumbersOnFocus",
          dGroup: "digitalGroupSpacing",
          aDec: "decimalCharacter",
          altDec: "decimalCharacterAlternative",
          aSign: "currencySymbol",
          pSign: "currencySymbolPlacement",
          pNeg: "negativePositiveSignPlacement",
          aSuffix: "suffixText",
          oLimits: "overrideMinMaxLimits",
          vMax: "maximumValue",
          vMin: "minimumValue",
          mDec: "decimalPlacesOverride",
          eDec: "decimalPlacesShownOnFocus",
          scaleDecimal: "decimalPlacesShownOnBlur",
          aStor: "saveValueToSessionStorage",
          mRound: "roundingMethod",
          aPad: "allowDecimalPadding",
          nBracket: "negativeBracketsTypeOnBlur",
          wEmpty: "emptyInputBehavior",
          lZero: "leadingZero",
          aForm: "formatOnPageLoad",
          sNumber: "selectNumberOnly",
          anDefault: "defaultValueOverride",
          unSetOnSubmit: "unformatOnSubmit",
          outputType: "outputFormat",
          debug: "showWarnings",
          // Current options :
          allowDecimalPadding: true,
          alwaysAllowDecimalCharacter: true,
          caretPositionOnFocus: true,
          createLocalList: true,
          currencySymbol: true,
          currencySymbolPlacement: true,
          decimalCharacter: true,
          decimalCharacterAlternative: true,
          decimalPlaces: true,
          decimalPlacesRawValue: true,
          decimalPlacesShownOnBlur: true,
          decimalPlacesShownOnFocus: true,
          defaultValueOverride: true,
          digitalGroupSpacing: true,
          digitGroupSeparator: true,
          divisorWhenUnfocused: true,
          emptyInputBehavior: true,
          eventBubbles: true,
          eventIsCancelable: true,
          failOnUnknownOption: true,
          formatOnPageLoad: true,
          formulaMode: true,
          historySize: true,
          isCancellable: true,
          leadingZero: true,
          maximumValue: true,
          minimumValue: true,
          modifyValueOnUpDownArrow: true,
          modifyValueOnWheel: true,
          negativeBracketsTypeOnBlur: true,
          negativePositiveSignPlacement: true,
          negativeSignCharacter: true,
          negativePositiveSignBehavior: true,
          noEventListeners: true,
          onInvalidPaste: true,
          outputFormat: true,
          overrideMinMaxLimits: true,
          positiveSignCharacter: true,
          rawValueDivisor: true,
          readOnly: true,
          roundingMethod: true,
          saveValueToSessionStorage: true,
          selectNumberOnly: true,
          selectOnFocus: true,
          serializeSpaces: true,
          showOnlyNumbersOnFocus: true,
          showPositiveSign: true,
          showWarnings: true,
          styleRules: true,
          suffixText: true,
          symbolWhenUnfocused: true,
          upDownStep: true,
          unformatOnHover: true,
          unformatOnSubmit: true,
          valuesToStrings: true,
          watchExternalChanges: true,
          wheelOn: true,
          wheelStep: true,
          // Additional information that are added to the `settings` object :
          //TODO Find a way to exclude those internal data from the settings object (ideally by using another object, or better yet, class attributes) -->
          allowedAutoStrip: true,
          formulaChars: true,
          isNegativeSignAllowed: true,
          isPositiveSignAllowed: true,
          mIntNeg: true,
          mIntPos: true,
          numRegAutoStrip: true,
          originalDecimalPlaces: true,
          originalDecimalPlacesRawValue: true,
          stripReg: true
        };
        for (const option in options) {
          if (Object.prototype.hasOwnProperty.call(options, option)) {
            if (oldOptionsConverter[option] === true) {
              continue;
            }
            if (Object.prototype.hasOwnProperty.call(oldOptionsConverter, option)) {
              AutoNumericHelper.warning(`You are using the deprecated option name '${option}'. Please use '${oldOptionsConverter[option]}' instead from now on. The old option name will be dropped very soon.`, true);
              options[oldOptionsConverter[option]] = options[option];
              delete options[option];
            } else if (options.failOnUnknownOption) {
              AutoNumericHelper.throwError(`Option name '${option}' is unknown. Please fix the options passed to autoNumeric`);
            }
          }
        }
        if ("mDec" in options) {
          AutoNumericHelper.warning("The old `mDec` option has been deprecated in favor of more accurate options ; `decimalPlaces`, `decimalPlacesRawValue`, `decimalPlacesShownOnFocus` and `decimalPlacesShownOnBlur`.", true);
        }
      }
      /**
       * Analyse the settings/options passed by the user, validate and clean them, then set them into `this.settings`.
       * Note: This sets the settings to `null` if somehow the settings objet is undefined or empty
       *       If only `decimalPlaces` is defined in the option, overwrite the other decimalPlaces* options, otherwise, use those options
       *
       * @param {object} options
       * @param {boolean} update - If set to `true`, then the settings already exists and this function only updates them instead of recreating them from scratch
       * @throws
       */
      _setSettings(options, update2 = false) {
        if (update2 || !AutoNumericHelper.isNull(options)) {
          this.constructor._convertOldOptionsToNewOnes(options);
        }
        if (update2) {
          const decimalPlacesRawValueInOptions = "decimalPlacesRawValue" in options;
          if (decimalPlacesRawValueInOptions) {
            this.settings.originalDecimalPlacesRawValue = options.decimalPlacesRawValue;
          }
          const decimalPlacesInOptions = "decimalPlaces" in options;
          if (decimalPlacesInOptions) {
            this.settings.originalDecimalPlaces = options.decimalPlaces;
          }
          this.constructor._calculateDecimalPlacesOnUpdate(options, this.settings);
          this._mergeSettings(options);
        } else {
          this.settings = {};
          this._mergeSettings(this.constructor.getDefaultConfig(), this.domElement.dataset, options, { rawValue: this.defaultRawValue });
          this.caretFix = false;
          this.throwInput = true;
          this.allowedTagList = AutoNumericEnum.allowedTagList;
          this.runOnce = false;
          this.hoveredWithAlt = false;
        }
        this._transformOptionsValuesToDefaultTypes();
        this._runCallbacksFoundInTheSettingsObject();
        this.constructor._correctNegativePositiveSignPlacementOption(this.settings);
        this.constructor._correctCaretPositionOnFocusAndSelectOnFocusOptions(this.settings);
        this.constructor._setNegativePositiveSignPermissions(this.settings);
        if (!update2) {
          if (AutoNumericHelper.isNull(options) || !options.decimalPlaces) {
            this.settings.originalDecimalPlaces = null;
          } else {
            this.settings.originalDecimalPlaces = options.decimalPlaces;
          }
          this.settings.originalDecimalPlacesRawValue = this.settings.decimalPlacesRawValue;
          this.constructor._calculateDecimalPlacesOnInit(this.settings);
        }
        this._calculateVMinAndVMaxIntegerSizes();
        this._setTrailingNegativeSignInfo();
        this.regex = {};
        this.constructor._cachesUsualRegularExpressions(this.settings, this.regex);
        this.constructor._setBrackets(this.settings);
        this._calculateValuesToStringsKeys();
        if (AutoNumericHelper.isEmptyObj(this.settings)) {
          AutoNumericHelper.throwError("Unable to set the settings, those are invalid ; an empty object was given.");
        }
        this.constructor.validate(this.settings, false, options);
        this._keepAnOriginalSettingsCopy();
      }
      /**
       * Define if the negative or positive signs are allowed, and update the given settings object directly.
       *
       * @param {object} settings
       * @private
       */
      static _setNegativePositiveSignPermissions(settings) {
        settings.isNegativeSignAllowed = settings.minimumValue < 0;
        settings.isPositiveSignAllowed = settings.maximumValue >= 0;
      }
      /**
       * Convert the `value` parameter that can either be :
       * - a real number,
       * - a number represented in the scientific notation (i.e. -123.4567e-6)
       * - a string representing a real number, or
       * - a string representing a localized number (with specific group separators and decimal character),
       * ...to a string representing a real 'javascript' number (i.e. '1234' or '1234.567').
       *
       * This function returns `NaN` if such conversion fails.
       *
       * @param {int|float|string} value
       * @param {object} settings
       * @returns {string|NaN}
       */
      static _toNumericValue(value, settings) {
        let result2;
        if (AutoNumericHelper.isNumber(Number(value))) {
          if (!AutoNumericHelper.isNumberStrict(value)) {
            value = String(value).trim();
          }
          result2 = AutoNumericHelper.scientificToDecimal(value);
        } else {
          result2 = this._convertToNumericString(value.toString(), settings);
          if (!AutoNumericHelper.isNumber(Number(result2))) {
            AutoNumericHelper.warning(`The given value "${value}" cannot be converted to a numeric one and therefore cannot be used appropriately.`, settings.showWarnings);
            result2 = NaN;
          }
        }
        return result2;
      }
      /**
       * Return the pasted text that will be used, by stripping most non-numeric characters
       *
       * @param {string} text
       * @returns {string}
       */
      _preparePastedText(text2) {
        return this.constructor._stripAllNonNumberCharacters(text2, this.settings, true, this.isFocused);
      }
      /**
       * Return TRUE if the given value (a number as a string) is within the range set in the settings `minimumValue` and `maximumValue`, FALSE otherwise.
       *
       * @param {string} value
       * @param {object} parsedMinValue Parsed via the `parseStr()` function
       * @param {object} parsedMaxValue Parsed via the `parseStr()` function
       * @returns {boolean}
       */
      static _checkIfInRange(value, parsedMinValue, parsedMaxValue) {
        const parsedValue = AutoNumericHelper.parseStr(value);
        return AutoNumericHelper.testMinMax(parsedMinValue, parsedValue) > -1 && AutoNumericHelper.testMinMax(parsedMaxValue, parsedValue) < 1;
      }
      /**
       * Update the selection values as well as resets the internal state of the current AutoNumeric object.
       * This keeps tracks of the current selection and resets the 'processed' state.
       *
       * Note : This state can change between the keydown, keypress and keyup events, that's why
       *        this function is called on each event handler.
       *
       * @private
       */
      _updateInternalProperties() {
        this.selection = AutoNumericHelper.getElementSelection(this.domElement);
        this.processed = false;
      }
      /**
       * Update the `event.key` attribute that triggered the given event.
       *
       * `event.key` describes:
       * - the key name (if a non-printable character),
       * - or directly the character that result from the key press used to trigger the event.
       *
       * @link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key
       * The key list is described here:
       * @link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values
       *
       * @param {Event|KeyboardEvent} e
       * @private
       */
      _updateEventKeyInfo(e2) {
        this.eventKey = AutoNumericHelper.character(e2);
      }
      /**
       * Save the unformatted element value.
       * This is used in the 'cancellable' feature where the element value is saved on focus and input validation, to be used if the user wants to cancel his modifications by hitting the 'Escape' key.
       *
       * @private
       */
      _saveCancellableValue() {
        this.savedCancellableValue = this.rawValue;
      }
      /**
       * Set the text selection inside the input with the given start and end position.
       *
       * @param {int} start
       * @param {int} end
       * @private
       */
      _setSelection(start2, end2) {
        start2 = Math.max(start2, 0);
        end2 = Math.min(end2, AutoNumericHelper.getElementValue(this.domElement).length);
        this.selection = {
          start: start2,
          end: end2,
          length: end2 - start2
        };
        AutoNumericHelper.setElementSelection(this.domElement, start2, end2);
      }
      /**
       * Set the caret position inside the input at the given position.
       *
       * @param {int} position
       * @private
       */
      _setCaretPosition(position) {
        this._setSelection(position, position);
      }
      /**
       * Return an array containing the string parts located on the left and right side of the caret or selection.
       * Those parts are left 'untouched', i.e. formatted by autoNumeric.
       *
       * @returns {[string, string]} The parts on the left and right of the caret or selection
       * @private
       */
      _getLeftAndRightPartAroundTheSelection() {
        const value = AutoNumericHelper.getElementValue(this.domElement);
        const left2 = value.substring(0, this.selection.start);
        const right2 = value.substring(this.selection.end, value.length);
        return [left2, right2];
      }
      /**
       * Return an array containing the string parts located on the left and right side of the caret or selection.
       * Those parts are unformatted (stripped) of any non-numbers characters, and any trailing negative character is put back on the left hand side of the number.
       *
       * @returns {[string, string]} The parts on the left and right of the caret or selection, unformatted.
       * @private
       */
      _getUnformattedLeftAndRightPartAroundTheSelection() {
        let [left2, right2] = this._getLeftAndRightPartAroundTheSelection();
        if (left2 === "" && right2 === "") {
          return ["", ""];
        }
        let stripZeros = true;
        if ((this.eventKey === AutoNumericEnum.keyName.Hyphen || this.eventKey === AutoNumericEnum.keyName.Minus) && Number(left2) === 0) {
          stripZeros = false;
        }
        if (this.isTrailingNegative && (AutoNumericHelper.isNegative(right2, this.settings.negativeSignCharacter) && // The caret is placed on the left of the negative sign
        !AutoNumericHelper.isNegative(left2, this.settings.negativeSignCharacter) || right2 === "" && // ...or the caret is placed on the far right of the input (Fix issue #481)
        AutoNumericHelper.isNegative(left2, this.settings.negativeSignCharacter, true))) {
          left2 = left2.replace(this.settings.negativeSignCharacter, "");
          right2 = right2.replace(this.settings.negativeSignCharacter, "");
          left2 = left2.replace("-", "");
          right2 = right2.replace("-", "");
          left2 = `-${left2}`;
        }
        left2 = _AutoNumeric._stripAllNonNumberCharactersExceptCustomDecimalChar(left2, this.settings, stripZeros, this.isFocused);
        right2 = _AutoNumeric._stripAllNonNumberCharactersExceptCustomDecimalChar(right2, this.settings, false, this.isFocused);
        return [left2, right2];
      }
      /**
       * Strip parts from excess characters and leading zeros.
       *
       * @param {string} left
       * @param {string} right
       * @returns {[*,*,*]}
       * @private
       */
      _normalizeParts(left2, right2) {
        let stripZeros = true;
        if ((this.eventKey === AutoNumericEnum.keyName.Hyphen || this.eventKey === AutoNumericEnum.keyName.Minus) && Number(left2) === 0) {
          stripZeros = false;
        }
        if (this.isTrailingNegative && AutoNumericHelper.isNegative(right2, this.settings.negativeSignCharacter) && !AutoNumericHelper.isNegative(left2, this.settings.negativeSignCharacter)) {
          left2 = `-${left2}`;
          right2 = right2.replace(this.settings.negativeSignCharacter, "");
        }
        left2 = _AutoNumeric._stripAllNonNumberCharactersExceptCustomDecimalChar(left2, this.settings, stripZeros, this.isFocused);
        right2 = _AutoNumeric._stripAllNonNumberCharactersExceptCustomDecimalChar(right2, this.settings, false, this.isFocused);
        if (this.settings.leadingZero === _AutoNumeric.options.leadingZero.deny && (this.eventKey === AutoNumericEnum.keyName.num0 || this.eventKey === AutoNumericEnum.keyName.numpad0) && Number(left2) === 0 && // If `right` is not empty and the first character is not `decimalCharacter`
        !AutoNumericHelper.contains(left2, this.settings.decimalCharacter) && right2 !== "") {
          left2 = left2.substring(0, left2.length - 1);
        }
        let newValue = left2 + right2;
        if (this.settings.decimalCharacter) {
          const m2 = newValue.match(new RegExp(`^${this.regex.aNegRegAutoStrip}\\${this.settings.decimalCharacter}`));
          if (m2) {
            left2 = left2.replace(m2[1], m2[1] + "0");
            newValue = left2 + right2;
          }
        }
        return [left2, right2, newValue];
      }
      /**
       * Set the formatted element value as well as the `rawValue`.
       * This returns `true` if the element and raw value have been modified, `false` otherwise.
       * This method also adjust the caret position according to the `leadingZero` option and the normalized value. //TODO What about the cursor *selection*?
       *
       * @param {string} left
       * @param {string} right
       * @param {boolean} isPaste
       * @returns {boolean}
       * @private
       */
      _setValueParts(left2, right2, isPaste = false) {
        const [normalizedLeft, normalizedRight, normalizedNewValue] = this._normalizeParts(left2, right2);
        const [minTest, maxTest] = _AutoNumeric._checkIfInRangeWithOverrideOption(normalizedNewValue, this.settings);
        if (minTest && maxTest) {
          const roundedRawValue = _AutoNumeric._truncateDecimalPlaces(normalizedNewValue, this.settings, isPaste, this.settings.decimalPlacesRawValue);
          const testValue = roundedRawValue.replace(this.settings.decimalCharacter, ".");
          if (testValue === "" || testValue === this.settings.negativeSignCharacter) {
            let valueToSetOnEmpty;
            switch (this.settings.emptyInputBehavior) {
              case _AutoNumeric.options.emptyInputBehavior.focus:
              case _AutoNumeric.options.emptyInputBehavior.press:
              case _AutoNumeric.options.emptyInputBehavior.always:
                valueToSetOnEmpty = "";
                break;
              case _AutoNumeric.options.emptyInputBehavior.min:
                valueToSetOnEmpty = this.settings.minimumValue;
                break;
              case _AutoNumeric.options.emptyInputBehavior.max:
                valueToSetOnEmpty = this.settings.maximumValue;
                break;
              case _AutoNumeric.options.emptyInputBehavior.zero:
                valueToSetOnEmpty = "0";
                break;
              case _AutoNumeric.options.emptyInputBehavior.null:
                valueToSetOnEmpty = null;
                break;
              default:
                valueToSetOnEmpty = this.settings.emptyInputBehavior;
            }
            this._setRawValue(valueToSetOnEmpty);
          } else {
            this._setRawValue(this._trimLeadingAndTrailingZeros(testValue));
          }
          const roundedValueToShow = _AutoNumeric._truncateDecimalPlaces(normalizedNewValue, this.settings, isPaste, this.settings.decimalPlacesShownOnFocus);
          let position = normalizedLeft.length;
          if (position > roundedValueToShow.length) {
            position = roundedValueToShow.length;
          }
          if (position === 1 && normalizedLeft === "0" && this.settings.leadingZero === _AutoNumeric.options.leadingZero.deny) {
            if (normalizedRight === "" || normalizedLeft === "0" && normalizedRight !== "") {
              position = 1;
            } else {
              position = 0;
            }
          }
          this._setElementValue(roundedValueToShow, false);
          this._setCaretPosition(position);
          return true;
        }
        this._triggerRangeEvents(minTest, maxTest);
        return false;
      }
      /**
       * Helper function for `_expandSelectionOnSign()`.
       *
       * @returns {Array} Array containing [signPosition, currencySymbolPosition] of a formatted value
       * @private
       */
      _getSignPosition() {
        let result2;
        if (this.settings.currencySymbol) {
          const currencySymbolLen = this.settings.currencySymbol.length;
          const value = AutoNumericHelper.getElementValue(this.domElement);
          if (this.settings.currencySymbolPlacement === _AutoNumeric.options.currencySymbolPlacement.prefix) {
            const hasNeg = this.settings.negativeSignCharacter && value && value.charAt(0) === this.settings.negativeSignCharacter;
            if (hasNeg) {
              result2 = [1, currencySymbolLen + 1];
            } else {
              result2 = [0, currencySymbolLen];
            }
          } else {
            const valueLen = value.length;
            result2 = [valueLen - currencySymbolLen, valueLen];
          }
        } else {
          result2 = [1e3, -1];
        }
        return result2;
      }
      /**
       * Expands selection to cover whole sign
       * Prevents partial deletion/copying/overwriting of a sign
       * @private
       */
      _expandSelectionOnSign() {
        const [signPosition, currencySymbolPosition] = this._getSignPosition();
        const selection = this.selection;
        if (selection.start < currencySymbolPosition && selection.end > signPosition) {
          if ((selection.start < signPosition || selection.end > currencySymbolPosition) && AutoNumericHelper.getElementValue(this.domElement).substring(Math.max(selection.start, signPosition), Math.min(selection.end, currencySymbolPosition)).match(/^\s*$/)) {
            if (selection.start < signPosition) {
              this._setSelection(selection.start, signPosition);
            } else {
              this._setSelection(currencySymbolPosition, selection.end);
            }
          } else {
            this._setSelection(Math.min(selection.start, signPosition), Math.max(selection.end, currencySymbolPosition));
          }
        }
      }
      /**
       * Try to strip pasted value to digits
       */
      _checkPaste() {
        if (this.formatted) {
          return;
        }
        if (!AutoNumericHelper.isUndefined(this.valuePartsBeforePaste)) {
          const oldParts = this.valuePartsBeforePaste;
          const [left2, right2] = this._getLeftAndRightPartAroundTheSelection();
          delete this.valuePartsBeforePaste;
          const modifiedLeftPart = left2.substr(0, oldParts[0].length) + _AutoNumeric._stripAllNonNumberCharactersExceptCustomDecimalChar(left2.substr(oldParts[0].length), this.settings, true, this.isFocused);
          if (!this._setValueParts(modifiedLeftPart, right2, true)) {
            this._setElementValue(oldParts.join(""), false);
            this._setCaretPosition(oldParts[0].length);
          }
        }
      }
      /**
       * Return `true` if the given key should be ignored or not.
       *
       * @param {string} eventKeyName
       * @returns {boolean}
       * @private
       */
      static _shouldSkipEventKey(eventKeyName) {
        const isFnKeys = AutoNumericHelper.isInArray(eventKeyName, AutoNumericEnum.keyName._allFnKeys);
        const isOSKeys = eventKeyName === AutoNumericEnum.keyName.OSLeft || eventKeyName === AutoNumericEnum.keyName.OSRight;
        const isContextMenu = eventKeyName === AutoNumericEnum.keyName.ContextMenu;
        const isSomeNonPrintableKeys = AutoNumericHelper.isInArray(eventKeyName, AutoNumericEnum.keyName._someNonPrintableKeys);
        const isOtherNonPrintableKeys = eventKeyName === AutoNumericEnum.keyName.NumLock || eventKeyName === AutoNumericEnum.keyName.ScrollLock || eventKeyName === AutoNumericEnum.keyName.Insert || eventKeyName === AutoNumericEnum.keyName.Command;
        const isUnrecognizableKeys = eventKeyName === AutoNumericEnum.keyName.Unidentified;
        return isFnKeys || isOSKeys || isContextMenu || isSomeNonPrintableKeys || isUnrecognizableKeys || isOtherNonPrintableKeys;
      }
      /**
       * Process copying, cutting and pasting, as well as undo/redoing and cursor moving.
       * Return `true` if further processing should not be performed.
       *
       * @param {KeyboardEvent} e
       * @returns {boolean}
       * @private
       */
      _processNonPrintableKeysAndShortcuts(e2) {
        if ((e2.ctrlKey || e2.metaKey) && e2.type === "keyup" && !AutoNumericHelper.isUndefined(this.valuePartsBeforePaste) || e2.shiftKey && this.eventKey === AutoNumericEnum.keyName.Insert) {
          this._checkPaste();
          return false;
        }
        if (this.constructor._shouldSkipEventKey(this.eventKey)) {
          return true;
        }
        if ((e2.ctrlKey || e2.metaKey) && this.eventKey === AutoNumericEnum.keyName.a) {
          if (this.settings.selectNumberOnly) {
            e2.preventDefault();
            this.selectNumber();
          }
          return true;
        }
        if ((e2.ctrlKey || e2.metaKey) && (this.eventKey === AutoNumericEnum.keyName.c || this.eventKey === AutoNumericEnum.keyName.v || this.eventKey === AutoNumericEnum.keyName.x)) {
          if (e2.type === "keydown") {
            this._expandSelectionOnSign();
          }
          if (this.eventKey === AutoNumericEnum.keyName.v || this.eventKey === AutoNumericEnum.keyName.Insert) {
            if (e2.type === "keydown" || e2.type === "keypress") {
              if (AutoNumericHelper.isUndefined(this.valuePartsBeforePaste)) {
                this.valuePartsBeforePaste = this._getLeftAndRightPartAroundTheSelection();
              }
            } else {
              this._checkPaste();
            }
          }
          return e2.type === "keydown" || e2.type === "keypress" || this.eventKey === AutoNumericEnum.keyName.c;
        }
        if (e2.ctrlKey || e2.metaKey) {
          return !(this.eventKey === AutoNumericEnum.keyName.Z || this.eventKey === AutoNumericEnum.keyName.z);
        }
        if (this.eventKey === AutoNumericEnum.keyName.LeftArrow || this.eventKey === AutoNumericEnum.keyName.RightArrow) {
          if (e2.type === "keydown" && !e2.shiftKey) {
            const value = AutoNumericHelper.getElementValue(this.domElement);
            if (this.eventKey === AutoNumericEnum.keyName.LeftArrow && (value.charAt(this.selection.start - 2) === this.settings.digitGroupSeparator || value.charAt(this.selection.start - 2) === this.settings.decimalCharacter)) {
              this._setCaretPosition(this.selection.start - 1);
            } else if (this.eventKey === AutoNumericEnum.keyName.RightArrow && (value.charAt(this.selection.start + 1) === this.settings.digitGroupSeparator || value.charAt(this.selection.start + 1) === this.settings.decimalCharacter)) {
              this._setCaretPosition(this.selection.start + 1);
            }
          }
          return true;
        }
        return AutoNumericHelper.isInArray(this.eventKey, AutoNumericEnum.keyName._directionKeys);
      }
      /**
       * Process deletion of characters when the minus sign is to the right of the numeric characters.
       *
       * @param {string[]} leftAndRight The parts on the left and on the right of the caret or selection as an array with [left, right]
       * @returns {string[]} Processed left and right as an array with [left, right]
       * @private
       */
      _processCharacterDeletionIfTrailingNegativeSign([left2, right2]) {
        const value = AutoNumericHelper.getElementValue(this.domElement);
        const isValNegative = AutoNumericHelper.isNegative(value, this.settings.negativeSignCharacter);
        if (this.settings.currencySymbolPlacement === _AutoNumeric.options.currencySymbolPlacement.prefix && this.settings.negativePositiveSignPlacement === _AutoNumeric.options.negativePositiveSignPlacement.suffix) {
          if (this.eventKey === AutoNumericEnum.keyName.Backspace) {
            this.caretFix = this.selection.start >= value.indexOf(this.settings.suffixText) && this.settings.suffixText !== "";
            if (value.charAt(this.selection.start - 1) === "-") {
              left2 = left2.substring(1);
            } else if (this.selection.start <= value.length - this.settings.suffixText.length) {
              left2 = left2.substring(0, left2.length - 1);
            }
          } else {
            this.caretFix = this.selection.start >= value.indexOf(this.settings.suffixText) && this.settings.suffixText !== "";
            if (this.selection.start >= value.indexOf(this.settings.currencySymbol) + this.settings.currencySymbol.length) {
              right2 = right2.substring(1, right2.length);
            }
            if (AutoNumericHelper.isNegative(left2, this.settings.negativeSignCharacter) && value.charAt(this.selection.start) === "-") {
              left2 = left2.substring(1);
            }
          }
        }
        if (this.settings.currencySymbolPlacement === _AutoNumeric.options.currencySymbolPlacement.suffix) {
          switch (this.settings.negativePositiveSignPlacement) {
            case _AutoNumeric.options.negativePositiveSignPlacement.left:
              this.caretFix = this.selection.start >= value.indexOf(this.settings.negativeSignCharacter) + this.settings.negativeSignCharacter.length;
              if (this.eventKey === AutoNumericEnum.keyName.Backspace) {
                if (this.selection.start === value.indexOf(this.settings.negativeSignCharacter) + this.settings.negativeSignCharacter.length && isValNegative) {
                  left2 = left2.substring(1);
                } else if (left2 !== "-" && (this.selection.start <= value.indexOf(this.settings.negativeSignCharacter) || !isValNegative)) {
                  left2 = left2.substring(0, left2.length - 1);
                }
              } else {
                if (left2[0] === "-") {
                  right2 = right2.substring(1);
                }
                if (this.selection.start === value.indexOf(this.settings.negativeSignCharacter) && isValNegative) {
                  left2 = left2.substring(1);
                }
              }
              break;
            case _AutoNumeric.options.negativePositiveSignPlacement.right:
              this.caretFix = this.selection.start >= value.indexOf(this.settings.negativeSignCharacter) + this.settings.negativeSignCharacter.length;
              if (this.eventKey === AutoNumericEnum.keyName.Backspace) {
                if (this.selection.start === value.indexOf(this.settings.negativeSignCharacter) + this.settings.negativeSignCharacter.length) {
                  left2 = left2.substring(1);
                } else if (left2 !== "-" && this.selection.start <= value.indexOf(this.settings.negativeSignCharacter) - this.settings.currencySymbol.length) {
                  left2 = left2.substring(0, left2.length - 1);
                } else if (left2 !== "" && !isValNegative) {
                  left2 = left2.substring(0, left2.length - 1);
                }
              } else {
                this.caretFix = this.selection.start >= value.indexOf(this.settings.currencySymbol) && this.settings.currencySymbol !== "";
                if (this.selection.start === value.indexOf(this.settings.negativeSignCharacter)) {
                  left2 = left2.substring(1);
                }
                right2 = right2.substring(1);
              }
              break;
          }
        }
        return [left2, right2];
      }
      /**
       * Process the deletion of characters.
       * Returns `true` if the deletion is allowed (within the min and max range, according to the `overrideMinMaxLimits` option), `false` otherwise.
       *
       * @param {Event} e
       * @returns {boolean}
       */
      _processCharacterDeletion(e2) {
        let left2;
        let right2;
        if (!this.selection.length) {
          [left2, right2] = this._getUnformattedLeftAndRightPartAroundTheSelection();
          if (left2 === "" && right2 === "") {
            this.throwInput = false;
          }
          if (this.isTrailingNegative && AutoNumericHelper.isNegative(AutoNumericHelper.getElementValue(this.domElement), this.settings.negativeSignCharacter)) {
            [left2, right2] = this._processCharacterDeletionIfTrailingNegativeSign([left2, right2]);
          } else {
            if (this.eventKey === AutoNumericEnum.keyName.Backspace) {
              left2 = left2.substring(0, left2.length - 1);
            } else {
              right2 = right2.substring(1, right2.length);
            }
          }
        } else {
          this._expandSelectionOnSign();
          [left2, right2] = this._getUnformattedLeftAndRightPartAroundTheSelection();
        }
        if (!this.constructor._isWithinRangeWithOverrideOption(`${left2}${right2}`, this.settings)) {
          return false;
        }
        if (AutoNumericHelper.getElementValue(e2.target) === this.settings.currencySymbol) {
          return false;
        }
        this._setValueParts(left2, right2);
        return true;
      }
      /**
       * Return `true` if a decimal character is allowed to be typed.
       * If the number of decimal places shown on focus is zero, then the decimal character is not allowed.
       *
       * @returns {boolean}
       * @private
       */
      _isDecimalCharacterInsertionAllowed() {
        return String(this.settings.decimalPlacesShownOnFocus) !== String(_AutoNumeric.options.decimalPlacesShownOnFocus.none) && String(this.settings.decimalPlaces) !== String(_AutoNumeric.options.decimalPlaces.none);
      }
      /**
       * Return `true` if the key is allowed.
       * This function decides if the key pressed should be dropped or accepted, and modify the value 'on-the-fly' accordingly.
       * //TODO This should use another function in order to separate the test and the modification
       *
       * @returns {boolean}
       */
      _processCharacterInsertion() {
        let [left2, right2] = this._getUnformattedLeftAndRightPartAroundTheSelection();
        if (this.eventKey !== AutoNumericEnum.keyName.AndroidDefault) {
          this.throwInput = true;
        }
        if (this.eventKey === this.settings.decimalCharacter || this.settings.decimalCharacterAlternative && this.eventKey === this.settings.decimalCharacterAlternative) {
          if (!this._isDecimalCharacterInsertionAllowed() || !this.settings.decimalCharacter) {
            return false;
          }
          if (this.settings.alwaysAllowDecimalCharacter) {
            left2 = left2.replace(this.settings.decimalCharacter, "");
            right2 = right2.replace(this.settings.decimalCharacter, "");
          } else {
            if (AutoNumericHelper.contains(left2, this.settings.decimalCharacter)) {
              return true;
            }
            if (right2.indexOf(this.settings.decimalCharacter) > 0) {
              return true;
            }
            if (right2.indexOf(this.settings.decimalCharacter) === 0) {
              right2 = right2.substr(1);
            }
          }
          if (this.settings.negativeSignCharacter && AutoNumericHelper.contains(right2, this.settings.negativeSignCharacter)) {
            left2 = `${this.settings.negativeSignCharacter}${left2}`;
            right2 = right2.replace(this.settings.negativeSignCharacter, "");
          }
          this._setValueParts(left2 + this.settings.decimalCharacter, right2);
          return true;
        }
        if ((this.eventKey === "-" || this.eventKey === "+") && this.settings.isNegativeSignAllowed) {
          if (left2 === "" && AutoNumericHelper.contains(right2, "-")) {
            if (this.settings.negativePositiveSignBehavior || !this.settings.negativePositiveSignBehavior && this.eventKey === "+") {
              right2 = right2.replace("-", "");
            }
          } else if (AutoNumericHelper.isNegativeStrict(left2, "-")) {
            if (this.settings.negativePositiveSignBehavior || !this.settings.negativePositiveSignBehavior && this.eventKey === "+") {
              left2 = left2.replace("-", "");
            }
          } else if (this.settings.negativePositiveSignBehavior || !this.settings.negativePositiveSignBehavior && this.eventKey === "-") {
            left2 = `${this.settings.negativeSignCharacter}${left2}`;
          }
          this._setValueParts(left2, right2);
          return true;
        }
        const eventNumber = Number(this.eventKey);
        if (eventNumber >= 0 && eventNumber <= 9) {
          if (this.settings.isNegativeSignAllowed && left2 === "" && AutoNumericHelper.contains(right2, "-")) {
            left2 = "-";
            right2 = right2.substring(1, right2.length);
          }
          if (this.settings.maximumValue <= 0 && this.settings.minimumValue < this.settings.maximumValue && !AutoNumericHelper.contains(AutoNumericHelper.getElementValue(this.domElement), this.settings.negativeSignCharacter) && this.eventKey !== "0") {
            left2 = `-${left2}`;
          }
          this._setValueParts(`${left2}${this.eventKey}`, right2);
          return true;
        }
        this.throwInput = false;
        return false;
      }
      /**
       * Formatting of just processed value while keeping the cursor position
       *
       * @param {Event} e
       * @private
       */
      _formatValue(e2) {
        const elementValue = AutoNumericHelper.getElementValue(this.domElement);
        let [left2] = this._getUnformattedLeftAndRightPartAroundTheSelection();
        if ((this.settings.digitGroupSeparator === "" || this.settings.digitGroupSeparator !== "" && !AutoNumericHelper.contains(elementValue, this.settings.digitGroupSeparator)) && (this.settings.currencySymbol === "" || this.settings.currencySymbol !== "" && !AutoNumericHelper.contains(elementValue, this.settings.currencySymbol))) {
          let [subParts] = elementValue.split(this.settings.decimalCharacter);
          let negativeSign = "";
          if (AutoNumericHelper.isNegative(subParts, this.settings.negativeSignCharacter)) {
            negativeSign = this.settings.negativeSignCharacter;
            subParts = subParts.replace(this.settings.negativeSignCharacter, "");
            left2 = left2.replace("-", "");
          }
          if (negativeSign === "" && subParts.length > this.settings.mIntPos && left2.charAt(0) === "0") {
            left2 = left2.slice(1);
          }
          if (negativeSign === this.settings.negativeSignCharacter && subParts.length > this.settings.mIntNeg && left2.charAt(0) === "0") {
            left2 = left2.slice(1);
          }
          if (!this.isTrailingNegative) {
            left2 = `${negativeSign}${left2}`;
          }
        }
        const value = this.constructor._addGroupSeparators(elementValue, this.settings, this.isFocused, this.rawValue);
        let position = value.length;
        if (value) {
          const leftAr = left2.split("");
          if ((this.settings.negativePositiveSignPlacement === _AutoNumeric.options.negativePositiveSignPlacement.suffix || this.settings.negativePositiveSignPlacement !== _AutoNumeric.options.negativePositiveSignPlacement.prefix && this.settings.currencySymbolPlacement === _AutoNumeric.options.currencySymbolPlacement.suffix) && leftAr[0] === this.settings.negativeSignCharacter && !this.settings.isNegativeSignAllowed) {
            leftAr.shift();
            if ((this.eventKey === AutoNumericEnum.keyName.Backspace || this.eventKey === AutoNumericEnum.keyName.Delete) && this.caretFix) {
              if (this.settings.currencySymbolPlacement === _AutoNumeric.options.currencySymbolPlacement.suffix && this.settings.negativePositiveSignPlacement === _AutoNumeric.options.negativePositiveSignPlacement.left || this.settings.currencySymbolPlacement === _AutoNumeric.options.currencySymbolPlacement.prefix && this.settings.negativePositiveSignPlacement === _AutoNumeric.options.negativePositiveSignPlacement.suffix) {
                leftAr.push(this.settings.negativeSignCharacter);
                this.caretFix = e2.type === "keydown";
              }
              if (this.settings.currencySymbolPlacement === _AutoNumeric.options.currencySymbolPlacement.suffix && this.settings.negativePositiveSignPlacement === _AutoNumeric.options.negativePositiveSignPlacement.right) {
                const signParts = this.settings.currencySymbol.split("");
                const escapeChr = ["\\", "^", "$", ".", "|", "?", "*", "+", "(", ")", "["];
                const escapedParts = [];
                signParts.forEach((i2, miniParts) => {
                  miniParts = signParts[i2];
                  if (AutoNumericHelper.isInArray(miniParts, escapeChr)) {
                    escapedParts.push("\\" + miniParts);
                  } else {
                    escapedParts.push(miniParts);
                  }
                });
                if (this.eventKey === AutoNumericEnum.keyName.Backspace && this.settings.negativeSignCharacter === "-") {
                  escapedParts.push("-");
                }
                leftAr.push(escapedParts.join(""));
                this.caretFix = e2.type === "keydown";
              }
            }
          }
          for (let i2 = 0; i2 < leftAr.length; i2++) {
            if (!leftAr[i2].match("\\d")) {
              leftAr[i2] = "\\" + leftAr[i2];
            }
          }
          let leftReg;
          if (this.settings.currencySymbolPlacement === _AutoNumeric.options.currencySymbolPlacement.suffix) {
            leftReg = new RegExp(`^.*?${leftAr.join(".*?")}`);
          } else {
            leftReg = new RegExp(`^.*?[${this.settings.currencySymbol}]*${leftAr.join(".*?")}`);
          }
          const newLeft = value.match(leftReg);
          if (newLeft) {
            position = newLeft[0].length;
            if (this.settings.showPositiveSign) {
              if (position === 0 && newLeft.input.charAt(0) === this.settings.positiveSignCharacter) {
                position = newLeft.input.indexOf(this.settings.currencySymbol) === 1 ? this.settings.currencySymbol.length + 1 : 1;
              }
              if (position === 0 && newLeft.input.charAt(this.settings.currencySymbol.length) === this.settings.positiveSignCharacter) {
                position = this.settings.currencySymbol.length + 1;
              }
            }
            if ((position === 0 && value.charAt(0) !== this.settings.negativeSignCharacter || position === 1 && value.charAt(0) === this.settings.negativeSignCharacter) && this.settings.currencySymbol && this.settings.currencySymbolPlacement === _AutoNumeric.options.currencySymbolPlacement.prefix) {
              position = this.settings.currencySymbol.length + (AutoNumericHelper.isNegativeStrict(value, this.settings.negativeSignCharacter) ? 1 : 0);
            }
          } else {
            if (this.settings.currencySymbol && this.settings.currencySymbolPlacement === _AutoNumeric.options.currencySymbolPlacement.suffix) {
              position -= this.settings.currencySymbol.length;
            }
            if (this.settings.suffixText) {
              position -= this.settings.suffixText.length;
            }
          }
        }
        if (value !== elementValue) {
          this._setElementValue(value, false);
          this._setCaretPosition(position);
        }
        this.formatted = true;
      }
      /**
       * Serialize the form child <input> element values to a string, or an Array.
       * The output format is defined with the `formatType` argument.
       * This is loosely based upon http://stackoverflow.com/a/40705993/2834898.
       *
       * @param {HTMLFormElement} form
       * @param {boolean} intoAnArray If `true`, instead of generating a string, it generates an Array.
       * @param {string} formatType If `'unformatted'`, then the AutoNumeric elements values are unformatted, if `'localized'`, then the AutoNumeric elements values are localized, and if `'formatted'`, then the AutoNumeric elements values are kept formatted. In either way, this function does not modify the value of each DOM element, but only affect the value that is returned by that serialize function.
       * @param {string} serializedSpaceCharacter Can either be the '+' character, or the '%20' string.
       * @param {string|null} forcedOutputFormat If set, then this is the format that is used for the localization, instead of the default `outputFormat` option.
       * @returns {string|Array}
       * @private
       */
      static _serialize(form, intoAnArray = false, formatType = "unformatted", serializedSpaceCharacter = "+", forcedOutputFormat = null) {
        const result2 = [];
        if (typeof form === "object" && form.nodeName.toLowerCase() === "form") {
          Array.prototype.slice.call(form.elements).forEach((element) => {
            if (element.name && !element.disabled && ["file", "reset", "submit", "button"].indexOf(element.type) === -1) {
              if (element.type === "select-multiple") {
                Array.prototype.slice.call(element.options).forEach((option) => {
                  if (option.selected) {
                    if (intoAnArray) {
                      result2.push({ name: element.name, value: option.value });
                    } else {
                      result2.push(`${encodeURIComponent(element.name)}=${encodeURIComponent(option.value)}`);
                    }
                  }
                });
              } else if (["checkbox", "radio"].indexOf(element.type) === -1 || element.checked) {
                let valueResult;
                if (this.isManagedByAutoNumeric(element)) {
                  let anObject;
                  switch (formatType) {
                    case "unformatted":
                      anObject = this.getAutoNumericElement(element);
                      if (!AutoNumericHelper.isNull(anObject)) {
                        valueResult = this.unformat(element, anObject.getSettings());
                      }
                      break;
                    case "localized":
                      anObject = this.getAutoNumericElement(element);
                      if (!AutoNumericHelper.isNull(anObject)) {
                        const currentSettings = AutoNumericHelper.cloneObject(anObject.getSettings());
                        if (!AutoNumericHelper.isNull(forcedOutputFormat)) {
                          currentSettings.outputFormat = forcedOutputFormat;
                        }
                        valueResult = this.localize(element, currentSettings);
                      }
                      break;
                    case "formatted":
                    default:
                      valueResult = element.value;
                  }
                } else {
                  valueResult = element.value;
                }
                if (AutoNumericHelper.isUndefined(valueResult)) {
                  AutoNumericHelper.throwError("This error should never be hit. If it has, something really wrong happened!");
                }
                if (intoAnArray) {
                  result2.push({ name: element.name, value: valueResult });
                } else {
                  result2.push(`${encodeURIComponent(element.name)}=${encodeURIComponent(valueResult)}`);
                }
              }
            }
          });
        }
        let finalResult;
        if (intoAnArray) {
          finalResult = result2;
        } else {
          finalResult = result2.join("&");
          if ("+" === serializedSpaceCharacter) {
            finalResult = finalResult.replace(/%20/g, "+");
          }
        }
        return finalResult;
      }
      /**
       * Serialize the form values to a string, outputting numeric strings for each AutoNumeric-managed element values.
       *
       * @param {HTMLFormElement} form
       * @param {string} serializedSpaceCharacter
       * @returns {string}
       */
      static _serializeNumericString(form, serializedSpaceCharacter = "+") {
        return this._serialize(form, false, "unformatted", serializedSpaceCharacter);
      }
      /**
       * Serialize the form values to a string, outputting the formatted value as strings for each AutoNumeric-managed elements.
       *
       * @param {HTMLFormElement} form
       * @param {string} serializedSpaceCharacter
       * @returns {string}
       */
      static _serializeFormatted(form, serializedSpaceCharacter = "+") {
        return this._serialize(form, false, "formatted", serializedSpaceCharacter);
      }
      /**
       * Serialize the form values to a string, outputting localized strings for each AutoNumeric-managed element values.
       *
       * @param {HTMLFormElement} form
       * @param {string} serializedSpaceCharacter
       * @param {string|null} forcedOutputFormat If set, then this is the format that is used for the localization, instead of the default `outputFormat` option.
       * @returns {string}
       */
      static _serializeLocalized(form, serializedSpaceCharacter = "+", forcedOutputFormat = null) {
        return this._serialize(form, false, "localized", serializedSpaceCharacter, forcedOutputFormat);
      }
      /**
       * Generate an Array with the form values, outputting numeric strings for each AutoNumeric-managed element values.
       *
       * @param {HTMLFormElement} form
       * @param {string} serializedSpaceCharacter
       * @returns {Array}
       */
      static _serializeNumericStringArray(form, serializedSpaceCharacter = "+") {
        return this._serialize(form, true, "unformatted", serializedSpaceCharacter);
      }
      /**
       * Generate an Array with the form values, outputting the formatted value as strings for each AutoNumeric-managed elements.
       *
       * @param {HTMLFormElement} form
       * @param {string} serializedSpaceCharacter
       * @returns {Array}
       */
      static _serializeFormattedArray(form, serializedSpaceCharacter = "+") {
        return this._serialize(form, true, "formatted", serializedSpaceCharacter);
      }
      /**
       * Generate an Array with the form values, outputting localized strings for each AutoNumeric-managed element values.
       *
       * @param {HTMLFormElement} form
       * @param {string} serializedSpaceCharacter
       * @param {string|null} forcedOutputFormat If set, then this is the format that is used for the localization, instead of the default `outputFormat` option.
       * @returns {Array}
       */
      static _serializeLocalizedArray(form, serializedSpaceCharacter = "+", forcedOutputFormat = null) {
        return this._serialize(form, true, "localized", serializedSpaceCharacter, forcedOutputFormat);
      }
    };
    __publicField(_AutoNumeric, "options");
    // Those static declarations are only used by the IDE, to prevent error messages not finding those fields declarations
    __publicField(_AutoNumeric, "events");
    __publicField(_AutoNumeric, "defaultSettings");
    __publicField(_AutoNumeric, "predefinedOptions");
    let AutoNumeric = _AutoNumeric;
    AutoNumeric.multiple = (arg1, initialValue = null, options = null) => {
      const result2 = [];
      if (AutoNumericHelper.isObject(initialValue)) {
        options = initialValue;
        initialValue = null;
      }
      if (AutoNumericHelper.isString(arg1)) {
        arg1 = [...document.querySelectorAll(arg1)];
      } else if (AutoNumericHelper.isObject(arg1)) {
        if (!Object.prototype.hasOwnProperty.call(arg1, "rootElement")) {
          AutoNumericHelper.throwError(`The object passed to the 'multiple' function is invalid ; no 'rootElement' attribute found.`);
        }
        const elements2 = [...arg1.rootElement.querySelectorAll("input")];
        if (Object.prototype.hasOwnProperty.call(arg1, "exclude")) {
          if (!Array.isArray(arg1.exclude)) {
            AutoNumericHelper.throwError(`The 'exclude' array passed to the 'multiple' function is invalid.`);
          }
          arg1 = AutoNumericHelper.filterOut(elements2, arg1.exclude);
        } else {
          arg1 = elements2;
        }
      } else if (!AutoNumericHelper.isArray(arg1)) {
        AutoNumericHelper.throwError(`The given parameters to the 'multiple' function are invalid.`);
      }
      if (arg1.length === 0) {
        let showWarnings = true;
        if (!AutoNumericHelper.isNull(options) && AutoNumericHelper.isBoolean(options.showWarnings)) {
          showWarnings = options.showWarnings;
        }
        AutoNumericHelper.warning(`No valid DOM elements were given hence no AutoNumeric objects were instantiated.`, showWarnings);
        return [];
      }
      const isInitialValueArray = AutoNumericHelper.isArray(initialValue);
      const isInitialValueArrayAndNotEmpty = isInitialValueArray && initialValue.length >= 1;
      let secondArgumentIsInitialValueArray = false;
      let secondArgumentIsOptionArray = false;
      if (isInitialValueArrayAndNotEmpty) {
        const typeOfFirstArrayElement = typeof Number(initialValue[0]);
        secondArgumentIsInitialValueArray = typeOfFirstArrayElement === "number" && !isNaN(Number(initialValue[0]));
        if (!secondArgumentIsInitialValueArray) {
          if (typeOfFirstArrayElement === "string" || isNaN(typeOfFirstArrayElement) || typeOfFirstArrayElement === "object") {
            secondArgumentIsOptionArray = true;
          }
        }
      }
      const isOptionsArrayAndNotEmpty = AutoNumericHelper.isArray(options) && options.length >= 1;
      let thirdArgumentIsOptionArray = false;
      if (isOptionsArrayAndNotEmpty) {
        const typeOfFirstArrayElement = typeof options[0];
        if (typeOfFirstArrayElement === "string" || typeOfFirstArrayElement === "object") {
          thirdArgumentIsOptionArray = true;
        }
      }
      let optionsToUse;
      if (secondArgumentIsOptionArray) {
        optionsToUse = AutoNumeric.mergeOptions(initialValue);
      } else if (thirdArgumentIsOptionArray) {
        optionsToUse = AutoNumeric.mergeOptions(options);
      } else {
        optionsToUse = options;
      }
      const isInitialValueNumber = AutoNumericHelper.isNumber(initialValue);
      let initialValueArraySize;
      if (secondArgumentIsInitialValueArray) {
        initialValueArraySize = initialValue.length;
      }
      arg1.forEach((domElement, index) => {
        if (isInitialValueNumber) {
          result2.push(new AutoNumeric(domElement, initialValue, optionsToUse));
        } else if (secondArgumentIsInitialValueArray && index <= initialValueArraySize) {
          result2.push(new AutoNumeric(domElement, initialValue[index], optionsToUse));
        } else {
          result2.push(new AutoNumeric(domElement, null, optionsToUse));
        }
      });
      return result2;
    };
    AutoNumeric.events = {
      correctedValue: "autoNumeric:correctedValue",
      initialized: "autoNumeric:initialized",
      invalidFormula: "autoNumeric:invalidFormula",
      invalidValue: "autoNumeric:invalidValue",
      formatted: "autoNumeric:formatted",
      rawValueModified: "autoNumeric:rawValueModified",
      minRangeExceeded: "autoNumeric:minExceeded",
      maxRangeExceeded: "autoNumeric:maxExceeded",
      native: {
        input: "input",
        change: "change"
      },
      validFormula: "autoNumeric:validFormula"
    };
    Object.freeze(AutoNumeric.events.native);
    Object.freeze(AutoNumeric.events);
    Object.defineProperty(AutoNumeric, "events", { configurable: false, writable: false });
    AutoNumeric.options = {
      /* Defines if the decimal places should be padded with zeroes
       * `true`     : always pad decimals with zeros (ie. '12.3400')
       * `false`    : never pad with zeros (ie. '12.34')
       * `'floats'` : pad with zeroes only when there are decimals (ie. '12' and '12.3400')
       * Note: setting allowDecimalPadding to 'false' will override the 'decimalPlaces' setting.
       */
      allowDecimalPadding: {
        always: true,
        never: false,
        floats: "floats"
      },
      /* Defines if the decimal character or decimal character alternative should be accepted when there is already a decimal character shown in the element.
       * If set to `true`, any decimal character input will be accepted and will subsequently modify the decimal character position, as well as the `rawValue`.
       * If set to `false`, the decimal character and its alternative key will be dropped as before. This is the default setting.
       */
      alwaysAllowDecimalCharacter: {
        alwaysAllow: true,
        doNotAllow: false
      },
      /* Defines where should be positioned the caret on focus
       * null : Do not enforce any caret positioning on focus (this is needed when using `selectOnFocus`)
       * `'start'` : put the caret of the far left side of the value (excluding the positive/negative sign and currency symbol, if any)
       * `'end'` : put the caret of the far right side of the value (excluding the positive/negative sign and currency symbol, if any)
       * `'decimalLeft'` : put the caret of the left of the decimal character if any
       * `'decimalRight'` : put the caret of the right of the decimal character if any
       */
      caretPositionOnFocus: {
        start: "start",
        end: "end",
        decimalLeft: "decimalLeft",
        decimalRight: "decimalRight",
        doNoForceCaretPosition: null
      },
      /* Defines if a local list of AutoNumeric objects should be kept when initializing this object.
       * This list is used by the `global.*` functions.
       */
      createLocalList: {
        createList: true,
        doNotCreateList: false
      },
      /* Defines the currency symbol string.
       * It can be a string of more than one character (allowing for instance to use a space on either side of it, example: '$ ' or ' $')
       * cf. https://en.wikipedia.org/wiki/Currency_symbol
       */
      currencySymbol: {
        none: "",
        currencySign: "",
        austral: "",
        // ARA
        australCentavo: "",
        baht: "",
        // THB
        cedi: "",
        // GHS
        cent: "",
        colon: "",
        // CRC
        cruzeiro: "",
        // BRB - Not used anymore since 1993
        dollar: "$",
        dong: "",
        // VND
        drachma: "",
        // GRD (or '.' or '.')
        dram: "",
        // AMD
        european: "",
        // XEU (old currency before the Euro)
        euro: "",
        // EUR
        florin: "",
        franc: "",
        // FRF
        guarani: "",
        // PYG
        hryvnia: "",
        // 
        kip: "",
        // LAK
        att: "",
        // cents of the Kip
        lepton: ".",
        // cents of the Drachma
        lira: "",
        // TRY
        liraOld: "",
        lari: "",
        // GEL
        mark: "",
        mill: "",
        naira: "",
        // NGN
        peseta: "",
        peso: "",
        // PHP
        pfennig: "",
        // cents of the Mark
        pound: "",
        real: "R$ ",
        // Brazilian real
        riel: "",
        // KHR
        ruble: "",
        // RUB
        rupee: "",
        // INR
        rupeeOld: "",
        shekel: "",
        shekelAlt: "",
        taka: "",
        // BDT
        tenge: "",
        // KZT
        togrog: "",
        // MNT
        won: "",
        yen: ""
      },
      /* Defines where the currency symbol should be placed (before of after the numbers)
       * for prefix currencySymbolPlacement: "p" (default)
       * for suffix currencySymbolPlacement: "s"
       */
      currencySymbolPlacement: {
        prefix: "p",
        suffix: "s"
      },
      /* Defines what decimal separator character is used
       */
      decimalCharacter: {
        comma: ",",
        dot: ".",
        middleDot: "",
        arabicDecimalSeparator: "",
        decimalSeparatorKeySymbol: ""
      },
      /* Allow to declare an alternative decimal separator which is automatically replaced by `decimalCharacter` when typed.
       * This is used by countries that use a comma ',' as the decimal character and have keyboards with a numeric pads that have
       * a period 'full stop' as the decimal character (France or Spain for instance).
       */
      decimalCharacterAlternative: {
        none: null,
        comma: ",",
        dot: "."
      },
      /* Defines the default number of decimal places to show on the formatted value, and keep for the precision.
       * Incidentally, since we need to be able to show that many decimal places, this also defines the raw value precision by default.
       */
      decimalPlaces: {
        none: 0,
        one: 1,
        two: 2,
        three: 3,
        four: 4,
        five: 5,
        six: 6
      },
      /* Defines how many decimal places should be kept for the raw value (ie. This is the precision for float values).
       *
       * If this option is set to `null` (which is the default), then the value of `decimalPlaces` is used for `decimalPlacesRawValue` as well.
       * Note: Setting this to a lower number of decimal places than the one to be shown will lead to confusion for the users.
       */
      decimalPlacesRawValue: {
        useDefault: null,
        none: 0,
        one: 1,
        two: 2,
        three: 3,
        four: 4,
        five: 5,
        six: 6
      },
      /* Defines how many decimal places should be visible when the element is unfocused.
       * If this is set to `null`, then this option is ignored, and the `decimalPlaces` option value will be used instead.
       * This means this is optional ; if omitted the decimal places will be the same when the input has the focus.
       *
       * This option can be used in conjonction with the two other `scale*` options, which allows to display a different formatted value when the element is unfocused, while another formatted value is shown when focused.
       * For those `scale*` options to have any effect, `divisorWhenUnfocused` must not be `null`.
       */
      decimalPlacesShownOnBlur: {
        useDefault: null,
        none: 0,
        one: 1,
        two: 2,
        three: 3,
        four: 4,
        five: 5,
        six: 6
      },
      /* Defines how many decimal places should be visible when the element has the focus.
       * If this is set to `null`, then this option is ignored, and the `decimalPlaces` option value will be used instead.
       *
       * Example:
       * For instance if `decimalPlacesShownOnFocus` is set to `5` and the default number of decimal places is `2`, then on focus `1,000.12345` will be shown, while without focus `1,000.12` will be set back.
       * Note 1: the results depends on the rounding method used.
       * Note 2: the `getNumericString()` method returns the extended decimal places
       */
      decimalPlacesShownOnFocus: {
        useDefault: null,
        none: 0,
        one: 1,
        two: 2,
        three: 3,
        four: 4,
        five: 5,
        six: 6
      },
      /* Helper option for ASP.NET postback
       * This should be set as the value of the unformatted default value
       * examples:
       * no default value="" {defaultValueOverride: ""}
       * value=1234.56 {defaultValueOverride: '1234.56'}
       */
      defaultValueOverride: {
        doNotOverride: null
      },
      /* Defines how many numbers should be grouped together (usually for the thousand separator)
       * - "2",  results in 99,99,99,99 Group by two
       * - "2t", results in 99,99,99,999 India's lakhs
       * - "2s", results in 99,999,99,99,999 India's lakhs scaled
       * - "3",  results in 999,999,999 (default)
       * - "4",  results in 9999,9999,9999 used in some Asian countries
       * Note: This option does not accept other grouping choice.
       */
      digitalGroupSpacing: {
        two: "2",
        twoThree: "2t",
        twoScaled: "2s",
        three: "3",
        four: "4"
      },
      /* Defines the thousand grouping separator character
       * Example : If `'.'` is set, then you'll get `'1.234.567'`
       */
      digitGroupSeparator: {
        comma: ",",
        dot: ".",
        normalSpace: " ",
        thinSpace: "",
        narrowNoBreakSpace: "",
        noBreakSpace: "",
        noSeparator: "",
        apostrophe: `'`,
        arabicThousandsSeparator: "",
        dotAbove: "",
        privateUseTwo: ""
        // \u0092
      },
      /* The `divisorWhenUnfocused` divide the element value on focus.
       * On blur, the element value is multiplied back.
       *
       * Example : Display percentages using { divisorWhenUnfocused: 100 } (or directly in the Html with `<input data-divisor-when-unfocused="100">`)
       * The divisor value does not need to be an integer, but please understand that Javascript has limited accuracy in math ; use with caution.
       * Note: The `getNumericString` method returns the full value, including the 'hidden' decimals.
       */
      divisorWhenUnfocused: {
        none: null,
        percentage: 100,
        permille: 1e3,
        basisPoint: 1e4
      },
      /* Defines what should be displayed in the element if the raw value is an empty string ('').
       * - 'focus'  : The currency sign is displayed when the input receives focus (default)
       * - 'press'  : The currency sign is displayed whenever a key is being pressed
       * - 'always' : The currency sign is always displayed
       * - 'zero'   : A zero is displayed ('rounded' with or without a currency sign) if the input has no value on focus out
       * - 'min'    : The minimum value is displayed if the input has no value on focus out
       * - 'max'    : The maximum value is displayed if the input has no value on focus out
       * - 'null'   : When the element is empty, the `rawValue` and the element value/text is set to `null`. This also allows to set the value to `null` using `anElement.set(null)`.
       */
      emptyInputBehavior: {
        focus: "focus",
        press: "press",
        always: "always",
        zero: "zero",
        min: "min",
        max: "max",
        null: "null"
      },
      /* Defines if the custom and native events triggered by AutoNumeric should bubble up or not.
       */
      eventBubbles: {
        bubbles: true,
        doesNotBubble: false
      },
      /* Defines if the custom and native events triggered by AutoNumeric should be cancelable.
       */
      eventIsCancelable: {
        isCancelable: true,
        isNotCancelable: false
      },
      /* This option is the 'strict mode' (aka 'debug' mode), which allows autoNumeric to strictly analyse the options passed, and fails if an unknown options is used in the settings object.
       * You should set that to `true` if you want to make sure you are only using 'pure' autoNumeric settings objects in your code.
       * If you see uncaught errors in the console and your code starts to fail, this means somehow those options gets polluted by another program (which usually happens when using frameworks).
       */
      failOnUnknownOption: {
        fail: true,
        ignore: false
      },
      /* Determine if the default value will be formatted on initialization.
       */
      formatOnPageLoad: {
        format: true,
        // automatically formats the default value on initialization
        doNotFormat: false
        // will not format the default value on initialization
      },
      /* Defines if the 'formula mode' can be activated by the user.
       * If set to `true`, then the user can enter the formula mode by entering the '=' character.
       * He will then be allowed to enter any simple math formula using numeric characters as well as the following operators +, -, *, /, ( and ).
       * The formula mode is closed when the user either validate their math expression using the `Enter` key, or when the element is blurred.
       * If the formula is invalid, the previous valid `rawValue` is set back, and the `autoNumeric:invalidFormula` event is sent.
       * When a valid formula is accepted, then its result is `set()`, and the `autoNumeric:validFormula` event is sent.
       *
       * By default, this mode is disabled.
       */
      formulaMode: {
        enabled: true,
        disabled: false
      },
      /* Set the undo/redo history table size.
       * Each record keeps the raw value as well and the last known caret/selection positions.
       */
      historySize: {
        verySmall: 5,
        small: 10,
        medium: 20,
        large: 50,
        veryLarge: 100,
        insane: Number.MAX_SAFE_INTEGER
      },
      /* Defines the name of the CSS class to use on contenteditable-enabled elements when the value is invalid
       * This is not used when the HTML element used is an input.
       */
      invalidClass: "an-invalid",
      /* Allow the user to 'cancel' and undo the changes he made to the given autonumeric-managed element, by pressing the 'Escape' key.
       * Whenever the user 'validate' the input (either by hitting 'Enter', or blurring the element), the new value is saved for subsequent 'cancellation'.
       *
       * The process :
       *   - save the input value on focus
       *   - if the user change the input value, and hit `Escape`, then the initial value saved on focus is set back
       *   - on the other hand if the user either have used `Enter` to validate (`Enter` throws a change event) his entries, or if the input value has been changed by another script in the mean time, then we save the new input value
       *   - on a successful 'cancel', select the whole value (while respecting the `selectNumberOnly` option)
       *   - bonus; if the value has not changed, hitting 'Esc' just select all the input value (while respecting the `selectNumberOnly` option)
       */
      isCancellable: {
        cancellable: true,
        notCancellable: false
      },
      /* Controls the leading zero behavior
       * - 'allow' : allows leading zeros to be entered. Zeros will be truncated when entering additional digits. On focusout zeros will be deleted
       * - 'deny'  : allows only one leading zero on values that are between 1 and -1
       * - 'keep'  : allows leading zeros to be entered. on focusout zeros will be retained
       */
      leadingZero: {
        allow: "allow",
        deny: "deny",
        keep: "keep"
      },
      /* Defines the maximum possible value a user can enter.
       * Notes:
       * - this value must be a string and use the period for the decimal point
       * - this value needs to be larger than `minimumValue`
       */
      maximumValue: {
        tenTrillions: "10000000000000",
        // 10000 billions
        oneBillion: "1000000000",
        zero: "0"
      },
      /* Defines the minimum possible value a user can enter.
       * Notes:
       * - this value must be a string and use the period for the decimal point
       * - this value needs to be smaller than `maximumValue`
       * - if this is superior to 0, then you'll effectively prevent your user to entirely delete the content of your element
       */
      minimumValue: {
        tenTrillions: "-10000000000000",
        // 10000 billions
        oneBillion: "-1000000000",
        zero: "0"
      },
      /* Allows the user to increment or decrement the element value with the up and down arrow keys.
       * The behavior is similar to the mouse wheel one.
       * The up and down arrow keys behavior can be modified by the `upDownStep` option.
       * This `upDownStep` option can be used in two ways, either by setting:
       * - a 'fixed' step value (`upDownStep : 1000`), or
       * - the 'progressive' string (`upDownStep : 'progressive'`), which will then activate a special mode where the step is automatically calculated based on the element value size.
       */
      modifyValueOnUpDownArrow: {
        modifyValue: true,
        doNothing: false
      },
      /* Allows the user to increment or decrement the element value with the mouse wheel.
       * The behavior is similar to the up/down arrow one.
       * The wheel behavior can be modified by the `wheelStep` option.
       * This `wheelStep` option can be used in two ways, either by setting:
       * - a 'fixed' step value (`wheelStep : 1000`), or
       * - the 'progressive' string (`wheelStep : 'progressive'`), which will then activate a special mode where the step is automatically calculated based on the element value size.
       *
       * Note :
       * You can activate/deactivate the wheel event for each `wheelOn` option value by using the 'Shift' modifier key while using the mouse wheel.
       */
      modifyValueOnWheel: {
        modifyValue: true,
        doNothing: false
      },
      /* Adds brackets on negative values (ie. transforms '-$ 999.99' to '($999.99)')
       * Those brackets are visible only when the field does NOT have the focus.
       * The left and right symbols should be enclosed in quotes and separated by a comma.
       */
      negativeBracketsTypeOnBlur: {
        parentheses: "(,)",
        brackets: "[,]",
        chevrons: "<,>",
        curlyBraces: "{,}",
        angleBrackets: ",",
        japaneseQuotationMarks: ",",
        halfBrackets: ",",
        whiteSquareBrackets: ",",
        quotationMarks: ",",
        guillemets: ",",
        none: null
        // This is the default value, which deactivate this feature
      },
      /* Placement of the negative/positive sign relative to the `currencySymbol` option.
       *
       * Example:
       * // Default values
       * -1,234.56  => default no options required
       * $-1,234.56 => {currencySymbol: "$", negativePositiveSignPlacement: "r"} // Default if negativePositiveSignPlacement is 'null' and currencySymbol is not empty
       *
       * // Sign on the left hand side of the whole number
       * -$1,234.56 => {currencySymbol: "$"} or {currencySymbol: "$", negativePositiveSignPlacement: "l"}
       * -1,234.56$ => {currencySymbol: "$", currencySymbolPlacement: "s", negativePositiveSignPlacement: "p"} // Default if negativePositiveSignPlacement is 'null' and currencySymbol is not empty
       *
       * // Sign on the right hand side of the whole number
       * 1,234.56-  => {negativePositiveSignPlacement: "s"}
       * $1,234.56- => {currencySymbol: "$", negativePositiveSignPlacement: "s"}
       * 1,234.56-$ => {currencySymbol: "$", currencySymbolPlacement: "s"}
       * 1,234.56$- => {currencySymbol: "$", currencySymbolPlacement: "s", negativePositiveSignPlacement: "r"}
       */
      negativePositiveSignPlacement: {
        prefix: "p",
        suffix: "s",
        left: "l",
        right: "r",
        none: null
      },
      /* Defines the negative sign symbol.
       * It can be a string of only one character.
       */
      negativeSignCharacter: {
        hyphen: "-",
        minus: "",
        heavyMinus: "",
        fullWidthHyphen: "",
        circledMinus: "",
        squaredMinus: "",
        triangleMinus: "",
        plusMinus: "",
        minusPlus: "",
        dotMinus: "",
        minusTilde: "",
        not: ""
      },
      /*
       * Defines if the negative sign should be toggled when hitting the negative or positive key multiple times.
       * When `toggle` is used, using the same '-' on '+' key will toggle between a positive and negative value.
       * When `doNotToggle` is used, using '-' will always set the value negative, and '+' will always set the value positive.
       */
      negativePositiveSignBehavior: {
        toggle: true,
        doNotToggle: false
      },
      /* Defines if the element should have event listeners activated on it.
       * By default, those event listeners are only added to <input> elements and html element with the `contenteditable` attribute set to `true`, but not on the other html tags.
       * This allows to initialize elements without any event listeners.
       * Warning: Since AutoNumeric will not check the input content after its initialization, using some autoNumeric methods afterwards *will* probably leads to formatting problems.
       */
      noEventListeners: {
        noEvents: true,
        addEvents: false
      },
      /* Manage how autoNumeric react when the user tries to paste an invalid number.
       * - 'error'    : (This is the default behavior) The input value is not changed and an error is output in the console.
       * - 'ignore'   : idem than 'error', but fail silently without outputting any error/warning in the console.
       * - 'clamp'    : if the pasted value is either too small or too big regarding the minimumValue and maximumValue range, then the result is clamped to those limits.
       * - 'truncate' : autoNumeric will insert as many pasted numbers it can at the initial caret/selection, until everything is pasted, or the range limit is hit.
       *                The non-pasted numbers are dropped and therefore not used at all.
       * - 'replace'  : autoNumeric will first insert as many pasted numbers it can at the initial caret/selection, then if the range limit is hit, it will try
       *                to replace one by one the remaining initial numbers (on the right side of the caret) with the rest of the pasted numbers.
       *
       * Note 1 : A paste content starting with a negative sign '-' will be accepted anywhere in the input, and will set the resulting value as a negative number
       * Note 2 : A paste content starting with a number will be accepted, even if the rest is gibberish (ie. '123foobar456').
       *          Only the first number will be used (here '123').
       * Note 3 : The paste event works with the `decimalPlacesShownOnFocus` option too.
       */
      onInvalidPaste: {
        error: "error",
        ignore: "ignore",
        clamp: "clamp",
        truncate: "truncate",
        replace: "replace"
      },
      /* Defines how the value should be formatted when wanting a 'localized' version of it.
       * - null or 'string' => 'nnnn.nn' or '-nnnn.nn' as text type. This is the default behavior.
       * - 'number'         => nnnn.nn or -nnnn.nn as a Number (Warning: this works only for integers inferior to Number.MAX_SAFE_INTEGER)
       * - ',' or '-,'      => 'nnnn,nn' or '-nnnn,nn'
       * - '.-'             => 'nnnn.nn' or 'nnnn.nn-'
       * - ',-'             => 'nnnn,nn' or 'nnnn,nn-'
       *
       * Note: The hyphen '-' is translated to the custom negative sign defined in `negativeSignCharacter`
       */
      outputFormat: {
        string: "string",
        number: "number",
        dot: ".",
        negativeDot: "-.",
        comma: ",",
        negativeComma: "-,",
        dotNegative: ".-",
        commaNegative: ",-",
        none: null
      },
      /* Defines if AutoNumeric should let the user override the minimum and/or maximum limits when he types numbers in the element.
       * - 'ceiling' Strictly adheres to `maximumValue` and ignores the `minimumValue` settings
       *             It allows the user to enter anything between - `and maximumValue`
       *             If `maximumValue` is less than 0, then it will prevent the user emptying the field or typing value above `maximumValue`, making sure the value entered is always valid
       * - 'floor'   Strictly adheres to `minimumValue` and ignores the `maximumValue` settings
       *             It allows the user to enter anything between `minimumValue` and +
       *             If `minimumValue` is higher than 0, then it will prevent the user emptying the field or typing value below `minimumValue`, making sure the value entered is always valid
       * - 'ignore'  Ignores both the `minimumValue` and `maximumValue` settings
       *             When using this option, the field will always be valid range-wise
       * - 'invalid' The user can temporarily type out-of-bound values. In doing so, the invalid state is set on the field.
       *             Whenever an invalid value is typed, an 'autoNumeric:invalidValue' event is sent
       *             When the value is correctly set back within the limit boundaries, the invalid state is removed, and the 'autoNumeric:correctedValue' event is sent
       * - 'doNotOverride' Strictly adheres to the `maximumValue` and `minimumValue` settings
       *                   This is the default behavior
       *                   If `0` is out of the min/max range, this will prevent the user clearing the input field, making sure the value entered is always valid
       */
      overrideMinMaxLimits: {
        ceiling: "ceiling",
        floor: "floor",
        ignore: "ignore",
        invalid: "invalid",
        doNotOverride: null
      },
      /* Defines the positive sign symbol.
       * It can be a string of only one character.
       * This is shown only if `showPositiveSign` is set to `true`.
       */
      positiveSignCharacter: {
        plus: "+",
        fullWidthPlus: "",
        heavyPlus: "",
        doublePlus: "",
        triplePlus: "",
        circledPlus: "",
        squaredPlus: "",
        trianglePlus: "",
        plusMinus: "",
        minusPlus: "",
        dotPlus: "",
        altHebrewPlus: "",
        normalSpace: " ",
        thinSpace: "",
        narrowNoBreakSpace: "",
        noBreakSpace: ""
      },
      /* The `rawValueDivisor` divides the formatted value shown in the AutoNumeric element and store the result in `rawValue`.
       * @example { rawValueDivisor: '100' } or <input data-raw-value-divisor="100">
       * Given the `0.01234` raw value, the formatted value will be displayed as `'1.234'`.
       * This is useful when displaying percentage for instance, and avoid the need to divide/multiply by 100 between the number shown and the raw value.
       */
      rawValueDivisor: {
        none: null,
        percentage: 100,
        permille: 1e3,
        basisPoint: 1e4
      },
      /* Defines if the element (`<input>` or another allowed html tag) should be set as read-only on initialization.
       * When set to `true`, then:
       * - the `readonly` html property is added to the <input> element on initialization, or
       * - the `contenteditable` attribute is set to `false` on non-input elements.
       */
      readOnly: {
        readOnly: true,
        readWrite: false
      },
      /* Defines the rounding method to use.
       * roundingMethod: "S", Round-Half-Up Symmetric (default)
       * roundingMethod: "A", Round-Half-Up Asymmetric
       * roundingMethod: "s", Round-Half-Down Symmetric (lower case s)
       * roundingMethod: "a", Round-Half-Down Asymmetric (lower case a)
       * roundingMethod: "B", Round-Half-Even "Bankers Rounding"
       * roundingMethod: "U", Round Up "Round-Away-From-Zero"
       * roundingMethod: "D", Round Down "Round-Toward-Zero" - same as truncate
       * roundingMethod: "C", Round to Ceiling "Toward Positive Infinity"
       * roundingMethod: "F", Round to Floor "Toward Negative Infinity"
       * roundingMethod: "N05" Rounds to the nearest .05 => same as "CHF" used in 1.9X and still valid
       * roundingMethod: "U05" Rounds up to next .05
       * roundingMethod: "D05" Rounds down to next .05
       */
      roundingMethod: {
        halfUpSymmetric: "S",
        halfUpAsymmetric: "A",
        halfDownSymmetric: "s",
        halfDownAsymmetric: "a",
        halfEvenBankersRounding: "B",
        upRoundAwayFromZero: "U",
        downRoundTowardZero: "D",
        toCeilingTowardPositiveInfinity: "C",
        toFloorTowardNegativeInfinity: "F",
        toNearest05: "N05",
        toNearest05Alt: "CHF",
        upToNext05: "U05",
        downToNext05: "D05"
      },
      /* Set to `true` to allow the `decimalPlacesShownOnFocus` value to be saved with sessionStorage
       * If IE 6 or 7 is detected, the value will be saved as a session cookie.
       */
      saveValueToSessionStorage: {
        save: true,
        doNotSave: false
      },
      /* Determine if the select all keyboard command will select the complete input text, or only the input numeric value
       * Note : If the currency symbol is between the numeric value and the negative sign, only the numeric value will be selected
       */
      selectNumberOnly: {
        selectNumbersOnly: true,
        selectAll: false
      },
      /* Defines if the element value should be selected on focus.
       * Note: The selection is done using the `selectNumberOnly` option.
       */
      selectOnFocus: {
        select: true,
        doNotSelect: false
      },
      /* Defines how the serialize functions should treat the spaces.
       * Those spaces ' ' can either be converted to the plus sign '+', which is the default, or to '%20'.
       * Both values being valid per the spec (http://www.w3.org/Addressing/URL/uri-spec.html).
       * Also see the summed up answer on http://stackoverflow.com/a/33939287.
       *
       * tl;dr : Spaces should be converted to '%20' before the '?' sign, then converted to '+' after.
       * In our case since we serialize the query, we use '+' as the default (but allow the user to get back the old *wrong* behavior).
       */
      serializeSpaces: {
        plus: "+",
        percent: "%20"
      },
      /* Defines if the element value should be converted to the raw value on focus (and back to the formatted on blur).
       * If set to `true`, then autoNumeric remove the thousand separator, currency symbol and suffix on focus.
       * Example:
       * If the input value is '$ 1,999.88 suffix', on focus it becomes '1999.88' and back to '$ 1,999.88 suffix' on blur.
       */
      showOnlyNumbersOnFocus: {
        onlyNumbers: true,
        showAll: false
      },
      /* Allow the positive sign symbol `+` to be displayed for positive numbers.
       * By default, this positive sign is not shown.
       * The sign placement is controlled by the 'negativePositiveSignPlacement' option, mimicking the negative sign placement rules.
       */
      showPositiveSign: {
        show: true,
        hide: false
      },
      /* Defines if warnings should be shown in the console.
       * Those warnings can be ignored, but are usually printed when something could be improved by the user (ie. option conflicts).
       */
      showWarnings: {
        show: true,
        // All warning are shown
        hide: false
        // No warnings are shown, only the thrown errors
      },
      /* Defines the rules that calculate the CSS class(es) to apply on the element, based on the raw unformatted value.
       * This can also be used to call callbacks whenever the `rawValue` is updated.
       * Important: all callbacks must return `null` if no ranges/userDefined classes are selected
       * @example
       * {
       *     positive   : 'autoNumeric-positive', // Or `null` to not use it
       *     negative   : 'autoNumeric-negative',
       *     ranges     : [
       *         { min: 0, max: 25, class: 'autoNumeric-red' },
       *         { min: 25, max: 50, class: 'autoNumeric-orange' },
       *         { min: 50, max: 75, class: 'autoNumeric-yellow' },
       *         { min: 75, max: Number.MAX_SAFE_INTEGER, class: 'autoNumeric-green' },
       *     ],
       *     userDefined: [
       *         // If 'classes' is a string, set it if `true`, remove it if `false`
       *         { callback: rawValue => { return true; }, classes: 'thisIsTrue' },
       *         // If 'classes' is an array with only 2 elements, set the first class if `true`, the second if `false`
       *         { callback: rawValue => rawValue % 2 === 0, classes: ['autoNumeric-even', 'autoNumeric-odd'] },
       *         // Return only one index to use on the `classes` array (here, 'class3')
       *         { callback: rawValue => { return 2; }, classes: ['class1', 'class2', 'class3'] },
       *         // Return an array of indexes to use on the `classes` array (here, 'class1' and 'class3')
       *         { callback: rawValue => { return [0, 2]; }, classes: ['class1', 'class2', 'class3'] },
       *         // If 'classes' is `undefined` or `null`, then the callback is called with the AutoNumeric object passed as a parameter
       *         { callback: anElement => { return anElement.getFormatted(); } },
       *     ],
       * }
       */
      styleRules: {
        none: null,
        positiveNegative: {
          positive: "autoNumeric-positive",
          negative: "autoNumeric-negative"
        },
        range0To100With4Steps: {
          ranges: [
            { min: 0, max: 25, class: "autoNumeric-red" },
            { min: 25, max: 50, class: "autoNumeric-orange" },
            { min: 50, max: 75, class: "autoNumeric-yellow" },
            { min: 75, max: 100, class: "autoNumeric-green" }
          ]
        },
        evenOdd: {
          userDefined: [
            { callback: (rawValue) => rawValue % 2 === 0, classes: ["autoNumeric-even", "autoNumeric-odd"] }
          ]
        },
        rangeSmallAndZero: {
          userDefined: [
            {
              callback: (rawValue) => {
                if (rawValue >= -1 && rawValue < 0) {
                  return 0;
                }
                if (Number(rawValue) === 0) {
                  return 1;
                }
                if (rawValue > 0 && rawValue <= 1) {
                  return 2;
                }
                return null;
              },
              classes: [
                "autoNumeric-small-negative",
                "autoNumeric-zero",
                "autoNumeric-small-positive"
              ]
            }
          ]
        }
      },
      /* Add a text on the right hand side of the element value.
       * This suffix text can have any characters in its string, except numeric characters and the negative/positive sign.
       * Example: ' dollars'
       */
      suffixText: {
        none: "",
        percentage: "%",
        permille: "",
        basisPoint: ""
      },
      /* The three options (divisorWhenUnfocused, decimalPlacesShownOnBlur & symbolWhenUnfocused) handle scaling of the input when the input does not have focus
       * Please note that the non-scaled value is held in data and it is advised that you use the `saveValueToSessionStorage` option to ensure retaining the value
       * ["divisor", "decimal places", "symbol"]
       * Example: with the following options set {divisorWhenUnfocused: '1000', decimalPlacesShownOnBlur: '1', symbolWhenUnfocused: ' K'}
       * Example: focusin value "1,111.11" focusout value "1.1 K"
       */
      /* The `symbolWhenUnfocused` option is a symbol placed as a suffix when not in focus.
       * This is optional too.
       */
      symbolWhenUnfocused: {
        none: null,
        percentage: "%",
        permille: "",
        basisPoint: ""
      },
      /* Defines if the element value should be unformatted when the user hover his mouse over it while holding the `Alt` key.
       * Unformatting there means that this removes any non-number characters and displays the *raw* value, as understood by Javascript (ie. `12.34` is a valid number, while `12,34` is not).
       *
       * We reformat back before anything else if :
       * - the user focus on the element by tabbing or clicking into it,
       * - the user releases the `Alt` key, and
       * - if we detect a mouseleave event.
       *
       * We unformat again if :
       * - while the mouse is over the element, the user hit `Alt` again
       */
      unformatOnHover: {
        unformat: true,
        doNotUnformat: false
        //TODO Rename to `keepFormat`
      },
      /* Removes the formatting and use the raw value in each autoNumeric elements of the parent form element, on the form `submit` event.
       * The output format is a numeric string (nnnn.nn or -nnnn.nn).
       */
      unformatOnSubmit: {
        unformat: true,
        keepCurrentValue: false
      },
      /* That option is linked to the `modifyValueOnUpDownArrow` one and will only be used if the latter is set to `true`.
       * This option will modify the up/down arrow behavior and can be used in two ways, either by setting :
       * - a 'fixed' step value (a positive float or integer number (ex: `1000`)), or
       * - the `'progressive'` string.
       *
       * The 'fixed' mode always increment/decrement the element value by that amount, while respecting the `minimumValue` and `maximumValue` settings.
       * The 'progressive' mode will increment/decrement the element value based on its current value. The bigger the number, the bigger the step, and vice versa.
       */
      upDownStep: {
        progressive: "progressive"
      },
      /* Provides a way for automatically replacing the formatted value with a pre-defined string, when the raw value is equal to a specific value
       * Here you can specify as many 'conversion' as needed.
       */
      valuesToStrings: {
        none: null,
        zeroDash: {
          0: "-"
        },
        oneAroundZero: {
          "-1": "Min",
          1: "Max"
        }
      },
      /* Defines if the AutoNumeric element should watch external changes made without using `.set()`, but by using the basic `aNElement.node().value = 42` notation.
       * If set to `watch`, then AutoNumeric will format the new value using `.set()` internally.
       * Otherwise it will neither format it, nor save it in the history.
       */
      watchExternalChanges: {
        watch: true,
        doNotWatch: false
      },
      /* Defines when the wheel event will increment or decrement the element value.
       * When set to `'focus'`, the AutoNumeric-managed element needs to be focused for the wheel event to change the value.
       * When set to `'hover'`, using the wheel event while the mouse is hovering the element is sufficient (no focus needed).
       *
       * Note :
       * When `wheelOn` is set to `'focus'`, you can use the 'Shift' modifier key while using the mouse wheel in order to temporarily activate the increment/decrement feature even if the element is not focused.
       * When `wheelOn` is set to `'hover'`, you can use the 'Shift' modifier key while using the mouse wheel in order to temporarily disable the increment/decrement feature even if the element is not hovered.
       */
      wheelOn: {
        focus: "focus",
        hover: "hover"
      },
      /* That option is linked to the `modifyValueOnWheel` one and will only be used if the latter is set to `true`.
       * This option will modify the wheel behavior and can be used in two ways, either by setting :
       * - a 'fixed' step value (a positive float or integer (ex: number `1000`)), or
       * - the `'progressive'` string.
       *
       * The 'fixed' mode always increment/decrement the element value by that amount, while respecting the `minimumValue` and `maximumValue` settings.
       * The 'progressive' mode will increment/decrement the element value based on its current value. The bigger the number, the bigger the step, and vice versa.
       */
      wheelStep: {
        progressive: "progressive"
      }
    };
    function freezeOptions(options) {
      Object.getOwnPropertyNames(options).forEach((optionName) => {
        if (optionName === "valuesToStrings") {
          const vsProps = Object.getOwnPropertyNames(options.valuesToStrings);
          vsProps.forEach((valuesToStringObjectName) => {
            if (options.valuesToStrings[valuesToStringObjectName] !== null) {
              Object.freeze(options.valuesToStrings[valuesToStringObjectName]);
            }
          });
        } else if (optionName !== "styleRules") {
          if (options[optionName] !== null) {
            Object.freeze(options[optionName]);
          }
        }
      });
      return Object.freeze(options);
    }
    freezeOptions(AutoNumeric.options);
    Object.defineProperty(AutoNumeric, "options", { configurable: false, writable: false });
    AutoNumeric.defaultSettings = {
      allowDecimalPadding: AutoNumeric.options.allowDecimalPadding.always,
      alwaysAllowDecimalCharacter: AutoNumeric.options.alwaysAllowDecimalCharacter.doNotAllow,
      caretPositionOnFocus: AutoNumeric.options.caretPositionOnFocus.doNoForceCaretPosition,
      createLocalList: AutoNumeric.options.createLocalList.createList,
      currencySymbol: AutoNumeric.options.currencySymbol.none,
      currencySymbolPlacement: AutoNumeric.options.currencySymbolPlacement.prefix,
      decimalCharacter: AutoNumeric.options.decimalCharacter.dot,
      decimalCharacterAlternative: AutoNumeric.options.decimalCharacterAlternative.none,
      decimalPlaces: AutoNumeric.options.decimalPlaces.two,
      decimalPlacesRawValue: AutoNumeric.options.decimalPlacesRawValue.useDefault,
      decimalPlacesShownOnBlur: AutoNumeric.options.decimalPlacesShownOnBlur.useDefault,
      decimalPlacesShownOnFocus: AutoNumeric.options.decimalPlacesShownOnFocus.useDefault,
      defaultValueOverride: AutoNumeric.options.defaultValueOverride.doNotOverride,
      digitalGroupSpacing: AutoNumeric.options.digitalGroupSpacing.three,
      digitGroupSeparator: AutoNumeric.options.digitGroupSeparator.comma,
      divisorWhenUnfocused: AutoNumeric.options.divisorWhenUnfocused.none,
      emptyInputBehavior: AutoNumeric.options.emptyInputBehavior.focus,
      eventBubbles: AutoNumeric.options.eventBubbles.bubbles,
      eventIsCancelable: AutoNumeric.options.eventIsCancelable.isCancelable,
      failOnUnknownOption: AutoNumeric.options.failOnUnknownOption.ignore,
      formatOnPageLoad: AutoNumeric.options.formatOnPageLoad.format,
      formulaMode: AutoNumeric.options.formulaMode.disabled,
      historySize: AutoNumeric.options.historySize.medium,
      invalidClass: AutoNumeric.options.invalidClass,
      isCancellable: AutoNumeric.options.isCancellable.cancellable,
      leadingZero: AutoNumeric.options.leadingZero.deny,
      maximumValue: AutoNumeric.options.maximumValue.tenTrillions,
      minimumValue: AutoNumeric.options.minimumValue.tenTrillions,
      modifyValueOnUpDownArrow: AutoNumeric.options.modifyValueOnUpDownArrow.modifyValue,
      modifyValueOnWheel: AutoNumeric.options.modifyValueOnWheel.modifyValue,
      negativeBracketsTypeOnBlur: AutoNumeric.options.negativeBracketsTypeOnBlur.none,
      negativePositiveSignPlacement: AutoNumeric.options.negativePositiveSignPlacement.none,
      negativeSignCharacter: AutoNumeric.options.negativeSignCharacter.hyphen,
      negativePositiveSignBehavior: AutoNumeric.options.negativePositiveSignBehavior.doNotToggle,
      noEventListeners: AutoNumeric.options.noEventListeners.addEvents,
      //TODO Shouldn't we use `truncate` as the default value?
      onInvalidPaste: AutoNumeric.options.onInvalidPaste.error,
      outputFormat: AutoNumeric.options.outputFormat.none,
      overrideMinMaxLimits: AutoNumeric.options.overrideMinMaxLimits.doNotOverride,
      positiveSignCharacter: AutoNumeric.options.positiveSignCharacter.plus,
      rawValueDivisor: AutoNumeric.options.rawValueDivisor.none,
      readOnly: AutoNumeric.options.readOnly.readWrite,
      roundingMethod: AutoNumeric.options.roundingMethod.halfUpSymmetric,
      saveValueToSessionStorage: AutoNumeric.options.saveValueToSessionStorage.doNotSave,
      selectNumberOnly: AutoNumeric.options.selectNumberOnly.selectNumbersOnly,
      selectOnFocus: AutoNumeric.options.selectOnFocus.select,
      serializeSpaces: AutoNumeric.options.serializeSpaces.plus,
      showOnlyNumbersOnFocus: AutoNumeric.options.showOnlyNumbersOnFocus.showAll,
      showPositiveSign: AutoNumeric.options.showPositiveSign.hide,
      showWarnings: AutoNumeric.options.showWarnings.show,
      styleRules: AutoNumeric.options.styleRules.none,
      suffixText: AutoNumeric.options.suffixText.none,
      symbolWhenUnfocused: AutoNumeric.options.symbolWhenUnfocused.none,
      unformatOnHover: AutoNumeric.options.unformatOnHover.unformat,
      unformatOnSubmit: AutoNumeric.options.unformatOnSubmit.keepCurrentValue,
      upDownStep: "1",
      // To mimic the behavior of 'numeric'-typed input
      valuesToStrings: AutoNumeric.options.valuesToStrings.none,
      watchExternalChanges: AutoNumeric.options.watchExternalChanges.doNotWatch,
      wheelOn: AutoNumeric.options.wheelOn.focus,
      wheelStep: AutoNumeric.options.wheelStep.progressive
    };
    Object.freeze(AutoNumeric.defaultSettings);
    Object.defineProperty(AutoNumeric, "defaultSettings", { configurable: false, writable: false });
    const euro = {
      // Franais
      digitGroupSeparator: AutoNumeric.options.digitGroupSeparator.dot,
      // or '\u202f'
      decimalCharacter: AutoNumeric.options.decimalCharacter.comma,
      decimalCharacterAlternative: AutoNumeric.options.decimalCharacterAlternative.dot,
      currencySymbol: "",
      currencySymbolPlacement: AutoNumeric.options.currencySymbolPlacement.suffix,
      negativePositiveSignPlacement: AutoNumeric.options.negativePositiveSignPlacement.prefix
    };
    const dollar = {
      digitGroupSeparator: AutoNumeric.options.digitGroupSeparator.comma,
      decimalCharacter: AutoNumeric.options.decimalCharacter.dot,
      currencySymbol: AutoNumeric.options.currencySymbol.dollar,
      currencySymbolPlacement: AutoNumeric.options.currencySymbolPlacement.prefix,
      negativePositiveSignPlacement: AutoNumeric.options.negativePositiveSignPlacement.right
    };
    const japanese = {
      // 
      digitGroupSeparator: AutoNumeric.options.digitGroupSeparator.comma,
      decimalCharacter: AutoNumeric.options.decimalCharacter.dot,
      currencySymbol: AutoNumeric.options.currencySymbol.yen,
      currencySymbolPlacement: AutoNumeric.options.currencySymbolPlacement.prefix,
      negativePositiveSignPlacement: AutoNumeric.options.negativePositiveSignPlacement.right
    };
    const euroF = AutoNumericHelper.cloneObject(euro);
    euroF.formulaMode = AutoNumeric.options.formulaMode.enabled;
    const euroPos = AutoNumericHelper.cloneObject(euro);
    euroPos.minimumValue = 0;
    const euroNeg = AutoNumericHelper.cloneObject(euro);
    euroNeg.maximumValue = 0;
    euroNeg.negativePositiveSignPlacement = AutoNumeric.options.negativePositiveSignPlacement.prefix;
    const euroSpace = AutoNumericHelper.cloneObject(euro);
    euroSpace.digitGroupSeparator = AutoNumeric.options.digitGroupSeparator.normalSpace;
    const euroSpacePos = AutoNumericHelper.cloneObject(euroSpace);
    euroSpacePos.minimumValue = 0;
    const euroSpaceNeg = AutoNumericHelper.cloneObject(euroSpace);
    euroSpaceNeg.maximumValue = 0;
    euroSpaceNeg.negativePositiveSignPlacement = AutoNumeric.options.negativePositiveSignPlacement.prefix;
    const percentageEU2dec = AutoNumericHelper.cloneObject(euro);
    percentageEU2dec.currencySymbol = AutoNumeric.options.currencySymbol.none;
    percentageEU2dec.suffixText = `${AutoNumeric.options.suffixText.percentage}`;
    percentageEU2dec.wheelStep = 1e-4;
    percentageEU2dec.rawValueDivisor = AutoNumeric.options.rawValueDivisor.percentage;
    const percentageEU2decPos = AutoNumericHelper.cloneObject(percentageEU2dec);
    percentageEU2decPos.minimumValue = 0;
    const percentageEU2decNeg = AutoNumericHelper.cloneObject(percentageEU2dec);
    percentageEU2decNeg.maximumValue = 0;
    percentageEU2decNeg.negativePositiveSignPlacement = AutoNumeric.options.negativePositiveSignPlacement.prefix;
    const percentageEU3dec = AutoNumericHelper.cloneObject(percentageEU2dec);
    percentageEU3dec.decimalPlaces = 3;
    const percentageEU3decPos = AutoNumericHelper.cloneObject(percentageEU2decPos);
    percentageEU3decPos.decimalPlaces = 3;
    const percentageEU3decNeg = AutoNumericHelper.cloneObject(percentageEU2decNeg);
    percentageEU3decNeg.decimalPlaces = 3;
    const dollarF = AutoNumericHelper.cloneObject(dollar);
    dollarF.formulaMode = AutoNumeric.options.formulaMode.enabled;
    const dollarPos = AutoNumericHelper.cloneObject(dollar);
    dollarPos.minimumValue = 0;
    const dollarNeg = AutoNumericHelper.cloneObject(dollar);
    dollarNeg.maximumValue = 0;
    dollarNeg.negativePositiveSignPlacement = AutoNumeric.options.negativePositiveSignPlacement.prefix;
    const dollarNegBrackets = AutoNumericHelper.cloneObject(dollarNeg);
    dollarNegBrackets.negativeBracketsTypeOnBlur = AutoNumeric.options.negativeBracketsTypeOnBlur.parentheses;
    const percentageUS2dec = AutoNumericHelper.cloneObject(dollar);
    percentageUS2dec.currencySymbol = AutoNumeric.options.currencySymbol.none;
    percentageUS2dec.suffixText = AutoNumeric.options.suffixText.percentage;
    percentageUS2dec.wheelStep = 1e-4;
    percentageUS2dec.rawValueDivisor = AutoNumeric.options.rawValueDivisor.percentage;
    const percentageUS2decPos = AutoNumericHelper.cloneObject(percentageUS2dec);
    percentageUS2decPos.minimumValue = 0;
    const percentageUS2decNeg = AutoNumericHelper.cloneObject(percentageUS2dec);
    percentageUS2decNeg.maximumValue = 0;
    percentageUS2decNeg.negativePositiveSignPlacement = AutoNumeric.options.negativePositiveSignPlacement.prefix;
    const percentageUS3dec = AutoNumericHelper.cloneObject(percentageUS2dec);
    percentageUS3dec.decimalPlaces = 3;
    const percentageUS3decPos = AutoNumericHelper.cloneObject(percentageUS2decPos);
    percentageUS3decPos.decimalPlaces = 3;
    const percentageUS3decNeg = AutoNumericHelper.cloneObject(percentageUS2decNeg);
    percentageUS3decNeg.decimalPlaces = 3;
    const turkish = AutoNumericHelper.cloneObject(euro);
    turkish.currencySymbol = AutoNumeric.options.currencySymbol.lira;
    AutoNumeric.predefinedOptions = {
      euro,
      euroPos,
      euroNeg,
      euroSpace,
      euroSpacePos,
      euroSpaceNeg,
      percentageEU2dec,
      percentageEU2decPos,
      percentageEU2decNeg,
      percentageEU3dec,
      percentageEU3decPos,
      percentageEU3decNeg,
      dollar,
      dollarPos,
      dollarNeg,
      dollarNegBrackets,
      percentageUS2dec,
      percentageUS2decPos,
      percentageUS2decNeg,
      percentageUS3dec,
      percentageUS3decPos,
      percentageUS3decNeg,
      French: euro,
      // Franais
      Spanish: euro,
      // Espaol
      NorthAmerican: dollar,
      British: {
        digitGroupSeparator: AutoNumeric.options.digitGroupSeparator.comma,
        decimalCharacter: AutoNumeric.options.decimalCharacter.dot,
        currencySymbol: AutoNumeric.options.currencySymbol.pound,
        currencySymbolPlacement: AutoNumeric.options.currencySymbolPlacement.prefix,
        negativePositiveSignPlacement: AutoNumeric.options.negativePositiveSignPlacement.right
      },
      Swiss: {
        // Suisse
        digitGroupSeparator: AutoNumeric.options.digitGroupSeparator.apostrophe,
        decimalCharacter: AutoNumeric.options.decimalCharacter.dot,
        currencySymbol: "CHF",
        currencySymbolPlacement: AutoNumeric.options.currencySymbolPlacement.suffix,
        negativePositiveSignPlacement: AutoNumeric.options.negativePositiveSignPlacement.prefix
      },
      Japanese: japanese,
      // 
      Chinese: japanese,
      //  (Chinese)
      Brazilian: {
        digitGroupSeparator: AutoNumeric.options.digitGroupSeparator.dot,
        decimalCharacter: AutoNumeric.options.decimalCharacter.comma,
        currencySymbol: AutoNumeric.options.currencySymbol.real,
        currencySymbolPlacement: AutoNumeric.options.currencySymbolPlacement.prefix,
        negativePositiveSignPlacement: AutoNumeric.options.negativePositiveSignPlacement.right
      },
      Turkish: turkish,
      dotDecimalCharCommaSeparator: {
        digitGroupSeparator: AutoNumeric.options.digitGroupSeparator.comma,
        decimalCharacter: AutoNumeric.options.decimalCharacter.dot
      },
      commaDecimalCharDotSeparator: {
        digitGroupSeparator: AutoNumeric.options.digitGroupSeparator.dot,
        decimalCharacter: AutoNumeric.options.decimalCharacter.comma,
        decimalCharacterAlternative: AutoNumeric.options.decimalCharacterAlternative.dot
      },
      integer: {
        decimalPlaces: 0
      },
      integerPos: {
        minimumValue: AutoNumeric.options.minimumValue.zero,
        decimalPlaces: 0
      },
      integerNeg: {
        maximumValue: AutoNumeric.options.maximumValue.zero,
        decimalPlaces: 0
      },
      float: {
        allowDecimalPadding: AutoNumeric.options.allowDecimalPadding.never
      },
      floatPos: {
        allowDecimalPadding: AutoNumeric.options.allowDecimalPadding.never,
        minimumValue: AutoNumeric.options.minimumValue.zero,
        maximumValue: AutoNumeric.options.maximumValue.tenTrillions
      },
      floatNeg: {
        allowDecimalPadding: AutoNumeric.options.allowDecimalPadding.never,
        minimumValue: AutoNumeric.options.minimumValue.tenTrillions,
        maximumValue: AutoNumeric.options.maximumValue.zero
      },
      numeric: {
        digitGroupSeparator: AutoNumeric.options.digitGroupSeparator.noSeparator,
        decimalCharacter: AutoNumeric.options.decimalCharacter.dot,
        currencySymbol: AutoNumeric.options.currencySymbol.none
      },
      numericPos: {
        digitGroupSeparator: AutoNumeric.options.digitGroupSeparator.noSeparator,
        decimalCharacter: AutoNumeric.options.decimalCharacter.dot,
        currencySymbol: AutoNumeric.options.currencySymbol.none,
        minimumValue: AutoNumeric.options.minimumValue.zero,
        maximumValue: AutoNumeric.options.maximumValue.tenTrillions
      },
      numericNeg: {
        digitGroupSeparator: AutoNumeric.options.digitGroupSeparator.noSeparator,
        decimalCharacter: AutoNumeric.options.decimalCharacter.dot,
        currencySymbol: AutoNumeric.options.currencySymbol.none,
        minimumValue: AutoNumeric.options.minimumValue.tenTrillions,
        maximumValue: AutoNumeric.options.maximumValue.zero
      }
    };
    Object.getOwnPropertyNames(AutoNumeric.predefinedOptions).forEach((optionName) => {
      Object.freeze(AutoNumeric.predefinedOptions[optionName]);
    });
    Object.freeze(AutoNumeric.predefinedOptions);
    Object.defineProperty(AutoNumeric, "predefinedOptions", { configurable: false, writable: false });
    const _sfc_main$10 = {
      __name: "simple-numeric",
      props: /* @__PURE__ */ mergeModels({
        id: {
          type: String,
          default: null
        },
        numericType: {
          type: String,
          default: "float"
        }
      }, {
        "modelValue": {},
        "modelModifiers": {},
        "formattedValue": {},
        "formattedValueModifiers": {}
      }),
      emits: ["update:modelValue", "update:formattedValue"],
      setup(__props, { expose: __expose }) {
        __expose();
        const props = __props;
        const inputValue = useModel(__props, "modelValue");
        const formattedValue = useModel(__props, "formattedValue");
        const inputElem = ref(null);
        const autoNumericObject = ref(null);
        const autoNumericOptions = computed(() => {
          let options = {
            maximumValue: "100000000000000000",
            emptyInputBehavior: "null"
          };
          if (props.numericType === "integer") {
            options.minimumValue = "0";
            options.decimalPlaces = 0;
            options.decimalCharacter = ",";
            options.digitGroupSeparator = " ";
          } else if (props.numericType === "code") {
            options.minimumValue = "0";
            options.decimalPlaces = 0;
            options.digitGroupSeparator = "";
          } else if (props.numericType === "float" || props.numericType === "numeric") {
            options.decimalCharacter = ",";
            options.digitGroupSeparator = " ";
          } else if (props.numericType === "currency") {
            options.decimalCharacter = ",";
            options.digitGroupSeparator = " ";
          }
          return options;
        });
        onBeforeMount(() => {
          format(inputValue.value);
        });
        onMounted(() => {
          autoNumericObject.value = new AutoNumeric(inputElem.value, autoNumericOptions.value);
        });
        watch(formattedValue, async (newValue, oldValue) => {
          if (typeof oldValue !== "undefined" && newValue !== oldValue) {
            inputValue.value = JSON.parse(JSON.stringify(
              autoNumericObject.value.getNumber()
            ));
          }
        });
        watch(inputValue, async (newValue, oldValue) => {
          newValue = isNaN(newValue) ? null : newValue;
          autoNumericObject.value.set(newValue);
          format(newValue);
        });
        function format(value) {
          formattedValue.value = value !== null ? JSON.parse(JSON.stringify(value)) : null;
        }
        const __returned__ = { props, inputValue, formattedValue, inputElem, autoNumericObject, autoNumericOptions, format, onMounted, ref, computed, onBeforeMount, watch, get AutoNumeric() {
          return AutoNumeric;
        } };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$M = ["id", "name"];
    function _sfc_render$10(_ctx, _cache, $props, $setup, $data, $options) {
      return withDirectives((openBlock(), createElementBlock("input", {
        type: "text",
        id: $props.id,
        name: $props.id,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.formattedValue = $event),
        class: normalizeClass(["field-edit", { "field-numeric": $props.numericType !== "code" }]),
        autocomplete: "off",
        ref: "inputElem",
        "on:autoNumeric:rawValueModified": _cache[1] || (_cache[1] = (...args) => _ctx.update && _ctx.update(...args))
      }, null, 42, _hoisted_1$M)), [
        [vModelText, $setup.formattedValue]
      ]);
    }
    const simpleNumeric = /* @__PURE__ */ _export_sfc(_sfc_main$10, [["render", _sfc_render$10], ["__scopeId", "data-v-ef7b592d"], ["__file", "/var/www/html/vendor/andreamarelli/modular-forms/src/resources/assets/js/inputs/simple-numeric.vue"]]);
    const _sfc_main$$ = {
      __name: "toggle",
      props: /* @__PURE__ */ mergeModels({
        id: {
          type: String,
          default: null
        },
        dataValues: {
          type: String,
          default: "{}"
        }
      }, {
        "modelValue": {},
        "modelModifiers": {}
      }),
      emits: ["update:modelValue"],
      setup(__props, { expose: __expose }) {
        __expose();
        const { sortList } = useList$1({});
        const props = __props;
        const inputValue = useModel(__props, "modelValue");
        let list = ref([]);
        onBeforeMount(() => {
          list = initializeOptions();
          if (list.map((item) => item.value).includes("true") || list.map((item) => item.value).includes(true)) {
            if (inputValue.value === "0" || inputValue.value === 0) {
              inputValue.value = false;
            } else if (inputValue.value === "1" || inputValue.value === 1) {
              inputValue.value = true;
            }
          }
        });
        function initializeOptions() {
          let option_list = JSON.parse(props.dataValues);
          let list2 = [];
          for (let key in option_list) {
            if (key !== "_" && key !== "null" && option_list.hasOwnProperty(key)) {
              list2.push({ "label": option_list[key], "value": key });
            }
          }
          list2 = sortList(list2);
          return list2;
        }
        function isSelected(value) {
          return value !== null && inputValue.value !== null && typeof inputValue.value !== "undefined" && value.toString() === inputValue.value.toString();
        }
        function setOption(value) {
          inputValue.value = inputValue.value === value ? null : value;
        }
        const __returned__ = { sortList, props, inputValue, get list() {
          return list;
        }, set list(v2) {
          list = v2;
        }, initializeOptions, isSelected, setOption, onBeforeMount, onMounted, ref, get useList() {
          return useList$1;
        } };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$L = { class: "toggle" };
    const _hoisted_2$D = ["onClick"];
    const _hoisted_3$v = ["id"];
    function _sfc_render$$(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", _hoisted_1$L, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($setup.list, (option) => {
          return openBlock(), createElementBlock("div", {
            class: normalizeClass($setup.isSelected(option.value) ? "active" : ""),
            onClick: ($event) => $setup.setOption(option.value)
          }, toDisplayString(option.label), 11, _hoisted_2$D);
        }), 256)),
        withDirectives(createBaseVNode("input", {
          type: "hidden",
          id: $props.id,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.inputValue = $event)
        }, null, 8, _hoisted_3$v), [
          [vModelText, $setup.inputValue]
        ])
      ]);
    }
    const toggle = /* @__PURE__ */ _export_sfc(_sfc_main$$, [["render", _sfc_render$$], ["__file", "/var/www/html/vendor/andreamarelli/modular-forms/src/resources/assets/js/inputs/toggle.vue"]]);
    const _sfc_main$_ = {
      __name: "checkbox",
      props: /* @__PURE__ */ mergeModels({
        id: {
          type: String,
          default: null
        },
        dataValues: {
          type: String,
          default: "{}"
        },
        boolean: {
          type: Boolean,
          default: false
        },
        booleanNumeric: {
          type: Boolean,
          default: false
        },
        inline: {
          type: Boolean,
          default: true
        }
      }, {
        "modelValue": {},
        "modelModifiers": {}
      }),
      emits: ["update:modelValue"],
      setup(__props, { expose: __expose }) {
        __expose();
        const { sortList } = useList$1({});
        const props = __props;
        const inputValue = useModel(__props, "modelValue");
        let list = ref([]);
        onBeforeMount(() => {
          initializeOptions();
        });
        const isChecked = computed(() => {
          return checkValue(inputValue.value);
        });
        function initializeOptions() {
          if (!props.boolean && !props.booleanNumeric) {
            let option_list = JSON.parse(props.dataValues);
            for (let key in option_list) {
              if (key !== "_" && key !== "null" && option_list.hasOwnProperty(key)) {
                list.value.push({
                  "label": option_list[key],
                  "value": key
                });
              }
            }
          }
        }
        function checkChange(optionValue) {
          if (props.boolean) {
            inputValue.value = !inputValue.value;
          } else if (props.booleanNumeric) {
            inputValue.value = inputValue.value === 1 ? 0 : 1;
          } else {
            let selected_list = window.ModularForms.Helpers.Common.isValidJSON(inputValue.value) ? JSON.parse(inputValue.value) : [];
            if (selected_list.includes(optionValue)) {
              selected_list = selected_list.filter((item) => item !== optionValue);
            } else {
              selected_list.push(optionValue);
            }
            inputValue.value = JSON.stringify(selected_list);
          }
        }
        function checkValue(value) {
          if (props.boolean) {
            return value === true;
          } else if (props.booleanNumeric) {
            return value === 1;
          }
        }
        function isOptionChecked(value) {
          return window.ModularForms.Helpers.Common.isValidJSON(inputValue.value) ? JSON.parse(inputValue.value).includes(value) : false;
        }
        const __returned__ = { sortList, props, inputValue, get list() {
          return list;
        }, set list(v2) {
          list = v2;
        }, isChecked, initializeOptions, checkChange, checkValue, isOptionChecked, computed, onBeforeMount, ref, get useList() {
          return useList$1;
        } };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$K = {
      key: 0,
      class: "checkbox"
    };
    const _hoisted_2$C = ["name", "id", "checked"];
    const _hoisted_3$u = ["for"];
    const _hoisted_4$m = ["name", "id", "checked", "onChange"];
    const _hoisted_5$l = ["for"];
    function _sfc_render$_(_ctx, _cache, $props, $setup, $data, $options) {
      return $props.boolean || $props.booleanNumeric ? (openBlock(), createElementBlock("span", _hoisted_1$K, [
        createBaseVNode("input", {
          type: "checkbox",
          name: $props.id,
          id: "bool-check_" + $props.id,
          checked: $setup.isChecked,
          onChange: _cache[0] || (_cache[0] = ($event) => $setup.checkChange())
        }, null, 40, _hoisted_2$C),
        createBaseVNode("label", {
          for: "bool-check_" + $props.id
        }, null, 8, _hoisted_3$u)
      ])) : (openBlock(), createElementBlock("span", {
        key: 1,
        class: normalizeClass(["checkbox list", $props.inline ? "inline" : ""])
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($setup.list, (option) => {
          return openBlock(), createElementBlock("span", null, [
            createBaseVNode("input", {
              type: "checkbox",
              name: $props.id,
              id: "check_" + option.value + "_" + $props.id,
              checked: $setup.isOptionChecked(option.value),
              onChange: ($event) => $setup.checkChange(option.value)
            }, null, 40, _hoisted_4$m),
            createBaseVNode("label", {
              for: "check_" + option.value + "_" + $props.id
            }, toDisplayString(option.label), 9, _hoisted_5$l)
          ]);
        }), 256))
      ], 2));
    }
    const checkbox = /* @__PURE__ */ _export_sfc(_sfc_main$_, [["render", _sfc_render$_], ["__file", "/var/www/html/vendor/andreamarelli/modular-forms/src/resources/assets/js/inputs/checkbox.vue"]]);
    const _sfc_main$Z = {
      __name: "redlist_category",
      props: {
        category: {
          type: String,
          default: null
        },
        compact: {
          type: Boolean,
          default: false
        }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const Locale2 = window.ModularForms.Helpers.Locale;
        const props = __props;
        const category_plain = Locale2.getLabel("modular-forms::entities.biodiversity.red_list_categories." + props.category);
        const __returned__ = { Locale: Locale2, props, category_plain };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    function _sfc_render$Z(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_tooltip = resolveComponent("tooltip");
      return openBlock(), createElementBlock("div", null, [
        createBaseVNode("span", {
          class: normalizeClass([$props.compact ? "compact" : "", "red-list_" + $props.category])
        }, toDisplayString($props.category), 3),
        createVNode(_component_tooltip, null, {
          default: withCtx(() => [
            createTextVNode(toDisplayString($setup.category_plain), 1)
          ]),
          _: 1
        })
      ]);
    }
    const redlist_category = /* @__PURE__ */ _export_sfc(_sfc_main$Z, [["render", _sfc_render$Z], ["__file", "/var/www/html/vendor/andreamarelli/modular-forms/src/resources/assets/js/templates/redlist_category.vue"]]);
    const redListImgUrl = "/build/assets/iucn_red_list-Bn3APVvg.png";
    const _sfc_main$Y = {
      __name: "selector-species_animal",
      props: /* @__PURE__ */ mergeModels({
        id: {
          type: String,
          default: null
        },
        searchUrl: {
          type: String,
          default: null
        },
        withInsert: {
          type: Boolean,
          default: false
        }
      }, {
        "modelValue": {},
        "modelModifiers": {}
      }),
      emits: ["update:modelValue"],
      setup(__props, { expose: __expose }) {
        __expose();
        const Locale2 = window.ModularForms.Helpers.Locale;
        const props = __props;
        const selectorDialogComponent = ref(null);
        provide("setLabel", setLabel);
        provide("setValue", setValue);
        provide("afterSearch", afterSearch);
        const inputValue = useModel(__props, "modelValue");
        const filterByClass = ref(null);
        const filterByOrder = ref(null);
        const orders = ref([]);
        const classes = ref([]);
        function setLabel(item) {
          if (typeof item === "object") {
            return item.genus + " " + item.species;
          } else if (item.split("|").length > 3) {
            let taxonomy = item.split("|");
            return taxonomy[4] + " " + taxonomy[5];
          }
          return item;
        }
        function setValue(item) {
          if (typeof item == "object") {
            return item.phylum + "|" + item.class + "|" + item.order + "|" + item.family + "|" + item.genus + "|" + item.species;
          }
          return item;
        }
        function getSpeciesDescription(item) {
          let description = "<div>" + item.class + " " + item.order + " " + item.family + " <b>" + item.genus + " " + item.species + "</b></div>";
          if (hasCommonNames(item)) {
            description += '<div class="common_names"><b><i>' + Locale2.getLabel("modular-forms::entities.biodiversity.common_names") + ":</i></b><br />";
            if (item.common_name_en !== null && item.common_name_en.toLowerCase() !== "null") {
              description += '<div><span class="fi fi-gb"></span> ' + item.common_name_en.replace(/\,/g, ", ") + "</div>";
            }
            if (item.common_name_fr !== null && item.common_name_fr.toLowerCase() !== "null") {
              description += '<div><span class="fi fi-fr"></span> ' + item.common_name_fr.replace(/\,/g, ", ") + "</div>";
            }
            if (item.common_name_sp !== null && item.common_name_sp.toLowerCase() !== "null") {
              description += '<div><span class="fi fi-es"></span> ' + item.common_name_sp.replace(/\,/g, ", ") + "</div>";
            }
            description += "</div>";
          }
          return description;
        }
        function hasCommonNames(item) {
          return item.common_name_en !== null || item.common_name_fr !== null || item.common_name_sp !== null;
        }
        function afterSearch(data) {
          orders.value = data["orders"];
          classes.value = data["classes"];
          filterByOrder.value = null;
          filterByClass.value = null;
        }
        function orderByClass() {
          return filterByClass.value != null ? orders.value[filterByClass.value] : [];
        }
        function filterList(alsoResetOrder) {
          if (alsoResetOrder) {
            filterByOrder.value = null;
          }
          filterByOrder.value = typeof filterByOrder.value === "undefined" ? null : filterByOrder.value;
          selectorDialogComponent.value.filterShowList({
            "class": filterByClass.value,
            "order": filterByOrder.value
          });
        }
        const __returned__ = { Locale: Locale2, props, selectorDialogComponent, inputValue, filterByClass, filterByOrder, orders, classes, setLabel, setValue, getSpeciesDescription, hasCommonNames, afterSearch, orderByClass, filterList, ref, provide, selectorDialog, redlist_category, get redListImgUrl() {
          return redListImgUrl;
        } };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$J = ["innerHTML"];
    const _hoisted_2$B = ["href"];
    const _hoisted_3$t = ["src"];
    function _sfc_render$Y(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createBlock($setup["selectorDialog"], {
        modelValue: $setup.inputValue,
        "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => $setup.inputValue = $event),
        "parent-id": $props.id,
        "search-url": $props.searchUrl,
        "with-insert": $props.withInsert,
        ref: "selectorDialogComponent"
      }, {
        searchResultFilters: withCtx(() => [
          createBaseVNode("i", null, toDisplayString($setup.Locale.getLabel("modular-forms::common.filter_results")) + ": ", 1),
          createTextVNode(" " + toDisplayString($setup.Locale.getLabel("modular-forms::entities.biodiversity.taxonomy.class")) + " ", 1),
          withDirectives(createBaseVNode("select", {
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.filterByClass = $event),
            onChange: _cache[1] || (_cache[1] = ($event) => $setup.filterList(true)),
            class: "field-edit filterByClass"
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList($setup.classes, (option) => {
              return openBlock(), createElementBlock("option", null, toDisplayString(option), 1);
            }), 256))
          ], 544), [
            [vModelSelect, $setup.filterByClass]
          ]),
          createTextVNode(" " + toDisplayString($setup.Locale.getLabel("modular-forms::entities.biodiversity.taxonomy.order")) + " ", 1),
          withDirectives(createBaseVNode("select", {
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $setup.filterByOrder = $event),
            onChange: _cache[3] || (_cache[3] = ($event) => $setup.filterList(false)),
            class: "field-edit filterByOrder"
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList($setup.orderByClass(), (option) => {
              return openBlock(), createElementBlock("option", null, toDisplayString(option), 1);
            }), 256))
          ], 544), [
            [vModelSelect, $setup.filterByOrder]
          ])
        ]),
        searchResultHeader: withCtx(() => [
          createBaseVNode("th", null, toDisplayString($setup.Locale.getLabel("modular-forms::entities.biodiversity.species", 1)), 1),
          createBaseVNode("th", null, toDisplayString($setup.Locale.getLabel("modular-forms::entities.biodiversity.red_list_category")), 1),
          createBaseVNode("th", null, toDisplayString($setup.Locale.getLabel("modular-forms::entities.biodiversity.red_list")), 1)
        ]),
        searchResultItem: withCtx(({ item }) => [
          createBaseVNode("td", null, [
            createBaseVNode("span", {
              class: "result_left",
              innerHTML: $setup.getSpeciesDescription(item)
            }, null, 8, _hoisted_1$J)
          ]),
          createBaseVNode("td", null, [
            createVNode($setup["redlist_category"], {
              category: item.iucn_redlist_category
            }, null, 8, ["category"])
          ]),
          createBaseVNode("td", null, [
            createBaseVNode("a", {
              target: "_blank",
              href: "http://www.iucnredlist.org/details/" + item.iucn_redlist_id + "/0"
            }, [
              createBaseVNode("img", {
                style: { "display": "inline-block" },
                src: $setup.redListImgUrl,
                alt: "IUCN RedList"
              }, null, 8, _hoisted_3$t)
            ], 8, _hoisted_2$B)
          ])
        ]),
        _: 1
      }, 8, ["modelValue", "parent-id", "search-url", "with-insert"]);
    }
    const selectorSpeciesAnimal = /* @__PURE__ */ _export_sfc(_sfc_main$Y, [["render", _sfc_render$Y], ["__scopeId", "data-v-dc359e20"], ["__file", "/var/www/html/vendor/andreamarelli/modular-forms/src/resources/assets/js/inputs/selector-species_animal.vue"]]);
    const _sfc_main$X = {
      __name: "upload",
      props: /* @__PURE__ */ mergeModels({
        uploadUrl: {
          type: String,
          default: null
        },
        allowedFormats: {
          type: Array,
          default: function() {
            return null;
          }
        },
        maxFileSize: {
          type: Number,
          default: 1e7
          // 10Mb
        }
      }, {
        "modelValue": {},
        "modelModifiers": {}
      }),
      emits: ["update:modelValue"],
      setup(__props, { expose: __expose }) {
        __expose();
        const Locale2 = window.ModularForms.Helpers.Locale;
        const props = __props;
        const dialogComponent = ref(null);
        const fileInput2 = ref(null);
        const inputValue = useModel(__props, "modelValue");
        let isFileSelected = ref(false);
        let selectedFile = ref(null);
        let selectedFileName = ref(null);
        let errorMessage = ref(null);
        let isUploading = ref(false);
        function openUploadDialog() {
          resetUploadDialog();
          dialogComponent.value.openDialog();
        }
        function closeUploadDialog() {
          dialogComponent.value.closeDialog();
          resetUploadDialog();
        }
        function resetUploadDialog() {
          isFileSelected.value = false;
          selectedFile.value = null;
          selectedFileName.value = null;
        }
        function openFileSelection() {
          fileInput2.value.click();
        }
        function validateFile(event) {
          errorMessage.value = null;
          let message = null;
          if (event.target.files.length > 0) {
            selectedFile.value = event.target.files[0];
            selectedFileName.value = selectedFile.value.name;
            isFileSelected.value = true;
            let extension = selectedFileName.value.split(".").pop();
            if (selectedFile.value.size > props.maxFileSize) {
              message = Locale2.getLabel("modular-forms::common.upload.too_big");
              message = message.replace("__maxFileSize__", props.maxFileSize / 1e6);
              isFileSelected.value = false;
            }
            if (props.allowedFormats !== null && !props.allowedFormats.includes(extension)) {
              message = Locale2.getLabel("modular-forms::common.upload.not_valid_format");
              isFileSelected.value = false;
            }
            let regex = /^[a-zA-Z0-9-_.&()\s]{1,250}\.[a-zA-Z0-9]{2,5}$/;
            if (!regex.test(selectedFileName.value)) {
              message = Locale2.getLabel("modular-forms::common.upload.not_valid_filename");
              isFileSelected.value = false;
            }
          }
          if (message !== null) {
            errorMessage.value = message;
          }
          event.target.value = "";
        }
        function uploadFile2() {
          isUploading.value = true;
          let data = new FormData();
          data.append("file_upload", selectedFile.value);
          fetch(props.uploadUrl, {
            method: "post",
            headers: {
              "X-CSRF-Token": window.Laravel.csrfToken
            },
            body: data
          }).then((response) => response.json()).then(function(data2) {
            applyAndClose(data2);
          }).catch(function(data2) {
            errorMessage.value = Locale2.getLabel("modular-forms::common.upload.error");
          }).finally(function(data2) {
            isUploading.value = false;
          });
        }
        function applyAndClose(response) {
          inputValue.value = {
            "original_filename": response.original_filename,
            "temp_filename": response.temp_filename,
            "download_link": response["download_link"],
            "changed": true
          };
          closeUploadDialog();
        }
        function deleteSelection() {
          inputValue.value = {
            "original_filename": null,
            "temp_filename": null,
            "download_link": null,
            "changed": true
          };
        }
        const __returned__ = { Locale: Locale2, props, dialogComponent, fileInput: fileInput2, inputValue, get isFileSelected() {
          return isFileSelected;
        }, set isFileSelected(v2) {
          isFileSelected = v2;
        }, get selectedFile() {
          return selectedFile;
        }, set selectedFile(v2) {
          selectedFile = v2;
        }, get selectedFileName() {
          return selectedFileName;
        }, set selectedFileName(v2) {
          selectedFileName = v2;
        }, get errorMessage() {
          return errorMessage;
        }, set errorMessage(v2) {
          errorMessage = v2;
        }, get isUploading() {
          return isUploading;
        }, set isUploading(v2) {
          isUploading = v2;
        }, openUploadDialog, closeUploadDialog, resetUploadDialog, openFileSelection, validateFile, uploadFile: uploadFile2, applyAndClose, deleteSelection, ref, provide, onMounted };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$I = { class: "upload-anchor dontOpenDialog" };
    const _hoisted_2$A = { class: "field-preview upload-filename" };
    const _hoisted_3$s = ["href"];
    const _hoisted_4$l = { class: "with_header_and_footer" };
    const _hoisted_5$k = { class: "header" };
    const _hoisted_6$f = { class: "dialog-title" };
    const _hoisted_7$c = { class: "body" };
    const _hoisted_8$8 = { key: 0 };
    const _hoisted_9$7 = { key: 1 };
    const _hoisted_10$5 = { class: "text-info" };
    const _hoisted_11$5 = {
      key: 0,
      class: "fa fa-spinner fa-spin fa-2x green-800"
    };
    const _hoisted_12$4 = { class: "footer" };
    const _hoisted_13$4 = { class: "error text-sm" };
    function _sfc_render$X(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_dialog_box = resolveComponent("dialog-box");
      return openBlock(), createBlock(_component_dialog_box, { ref: "dialogComponent" }, {
        "dialog-anchor": withCtx(() => [
          createBaseVNode("div", _hoisted_1$I, [
            createBaseVNode("span", _hoisted_2$A, toDisplayString($setup.inputValue instanceof Object ? $setup.inputValue.original_filename : $setup.inputValue), 1),
            withDirectives(createBaseVNode("a", {
              class: "btn-nav dark small",
              target: "_blank",
              href: $setup.inputValue.download_link
            }, _cache[0] || (_cache[0] = [
              createBaseVNode("i", { class: "fa fa-cloud-download-alt white" }, null, -1)
            ]), 8, _hoisted_3$s), [
              [vShow, $setup.inputValue.original_filename !== null]
            ]),
            withDirectives(createBaseVNode("button", {
              type: "button",
              class: "btn-nav small red",
              onClick: $setup.deleteSelection
            }, _cache[1] || (_cache[1] = [
              createBaseVNode("i", { class: "fa fa-times-circle white" }, null, -1)
            ]), 512), [
              [vShow, $setup.inputValue.original_filename !== null]
            ]),
            withDirectives(createBaseVNode("button", {
              type: "button",
              class: "btn-nav small",
              onClick: $setup.openUploadDialog
            }, [
              _cache[2] || (_cache[2] = createBaseVNode("i", { class: "fa fa-upload white" }, null, -1)),
              createTextVNode(" " + toDisplayString($setup.Locale.getLabel("modular-forms::common.upload.upload_file")), 1)
            ], 512), [
              [vShow, $setup.inputValue.original_filename === null]
            ])
          ])
        ]),
        "dialog-content": withCtx(() => [
          withDirectives(createBaseVNode("input", {
            ref: "fileInput",
            name: "file_upload",
            type: "file",
            onChange: $setup.validateFile
          }, null, 544), [
            [vShow, false]
          ]),
          createBaseVNode("div", _hoisted_4$l, [
            createBaseVNode("div", _hoisted_5$k, [
              createBaseVNode("div", _hoisted_6$f, toDisplayString($setup.Locale.getLabel("modular-forms::common.upload.upload_file")), 1),
              createBaseVNode("button", {
                type: "button",
                class: "close",
                onClick: $setup.closeUploadDialog
              }, _cache[3] || (_cache[3] = [
                createBaseVNode("i", { class: "fa fa-times black" }, null, -1)
              ]))
            ]),
            createBaseVNode("div", _hoisted_7$c, [
              !$setup.isFileSelected ? (openBlock(), createElementBlock("span", _hoisted_8$8, [
                createBaseVNode("label", null, toDisplayString($setup.Locale.getLabel("modular-forms::common.upload.no_file_selected")), 1),
                _cache[5] || (_cache[5] = createTextVNode("  ")),
                createBaseVNode("button", {
                  type: "button",
                  onClick: $setup.openFileSelection,
                  class: "btn-nav small"
                }, [
                  _cache[4] || (_cache[4] = createBaseVNode("i", { class: "fa fa-folder-open white" }, null, -1)),
                  createTextVNode(" " + toDisplayString($setup.Locale.getLabel("modular-forms::common.upload.select_file")), 1)
                ])
              ])) : createCommentVNode("", true),
              $setup.isFileSelected ? (openBlock(), createElementBlock("span", _hoisted_9$7, [
                createBaseVNode("label", null, [
                  createBaseVNode("span", _hoisted_10$5, [
                    _cache[6] || (_cache[6] = createBaseVNode("i", { class: "fa fa-file" }, null, -1)),
                    createTextVNode("" + toDisplayString($setup.selectedFileName), 1)
                  ])
                ]),
                _cache[8] || (_cache[8] = createTextVNode("  ")),
                $setup.isUploading ? (openBlock(), createElementBlock("i", _hoisted_11$5)) : createCommentVNode("", true),
                createBaseVNode("button", {
                  type: "button",
                  onClick: $setup.uploadFile,
                  class: normalizeClass(["btn-nav small", { hidden: $setup.isUploading }])
                }, [
                  _cache[7] || (_cache[7] = createBaseVNode("i", { class: "fa fa-upload white" }, null, -1)),
                  createTextVNode(" " + toDisplayString($setup.Locale.getLabel("modular-forms::common.upload.upload")), 1)
                ], 2)
              ])) : createCommentVNode("", true)
            ]),
            withDirectives(createBaseVNode("div", _hoisted_12$4, [
              createBaseVNode("div", _hoisted_13$4, toDisplayString($setup.errorMessage), 1)
            ], 512), [
              [vShow, $setup.errorMessage != null]
            ])
          ])
        ]),
        _: 1
      }, 512);
    }
    const uploadFile = /* @__PURE__ */ _export_sfc(_sfc_main$X, [["render", _sfc_render$X], ["__scopeId", "data-v-32093f7c"], ["__file", "/var/www/html/vendor/andreamarelli/modular-forms/src/resources/assets/js/inputs/upload.vue"]]);
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root$1 = freeGlobal || freeSelf || Function("return this")();
    var Symbol$1 = root$1.Symbol;
    var objectProto$s = Object.prototype;
    var hasOwnProperty$o = objectProto$s.hasOwnProperty;
    var nativeObjectToString$3 = objectProto$s.toString;
    var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty$o.call(value, symToStringTag$1), tag = value[symToStringTag$1];
      try {
        value[symToStringTag$1] = void 0;
        var unmasked = true;
      } catch (e2) {
      }
      var result2 = nativeObjectToString$3.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }
      return result2;
    }
    var objectProto$r = Object.prototype;
    var nativeObjectToString$2 = objectProto$r.toString;
    function objectToString(value) {
      return nativeObjectToString$2.call(value);
    }
    var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var symbolTag$3 = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$3;
    }
    var NAN$2 = 0 / 0;
    function baseToNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN$2;
      }
      return +value;
    }
    function arrayMap(array2, iteratee2) {
      var index = -1, length = array2 == null ? 0 : array2.length, result2 = Array(length);
      while (++index < length) {
        result2[index] = iteratee2(array2[index], index, array2);
      }
      return result2;
    }
    var isArray = Array.isArray;
    var INFINITY$5 = 1 / 0;
    var symbolProto$2 = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result2 = value + "";
      return result2 == "0" && 1 / value == -INFINITY$5 ? "-0" : result2;
    }
    function createMathOperation(operator, defaultValue) {
      return function(value, other) {
        var result2;
        if (value === void 0 && other === void 0) {
          return defaultValue;
        }
        if (value !== void 0) {
          result2 = value;
        }
        if (other !== void 0) {
          if (result2 === void 0) {
            return other;
          }
          if (typeof value == "string" || typeof other == "string") {
            value = baseToString(value);
            other = baseToString(other);
          } else {
            value = baseToNumber(value);
            other = baseToNumber(other);
          }
          result2 = operator(value, other);
        }
        return result2;
      };
    }
    var add = createMathOperation(function(augend, addend) {
      return augend + addend;
    }, 0);
    var reWhitespace = /\s/;
    function trimmedEndIndex(string2) {
      var index = string2.length;
      while (index-- && reWhitespace.test(string2.charAt(index))) {
      }
      return index;
    }
    var reTrimStart$2 = /^\s+/;
    function baseTrim(string2) {
      return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart$2, "") : string2;
    }
    function isObject$3(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    var NAN$1 = 0 / 0;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN$1;
      }
      if (isObject$3(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject$3(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN$1 : +value;
    }
    var INFINITY$4 = 1 / 0, MAX_INTEGER = 17976931348623157e292;
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY$4 || value === -INFINITY$4) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result2 = toFinite(value), remainder = result2 % 1;
      return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
    }
    var FUNC_ERROR_TEXT$b = "Expected a function";
    function after(n2, func2) {
      if (typeof func2 != "function") {
        throw new TypeError(FUNC_ERROR_TEXT$b);
      }
      n2 = toInteger(n2);
      return function() {
        if (--n2 < 1) {
          return func2.apply(this, arguments);
        }
      };
    }
    function identity(value) {
      return value;
    }
    var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
    function isFunction(value) {
      if (!isObject$3(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
    }
    var coreJsData = root$1["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid2 ? "Symbol(src)_1." + uid2 : "";
    }();
    function isMasked(func2) {
      return !!maskSrcKey && maskSrcKey in func2;
    }
    var funcProto$2 = Function.prototype;
    var funcToString$2 = funcProto$2.toString;
    function toSource(func2) {
      if (func2 != null) {
        try {
          return funcToString$2.call(func2);
        } catch (e2) {
        }
        try {
          return func2 + "";
        } catch (e2) {
        }
      }
      return "";
    }
    var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto$1 = Function.prototype, objectProto$q = Object.prototype;
    var funcToString$1 = funcProto$1.toString;
    var hasOwnProperty$n = objectProto$q.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString$1.call(hasOwnProperty$n).replace(reRegExpChar$1, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject$3(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function getValue(object2, key) {
      return object2 == null ? void 0 : object2[key];
    }
    function getNative(object2, key) {
      var value = getValue(object2, key);
      return baseIsNative(value) ? value : void 0;
    }
    var WeakMap$1 = getNative(root$1, "WeakMap");
    var metaMap = WeakMap$1 && new WeakMap$1();
    var baseSetData = !metaMap ? identity : function(func2, data) {
      metaMap.set(func2, data);
      return func2;
    };
    var objectCreate = Object.create;
    var baseCreate = /* @__PURE__ */ function() {
      function object2() {
      }
      return function(proto) {
        if (!isObject$3(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object2.prototype = proto;
        var result2 = new object2();
        object2.prototype = void 0;
        return result2;
      };
    }();
    function createCtor(Ctor) {
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0:
            return new Ctor();
          case 1:
            return new Ctor(args[0]);
          case 2:
            return new Ctor(args[0], args[1]);
          case 3:
            return new Ctor(args[0], args[1], args[2]);
          case 4:
            return new Ctor(args[0], args[1], args[2], args[3]);
          case 5:
            return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6:
            return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7:
            return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
        return isObject$3(result2) ? result2 : thisBinding;
      };
    }
    var WRAP_BIND_FLAG$8 = 1;
    function createBind(func2, bitmask, thisArg) {
      var isBind = bitmask & WRAP_BIND_FLAG$8, Ctor = createCtor(func2);
      function wrapper() {
        var fn2 = this && this !== root$1 && this instanceof wrapper ? Ctor : func2;
        return fn2.apply(isBind ? thisArg : this, arguments);
      }
      return wrapper;
    }
    function apply(func2, thisArg, args) {
      switch (args.length) {
        case 0:
          return func2.call(thisArg);
        case 1:
          return func2.call(thisArg, args[0]);
        case 2:
          return func2.call(thisArg, args[0], args[1]);
        case 3:
          return func2.call(thisArg, args[0], args[1], args[2]);
      }
      return func2.apply(thisArg, args);
    }
    var nativeMax$g = Math.max;
    function composeArgs(args, partials, holders, isCurried) {
      var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax$g(argsLength - holdersLength, 0), result2 = Array(leftLength + rangeLength), isUncurried = !isCurried;
      while (++leftIndex < leftLength) {
        result2[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result2[holders[argsIndex]] = args[argsIndex];
        }
      }
      while (rangeLength--) {
        result2[leftIndex++] = args[argsIndex++];
      }
      return result2;
    }
    var nativeMax$f = Math.max;
    function composeArgsRight(args, partials, holders, isCurried) {
      var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax$f(argsLength - holdersLength, 0), result2 = Array(rangeLength + rightLength), isUncurried = !isCurried;
      while (++argsIndex < rangeLength) {
        result2[argsIndex] = args[argsIndex];
      }
      var offset2 = argsIndex;
      while (++rightIndex < rightLength) {
        result2[offset2 + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result2[offset2 + holders[holdersIndex]] = args[argsIndex++];
        }
      }
      return result2;
    }
    function countHolders(array2, placeholder) {
      var length = array2.length, result2 = 0;
      while (length--) {
        if (array2[length] === placeholder) {
          ++result2;
        }
      }
      return result2;
    }
    function baseLodash() {
    }
    var MAX_ARRAY_LENGTH$6 = 4294967295;
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = MAX_ARRAY_LENGTH$6;
      this.__views__ = [];
    }
    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;
    function noop$2() {
    }
    var getData = !metaMap ? noop$2 : function(func2) {
      return metaMap.get(func2);
    };
    var realNames = {};
    var objectProto$p = Object.prototype;
    var hasOwnProperty$m = objectProto$p.hasOwnProperty;
    function getFuncName(func2) {
      var result2 = func2.name + "", array2 = realNames[result2], length = hasOwnProperty$m.call(realNames, result2) ? array2.length : 0;
      while (length--) {
        var data = array2[length], otherFunc = data.func;
        if (otherFunc == null || otherFunc == func2) {
          return data.name;
        }
      }
      return result2;
    }
    function LodashWrapper(value, chainAll) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__chain__ = !!chainAll;
      this.__index__ = 0;
      this.__values__ = void 0;
    }
    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;
    function copyArray(source, array2) {
      var index = -1, length = source.length;
      array2 || (array2 = Array(length));
      while (++index < length) {
        array2[index] = source[index];
      }
      return array2;
    }
    function wrapperClone(wrapper) {
      if (wrapper instanceof LazyWrapper) {
        return wrapper.clone();
      }
      var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
      result2.__actions__ = copyArray(wrapper.__actions__);
      result2.__index__ = wrapper.__index__;
      result2.__values__ = wrapper.__values__;
      return result2;
    }
    var objectProto$o = Object.prototype;
    var hasOwnProperty$l = objectProto$o.hasOwnProperty;
    function lodash$1(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty$l.call(value, "__wrapped__")) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }
    lodash$1.prototype = baseLodash.prototype;
    lodash$1.prototype.constructor = lodash$1;
    function isLaziable(func2) {
      var funcName = getFuncName(func2), other = lodash$1[funcName];
      if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
        return false;
      }
      if (func2 === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func2 === data[0];
    }
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func2) {
      var count2 = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count2 >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count2 = 0;
        }
        return func2.apply(void 0, arguments);
      };
    }
    var setData = shortOut(baseSetData);
    var reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    function getWrapDetails(source) {
      var match = source.match(reWrapDetails);
      return match ? match[1].split(reSplitDetails) : [];
    }
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;
    function insertWrapDetails(source, details) {
      var length = details.length;
      if (!length) {
        return source;
      }
      var lastIndex = length - 1;
      details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
      details = details.join(length > 2 ? ", " : " ");
      return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
    }
    function constant(value) {
      return function() {
        return value;
      };
    }
    var defineProperty = function() {
      try {
        var func2 = getNative(Object, "defineProperty");
        func2({}, "", {});
        return func2;
      } catch (e2) {
      }
    }();
    var baseSetToString = !defineProperty ? identity : function(func2, string2) {
      return defineProperty(func2, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string2),
        "writable": true
      });
    };
    var setToString = shortOut(baseSetToString);
    function arrayEach(array2, iteratee2) {
      var index = -1, length = array2 == null ? 0 : array2.length;
      while (++index < length) {
        if (iteratee2(array2[index], index, array2) === false) {
          break;
        }
      }
      return array2;
    }
    function baseFindIndex(array2, predicate, fromIndex, fromRight) {
      var length = array2.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array2[index], index, array2)) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function strictIndexOf(array2, value, fromIndex) {
      var index = fromIndex - 1, length = array2.length;
      while (++index < length) {
        if (array2[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array2, value, fromIndex) {
      return value === value ? strictIndexOf(array2, value, fromIndex) : baseFindIndex(array2, baseIsNaN, fromIndex);
    }
    function arrayIncludes(array2, value) {
      var length = array2 == null ? 0 : array2.length;
      return !!length && baseIndexOf(array2, value, 0) > -1;
    }
    var WRAP_BIND_FLAG$7 = 1, WRAP_BIND_KEY_FLAG$6 = 2, WRAP_CURRY_FLAG$6 = 8, WRAP_CURRY_RIGHT_FLAG$3 = 16, WRAP_PARTIAL_FLAG$6 = 32, WRAP_PARTIAL_RIGHT_FLAG$3 = 64, WRAP_ARY_FLAG$4 = 128, WRAP_REARG_FLAG$3 = 256, WRAP_FLIP_FLAG$2 = 512;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG$4],
      ["bind", WRAP_BIND_FLAG$7],
      ["bindKey", WRAP_BIND_KEY_FLAG$6],
      ["curry", WRAP_CURRY_FLAG$6],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG$3],
      ["flip", WRAP_FLIP_FLAG$2],
      ["partial", WRAP_PARTIAL_FLAG$6],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG$3],
      ["rearg", WRAP_REARG_FLAG$3]
    ];
    function updateWrapDetails(details, bitmask) {
      arrayEach(wrapFlags, function(pair) {
        var value = "_." + pair[0];
        if (bitmask & pair[1] && !arrayIncludes(details, value)) {
          details.push(value);
        }
      });
      return details.sort();
    }
    function setWrapToString(wrapper, reference2, bitmask) {
      var source = reference2 + "";
      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
    }
    var WRAP_BIND_FLAG$6 = 1, WRAP_BIND_KEY_FLAG$5 = 2, WRAP_CURRY_BOUND_FLAG$1 = 4, WRAP_CURRY_FLAG$5 = 8, WRAP_PARTIAL_FLAG$5 = 32, WRAP_PARTIAL_RIGHT_FLAG$2 = 64;
    function createRecurry(func2, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
      var isCurry = bitmask & WRAP_CURRY_FLAG$5, newHolders = isCurry ? holders : void 0, newHoldersRight = isCurry ? void 0 : holders, newPartials = isCurry ? partials : void 0, newPartialsRight = isCurry ? void 0 : partials;
      bitmask |= isCurry ? WRAP_PARTIAL_FLAG$5 : WRAP_PARTIAL_RIGHT_FLAG$2;
      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG$2 : WRAP_PARTIAL_FLAG$5);
      if (!(bitmask & WRAP_CURRY_BOUND_FLAG$1)) {
        bitmask &= ~(WRAP_BIND_FLAG$6 | WRAP_BIND_KEY_FLAG$5);
      }
      var newData = [
        func2,
        bitmask,
        thisArg,
        newPartials,
        newHolders,
        newPartialsRight,
        newHoldersRight,
        argPos,
        ary2,
        arity
      ];
      var result2 = wrapFunc.apply(void 0, newData);
      if (isLaziable(func2)) {
        setData(result2, newData);
      }
      result2.placeholder = placeholder;
      return setWrapToString(result2, func2, bitmask);
    }
    function getHolder(func2) {
      var object2 = func2;
      return object2.placeholder;
    }
    var MAX_SAFE_INTEGER$5 = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER$5 : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    var nativeMin$e = Math.min;
    function reorder(array2, indexes) {
      var arrLength = array2.length, length = nativeMin$e(indexes.length, arrLength), oldArray = copyArray(array2);
      while (length--) {
        var index = indexes[length];
        array2[length] = isIndex(index, arrLength) ? oldArray[index] : void 0;
      }
      return array2;
    }
    var PLACEHOLDER$1 = "__lodash_placeholder__";
    function replaceHolders(array2, placeholder) {
      var index = -1, length = array2.length, resIndex = 0, result2 = [];
      while (++index < length) {
        var value = array2[index];
        if (value === placeholder || value === PLACEHOLDER$1) {
          array2[index] = PLACEHOLDER$1;
          result2[resIndex++] = index;
        }
      }
      return result2;
    }
    var WRAP_BIND_FLAG$5 = 1, WRAP_BIND_KEY_FLAG$4 = 2, WRAP_CURRY_FLAG$4 = 8, WRAP_CURRY_RIGHT_FLAG$2 = 16, WRAP_ARY_FLAG$3 = 128, WRAP_FLIP_FLAG$1 = 512;
    function createHybrid(func2, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
      var isAry = bitmask & WRAP_ARY_FLAG$3, isBind = bitmask & WRAP_BIND_FLAG$5, isBindKey = bitmask & WRAP_BIND_KEY_FLAG$4, isCurried = bitmask & (WRAP_CURRY_FLAG$4 | WRAP_CURRY_RIGHT_FLAG$2), isFlip = bitmask & WRAP_FLIP_FLAG$1, Ctor = isBindKey ? void 0 : createCtor(func2);
      function wrapper() {
        var length = arguments.length, args = Array(length), index = length;
        while (index--) {
          args[index] = arguments[index];
        }
        if (isCurried) {
          var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
        }
        if (partials) {
          args = composeArgs(args, partials, holders, isCurried);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
        }
        length -= holdersCount;
        if (isCurried && length < arity) {
          var newHolders = replaceHolders(args, placeholder);
          return createRecurry(
            func2,
            bitmask,
            createHybrid,
            wrapper.placeholder,
            thisArg,
            args,
            newHolders,
            argPos,
            ary2,
            arity - length
          );
        }
        var thisBinding = isBind ? thisArg : this, fn2 = isBindKey ? thisBinding[func2] : func2;
        length = args.length;
        if (argPos) {
          args = reorder(args, argPos);
        } else if (isFlip && length > 1) {
          args.reverse();
        }
        if (isAry && ary2 < length) {
          args.length = ary2;
        }
        if (this && this !== root$1 && this instanceof wrapper) {
          fn2 = Ctor || createCtor(fn2);
        }
        return fn2.apply(thisBinding, args);
      }
      return wrapper;
    }
    function createCurry(func2, bitmask, arity) {
      var Ctor = createCtor(func2);
      function wrapper() {
        var length = arguments.length, args = Array(length), index = length, placeholder = getHolder(wrapper);
        while (index--) {
          args[index] = arguments[index];
        }
        var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
        length -= holders.length;
        if (length < arity) {
          return createRecurry(
            func2,
            bitmask,
            createHybrid,
            wrapper.placeholder,
            void 0,
            args,
            holders,
            void 0,
            void 0,
            arity - length
          );
        }
        var fn2 = this && this !== root$1 && this instanceof wrapper ? Ctor : func2;
        return apply(fn2, this, args);
      }
      return wrapper;
    }
    var WRAP_BIND_FLAG$4 = 1;
    function createPartial(func2, bitmask, thisArg, partials) {
      var isBind = bitmask & WRAP_BIND_FLAG$4, Ctor = createCtor(func2);
      function wrapper() {
        var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn2 = this && this !== root$1 && this instanceof wrapper ? Ctor : func2;
        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        return apply(fn2, isBind ? thisArg : this, args);
      }
      return wrapper;
    }
    var PLACEHOLDER = "__lodash_placeholder__";
    var WRAP_BIND_FLAG$3 = 1, WRAP_BIND_KEY_FLAG$3 = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG$3 = 8, WRAP_ARY_FLAG$2 = 128, WRAP_REARG_FLAG$2 = 256;
    var nativeMin$d = Math.min;
    function mergeData(data, source) {
      var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG$3 | WRAP_BIND_KEY_FLAG$3 | WRAP_ARY_FLAG$2);
      var isCombo = srcBitmask == WRAP_ARY_FLAG$2 && bitmask == WRAP_CURRY_FLAG$3 || srcBitmask == WRAP_ARY_FLAG$2 && bitmask == WRAP_REARG_FLAG$2 && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG$2 | WRAP_REARG_FLAG$2) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG$3;
      if (!(isCommon || isCombo)) {
        return data;
      }
      if (srcBitmask & WRAP_BIND_FLAG$3) {
        data[2] = source[2];
        newBitmask |= bitmask & WRAP_BIND_FLAG$3 ? 0 : WRAP_CURRY_BOUND_FLAG;
      }
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
      }
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
      }
      value = source[7];
      if (value) {
        data[7] = value;
      }
      if (srcBitmask & WRAP_ARY_FLAG$2) {
        data[8] = data[8] == null ? source[8] : nativeMin$d(data[8], source[8]);
      }
      if (data[9] == null) {
        data[9] = source[9];
      }
      data[0] = source[0];
      data[1] = newBitmask;
      return data;
    }
    var FUNC_ERROR_TEXT$a = "Expected a function";
    var WRAP_BIND_FLAG$2 = 1, WRAP_BIND_KEY_FLAG$2 = 2, WRAP_CURRY_FLAG$2 = 8, WRAP_CURRY_RIGHT_FLAG$1 = 16, WRAP_PARTIAL_FLAG$4 = 32, WRAP_PARTIAL_RIGHT_FLAG$1 = 64;
    var nativeMax$e = Math.max;
    function createWrap(func2, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG$2;
      if (!isBindKey && typeof func2 != "function") {
        throw new TypeError(FUNC_ERROR_TEXT$a);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(WRAP_PARTIAL_FLAG$4 | WRAP_PARTIAL_RIGHT_FLAG$1);
        partials = holders = void 0;
      }
      ary2 = ary2 === void 0 ? ary2 : nativeMax$e(toInteger(ary2), 0);
      arity = arity === void 0 ? arity : toInteger(arity);
      length -= holders ? holders.length : 0;
      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG$1) {
        var partialsRight = partials, holdersRight = holders;
        partials = holders = void 0;
      }
      var data = isBindKey ? void 0 : getData(func2);
      var newData = [
        func2,
        bitmask,
        thisArg,
        partials,
        holders,
        partialsRight,
        holdersRight,
        argPos,
        ary2,
        arity
      ];
      if (data) {
        mergeData(newData, data);
      }
      func2 = newData[0];
      bitmask = newData[1];
      thisArg = newData[2];
      partials = newData[3];
      holders = newData[4];
      arity = newData[9] = newData[9] === void 0 ? isBindKey ? 0 : func2.length : nativeMax$e(newData[9] - length, 0);
      if (!arity && bitmask & (WRAP_CURRY_FLAG$2 | WRAP_CURRY_RIGHT_FLAG$1)) {
        bitmask &= ~(WRAP_CURRY_FLAG$2 | WRAP_CURRY_RIGHT_FLAG$1);
      }
      if (!bitmask || bitmask == WRAP_BIND_FLAG$2) {
        var result2 = createBind(func2, bitmask, thisArg);
      } else if (bitmask == WRAP_CURRY_FLAG$2 || bitmask == WRAP_CURRY_RIGHT_FLAG$1) {
        result2 = createCurry(func2, bitmask, arity);
      } else if ((bitmask == WRAP_PARTIAL_FLAG$4 || bitmask == (WRAP_BIND_FLAG$2 | WRAP_PARTIAL_FLAG$4)) && !holders.length) {
        result2 = createPartial(func2, bitmask, thisArg, partials);
      } else {
        result2 = createHybrid.apply(void 0, newData);
      }
      var setter = data ? baseSetData : setData;
      return setWrapToString(setter(result2, newData), func2, bitmask);
    }
    var WRAP_ARY_FLAG$1 = 128;
    function ary(func2, n2, guard) {
      n2 = guard ? void 0 : n2;
      n2 = func2 && n2 == null ? func2.length : n2;
      return createWrap(func2, WRAP_ARY_FLAG$1, void 0, void 0, void 0, void 0, n2);
    }
    function baseAssignValue(object2, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object2, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object2[key] = value;
      }
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var objectProto$n = Object.prototype;
    var hasOwnProperty$k = objectProto$n.hasOwnProperty;
    function assignValue(object2, key, value) {
      var objValue = object2[key];
      if (!(hasOwnProperty$k.call(object2, key) && eq(objValue, value)) || value === void 0 && !(key in object2)) {
        baseAssignValue(object2, key, value);
      }
    }
    function copyObject(source, props, object2, customizer) {
      var isNew = !object2;
      object2 || (object2 = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object2, key, newValue);
        } else {
          assignValue(object2, key, newValue);
        }
      }
      return object2;
    }
    var nativeMax$d = Math.max;
    function overRest(func2, start2, transform2) {
      start2 = nativeMax$d(start2 === void 0 ? func2.length - 1 : start2, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax$d(args.length - start2, 0), array2 = Array(length);
        while (++index < length) {
          array2[index] = args[start2 + index];
        }
        index = -1;
        var otherArgs = Array(start2 + 1);
        while (++index < start2) {
          otherArgs[index] = args[index];
        }
        otherArgs[start2] = transform2(array2);
        return apply(func2, this, otherArgs);
      };
    }
    function baseRest(func2, start2) {
      return setToString(overRest(func2, start2, identity), func2 + "");
    }
    var MAX_SAFE_INTEGER$4 = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$4;
    }
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isIterateeCall(value, index, object2) {
      if (!isObject$3(object2)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object2) && isIndex(index, object2.length) : type == "string" && index in object2) {
        return eq(object2[index], value);
      }
      return false;
    }
    function createAssigner(assigner) {
      return baseRest(function(object2, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object2 = Object(object2);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object2, source, index, customizer);
          }
        }
        return object2;
      });
    }
    var objectProto$m = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$m;
      return value === proto;
    }
    function baseTimes(n2, iteratee2) {
      var index = -1, result2 = Array(n2);
      while (++index < n2) {
        result2[index] = iteratee2(index);
      }
      return result2;
    }
    var argsTag$3 = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag$3;
    }
    var objectProto$l = Object.prototype;
    var hasOwnProperty$j = objectProto$l.hasOwnProperty;
    var propertyIsEnumerable$1 = objectProto$l.propertyIsEnumerable;
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty$j.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
    };
    function stubFalse() {
      return false;
    }
    var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
    var Buffer$2 = moduleExports$2 ? root$1.Buffer : void 0;
    var nativeIsBuffer = Buffer$2 ? Buffer$2.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$4 = "[object Boolean]", dateTag$4 = "[object Date]", errorTag$3 = "[object Error]", funcTag$1 = "[object Function]", mapTag$9 = "[object Map]", numberTag$4 = "[object Number]", objectTag$4 = "[object Object]", regexpTag$4 = "[object RegExp]", setTag$9 = "[object Set]", stringTag$4 = "[object String]", weakMapTag$3 = "[object WeakMap]";
    var arrayBufferTag$4 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
    typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$4] = typedArrayTags[boolTag$4] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$4] = typedArrayTags[errorTag$3] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$9] = typedArrayTags[numberTag$4] = typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$4] = typedArrayTags[setTag$9] = typedArrayTags[stringTag$4] = typedArrayTags[weakMapTag$3] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseUnary(func2) {
      return function(value) {
        return func2(value);
      };
    }
    var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
    var freeProcess = moduleExports$1 && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e2) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    var objectProto$k = Object.prototype;
    var hasOwnProperty$i = objectProto$k.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String) : [], length = result2.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty$i.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result2.push(key);
        }
      }
      return result2;
    }
    function overArg(func2, transform2) {
      return function(arg) {
        return func2(transform2(arg));
      };
    }
    var nativeKeys = overArg(Object.keys, Object);
    var objectProto$j = Object.prototype;
    var hasOwnProperty$h = objectProto$j.hasOwnProperty;
    function baseKeys(object2) {
      if (!isPrototype(object2)) {
        return nativeKeys(object2);
      }
      var result2 = [];
      for (var key in Object(object2)) {
        if (hasOwnProperty$h.call(object2, key) && key != "constructor") {
          result2.push(key);
        }
      }
      return result2;
    }
    function keys(object2) {
      return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
    }
    var objectProto$i = Object.prototype;
    var hasOwnProperty$g = objectProto$i.hasOwnProperty;
    var assign$2 = createAssigner(function(object2, source) {
      if (isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object2);
        return;
      }
      for (var key in source) {
        if (hasOwnProperty$g.call(source, key)) {
          assignValue(object2, key, source[key]);
        }
      }
    });
    function nativeKeysIn(object2) {
      var result2 = [];
      if (object2 != null) {
        for (var key in Object(object2)) {
          result2.push(key);
        }
      }
      return result2;
    }
    var objectProto$h = Object.prototype;
    var hasOwnProperty$f = objectProto$h.hasOwnProperty;
    function baseKeysIn(object2) {
      if (!isObject$3(object2)) {
        return nativeKeysIn(object2);
      }
      var isProto = isPrototype(object2), result2 = [];
      for (var key in object2) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty$f.call(object2, key)))) {
          result2.push(key);
        }
      }
      return result2;
    }
    function keysIn(object2) {
      return isArrayLike(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
    }
    var assignIn = createAssigner(function(object2, source) {
      copyObject(source, keysIn(source), object2);
    });
    var assignInWith = createAssigner(function(object2, source, srcIndex, customizer) {
      copyObject(source, keysIn(source), object2, customizer);
    });
    var assignWith = createAssigner(function(object2, source, srcIndex, customizer) {
      copyObject(source, keys(source), object2, customizer);
    });
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
    function isKey(value, object2) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
    }
    var nativeCreate = getNative(Object, "create");
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result2 = this.has(key) && delete this.__data__[key];
      this.size -= result2 ? 1 : 0;
      return result2;
    }
    var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
    var objectProto$g = Object.prototype;
    var hasOwnProperty$e = objectProto$g.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result2 = data[key];
        return result2 === HASH_UNDEFINED$2 ? void 0 : result2;
      }
      return hasOwnProperty$e.call(data, key) ? data[key] : void 0;
    }
    var objectProto$f = Object.prototype;
    var hasOwnProperty$d = objectProto$f.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty$d.call(data, key);
    }
    var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
      return this;
    }
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function assocIndexOf(array2, key) {
      var length = array2.length;
      while (length--) {
        if (eq(array2[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    var arrayProto$5 = Array.prototype;
    var splice$2 = arrayProto$5.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice$2.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    var Map$1 = getNative(root$1, "Map");
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map$1 || ListCache)(),
        "string": new Hash()
      };
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function getMapData(map2, key) {
      var data = map2.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function mapCacheDelete(key) {
      var result2 = getMapData(this, key)["delete"](key);
      this.size -= result2 ? 1 : 0;
      return result2;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size2 = data.size;
      data.set(key, value);
      this.size += data.size == size2 ? 0 : 1;
      return this;
    }
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    var FUNC_ERROR_TEXT$9 = "Expected a function";
    function memoize(func2, resolver) {
      if (typeof func2 != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT$9);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
        if (cache2.has(key)) {
          return cache2.get(key);
        }
        var result2 = func2.apply(this, args);
        memoized.cache = cache2.set(key, result2) || cache2;
        return result2;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func2) {
      var result2 = memoize(func2, function(key) {
        if (cache2.size === MAX_MEMOIZE_SIZE) {
          cache2.clear();
        }
        return key;
      });
      var cache2 = result2.cache;
      return result2;
    }
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string2) {
      var result2 = [];
      if (string2.charCodeAt(0) === 46) {
        result2.push("");
      }
      string2.replace(rePropName, function(match, number2, quote2, subString) {
        result2.push(quote2 ? subString.replace(reEscapeChar, "$1") : number2 || match);
      });
      return result2;
    });
    function toString$1(value) {
      return value == null ? "" : baseToString(value);
    }
    function castPath(value, object2) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object2) ? [value] : stringToPath(toString$1(value));
    }
    var INFINITY$3 = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result2 = value + "";
      return result2 == "0" && 1 / value == -INFINITY$3 ? "-0" : result2;
    }
    function baseGet(object2, path) {
      path = castPath(path, object2);
      var index = 0, length = path.length;
      while (object2 != null && index < length) {
        object2 = object2[toKey(path[index++])];
      }
      return index && index == length ? object2 : void 0;
    }
    function get(object2, path, defaultValue) {
      var result2 = object2 == null ? void 0 : baseGet(object2, path);
      return result2 === void 0 ? defaultValue : result2;
    }
    function baseAt(object2, paths) {
      var index = -1, length = paths.length, result2 = Array(length), skip = object2 == null;
      while (++index < length) {
        result2[index] = skip ? void 0 : get(object2, paths[index]);
      }
      return result2;
    }
    function arrayPush(array2, values2) {
      var index = -1, length = values2.length, offset2 = array2.length;
      while (++index < length) {
        array2[offset2 + index] = values2[index];
      }
      return array2;
    }
    var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    function baseFlatten(array2, depth, predicate, isStrict, result2) {
      var index = -1, length = array2.length;
      predicate || (predicate = isFlattenable);
      result2 || (result2 = []);
      while (++index < length) {
        var value = array2[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result2);
          } else {
            arrayPush(result2, value);
          }
        } else if (!isStrict) {
          result2[result2.length] = value;
        }
      }
      return result2;
    }
    function flatten(array2) {
      var length = array2 == null ? 0 : array2.length;
      return length ? baseFlatten(array2, 1) : [];
    }
    function flatRest(func2) {
      return setToString(overRest(func2, void 0, flatten), func2 + "");
    }
    var at$1 = flatRest(baseAt);
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectTag$3 = "[object Object]";
    var funcProto = Function.prototype, objectProto$e = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty$c = objectProto$e.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject$2(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag$3) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty$c.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    var domExcTag = "[object DOMException]", errorTag$2 = "[object Error]";
    function isError(value) {
      if (!isObjectLike(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == errorTag$2 || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject$2(value);
    }
    var attempt = baseRest(function(func2, args) {
      try {
        return apply(func2, void 0, args);
      } catch (e2) {
        return isError(e2) ? e2 : new Error(e2);
      }
    });
    var FUNC_ERROR_TEXT$8 = "Expected a function";
    function before(n2, func2) {
      var result2;
      if (typeof func2 != "function") {
        throw new TypeError(FUNC_ERROR_TEXT$8);
      }
      n2 = toInteger(n2);
      return function() {
        if (--n2 > 0) {
          result2 = func2.apply(this, arguments);
        }
        if (n2 <= 1) {
          func2 = void 0;
        }
        return result2;
      };
    }
    var WRAP_BIND_FLAG$1 = 1, WRAP_PARTIAL_FLAG$3 = 32;
    var bind = baseRest(function(func2, thisArg, partials) {
      var bitmask = WRAP_BIND_FLAG$1;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bind));
        bitmask |= WRAP_PARTIAL_FLAG$3;
      }
      return createWrap(func2, bitmask, thisArg, partials, holders);
    });
    bind.placeholder = {};
    var bindAll = flatRest(function(object2, methodNames) {
      arrayEach(methodNames, function(key) {
        key = toKey(key);
        baseAssignValue(object2, key, bind(object2[key], object2));
      });
      return object2;
    });
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG$1 = 2, WRAP_PARTIAL_FLAG$2 = 32;
    var bindKey = baseRest(function(object2, key, partials) {
      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG$1;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bindKey));
        bitmask |= WRAP_PARTIAL_FLAG$2;
      }
      return createWrap(key, bitmask, object2, partials, holders);
    });
    bindKey.placeholder = {};
    function baseSlice(array2, start2, end2) {
      var index = -1, length = array2.length;
      if (start2 < 0) {
        start2 = -start2 > length ? 0 : length + start2;
      }
      end2 = end2 > length ? length : end2;
      if (end2 < 0) {
        end2 += length;
      }
      length = start2 > end2 ? 0 : end2 - start2 >>> 0;
      start2 >>>= 0;
      var result2 = Array(length);
      while (++index < length) {
        result2[index] = array2[index + start2];
      }
      return result2;
    }
    function castSlice(array2, start2, end2) {
      var length = array2.length;
      end2 = end2 === void 0 ? length : end2;
      return !start2 && end2 >= length ? array2 : baseSlice(array2, start2, end2);
    }
    var rsAstralRange$3 = "\\ud800-\\udfff", rsComboMarksRange$4 = "\\u0300-\\u036f", reComboHalfMarksRange$4 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$4 = "\\u20d0-\\u20ff", rsComboRange$4 = rsComboMarksRange$4 + reComboHalfMarksRange$4 + rsComboSymbolsRange$4, rsVarRange$3 = "\\ufe0e\\ufe0f";
    var rsZWJ$3 = "\\u200d";
    var reHasUnicode = RegExp("[" + rsZWJ$3 + rsAstralRange$3 + rsComboRange$4 + rsVarRange$3 + "]");
    function hasUnicode(string2) {
      return reHasUnicode.test(string2);
    }
    function asciiToArray(string2) {
      return string2.split("");
    }
    var rsAstralRange$2 = "\\ud800-\\udfff", rsComboMarksRange$3 = "\\u0300-\\u036f", reComboHalfMarksRange$3 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$3 = "\\u20d0-\\u20ff", rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3, rsVarRange$2 = "\\ufe0e\\ufe0f";
    var rsAstral$1 = "[" + rsAstralRange$2 + "]", rsCombo$3 = "[" + rsComboRange$3 + "]", rsFitz$2 = "\\ud83c[\\udffb-\\udfff]", rsModifier$2 = "(?:" + rsCombo$3 + "|" + rsFitz$2 + ")", rsNonAstral$2 = "[^" + rsAstralRange$2 + "]", rsRegional$2 = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair$2 = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ$2 = "\\u200d";
    var reOptMod$2 = rsModifier$2 + "?", rsOptVar$2 = "[" + rsVarRange$2 + "]?", rsOptJoin$2 = "(?:" + rsZWJ$2 + "(?:" + [rsNonAstral$2, rsRegional$2, rsSurrPair$2].join("|") + ")" + rsOptVar$2 + reOptMod$2 + ")*", rsSeq$2 = rsOptVar$2 + reOptMod$2 + rsOptJoin$2, rsSymbol$1 = "(?:" + [rsNonAstral$2 + rsCombo$3 + "?", rsCombo$3, rsRegional$2, rsSurrPair$2, rsAstral$1].join("|") + ")";
    var reUnicode$1 = RegExp(rsFitz$2 + "(?=" + rsFitz$2 + ")|" + rsSymbol$1 + rsSeq$2, "g");
    function unicodeToArray(string2) {
      return string2.match(reUnicode$1) || [];
    }
    function stringToArray(string2) {
      return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
    }
    function createCaseFirst(methodName) {
      return function(string2) {
        string2 = toString$1(string2);
        var strSymbols = hasUnicode(string2) ? stringToArray(string2) : void 0;
        var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
        var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
        return chr[methodName]() + trailing;
      };
    }
    var upperFirst = createCaseFirst("toUpperCase");
    function capitalize(string2) {
      return upperFirst(toString$1(string2).toLowerCase());
    }
    function arrayReduce(array2, iteratee2, accumulator, initAccum) {
      var index = -1, length = array2 == null ? 0 : array2.length;
      if (initAccum && length) {
        accumulator = array2[++index];
      }
      while (++index < length) {
        accumulator = iteratee2(accumulator, array2[index], index, array2);
      }
      return accumulator;
    }
    function basePropertyOf(object2) {
      return function(key) {
        return object2 == null ? void 0 : object2[key];
      };
    }
    var deburredLetters = {
      // Latin-1 Supplement block.
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "C",
      "": "c",
      "": "D",
      "": "d",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "N",
      "": "n",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "Y",
      "": "y",
      "": "y",
      "": "Ae",
      "": "ae",
      "": "Th",
      "": "th",
      "": "ss",
      // Latin Extended-A block.
      "": "A",
      "": "A",
      "": "A",
      "": "a",
      "": "a",
      "": "a",
      "": "C",
      "": "C",
      "": "C",
      "": "C",
      "": "c",
      "": "c",
      "": "c",
      "": "c",
      "": "D",
      "": "D",
      "": "d",
      "": "d",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "G",
      "": "G",
      "": "G",
      "": "G",
      "": "g",
      "": "g",
      "": "g",
      "": "g",
      "": "H",
      "": "H",
      "": "h",
      "": "h",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "J",
      "": "j",
      "": "K",
      "": "k",
      "": "k",
      "": "L",
      "": "L",
      "": "L",
      "": "L",
      "": "L",
      "": "l",
      "": "l",
      "": "l",
      "": "l",
      "": "l",
      "": "N",
      "": "N",
      "": "N",
      "": "N",
      "": "n",
      "": "n",
      "": "n",
      "": "n",
      "": "O",
      "": "O",
      "": "O",
      "": "o",
      "": "o",
      "": "o",
      "": "R",
      "": "R",
      "": "R",
      "": "r",
      "": "r",
      "": "r",
      "": "S",
      "": "S",
      "": "S",
      "": "S",
      "": "s",
      "": "s",
      "": "s",
      "": "s",
      "": "T",
      "": "T",
      "": "T",
      "": "t",
      "": "t",
      "": "t",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "W",
      "": "w",
      "": "Y",
      "": "y",
      "": "Y",
      "": "Z",
      "": "Z",
      "": "Z",
      "": "z",
      "": "z",
      "": "z",
      "": "IJ",
      "": "ij",
      "": "Oe",
      "": "oe",
      "": "'n",
      "": "s"
    };
    var deburrLetter = basePropertyOf(deburredLetters);
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var rsComboMarksRange$2 = "\\u0300-\\u036f", reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$2 = "\\u20d0-\\u20ff", rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2;
    var rsCombo$2 = "[" + rsComboRange$2 + "]";
    var reComboMark = RegExp(rsCombo$2, "g");
    function deburr(string2) {
      string2 = toString$1(string2);
      return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
    }
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    function asciiWords(string2) {
      return string2.match(reAsciiWord) || [];
    }
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    function hasUnicodeWord(string2) {
      return reHasUnicodeWord.test(string2);
    }
    var rsAstralRange$1 = "\\ud800-\\udfff", rsComboMarksRange$1 = "\\u0300-\\u036f", reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$1 = "\\u20d0-\\u20ff", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange$1 = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos$1 = "[']", rsBreak = "[" + rsBreakRange + "]", rsCombo$1 = "[" + rsComboRange$1 + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange$1 + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz$1 = "\\ud83c[\\udffb-\\udfff]", rsModifier$1 = "(?:" + rsCombo$1 + "|" + rsFitz$1 + ")", rsNonAstral$1 = "[^" + rsAstralRange$1 + "]", rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ$1 = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos$1 + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos$1 + "(?:D|LL|M|RE|S|T|VE))?", reOptMod$1 = rsModifier$1 + "?", rsOptVar$1 = "[" + rsVarRange$1 + "]?", rsOptJoin$1 = "(?:" + rsZWJ$1 + "(?:" + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsOptVar$1 + reOptMod$1 + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1, rsEmoji = "(?:" + [rsDingbat, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsSeq$1;
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    function unicodeWords(string2) {
      return string2.match(reUnicodeWord) || [];
    }
    function words(string2, pattern, guard) {
      string2 = toString$1(string2);
      pattern = guard ? void 0 : pattern;
      if (pattern === void 0) {
        return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
      }
      return string2.match(pattern) || [];
    }
    var rsApos = "[']";
    var reApos = RegExp(rsApos, "g");
    function createCompounder(callback) {
      return function(string2) {
        return arrayReduce(words(deburr(string2).replace(reApos, "")), callback, "");
      };
    }
    var camelCase = createCompounder(function(result2, word, index) {
      word = word.toLowerCase();
      return result2 + (index ? capitalize(word) : word);
    });
    function castArray() {
      if (!arguments.length) {
        return [];
      }
      var value = arguments[0];
      return isArray(value) ? value : [value];
    }
    var nativeIsFinite$1 = root$1.isFinite, nativeMin$c = Math.min;
    function createRound(methodName) {
      var func2 = Math[methodName];
      return function(number2, precision) {
        number2 = toNumber(number2);
        precision = precision == null ? 0 : nativeMin$c(toInteger(precision), 292);
        if (precision && nativeIsFinite$1(number2)) {
          var pair = (toString$1(number2) + "e").split("e"), value = func2(pair[0] + "e" + (+pair[1] + precision));
          pair = (toString$1(value) + "e").split("e");
          return +(pair[0] + "e" + (+pair[1] - precision));
        }
        return func2(number2);
      };
    }
    var ceil = createRound("ceil");
    function chain(value) {
      var result2 = lodash$1(value);
      result2.__chain__ = true;
      return result2;
    }
    var nativeCeil$3 = Math.ceil, nativeMax$c = Math.max;
    function chunk(array2, size2, guard) {
      if (guard ? isIterateeCall(array2, size2, guard) : size2 === void 0) {
        size2 = 1;
      } else {
        size2 = nativeMax$c(toInteger(size2), 0);
      }
      var length = array2 == null ? 0 : array2.length;
      if (!length || size2 < 1) {
        return [];
      }
      var index = 0, resIndex = 0, result2 = Array(nativeCeil$3(length / size2));
      while (index < length) {
        result2[resIndex++] = baseSlice(array2, index, index += size2);
      }
      return result2;
    }
    function baseClamp(number2, lower, upper) {
      if (number2 === number2) {
        if (upper !== void 0) {
          number2 = number2 <= upper ? number2 : upper;
        }
        if (lower !== void 0) {
          number2 = number2 >= lower ? number2 : lower;
        }
      }
      return number2;
    }
    function clamp(number2, lower, upper) {
      if (upper === void 0) {
        upper = lower;
        lower = void 0;
      }
      if (upper !== void 0) {
        upper = toNumber(upper);
        upper = upper === upper ? upper : 0;
      }
      if (lower !== void 0) {
        lower = toNumber(lower);
        lower = lower === lower ? lower : 0;
      }
      return baseClamp(toNumber(number2), lower, upper);
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result2 = data["delete"](key);
      this.size = data.size;
      return result2;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    var LARGE_ARRAY_SIZE$2 = 200;
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE$2 - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function baseAssign(object2, source) {
      return object2 && copyObject(source, keys(source), object2);
    }
    function baseAssignIn(object2, source) {
      return object2 && copyObject(source, keysIn(source), object2);
    }
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer$1 = moduleExports ? root$1.Buffer : void 0, allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result2);
      return result2;
    }
    function arrayFilter(array2, predicate) {
      var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result2 = [];
      while (++index < length) {
        var value = array2[index];
        if (predicate(value, index, array2)) {
          result2[resIndex++] = value;
        }
      }
      return result2;
    }
    function stubArray() {
      return [];
    }
    var objectProto$d = Object.prototype;
    var propertyIsEnumerable = objectProto$d.propertyIsEnumerable;
    var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object2) {
      if (object2 == null) {
        return [];
      }
      object2 = Object(object2);
      return arrayFilter(nativeGetSymbols$1(object2), function(symbol) {
        return propertyIsEnumerable.call(object2, symbol);
      });
    };
    function copySymbols(source, object2) {
      return copyObject(source, getSymbols(source), object2);
    }
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object2) {
      var result2 = [];
      while (object2) {
        arrayPush(result2, getSymbols(object2));
        object2 = getPrototype(object2);
      }
      return result2;
    };
    function copySymbolsIn(source, object2) {
      return copyObject(source, getSymbolsIn(source), object2);
    }
    function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
      var result2 = keysFunc(object2);
      return isArray(object2) ? result2 : arrayPush(result2, symbolsFunc(object2));
    }
    function getAllKeys(object2) {
      return baseGetAllKeys(object2, keys, getSymbols);
    }
    function getAllKeysIn(object2) {
      return baseGetAllKeys(object2, keysIn, getSymbolsIn);
    }
    var DataView = getNative(root$1, "DataView");
    var Promise$1 = getNative(root$1, "Promise");
    var Set$1 = getNative(root$1, "Set");
    var mapTag$8 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$8 = "[object Set]", weakMapTag$2 = "[object WeakMap]";
    var dataViewTag$3 = "[object DataView]";
    var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$3 || Map$1 && getTag(new Map$1()) != mapTag$8 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$8 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag$2) {
      getTag = function(value) {
        var result2 = baseGetTag(value), Ctor = result2 == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag$3;
            case mapCtorString:
              return mapTag$8;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag$8;
            case weakMapCtorString:
              return weakMapTag$2;
          }
        }
        return result2;
      };
    }
    var objectProto$c = Object.prototype;
    var hasOwnProperty$b = objectProto$c.hasOwnProperty;
    function initCloneArray(array2) {
      var length = array2.length, result2 = new array2.constructor(length);
      if (length && typeof array2[0] == "string" && hasOwnProperty$b.call(array2, "index")) {
        result2.index = array2.index;
        result2.input = array2.input;
      }
      return result2;
    }
    var Uint8Array$1 = root$1.Uint8Array;
    function cloneArrayBuffer(arrayBuffer) {
      var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array$1(result2).set(new Uint8Array$1(arrayBuffer));
      return result2;
    }
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    var reFlags$1 = /\w*$/;
    function cloneRegExp(regexp) {
      var result2 = new regexp.constructor(regexp.source, reFlags$1.exec(regexp));
      result2.lastIndex = regexp.lastIndex;
      return result2;
    }
    var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
    function cloneSymbol(symbol) {
      return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    var boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", mapTag$7 = "[object Map]", numberTag$3 = "[object Number]", regexpTag$3 = "[object RegExp]", setTag$7 = "[object Set]", stringTag$3 = "[object String]", symbolTag$2 = "[object Symbol]";
    var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
    function initCloneByTag(object2, tag, isDeep) {
      var Ctor = object2.constructor;
      switch (tag) {
        case arrayBufferTag$3:
          return cloneArrayBuffer(object2);
        case boolTag$3:
        case dateTag$3:
          return new Ctor(+object2);
        case dataViewTag$2:
          return cloneDataView(object2, isDeep);
        case float32Tag$1:
        case float64Tag$1:
        case int8Tag$1:
        case int16Tag$1:
        case int32Tag$1:
        case uint8Tag$1:
        case uint8ClampedTag$1:
        case uint16Tag$1:
        case uint32Tag$1:
          return cloneTypedArray(object2, isDeep);
        case mapTag$7:
          return new Ctor();
        case numberTag$3:
        case stringTag$3:
          return new Ctor(object2);
        case regexpTag$3:
          return cloneRegExp(object2);
        case setTag$7:
          return new Ctor();
        case symbolTag$2:
          return cloneSymbol(object2);
      }
    }
    function initCloneObject(object2) {
      return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate(getPrototype(object2)) : {};
    }
    var mapTag$6 = "[object Map]";
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag$6;
    }
    var nodeIsMap = nodeUtil && nodeUtil.isMap;
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
    var setTag$6 = "[object Set]";
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag$6;
    }
    var nodeIsSet = nodeUtil && nodeUtil.isSet;
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
    var CLONE_DEEP_FLAG$7 = 1, CLONE_FLAT_FLAG$1 = 2, CLONE_SYMBOLS_FLAG$5 = 4;
    var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag$5 = "[object Map]", numberTag$2 = "[object Number]", objectTag$1 = "[object Object]", regexpTag$2 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$2 = "[object String]", symbolTag$1 = "[object Symbol]", weakMapTag$1 = "[object WeakMap]";
    var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$2] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$2] = cloneableTags[dateTag$2] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$5] = cloneableTags[numberTag$2] = cloneableTags[objectTag$1] = cloneableTags[regexpTag$2] = cloneableTags[setTag$5] = cloneableTags[stringTag$2] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag$1] = false;
    function baseClone(value, bitmask, customizer, key, object2, stack) {
      var result2, isDeep = bitmask & CLONE_DEEP_FLAG$7, isFlat = bitmask & CLONE_FLAT_FLAG$1, isFull = bitmask & CLONE_SYMBOLS_FLAG$5;
      if (customizer) {
        result2 = object2 ? customizer(value, key, object2, stack) : customizer(value);
      }
      if (result2 !== void 0) {
        return result2;
      }
      if (!isObject$3(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result2 = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result2);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag$1 || tag == argsTag$1 || isFunc && !object2) {
          result2 = isFlat || isFunc ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object2 ? value : {};
          }
          result2 = initCloneByTag(value, tag, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result2);
      if (isSet(value)) {
        value.forEach(function(subValue) {
          result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key2) {
          result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
      var props = isArr ? void 0 : keysFunc(value);
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
      });
      return result2;
    }
    var CLONE_SYMBOLS_FLAG$4 = 4;
    function clone$1(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG$4);
    }
    var CLONE_DEEP_FLAG$6 = 1, CLONE_SYMBOLS_FLAG$3 = 4;
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG$6 | CLONE_SYMBOLS_FLAG$3);
    }
    var CLONE_DEEP_FLAG$5 = 1, CLONE_SYMBOLS_FLAG$2 = 4;
    function cloneDeepWith(value, customizer) {
      customizer = typeof customizer == "function" ? customizer : void 0;
      return baseClone(value, CLONE_DEEP_FLAG$5 | CLONE_SYMBOLS_FLAG$2, customizer);
    }
    var CLONE_SYMBOLS_FLAG$1 = 4;
    function cloneWith(value, customizer) {
      customizer = typeof customizer == "function" ? customizer : void 0;
      return baseClone(value, CLONE_SYMBOLS_FLAG$1, customizer);
    }
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }
    function compact(array2) {
      var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result2 = [];
      while (++index < length) {
        var value = array2[index];
        if (value) {
          result2[resIndex++] = value;
        }
      }
      return result2;
    }
    function concat() {
      var length = arguments.length;
      if (!length) {
        return [];
      }
      var args = Array(length - 1), array2 = arguments[0], index = length;
      while (index--) {
        args[index - 1] = arguments[index];
      }
      return arrayPush(isArray(array2) ? copyArray(array2) : [array2], baseFlatten(args, 1));
    }
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    function SetCache(values2) {
      var index = -1, length = values2 == null ? 0 : values2.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values2[index]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function arraySome(array2, predicate) {
      var index = -1, length = array2 == null ? 0 : array2.length;
      while (++index < length) {
        if (predicate(array2[index], index, array2)) {
          return true;
        }
      }
      return false;
    }
    function cacheHas(cache2, key) {
      return cache2.has(key);
    }
    var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
    function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array2.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack.get(array2);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array2;
      }
      var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
      stack.set(array2, other);
      stack.set(other, array2);
      while (++index < arrLength) {
        var arrValue = array2[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array2, stack) : customizer(arrValue, othValue, index, array2, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result2 = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result2 = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result2 = false;
          break;
        }
      }
      stack["delete"](array2);
      stack["delete"](other);
      return result2;
    }
    function mapToArray(map2) {
      var index = -1, result2 = Array(map2.size);
      map2.forEach(function(value, key) {
        result2[++index] = [key, value];
      });
      return result2;
    }
    function setToArray(set2) {
      var index = -1, result2 = Array(set2.size);
      set2.forEach(function(value) {
        result2[++index] = value;
      });
      return result2;
    }
    var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
    var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag = "[object Error]", mapTag$4 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$4 = "[object Set]", stringTag$1 = "[object String]", symbolTag = "[object Symbol]";
    var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
    var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
            return false;
          }
          object2 = object2.buffer;
          other = other.buffer;
        case arrayBufferTag$1:
          if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object2), new Uint8Array$1(other))) {
            return false;
          }
          return true;
        case boolTag$1:
        case dateTag$1:
        case numberTag$1:
          return eq(+object2, +other);
        case errorTag:
          return object2.name == other.name && object2.message == other.message;
        case regexpTag$1:
        case stringTag$1:
          return object2 == other + "";
        case mapTag$4:
          var convert2 = mapToArray;
        case setTag$4:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
          convert2 || (convert2 = setToArray);
          if (object2.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object2);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG$2;
          stack.set(object2, other);
          var result2 = equalArrays(convert2(object2), convert2(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object2);
          return result2;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object2) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    var COMPARE_PARTIAL_FLAG$3 = 1;
    var objectProto$b = Object.prototype;
    var hasOwnProperty$a = objectProto$b.hasOwnProperty;
    function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty$a.call(other, key))) {
          return false;
        }
      }
      var objStacked = stack.get(object2);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object2;
      }
      var result2 = true;
      stack.set(object2, other);
      stack.set(other, object2);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object2[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result2 = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result2 && !skipCtor) {
        var objCtor = object2.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result2 = false;
        }
      }
      stack["delete"](object2);
      stack["delete"](other);
      return result2;
    }
    var COMPARE_PARTIAL_FLAG$2 = 1;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
    var objectProto$a = Object.prototype;
    var hasOwnProperty$9 = objectProto$a.hasOwnProperty;
    function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object2), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object2)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
        var objIsWrapped = objIsObj && hasOwnProperty$9.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$9.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
    }
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
    function baseIsMatch(object2, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object2 == null) {
        return !length;
      }
      object2 = Object(object2);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object2[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object2)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result2 = customizer(objValue, srcValue, key, object2, source, stack);
          }
          if (!(result2 === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result2)) {
            return false;
          }
        }
      }
      return true;
    }
    function isStrictComparable(value) {
      return value === value && !isObject$3(value);
    }
    function getMatchData(object2) {
      var result2 = keys(object2), length = result2.length;
      while (length--) {
        var key = result2[length], value = object2[key];
        result2[length] = [key, value, isStrictComparable(value)];
      }
      return result2;
    }
    function matchesStrictComparable(key, srcValue) {
      return function(object2) {
        if (object2 == null) {
          return false;
        }
        return object2[key] === srcValue && (srcValue !== void 0 || key in Object(object2));
      };
    }
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object2) {
        return object2 === source || baseIsMatch(object2, source, matchData);
      };
    }
    function baseHasIn(object2, key) {
      return object2 != null && key in Object(object2);
    }
    function hasPath(object2, path, hasFunc) {
      path = castPath(path, object2);
      var index = -1, length = path.length, result2 = false;
      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result2 = object2 != null && hasFunc(object2, key))) {
          break;
        }
        object2 = object2[key];
      }
      if (result2 || ++index != length) {
        return result2;
      }
      length = object2 == null ? 0 : object2.length;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object2) || isArguments(object2));
    }
    function hasIn(object2, path) {
      return object2 != null && hasPath(object2, path, baseHasIn);
    }
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object2) {
        var objValue = get(object2, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object2, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }
    function baseProperty(key) {
      return function(object2) {
        return object2 == null ? void 0 : object2[key];
      };
    }
    function basePropertyDeep(path) {
      return function(object2) {
        return baseGet(object2, path);
      };
    }
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    var FUNC_ERROR_TEXT$7 = "Expected a function";
    function cond(pairs) {
      var length = pairs == null ? 0 : pairs.length, toIteratee = baseIteratee;
      pairs = !length ? [] : arrayMap(pairs, function(pair) {
        if (typeof pair[1] != "function") {
          throw new TypeError(FUNC_ERROR_TEXT$7);
        }
        return [toIteratee(pair[0]), pair[1]];
      });
      return baseRest(function(args) {
        var index = -1;
        while (++index < length) {
          var pair = pairs[index];
          if (apply(pair[0], this, args)) {
            return apply(pair[1], this, args);
          }
        }
      });
    }
    function baseConformsTo(object2, source, props) {
      var length = props.length;
      if (object2 == null) {
        return !length;
      }
      object2 = Object(object2);
      while (length--) {
        var key = props[length], predicate = source[key], value = object2[key];
        if (value === void 0 && !(key in object2) || !predicate(value)) {
          return false;
        }
      }
      return true;
    }
    function baseConforms(source) {
      var props = keys(source);
      return function(object2) {
        return baseConformsTo(object2, source, props);
      };
    }
    var CLONE_DEEP_FLAG$4 = 1;
    function conforms(source) {
      return baseConforms(baseClone(source, CLONE_DEEP_FLAG$4));
    }
    function conformsTo(object2, source) {
      return source == null || baseConformsTo(object2, source, keys(source));
    }
    function arrayAggregator(array2, setter, iteratee2, accumulator) {
      var index = -1, length = array2 == null ? 0 : array2.length;
      while (++index < length) {
        var value = array2[index];
        setter(accumulator, value, iteratee2(value), array2);
      }
      return accumulator;
    }
    function createBaseFor(fromRight) {
      return function(object2, iteratee2, keysFunc) {
        var index = -1, iterable = Object(object2), props = keysFunc(object2), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee2(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object2;
      };
    }
    var baseFor = createBaseFor();
    function baseForOwn(object2, iteratee2) {
      return object2 && baseFor(object2, iteratee2, keys);
    }
    function createBaseEach(eachFunc, fromRight) {
      return function(collection2, iteratee2) {
        if (collection2 == null) {
          return collection2;
        }
        if (!isArrayLike(collection2)) {
          return eachFunc(collection2, iteratee2);
        }
        var length = collection2.length, index = fromRight ? length : -1, iterable = Object(collection2);
        while (fromRight ? index-- : ++index < length) {
          if (iteratee2(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection2;
      };
    }
    var baseEach = createBaseEach(baseForOwn);
    function baseAggregator(collection2, setter, iteratee2, accumulator) {
      baseEach(collection2, function(value, key, collection3) {
        setter(accumulator, value, iteratee2(value), collection3);
      });
      return accumulator;
    }
    function createAggregator(setter, initializer) {
      return function(collection2, iteratee2) {
        var func2 = isArray(collection2) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
        return func2(collection2, setter, baseIteratee(iteratee2), accumulator);
      };
    }
    var objectProto$9 = Object.prototype;
    var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
    var countBy = createAggregator(function(result2, value, key) {
      if (hasOwnProperty$8.call(result2, key)) {
        ++result2[key];
      } else {
        baseAssignValue(result2, key, 1);
      }
    });
    function create(prototype, properties) {
      var result2 = baseCreate(prototype);
      return properties == null ? result2 : baseAssign(result2, properties);
    }
    var WRAP_CURRY_FLAG$1 = 8;
    function curry(func2, arity, guard) {
      arity = guard ? void 0 : arity;
      var result2 = createWrap(func2, WRAP_CURRY_FLAG$1, void 0, void 0, void 0, void 0, void 0, arity);
      result2.placeholder = curry.placeholder;
      return result2;
    }
    curry.placeholder = {};
    var WRAP_CURRY_RIGHT_FLAG = 16;
    function curryRight(func2, arity, guard) {
      arity = guard ? void 0 : arity;
      var result2 = createWrap(func2, WRAP_CURRY_RIGHT_FLAG, void 0, void 0, void 0, void 0, void 0, arity);
      result2.placeholder = curryRight.placeholder;
      return result2;
    }
    curryRight.placeholder = {};
    var now$1 = function() {
      return root$1.Date.now();
    };
    var FUNC_ERROR_TEXT$6 = "Expected a function";
    var nativeMax$b = Math.max, nativeMin$b = Math.min;
    function debounce$1(func2, wait, options) {
      var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func2 != "function") {
        throw new TypeError(FUNC_ERROR_TEXT$6);
      }
      wait = toNumber(wait) || 0;
      if (isObject$3(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax$b(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result2 = func2.apply(thisArg, args);
        return result2;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result2;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
        return maxing ? nativeMin$b(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now$1();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result2;
      }
      function cancel2() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result2 : trailingEdge(now$1());
      }
      function debounced() {
        var time = now$1(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result2;
      }
      debounced.cancel = cancel2;
      debounced.flush = flush;
      return debounced;
    }
    function defaultTo(value, defaultValue) {
      return value == null || value !== value ? defaultValue : value;
    }
    var objectProto$8 = Object.prototype;
    var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
    var defaults$1 = baseRest(function(object2, sources) {
      object2 = Object(object2);
      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : void 0;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }
      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;
        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object2[key];
          if (value === void 0 || eq(value, objectProto$8[key]) && !hasOwnProperty$7.call(object2, key)) {
            object2[key] = source[key];
          }
        }
      }
      return object2;
    });
    function assignMergeValue(object2, key, value) {
      if (value !== void 0 && !eq(object2[key], value) || value === void 0 && !(key in object2)) {
        baseAssignValue(object2, key, value);
      }
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function safeGet(object2, key) {
      if (key === "constructor" && typeof object2[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object2[key];
    }
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    function baseMergeDeep(object2, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object2, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object2, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object2, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject$2(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject$3(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object2, key, newValue);
    }
    function baseMerge(object2, source, srcIndex, customizer, stack) {
      if (object2 === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack());
        if (isObject$3(srcValue)) {
          baseMergeDeep(object2, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object2, key), srcValue, key + "", object2, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object2, key, newValue);
        }
      }, keysIn);
    }
    function customDefaultsMerge(objValue, srcValue, key, object2, source, stack) {
      if (isObject$3(objValue) && isObject$3(srcValue)) {
        stack.set(srcValue, objValue);
        baseMerge(objValue, srcValue, void 0, customDefaultsMerge, stack);
        stack["delete"](srcValue);
      }
      return objValue;
    }
    var mergeWith = createAssigner(function(object2, source, srcIndex, customizer) {
      baseMerge(object2, source, srcIndex, customizer);
    });
    var defaultsDeep = baseRest(function(args) {
      args.push(void 0, customDefaultsMerge);
      return apply(mergeWith, void 0, args);
    });
    var FUNC_ERROR_TEXT$5 = "Expected a function";
    function baseDelay(func2, wait, args) {
      if (typeof func2 != "function") {
        throw new TypeError(FUNC_ERROR_TEXT$5);
      }
      return setTimeout(function() {
        func2.apply(void 0, args);
      }, wait);
    }
    var defer = baseRest(function(func2, args) {
      return baseDelay(func2, 1, args);
    });
    var delay$1 = baseRest(function(func2, wait, args) {
      return baseDelay(func2, toNumber(wait) || 0, args);
    });
    function arrayIncludesWith(array2, value, comparator) {
      var index = -1, length = array2 == null ? 0 : array2.length;
      while (++index < length) {
        if (comparator(value, array2[index])) {
          return true;
        }
      }
      return false;
    }
    var LARGE_ARRAY_SIZE$1 = 200;
    function baseDifference(array2, values2, iteratee2, comparator) {
      var index = -1, includes2 = arrayIncludes, isCommon = true, length = array2.length, result2 = [], valuesLength = values2.length;
      if (!length) {
        return result2;
      }
      if (iteratee2) {
        values2 = arrayMap(values2, baseUnary(iteratee2));
      }
      if (comparator) {
        includes2 = arrayIncludesWith;
        isCommon = false;
      } else if (values2.length >= LARGE_ARRAY_SIZE$1) {
        includes2 = cacheHas;
        isCommon = false;
        values2 = new SetCache(values2);
      }
      outer:
        while (++index < length) {
          var value = array2[index], computed2 = iteratee2 == null ? value : iteratee2(value);
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed2 === computed2) {
            var valuesIndex = valuesLength;
            while (valuesIndex--) {
              if (values2[valuesIndex] === computed2) {
                continue outer;
              }
            }
            result2.push(value);
          } else if (!includes2(values2, computed2, comparator)) {
            result2.push(value);
          }
        }
      return result2;
    }
    var difference = baseRest(function(array2, values2) {
      return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
    });
    function last(array2) {
      var length = array2 == null ? 0 : array2.length;
      return length ? array2[length - 1] : void 0;
    }
    var differenceBy = baseRest(function(array2, values2) {
      var iteratee2 = last(values2);
      if (isArrayLikeObject(iteratee2)) {
        iteratee2 = void 0;
      }
      return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values2, 1, isArrayLikeObject, true), baseIteratee(iteratee2)) : [];
    });
    var differenceWith = baseRest(function(array2, values2) {
      var comparator = last(values2);
      if (isArrayLikeObject(comparator)) {
        comparator = void 0;
      }
      return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values2, 1, isArrayLikeObject, true), void 0, comparator) : [];
    });
    var divide = createMathOperation(function(dividend, divisor) {
      return dividend / divisor;
    }, 1);
    function drop(array2, n2, guard) {
      var length = array2 == null ? 0 : array2.length;
      if (!length) {
        return [];
      }
      n2 = guard || n2 === void 0 ? 1 : toInteger(n2);
      return baseSlice(array2, n2 < 0 ? 0 : n2, length);
    }
    function dropRight(array2, n2, guard) {
      var length = array2 == null ? 0 : array2.length;
      if (!length) {
        return [];
      }
      n2 = guard || n2 === void 0 ? 1 : toInteger(n2);
      n2 = length - n2;
      return baseSlice(array2, 0, n2 < 0 ? 0 : n2);
    }
    function baseWhile(array2, predicate, isDrop, fromRight) {
      var length = array2.length, index = fromRight ? length : -1;
      while ((fromRight ? index-- : ++index < length) && predicate(array2[index], index, array2)) {
      }
      return isDrop ? baseSlice(array2, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array2, fromRight ? index + 1 : 0, fromRight ? length : index);
    }
    function dropRightWhile(array2, predicate) {
      return array2 && array2.length ? baseWhile(array2, baseIteratee(predicate), true, true) : [];
    }
    function dropWhile(array2, predicate) {
      return array2 && array2.length ? baseWhile(array2, baseIteratee(predicate), true) : [];
    }
    function castFunction(value) {
      return typeof value == "function" ? value : identity;
    }
    function forEach(collection2, iteratee2) {
      var func2 = isArray(collection2) ? arrayEach : baseEach;
      return func2(collection2, castFunction(iteratee2));
    }
    function arrayEachRight(array2, iteratee2) {
      var length = array2 == null ? 0 : array2.length;
      while (length--) {
        if (iteratee2(array2[length], length, array2) === false) {
          break;
        }
      }
      return array2;
    }
    var baseForRight = createBaseFor(true);
    function baseForOwnRight(object2, iteratee2) {
      return object2 && baseForRight(object2, iteratee2, keys);
    }
    var baseEachRight = createBaseEach(baseForOwnRight, true);
    function forEachRight(collection2, iteratee2) {
      var func2 = isArray(collection2) ? arrayEachRight : baseEachRight;
      return func2(collection2, castFunction(iteratee2));
    }
    function endsWith(string2, target, position) {
      string2 = toString$1(string2);
      target = baseToString(target);
      var length = string2.length;
      position = position === void 0 ? length : baseClamp(toInteger(position), 0, length);
      var end2 = position;
      position -= target.length;
      return position >= 0 && string2.slice(position, end2) == target;
    }
    function baseToPairs(object2, props) {
      return arrayMap(props, function(key) {
        return [key, object2[key]];
      });
    }
    function setToPairs(set2) {
      var index = -1, result2 = Array(set2.size);
      set2.forEach(function(value) {
        result2[++index] = [value, value];
      });
      return result2;
    }
    var mapTag$3 = "[object Map]", setTag$3 = "[object Set]";
    function createToPairs(keysFunc) {
      return function(object2) {
        var tag = getTag(object2);
        if (tag == mapTag$3) {
          return mapToArray(object2);
        }
        if (tag == setTag$3) {
          return setToPairs(object2);
        }
        return baseToPairs(object2, keysFunc(object2));
      };
    }
    var toPairs = createToPairs(keys);
    var toPairsIn = createToPairs(keysIn);
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    var reUnescapedHtml = /[&<>"']/g, reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    function escape$1(string2) {
      string2 = toString$1(string2);
      return string2 && reHasUnescapedHtml.test(string2) ? string2.replace(reUnescapedHtml, escapeHtmlChar) : string2;
    }
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    function escapeRegExp(string2) {
      string2 = toString$1(string2);
      return string2 && reHasRegExpChar.test(string2) ? string2.replace(reRegExpChar, "\\$&") : string2;
    }
    function arrayEvery(array2, predicate) {
      var index = -1, length = array2 == null ? 0 : array2.length;
      while (++index < length) {
        if (!predicate(array2[index], index, array2)) {
          return false;
        }
      }
      return true;
    }
    function baseEvery(collection2, predicate) {
      var result2 = true;
      baseEach(collection2, function(value, index, collection3) {
        result2 = !!predicate(value, index, collection3);
        return result2;
      });
      return result2;
    }
    function every(collection2, predicate, guard) {
      var func2 = isArray(collection2) ? arrayEvery : baseEvery;
      if (guard && isIterateeCall(collection2, predicate, guard)) {
        predicate = void 0;
      }
      return func2(collection2, baseIteratee(predicate));
    }
    var MAX_ARRAY_LENGTH$5 = 4294967295;
    function toLength(value) {
      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH$5) : 0;
    }
    function baseFill(array2, value, start2, end2) {
      var length = array2.length;
      start2 = toInteger(start2);
      if (start2 < 0) {
        start2 = -start2 > length ? 0 : length + start2;
      }
      end2 = end2 === void 0 || end2 > length ? length : toInteger(end2);
      if (end2 < 0) {
        end2 += length;
      }
      end2 = start2 > end2 ? 0 : toLength(end2);
      while (start2 < end2) {
        array2[start2++] = value;
      }
      return array2;
    }
    function fill(array2, value, start2, end2) {
      var length = array2 == null ? 0 : array2.length;
      if (!length) {
        return [];
      }
      if (start2 && typeof start2 != "number" && isIterateeCall(array2, value, start2)) {
        start2 = 0;
        end2 = length;
      }
      return baseFill(array2, value, start2, end2);
    }
    function baseFilter(collection2, predicate) {
      var result2 = [];
      baseEach(collection2, function(value, index, collection3) {
        if (predicate(value, index, collection3)) {
          result2.push(value);
        }
      });
      return result2;
    }
    function filter(collection2, predicate) {
      var func2 = isArray(collection2) ? arrayFilter : baseFilter;
      return func2(collection2, baseIteratee(predicate));
    }
    function createFind(findIndexFunc) {
      return function(collection2, predicate, fromIndex) {
        var iterable = Object(collection2);
        if (!isArrayLike(collection2)) {
          var iteratee2 = baseIteratee(predicate);
          collection2 = keys(collection2);
          predicate = function(key) {
            return iteratee2(iterable[key], key, iterable);
          };
        }
        var index = findIndexFunc(collection2, predicate, fromIndex);
        return index > -1 ? iterable[iteratee2 ? collection2[index] : index] : void 0;
      };
    }
    var nativeMax$a = Math.max;
    function findIndex(array2, predicate, fromIndex) {
      var length = array2 == null ? 0 : array2.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax$a(length + index, 0);
      }
      return baseFindIndex(array2, baseIteratee(predicate), index);
    }
    var find = createFind(findIndex);
    function baseFindKey(collection2, predicate, eachFunc) {
      var result2;
      eachFunc(collection2, function(value, key, collection3) {
        if (predicate(value, key, collection3)) {
          result2 = key;
          return false;
        }
      });
      return result2;
    }
    function findKey(object2, predicate) {
      return baseFindKey(object2, baseIteratee(predicate), baseForOwn);
    }
    var nativeMax$9 = Math.max, nativeMin$a = Math.min;
    function findLastIndex(array2, predicate, fromIndex) {
      var length = array2 == null ? 0 : array2.length;
      if (!length) {
        return -1;
      }
      var index = length - 1;
      if (fromIndex !== void 0) {
        index = toInteger(fromIndex);
        index = fromIndex < 0 ? nativeMax$9(length + index, 0) : nativeMin$a(index, length - 1);
      }
      return baseFindIndex(array2, baseIteratee(predicate), index, true);
    }
    var findLast = createFind(findLastIndex);
    function findLastKey(object2, predicate) {
      return baseFindKey(object2, baseIteratee(predicate), baseForOwnRight);
    }
    function head(array2) {
      return array2 && array2.length ? array2[0] : void 0;
    }
    function baseMap(collection2, iteratee2) {
      var index = -1, result2 = isArrayLike(collection2) ? Array(collection2.length) : [];
      baseEach(collection2, function(value, key, collection3) {
        result2[++index] = iteratee2(value, key, collection3);
      });
      return result2;
    }
    function map(collection2, iteratee2) {
      var func2 = isArray(collection2) ? arrayMap : baseMap;
      return func2(collection2, baseIteratee(iteratee2));
    }
    function flatMap(collection2, iteratee2) {
      return baseFlatten(map(collection2, iteratee2), 1);
    }
    var INFINITY$2 = 1 / 0;
    function flatMapDeep(collection2, iteratee2) {
      return baseFlatten(map(collection2, iteratee2), INFINITY$2);
    }
    function flatMapDepth(collection2, iteratee2, depth) {
      depth = depth === void 0 ? 1 : toInteger(depth);
      return baseFlatten(map(collection2, iteratee2), depth);
    }
    var INFINITY$1 = 1 / 0;
    function flattenDeep(array2) {
      var length = array2 == null ? 0 : array2.length;
      return length ? baseFlatten(array2, INFINITY$1) : [];
    }
    function flattenDepth(array2, depth) {
      var length = array2 == null ? 0 : array2.length;
      if (!length) {
        return [];
      }
      depth = depth === void 0 ? 1 : toInteger(depth);
      return baseFlatten(array2, depth);
    }
    var WRAP_FLIP_FLAG = 512;
    function flip$3(func2) {
      return createWrap(func2, WRAP_FLIP_FLAG);
    }
    var floor = createRound("floor");
    var FUNC_ERROR_TEXT$4 = "Expected a function";
    var WRAP_CURRY_FLAG = 8, WRAP_PARTIAL_FLAG$1 = 32, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG$1 = 256;
    function createFlow(fromRight) {
      return flatRest(function(funcs) {
        var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
        if (fromRight) {
          funcs.reverse();
        }
        while (index--) {
          var func2 = funcs[index];
          if (typeof func2 != "function") {
            throw new TypeError(FUNC_ERROR_TEXT$4);
          }
          if (prereq && !wrapper && getFuncName(func2) == "wrapper") {
            var wrapper = new LodashWrapper([], true);
          }
        }
        index = wrapper ? index : length;
        while (++index < length) {
          func2 = funcs[index];
          var funcName = getFuncName(func2), data = funcName == "wrapper" ? getData(func2) : void 0;
          if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG$1 | WRAP_REARG_FLAG$1) && !data[4].length && data[9] == 1) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = func2.length == 1 && isLaziable(func2) ? wrapper[funcName]() : wrapper.thru(func2);
          }
        }
        return function() {
          var args = arguments, value = args[0];
          if (wrapper && args.length == 1 && isArray(value)) {
            return wrapper.plant(value).value();
          }
          var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
          while (++index2 < length) {
            result2 = funcs[index2].call(this, result2);
          }
          return result2;
        };
      });
    }
    var flow = createFlow();
    var flowRight = createFlow(true);
    function forIn(object2, iteratee2) {
      return object2 == null ? object2 : baseFor(object2, castFunction(iteratee2), keysIn);
    }
    function forInRight(object2, iteratee2) {
      return object2 == null ? object2 : baseForRight(object2, castFunction(iteratee2), keysIn);
    }
    function forOwn(object2, iteratee2) {
      return object2 && baseForOwn(object2, castFunction(iteratee2));
    }
    function forOwnRight(object2, iteratee2) {
      return object2 && baseForOwnRight(object2, castFunction(iteratee2));
    }
    function fromPairs(pairs) {
      var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
      while (++index < length) {
        var pair = pairs[index];
        result2[pair[0]] = pair[1];
      }
      return result2;
    }
    function baseFunctions(object2, props) {
      return arrayFilter(props, function(key) {
        return isFunction(object2[key]);
      });
    }
    function functions(object2) {
      return object2 == null ? [] : baseFunctions(object2, keys(object2));
    }
    function functionsIn(object2) {
      return object2 == null ? [] : baseFunctions(object2, keysIn(object2));
    }
    var objectProto$7 = Object.prototype;
    var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
    var groupBy = createAggregator(function(result2, value, key) {
      if (hasOwnProperty$6.call(result2, key)) {
        result2[key].push(value);
      } else {
        baseAssignValue(result2, key, [value]);
      }
    });
    function baseGt(value, other) {
      return value > other;
    }
    function createRelationalOperation(operator) {
      return function(value, other) {
        if (!(typeof value == "string" && typeof other == "string")) {
          value = toNumber(value);
          other = toNumber(other);
        }
        return operator(value, other);
      };
    }
    var gt$2 = createRelationalOperation(baseGt);
    var gte = createRelationalOperation(function(value, other) {
      return value >= other;
    });
    var objectProto$6 = Object.prototype;
    var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
    function baseHas(object2, key) {
      return object2 != null && hasOwnProperty$5.call(object2, key);
    }
    function has(object2, path) {
      return object2 != null && hasPath(object2, path, baseHas);
    }
    var nativeMax$8 = Math.max, nativeMin$9 = Math.min;
    function baseInRange(number2, start2, end2) {
      return number2 >= nativeMin$9(start2, end2) && number2 < nativeMax$8(start2, end2);
    }
    function inRange(number2, start2, end2) {
      start2 = toFinite(start2);
      if (end2 === void 0) {
        end2 = start2;
        start2 = 0;
      } else {
        end2 = toFinite(end2);
      }
      number2 = toNumber(number2);
      return baseInRange(number2, start2, end2);
    }
    var stringTag = "[object String]";
    function isString(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
    }
    function baseValues(object2, props) {
      return arrayMap(props, function(key) {
        return object2[key];
      });
    }
    function values(object2) {
      return object2 == null ? [] : baseValues(object2, keys(object2));
    }
    var nativeMax$7 = Math.max;
    function includes(collection2, value, fromIndex, guard) {
      collection2 = isArrayLike(collection2) ? collection2 : values(collection2);
      fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
      var length = collection2.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax$7(length + fromIndex, 0);
      }
      return isString(collection2) ? fromIndex <= length && collection2.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection2, value, fromIndex) > -1;
    }
    var nativeMax$6 = Math.max;
    function indexOf$1(array2, value, fromIndex) {
      var length = array2 == null ? 0 : array2.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax$6(length + index, 0);
      }
      return baseIndexOf(array2, value, index);
    }
    function initial(array2) {
      var length = array2 == null ? 0 : array2.length;
      return length ? baseSlice(array2, 0, -1) : [];
    }
    var nativeMin$8 = Math.min;
    function baseIntersection(arrays, iteratee2, comparator) {
      var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result2 = [];
      while (othIndex--) {
        var array2 = arrays[othIndex];
        if (othIndex && iteratee2) {
          array2 = arrayMap(array2, baseUnary(iteratee2));
        }
        maxLength = nativeMin$8(array2.length, maxLength);
        caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array2.length >= 120) ? new SetCache(othIndex && array2) : void 0;
      }
      array2 = arrays[0];
      var index = -1, seen = caches[0];
      outer:
        while (++index < length && result2.length < maxLength) {
          var value = array2[index], computed2 = iteratee2 ? iteratee2(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (!(seen ? cacheHas(seen, computed2) : includes2(result2, computed2, comparator))) {
            othIndex = othLength;
            while (--othIndex) {
              var cache2 = caches[othIndex];
              if (!(cache2 ? cacheHas(cache2, computed2) : includes2(arrays[othIndex], computed2, comparator))) {
                continue outer;
              }
            }
            if (seen) {
              seen.push(computed2);
            }
            result2.push(value);
          }
        }
      return result2;
    }
    function castArrayLikeObject(value) {
      return isArrayLikeObject(value) ? value : [];
    }
    var intersection = baseRest(function(arrays) {
      var mapped = arrayMap(arrays, castArrayLikeObject);
      return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
    });
    var intersectionBy = baseRest(function(arrays) {
      var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
      if (iteratee2 === last(mapped)) {
        iteratee2 = void 0;
      } else {
        mapped.pop();
      }
      return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, baseIteratee(iteratee2)) : [];
    });
    var intersectionWith = baseRest(function(arrays) {
      var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
      comparator = typeof comparator == "function" ? comparator : void 0;
      if (comparator) {
        mapped.pop();
      }
      return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, void 0, comparator) : [];
    });
    function baseInverter(object2, setter, iteratee2, accumulator) {
      baseForOwn(object2, function(value, key, object3) {
        setter(accumulator, iteratee2(value), key, object3);
      });
      return accumulator;
    }
    function createInverter(setter, toIteratee) {
      return function(object2, iteratee2) {
        return baseInverter(object2, setter, toIteratee(iteratee2), {});
      };
    }
    var objectProto$5 = Object.prototype;
    var nativeObjectToString$1 = objectProto$5.toString;
    var invert = createInverter(function(result2, value, key) {
      if (value != null && typeof value.toString != "function") {
        value = nativeObjectToString$1.call(value);
      }
      result2[value] = key;
    }, constant(identity));
    var objectProto$4 = Object.prototype;
    var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
    var nativeObjectToString = objectProto$4.toString;
    var invertBy = createInverter(function(result2, value, key) {
      if (value != null && typeof value.toString != "function") {
        value = nativeObjectToString.call(value);
      }
      if (hasOwnProperty$4.call(result2, value)) {
        result2[value].push(key);
      } else {
        result2[value] = [key];
      }
    }, baseIteratee);
    function parent(object2, path) {
      return path.length < 2 ? object2 : baseGet(object2, baseSlice(path, 0, -1));
    }
    function baseInvoke(object2, path, args) {
      path = castPath(path, object2);
      object2 = parent(object2, path);
      var func2 = object2 == null ? object2 : object2[toKey(last(path))];
      return func2 == null ? void 0 : apply(func2, object2, args);
    }
    var invoke = baseRest(baseInvoke);
    var invokeMap = baseRest(function(collection2, path, args) {
      var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection2) ? Array(collection2.length) : [];
      baseEach(collection2, function(value) {
        result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
      });
      return result2;
    });
    var arrayBufferTag = "[object ArrayBuffer]";
    function baseIsArrayBuffer(value) {
      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
    }
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer;
    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
    var boolTag = "[object Boolean]";
    function isBoolean(value) {
      return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
    }
    var dateTag = "[object Date]";
    function baseIsDate(value) {
      return isObjectLike(value) && baseGetTag(value) == dateTag;
    }
    var nodeIsDate = nodeUtil && nodeUtil.isDate;
    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
    function isElement$3(value) {
      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject$2(value);
    }
    var mapTag$2 = "[object Map]", setTag$2 = "[object Set]";
    var objectProto$3 = Object.prototype;
    var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag = getTag(value);
      if (tag == mapTag$2 || tag == setTag$2) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key in value) {
        if (hasOwnProperty$3.call(value, key)) {
          return false;
        }
      }
      return true;
    }
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    function isEqualWith(value, other, customizer) {
      customizer = typeof customizer == "function" ? customizer : void 0;
      var result2 = customizer ? customizer(value, other) : void 0;
      return result2 === void 0 ? baseIsEqual(value, other, void 0, customizer) : !!result2;
    }
    var nativeIsFinite = root$1.isFinite;
    function isFinite$1(value) {
      return typeof value == "number" && nativeIsFinite(value);
    }
    function isInteger(value) {
      return typeof value == "number" && value == toInteger(value);
    }
    function isMatch(object2, source) {
      return object2 === source || baseIsMatch(object2, source, getMatchData(source));
    }
    function isMatchWith(object2, source, customizer) {
      customizer = typeof customizer == "function" ? customizer : void 0;
      return baseIsMatch(object2, source, getMatchData(source), customizer);
    }
    var numberTag = "[object Number]";
    function isNumber(value) {
      return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
    }
    function isNaN$1(value) {
      return isNumber(value) && value != +value;
    }
    var isMaskable = coreJsData ? isFunction : stubFalse;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.";
    function isNative(value) {
      if (isMaskable(value)) {
        throw new Error(CORE_ERROR_TEXT);
      }
      return baseIsNative(value);
    }
    function isNil(value) {
      return value == null;
    }
    function isNull(value) {
      return value === null;
    }
    var regexpTag = "[object RegExp]";
    function baseIsRegExp(value) {
      return isObjectLike(value) && baseGetTag(value) == regexpTag;
    }
    var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;
    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
    var MAX_SAFE_INTEGER$3 = 9007199254740991;
    function isSafeInteger(value) {
      return isInteger(value) && value >= -MAX_SAFE_INTEGER$3 && value <= MAX_SAFE_INTEGER$3;
    }
    function isUndefined(value) {
      return value === void 0;
    }
    var weakMapTag = "[object WeakMap]";
    function isWeakMap(value) {
      return isObjectLike(value) && getTag(value) == weakMapTag;
    }
    var weakSetTag = "[object WeakSet]";
    function isWeakSet(value) {
      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
    }
    var CLONE_DEEP_FLAG$3 = 1;
    function iteratee(func2) {
      return baseIteratee(typeof func2 == "function" ? func2 : baseClone(func2, CLONE_DEEP_FLAG$3));
    }
    var arrayProto$4 = Array.prototype;
    var nativeJoin = arrayProto$4.join;
    function join(array2, separator) {
      return array2 == null ? "" : nativeJoin.call(array2, separator);
    }
    var kebabCase = createCompounder(function(result2, word, index) {
      return result2 + (index ? "-" : "") + word.toLowerCase();
    });
    var keyBy = createAggregator(function(result2, value, key) {
      baseAssignValue(result2, key, value);
    });
    function strictLastIndexOf(array2, value, fromIndex) {
      var index = fromIndex + 1;
      while (index--) {
        if (array2[index] === value) {
          return index;
        }
      }
      return index;
    }
    var nativeMax$5 = Math.max, nativeMin$7 = Math.min;
    function lastIndexOf(array2, value, fromIndex) {
      var length = array2 == null ? 0 : array2.length;
      if (!length) {
        return -1;
      }
      var index = length;
      if (fromIndex !== void 0) {
        index = toInteger(fromIndex);
        index = index < 0 ? nativeMax$5(length + index, 0) : nativeMin$7(index, length - 1);
      }
      return value === value ? strictLastIndexOf(array2, value, index) : baseFindIndex(array2, baseIsNaN, index, true);
    }
    var lowerCase = createCompounder(function(result2, word, index) {
      return result2 + (index ? " " : "") + word.toLowerCase();
    });
    var lowerFirst = createCaseFirst("toLowerCase");
    function baseLt(value, other) {
      return value < other;
    }
    var lt$2 = createRelationalOperation(baseLt);
    var lte = createRelationalOperation(function(value, other) {
      return value <= other;
    });
    function mapKeys(object2, iteratee2) {
      var result2 = {};
      iteratee2 = baseIteratee(iteratee2);
      baseForOwn(object2, function(value, key, object3) {
        baseAssignValue(result2, iteratee2(value, key, object3), value);
      });
      return result2;
    }
    function mapValues(object2, iteratee2) {
      var result2 = {};
      iteratee2 = baseIteratee(iteratee2);
      baseForOwn(object2, function(value, key, object3) {
        baseAssignValue(result2, key, iteratee2(value, key, object3));
      });
      return result2;
    }
    var CLONE_DEEP_FLAG$2 = 1;
    function matches(source) {
      return baseMatches(baseClone(source, CLONE_DEEP_FLAG$2));
    }
    var CLONE_DEEP_FLAG$1 = 1;
    function matchesProperty(path, srcValue) {
      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG$1));
    }
    function baseExtremum(array2, iteratee2, comparator) {
      var index = -1, length = array2.length;
      while (++index < length) {
        var value = array2[index], current = iteratee2(value);
        if (current != null && (computed2 === void 0 ? current === current && !isSymbol(current) : comparator(current, computed2))) {
          var computed2 = current, result2 = value;
        }
      }
      return result2;
    }
    function max$1(array2) {
      return array2 && array2.length ? baseExtremum(array2, identity, baseGt) : void 0;
    }
    function maxBy(array2, iteratee2) {
      return array2 && array2.length ? baseExtremum(array2, baseIteratee(iteratee2), baseGt) : void 0;
    }
    function baseSum(array2, iteratee2) {
      var result2, index = -1, length = array2.length;
      while (++index < length) {
        var current = iteratee2(array2[index]);
        if (current !== void 0) {
          result2 = result2 === void 0 ? current : result2 + current;
        }
      }
      return result2;
    }
    var NAN = 0 / 0;
    function baseMean(array2, iteratee2) {
      var length = array2 == null ? 0 : array2.length;
      return length ? baseSum(array2, iteratee2) / length : NAN;
    }
    function mean(array2) {
      return baseMean(array2, identity);
    }
    function meanBy(array2, iteratee2) {
      return baseMean(array2, baseIteratee(iteratee2));
    }
    var merge$1 = createAssigner(function(object2, source, srcIndex) {
      baseMerge(object2, source, srcIndex);
    });
    var method = baseRest(function(path, args) {
      return function(object2) {
        return baseInvoke(object2, path, args);
      };
    });
    var methodOf = baseRest(function(object2, args) {
      return function(path) {
        return baseInvoke(object2, path, args);
      };
    });
    function min$1(array2) {
      return array2 && array2.length ? baseExtremum(array2, identity, baseLt) : void 0;
    }
    function minBy(array2, iteratee2) {
      return array2 && array2.length ? baseExtremum(array2, baseIteratee(iteratee2), baseLt) : void 0;
    }
    function mixin$1(object2, source, options) {
      var props = keys(source), methodNames = baseFunctions(source, props);
      var chain2 = !(isObject$3(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object2);
      arrayEach(methodNames, function(methodName) {
        var func2 = source[methodName];
        object2[methodName] = func2;
        if (isFunc) {
          object2.prototype[methodName] = function() {
            var chainAll = this.__chain__;
            if (chain2 || chainAll) {
              var result2 = object2(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
              actions.push({ "func": func2, "args": arguments, "thisArg": object2 });
              result2.__chain__ = chainAll;
              return result2;
            }
            return func2.apply(object2, arrayPush([this.value()], arguments));
          };
        }
      });
      return object2;
    }
    var multiply = createMathOperation(function(multiplier, multiplicand) {
      return multiplier * multiplicand;
    }, 1);
    var FUNC_ERROR_TEXT$3 = "Expected a function";
    function negate(predicate) {
      if (typeof predicate != "function") {
        throw new TypeError(FUNC_ERROR_TEXT$3);
      }
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0:
            return !predicate.call(this);
          case 1:
            return !predicate.call(this, args[0]);
          case 2:
            return !predicate.call(this, args[0], args[1]);
          case 3:
            return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
      };
    }
    function iteratorToArray(iterator) {
      var data, result2 = [];
      while (!(data = iterator.next()).done) {
        result2.push(data.value);
      }
      return result2;
    }
    var mapTag$1 = "[object Map]", setTag$1 = "[object Set]";
    var symIterator$1 = Symbol$1 ? Symbol$1.iterator : void 0;
    function toArray$3(value) {
      if (!value) {
        return [];
      }
      if (isArrayLike(value)) {
        return isString(value) ? stringToArray(value) : copyArray(value);
      }
      if (symIterator$1 && value[symIterator$1]) {
        return iteratorToArray(value[symIterator$1]());
      }
      var tag = getTag(value), func2 = tag == mapTag$1 ? mapToArray : tag == setTag$1 ? setToArray : values;
      return func2(value);
    }
    function wrapperNext() {
      if (this.__values__ === void 0) {
        this.__values__ = toArray$3(this.value());
      }
      var done = this.__index__ >= this.__values__.length, value = done ? void 0 : this.__values__[this.__index__++];
      return { "done": done, "value": value };
    }
    function baseNth(array2, n2) {
      var length = array2.length;
      if (!length) {
        return;
      }
      n2 += n2 < 0 ? length : 0;
      return isIndex(n2, length) ? array2[n2] : void 0;
    }
    function nth(array2, n2) {
      return array2 && array2.length ? baseNth(array2, toInteger(n2)) : void 0;
    }
    function nthArg(n2) {
      n2 = toInteger(n2);
      return baseRest(function(args) {
        return baseNth(args, n2);
      });
    }
    function baseUnset(object2, path) {
      path = castPath(path, object2);
      object2 = parent(object2, path);
      return object2 == null || delete object2[toKey(last(path))];
    }
    function customOmitClone(value) {
      return isPlainObject$2(value) ? void 0 : value;
    }
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var omit = flatRest(function(object2, paths) {
      var result2 = {};
      if (object2 == null) {
        return result2;
      }
      var isDeep = false;
      paths = arrayMap(paths, function(path) {
        path = castPath(path, object2);
        isDeep || (isDeep = path.length > 1);
        return path;
      });
      copyObject(object2, getAllKeysIn(object2), result2);
      if (isDeep) {
        result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
      }
      var length = paths.length;
      while (length--) {
        baseUnset(result2, paths[length]);
      }
      return result2;
    });
    function baseSet(object2, path, value, customizer) {
      if (!isObject$3(object2)) {
        return object2;
      }
      path = castPath(path, object2);
      var index = -1, length = path.length, lastIndex = length - 1, nested = object2;
      while (nested != null && ++index < length) {
        var key = toKey(path[index]), newValue = value;
        if (key === "__proto__" || key === "constructor" || key === "prototype") {
          return object2;
        }
        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : void 0;
          if (newValue === void 0) {
            newValue = isObject$3(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object2;
    }
    function basePickBy(object2, paths, predicate) {
      var index = -1, length = paths.length, result2 = {};
      while (++index < length) {
        var path = paths[index], value = baseGet(object2, path);
        if (predicate(value, path)) {
          baseSet(result2, castPath(path, object2), value);
        }
      }
      return result2;
    }
    function pickBy(object2, predicate) {
      if (object2 == null) {
        return {};
      }
      var props = arrayMap(getAllKeysIn(object2), function(prop) {
        return [prop];
      });
      predicate = baseIteratee(predicate);
      return basePickBy(object2, props, function(value, path) {
        return predicate(value, path[0]);
      });
    }
    function omitBy(object2, predicate) {
      return pickBy(object2, negate(baseIteratee(predicate)));
    }
    function once(func2) {
      return before(2, func2);
    }
    function baseSortBy(array2, comparer) {
      var length = array2.length;
      array2.sort(comparer);
      while (length--) {
        array2[length] = array2[length].value;
      }
      return array2;
    }
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
        var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
        if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
          return 1;
        }
        if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }
    function compareMultiple(object2, other, orders) {
      var index = -1, objCriteria = object2.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
      while (++index < length) {
        var result2 = compareAscending(objCriteria[index], othCriteria[index]);
        if (result2) {
          if (index >= ordersLength) {
            return result2;
          }
          var order2 = orders[index];
          return result2 * (order2 == "desc" ? -1 : 1);
        }
      }
      return object2.index - other.index;
    }
    function baseOrderBy(collection2, iteratees, orders) {
      if (iteratees.length) {
        iteratees = arrayMap(iteratees, function(iteratee2) {
          if (isArray(iteratee2)) {
            return function(value) {
              return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
            };
          }
          return iteratee2;
        });
      } else {
        iteratees = [identity];
      }
      var index = -1;
      iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
      var result2 = baseMap(collection2, function(value, key, collection3) {
        var criteria = arrayMap(iteratees, function(iteratee2) {
          return iteratee2(value);
        });
        return { "criteria": criteria, "index": ++index, "value": value };
      });
      return baseSortBy(result2, function(object2, other) {
        return compareMultiple(object2, other, orders);
      });
    }
    function orderBy(collection2, iteratees, orders, guard) {
      if (collection2 == null) {
        return [];
      }
      if (!isArray(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
      }
      orders = guard ? void 0 : orders;
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseOrderBy(collection2, iteratees, orders);
    }
    function createOver(arrayFunc) {
      return flatRest(function(iteratees) {
        iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
        return baseRest(function(args) {
          var thisArg = this;
          return arrayFunc(iteratees, function(iteratee2) {
            return apply(iteratee2, thisArg, args);
          });
        });
      });
    }
    var over = createOver(arrayMap);
    var castRest = baseRest;
    var nativeMin$6 = Math.min;
    var overArgs = castRest(function(func2, transforms) {
      transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(baseIteratee)) : arrayMap(baseFlatten(transforms, 1), baseUnary(baseIteratee));
      var funcsLength = transforms.length;
      return baseRest(function(args) {
        var index = -1, length = nativeMin$6(args.length, funcsLength);
        while (++index < length) {
          args[index] = transforms[index].call(this, args[index]);
        }
        return apply(func2, this, args);
      });
    });
    var overEvery = createOver(arrayEvery);
    var overSome = createOver(arraySome);
    var MAX_SAFE_INTEGER$2 = 9007199254740991;
    var nativeFloor$3 = Math.floor;
    function baseRepeat(string2, n2) {
      var result2 = "";
      if (!string2 || n2 < 1 || n2 > MAX_SAFE_INTEGER$2) {
        return result2;
      }
      do {
        if (n2 % 2) {
          result2 += string2;
        }
        n2 = nativeFloor$3(n2 / 2);
        if (n2) {
          string2 += string2;
        }
      } while (n2);
      return result2;
    }
    var asciiSize = baseProperty("length");
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f";
    var rsAstral = "[" + rsAstralRange + "]", rsCombo = "[" + rsComboRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ = "\\u200d";
    var reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    function unicodeSize(string2) {
      var result2 = reUnicode.lastIndex = 0;
      while (reUnicode.test(string2)) {
        ++result2;
      }
      return result2;
    }
    function stringSize(string2) {
      return hasUnicode(string2) ? unicodeSize(string2) : asciiSize(string2);
    }
    var nativeCeil$2 = Math.ceil;
    function createPadding(length, chars) {
      chars = chars === void 0 ? " " : baseToString(chars);
      var charsLength = chars.length;
      if (charsLength < 2) {
        return charsLength ? baseRepeat(chars, length) : chars;
      }
      var result2 = baseRepeat(chars, nativeCeil$2(length / stringSize(chars)));
      return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
    }
    var nativeCeil$1 = Math.ceil, nativeFloor$2 = Math.floor;
    function pad(string2, length, chars) {
      string2 = toString$1(string2);
      length = toInteger(length);
      var strLength = length ? stringSize(string2) : 0;
      if (!length || strLength >= length) {
        return string2;
      }
      var mid = (length - strLength) / 2;
      return createPadding(nativeFloor$2(mid), chars) + string2 + createPadding(nativeCeil$1(mid), chars);
    }
    function padEnd(string2, length, chars) {
      string2 = toString$1(string2);
      length = toInteger(length);
      var strLength = length ? stringSize(string2) : 0;
      return length && strLength < length ? string2 + createPadding(length - strLength, chars) : string2;
    }
    function padStart(string2, length, chars) {
      string2 = toString$1(string2);
      length = toInteger(length);
      var strLength = length ? stringSize(string2) : 0;
      return length && strLength < length ? createPadding(length - strLength, chars) + string2 : string2;
    }
    var reTrimStart$1 = /^\s+/;
    var nativeParseInt = root$1.parseInt;
    function parseInt$1(string2, radix, guard) {
      if (guard || radix == null) {
        radix = 0;
      } else if (radix) {
        radix = +radix;
      }
      return nativeParseInt(toString$1(string2).replace(reTrimStart$1, ""), radix || 0);
    }
    var WRAP_PARTIAL_FLAG = 32;
    var partial = baseRest(function(func2, partials) {
      var holders = replaceHolders(partials, getHolder(partial));
      return createWrap(func2, WRAP_PARTIAL_FLAG, void 0, partials, holders);
    });
    partial.placeholder = {};
    var WRAP_PARTIAL_RIGHT_FLAG = 64;
    var partialRight = baseRest(function(func2, partials) {
      var holders = replaceHolders(partials, getHolder(partialRight));
      return createWrap(func2, WRAP_PARTIAL_RIGHT_FLAG, void 0, partials, holders);
    });
    partialRight.placeholder = {};
    var partition = createAggregator(function(result2, value, key) {
      result2[key ? 0 : 1].push(value);
    }, function() {
      return [[], []];
    });
    function basePick(object2, paths) {
      return basePickBy(object2, paths, function(value, path) {
        return hasIn(object2, path);
      });
    }
    var pick = flatRest(function(object2, paths) {
      return object2 == null ? {} : basePick(object2, paths);
    });
    function wrapperPlant(value) {
      var result2, parent2 = this;
      while (parent2 instanceof baseLodash) {
        var clone2 = wrapperClone(parent2);
        clone2.__index__ = 0;
        clone2.__values__ = void 0;
        if (result2) {
          previous.__wrapped__ = clone2;
        } else {
          result2 = clone2;
        }
        var previous = clone2;
        parent2 = parent2.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result2;
    }
    function propertyOf(object2) {
      return function(path) {
        return object2 == null ? void 0 : baseGet(object2, path);
      };
    }
    function baseIndexOfWith(array2, value, fromIndex, comparator) {
      var index = fromIndex - 1, length = array2.length;
      while (++index < length) {
        if (comparator(array2[index], value)) {
          return index;
        }
      }
      return -1;
    }
    var arrayProto$3 = Array.prototype;
    var splice$1 = arrayProto$3.splice;
    function basePullAll(array2, values2, iteratee2, comparator) {
      var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array2;
      if (array2 === values2) {
        values2 = copyArray(values2);
      }
      if (iteratee2) {
        seen = arrayMap(array2, baseUnary(iteratee2));
      }
      while (++index < length) {
        var fromIndex = 0, value = values2[index], computed2 = iteratee2 ? iteratee2(value) : value;
        while ((fromIndex = indexOf2(seen, computed2, fromIndex, comparator)) > -1) {
          if (seen !== array2) {
            splice$1.call(seen, fromIndex, 1);
          }
          splice$1.call(array2, fromIndex, 1);
        }
      }
      return array2;
    }
    function pullAll(array2, values2) {
      return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2) : array2;
    }
    var pull = baseRest(pullAll);
    function pullAllBy(array2, values2, iteratee2) {
      return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2, baseIteratee(iteratee2)) : array2;
    }
    function pullAllWith(array2, values2, comparator) {
      return array2 && array2.length && values2 && values2.length ? basePullAll(array2, values2, void 0, comparator) : array2;
    }
    var arrayProto$2 = Array.prototype;
    var splice = arrayProto$2.splice;
    function basePullAt(array2, indexes) {
      var length = array2 ? indexes.length : 0, lastIndex = length - 1;
      while (length--) {
        var index = indexes[length];
        if (length == lastIndex || index !== previous) {
          var previous = index;
          if (isIndex(index)) {
            splice.call(array2, index, 1);
          } else {
            baseUnset(array2, index);
          }
        }
      }
      return array2;
    }
    var pullAt = flatRest(function(array2, indexes) {
      var length = array2 == null ? 0 : array2.length, result2 = baseAt(array2, indexes);
      basePullAt(array2, arrayMap(indexes, function(index) {
        return isIndex(index, length) ? +index : index;
      }).sort(compareAscending));
      return result2;
    });
    var nativeFloor$1 = Math.floor, nativeRandom$1 = Math.random;
    function baseRandom(lower, upper) {
      return lower + nativeFloor$1(nativeRandom$1() * (upper - lower + 1));
    }
    var freeParseFloat = parseFloat;
    var nativeMin$5 = Math.min, nativeRandom = Math.random;
    function random(lower, upper, floating) {
      if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
        upper = floating = void 0;
      }
      if (floating === void 0) {
        if (typeof upper == "boolean") {
          floating = upper;
          upper = void 0;
        } else if (typeof lower == "boolean") {
          floating = lower;
          lower = void 0;
        }
      }
      if (lower === void 0 && upper === void 0) {
        lower = 0;
        upper = 1;
      } else {
        lower = toFinite(lower);
        if (upper === void 0) {
          upper = lower;
          lower = 0;
        } else {
          upper = toFinite(upper);
        }
      }
      if (lower > upper) {
        var temp = lower;
        lower = upper;
        upper = temp;
      }
      if (floating || lower % 1 || upper % 1) {
        var rand = nativeRandom();
        return nativeMin$5(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
      }
      return baseRandom(lower, upper);
    }
    var nativeCeil = Math.ceil, nativeMax$4 = Math.max;
    function baseRange(start2, end2, step, fromRight) {
      var index = -1, length = nativeMax$4(nativeCeil((end2 - start2) / (step || 1)), 0), result2 = Array(length);
      while (length--) {
        result2[fromRight ? length : ++index] = start2;
        start2 += step;
      }
      return result2;
    }
    function createRange(fromRight) {
      return function(start2, end2, step) {
        if (step && typeof step != "number" && isIterateeCall(start2, end2, step)) {
          end2 = step = void 0;
        }
        start2 = toFinite(start2);
        if (end2 === void 0) {
          end2 = start2;
          start2 = 0;
        } else {
          end2 = toFinite(end2);
        }
        step = step === void 0 ? start2 < end2 ? 1 : -1 : toFinite(step);
        return baseRange(start2, end2, step, fromRight);
      };
    }
    var range = createRange();
    var rangeRight = createRange(true);
    var WRAP_REARG_FLAG = 256;
    var rearg = flatRest(function(func2, indexes) {
      return createWrap(func2, WRAP_REARG_FLAG, void 0, void 0, void 0, indexes);
    });
    function baseReduce(collection2, iteratee2, accumulator, initAccum, eachFunc) {
      eachFunc(collection2, function(value, index, collection3) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee2(accumulator, value, index, collection3);
      });
      return accumulator;
    }
    function reduce(collection2, iteratee2, accumulator) {
      var func2 = isArray(collection2) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
      return func2(collection2, baseIteratee(iteratee2), accumulator, initAccum, baseEach);
    }
    function arrayReduceRight(array2, iteratee2, accumulator, initAccum) {
      var length = array2 == null ? 0 : array2.length;
      if (initAccum && length) {
        accumulator = array2[--length];
      }
      while (length--) {
        accumulator = iteratee2(accumulator, array2[length], length, array2);
      }
      return accumulator;
    }
    function reduceRight(collection2, iteratee2, accumulator) {
      var func2 = isArray(collection2) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
      return func2(collection2, baseIteratee(iteratee2), accumulator, initAccum, baseEachRight);
    }
    function reject(collection2, predicate) {
      var func2 = isArray(collection2) ? arrayFilter : baseFilter;
      return func2(collection2, negate(baseIteratee(predicate)));
    }
    function remove$2(array2, predicate) {
      var result2 = [];
      if (!(array2 && array2.length)) {
        return result2;
      }
      var index = -1, indexes = [], length = array2.length;
      predicate = baseIteratee(predicate);
      while (++index < length) {
        var value = array2[index];
        if (predicate(value, index, array2)) {
          result2.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array2, indexes);
      return result2;
    }
    function repeat(string2, n2, guard) {
      if (guard ? isIterateeCall(string2, n2, guard) : n2 === void 0) {
        n2 = 1;
      } else {
        n2 = toInteger(n2);
      }
      return baseRepeat(toString$1(string2), n2);
    }
    function replace() {
      var args = arguments, string2 = toString$1(args[0]);
      return args.length < 3 ? string2 : string2.replace(args[1], args[2]);
    }
    var FUNC_ERROR_TEXT$2 = "Expected a function";
    function rest(func2, start2) {
      if (typeof func2 != "function") {
        throw new TypeError(FUNC_ERROR_TEXT$2);
      }
      start2 = start2 === void 0 ? start2 : toInteger(start2);
      return baseRest(func2, start2);
    }
    function result(object2, path, defaultValue) {
      path = castPath(path, object2);
      var index = -1, length = path.length;
      if (!length) {
        length = 1;
        object2 = void 0;
      }
      while (++index < length) {
        var value = object2 == null ? void 0 : object2[toKey(path[index])];
        if (value === void 0) {
          index = length;
          value = defaultValue;
        }
        object2 = isFunction(value) ? value.call(object2) : value;
      }
      return object2;
    }
    var arrayProto$1 = Array.prototype;
    var nativeReverse = arrayProto$1.reverse;
    function reverse(array2) {
      return array2 == null ? array2 : nativeReverse.call(array2);
    }
    var round$1 = createRound("round");
    function arraySample(array2) {
      var length = array2.length;
      return length ? array2[baseRandom(0, length - 1)] : void 0;
    }
    function baseSample(collection2) {
      return arraySample(values(collection2));
    }
    function sample(collection2) {
      var func2 = isArray(collection2) ? arraySample : baseSample;
      return func2(collection2);
    }
    function shuffleSelf(array2, size2) {
      var index = -1, length = array2.length, lastIndex = length - 1;
      size2 = size2 === void 0 ? length : size2;
      while (++index < size2) {
        var rand = baseRandom(index, lastIndex), value = array2[rand];
        array2[rand] = array2[index];
        array2[index] = value;
      }
      array2.length = size2;
      return array2;
    }
    function arraySampleSize(array2, n2) {
      return shuffleSelf(copyArray(array2), baseClamp(n2, 0, array2.length));
    }
    function baseSampleSize(collection2, n2) {
      var array2 = values(collection2);
      return shuffleSelf(array2, baseClamp(n2, 0, array2.length));
    }
    function sampleSize(collection2, n2, guard) {
      if (guard ? isIterateeCall(collection2, n2, guard) : n2 === void 0) {
        n2 = 1;
      } else {
        n2 = toInteger(n2);
      }
      var func2 = isArray(collection2) ? arraySampleSize : baseSampleSize;
      return func2(collection2, n2);
    }
    function set$1(object2, path, value) {
      return object2 == null ? object2 : baseSet(object2, path, value);
    }
    function setWith(object2, path, value, customizer) {
      customizer = typeof customizer == "function" ? customizer : void 0;
      return object2 == null ? object2 : baseSet(object2, path, value, customizer);
    }
    function arrayShuffle(array2) {
      return shuffleSelf(copyArray(array2));
    }
    function baseShuffle(collection2) {
      return shuffleSelf(values(collection2));
    }
    function shuffle(collection2) {
      var func2 = isArray(collection2) ? arrayShuffle : baseShuffle;
      return func2(collection2);
    }
    var mapTag = "[object Map]", setTag = "[object Set]";
    function size(collection2) {
      if (collection2 == null) {
        return 0;
      }
      if (isArrayLike(collection2)) {
        return isString(collection2) ? stringSize(collection2) : collection2.length;
      }
      var tag = getTag(collection2);
      if (tag == mapTag || tag == setTag) {
        return collection2.size;
      }
      return baseKeys(collection2).length;
    }
    function slice(array2, start2, end2) {
      var length = array2 == null ? 0 : array2.length;
      if (!length) {
        return [];
      }
      if (end2 && typeof end2 != "number" && isIterateeCall(array2, start2, end2)) {
        start2 = 0;
        end2 = length;
      } else {
        start2 = start2 == null ? 0 : toInteger(start2);
        end2 = end2 === void 0 ? length : toInteger(end2);
      }
      return baseSlice(array2, start2, end2);
    }
    var snakeCase = createCompounder(function(result2, word, index) {
      return result2 + (index ? "_" : "") + word.toLowerCase();
    });
    function baseSome(collection2, predicate) {
      var result2;
      baseEach(collection2, function(value, index, collection3) {
        result2 = predicate(value, index, collection3);
        return !result2;
      });
      return !!result2;
    }
    function some(collection2, predicate, guard) {
      var func2 = isArray(collection2) ? arraySome : baseSome;
      if (guard && isIterateeCall(collection2, predicate, guard)) {
        predicate = void 0;
      }
      return func2(collection2, baseIteratee(predicate));
    }
    var sortBy = baseRest(function(collection2, iteratees) {
      if (collection2 == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection2, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection2, baseFlatten(iteratees, 1), []);
    });
    var MAX_ARRAY_LENGTH$4 = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH$4 - 1;
    var nativeFloor = Math.floor, nativeMin$4 = Math.min;
    function baseSortedIndexBy(array2, value, iteratee2, retHighest) {
      var low = 0, high = array2 == null ? 0 : array2.length;
      if (high === 0) {
        return 0;
      }
      value = iteratee2(value);
      var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === void 0;
      while (low < high) {
        var mid = nativeFloor((low + high) / 2), computed2 = iteratee2(array2[mid]), othIsDefined = computed2 !== void 0, othIsNull = computed2 === null, othIsReflexive = computed2 === computed2, othIsSymbol = isSymbol(computed2);
        if (valIsNaN) {
          var setLow = retHighest || othIsReflexive;
        } else if (valIsUndefined) {
          setLow = othIsReflexive && (retHighest || othIsDefined);
        } else if (valIsNull) {
          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
        } else if (valIsSymbol) {
          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
        } else if (othIsNull || othIsSymbol) {
          setLow = false;
        } else {
          setLow = retHighest ? computed2 <= value : computed2 < value;
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin$4(high, MAX_ARRAY_INDEX);
    }
    var MAX_ARRAY_LENGTH$3 = 4294967295, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH$3 >>> 1;
    function baseSortedIndex(array2, value, retHighest) {
      var low = 0, high = array2 == null ? low : array2.length;
      if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = low + high >>> 1, computed2 = array2[mid];
          if (computed2 !== null && !isSymbol(computed2) && (retHighest ? computed2 <= value : computed2 < value)) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return baseSortedIndexBy(array2, value, identity, retHighest);
    }
    function sortedIndex(array2, value) {
      return baseSortedIndex(array2, value);
    }
    function sortedIndexBy(array2, value, iteratee2) {
      return baseSortedIndexBy(array2, value, baseIteratee(iteratee2));
    }
    function sortedIndexOf(array2, value) {
      var length = array2 == null ? 0 : array2.length;
      if (length) {
        var index = baseSortedIndex(array2, value);
        if (index < length && eq(array2[index], value)) {
          return index;
        }
      }
      return -1;
    }
    function sortedLastIndex(array2, value) {
      return baseSortedIndex(array2, value, true);
    }
    function sortedLastIndexBy(array2, value, iteratee2) {
      return baseSortedIndexBy(array2, value, baseIteratee(iteratee2), true);
    }
    function sortedLastIndexOf(array2, value) {
      var length = array2 == null ? 0 : array2.length;
      if (length) {
        var index = baseSortedIndex(array2, value, true) - 1;
        if (eq(array2[index], value)) {
          return index;
        }
      }
      return -1;
    }
    function baseSortedUniq(array2, iteratee2) {
      var index = -1, length = array2.length, resIndex = 0, result2 = [];
      while (++index < length) {
        var value = array2[index], computed2 = iteratee2 ? iteratee2(value) : value;
        if (!index || !eq(computed2, seen)) {
          var seen = computed2;
          result2[resIndex++] = value === 0 ? 0 : value;
        }
      }
      return result2;
    }
    function sortedUniq(array2) {
      return array2 && array2.length ? baseSortedUniq(array2) : [];
    }
    function sortedUniqBy(array2, iteratee2) {
      return array2 && array2.length ? baseSortedUniq(array2, baseIteratee(iteratee2)) : [];
    }
    var MAX_ARRAY_LENGTH$2 = 4294967295;
    function split(string2, separator, limit) {
      if (limit && typeof limit != "number" && isIterateeCall(string2, separator, limit)) {
        separator = limit = void 0;
      }
      limit = limit === void 0 ? MAX_ARRAY_LENGTH$2 : limit >>> 0;
      if (!limit) {
        return [];
      }
      string2 = toString$1(string2);
      if (string2 && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
        separator = baseToString(separator);
        if (!separator && hasUnicode(string2)) {
          return castSlice(stringToArray(string2), 0, limit);
        }
      }
      return string2.split(separator, limit);
    }
    var FUNC_ERROR_TEXT$1 = "Expected a function";
    var nativeMax$3 = Math.max;
    function spread(func2, start2) {
      if (typeof func2 != "function") {
        throw new TypeError(FUNC_ERROR_TEXT$1);
      }
      start2 = start2 == null ? 0 : nativeMax$3(toInteger(start2), 0);
      return baseRest(function(args) {
        var array2 = args[start2], otherArgs = castSlice(args, 0, start2);
        if (array2) {
          arrayPush(otherArgs, array2);
        }
        return apply(func2, this, otherArgs);
      });
    }
    var startCase = createCompounder(function(result2, word, index) {
      return result2 + (index ? " " : "") + upperFirst(word);
    });
    function startsWith(string2, target, position) {
      string2 = toString$1(string2);
      position = position == null ? 0 : baseClamp(toInteger(position), 0, string2.length);
      target = baseToString(target);
      return string2.slice(position, position + target.length) == target;
    }
    function stubObject() {
      return {};
    }
    function stubString() {
      return "";
    }
    function stubTrue() {
      return true;
    }
    var subtract = createMathOperation(function(minuend, subtrahend) {
      return minuend - subtrahend;
    }, 0);
    function sum(array2) {
      return array2 && array2.length ? baseSum(array2, identity) : 0;
    }
    function sumBy(array2, iteratee2) {
      return array2 && array2.length ? baseSum(array2, baseIteratee(iteratee2)) : 0;
    }
    function tail(array2) {
      var length = array2 == null ? 0 : array2.length;
      return length ? baseSlice(array2, 1, length) : [];
    }
    function take(array2, n2, guard) {
      if (!(array2 && array2.length)) {
        return [];
      }
      n2 = guard || n2 === void 0 ? 1 : toInteger(n2);
      return baseSlice(array2, 0, n2 < 0 ? 0 : n2);
    }
    function takeRight(array2, n2, guard) {
      var length = array2 == null ? 0 : array2.length;
      if (!length) {
        return [];
      }
      n2 = guard || n2 === void 0 ? 1 : toInteger(n2);
      n2 = length - n2;
      return baseSlice(array2, n2 < 0 ? 0 : n2, length);
    }
    function takeRightWhile(array2, predicate) {
      return array2 && array2.length ? baseWhile(array2, baseIteratee(predicate), false, true) : [];
    }
    function takeWhile(array2, predicate) {
      return array2 && array2.length ? baseWhile(array2, baseIteratee(predicate)) : [];
    }
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }
    var objectProto$2 = Object.prototype;
    var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
    function customDefaultsAssignIn(objValue, srcValue, key, object2) {
      if (objValue === void 0 || eq(objValue, objectProto$2[key]) && !hasOwnProperty$2.call(object2, key)) {
        return srcValue;
      }
      return objValue;
    }
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    var reInterpolate = /<%=([\s\S]+?)%>/g;
    var reEscape = /<%-([\s\S]+?)%>/g;
    var reEvaluate = /<%([\s\S]+?)%>/g;
    var templateSettings = {
      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      "escape": reEscape,
      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      "evaluate": reEvaluate,
      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      "interpolate": reInterpolate,
      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */
      "variable": "",
      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */
      "imports": {
        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */
        "_": { "escape": escape$1 }
      }
    };
    var INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var objectProto$1 = Object.prototype;
    var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
    function template(string2, options, guard) {
      var settings = templateSettings.imports._.templateSettings || templateSettings;
      if (guard && isIterateeCall(string2, options, guard)) {
        options = void 0;
      }
      string2 = toString$1(string2);
      options = assignInWith({}, options, settings, customDefaultsAssignIn);
      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
      var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
        "g"
      );
      var sourceURL = hasOwnProperty$1.call(options, "sourceURL") ? "//# sourceURL=" + (options.sourceURL + "").replace(/\s/g, " ") + "\n" : "";
      string2.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset2) {
        interpolateValue || (interpolateValue = esTemplateValue);
        source += string2.slice(index, offset2).replace(reUnescapedString, escapeStringChar);
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset2 + match.length;
        return match;
      });
      source += "';\n";
      var variable = hasOwnProperty$1.call(options, "variable") && options.variable;
      if (!variable) {
        source = "with (obj) {\n" + source + "\n}\n";
      } else if (reForbiddenIdentifierChars.test(variable)) {
        throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
      }
      source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
      source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
      var result2 = attempt(function() {
        return Function(importsKeys, sourceURL + "return " + source).apply(void 0, importsValues);
      });
      result2.source = source;
      if (isError(result2)) {
        throw result2;
      }
      return result2;
    }
    var FUNC_ERROR_TEXT = "Expected a function";
    function throttle(func2, wait, options) {
      var leading = true, trailing = true;
      if (typeof func2 != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject$3(options)) {
        leading = "leading" in options ? !!options.leading : leading;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      return debounce$1(func2, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
      });
    }
    function thru(value, interceptor) {
      return interceptor(value);
    }
    var MAX_SAFE_INTEGER$1 = 9007199254740991;
    var MAX_ARRAY_LENGTH$1 = 4294967295;
    var nativeMin$3 = Math.min;
    function times(n2, iteratee2) {
      n2 = toInteger(n2);
      if (n2 < 1 || n2 > MAX_SAFE_INTEGER$1) {
        return [];
      }
      var index = MAX_ARRAY_LENGTH$1, length = nativeMin$3(n2, MAX_ARRAY_LENGTH$1);
      iteratee2 = castFunction(iteratee2);
      n2 -= MAX_ARRAY_LENGTH$1;
      var result2 = baseTimes(length, iteratee2);
      while (++index < n2) {
        iteratee2(index);
      }
      return result2;
    }
    function wrapperToIterator() {
      return this;
    }
    function baseWrapperValue(value, actions) {
      var result2 = value;
      if (result2 instanceof LazyWrapper) {
        result2 = result2.value();
      }
      return arrayReduce(actions, function(result3, action) {
        return action.func.apply(action.thisArg, arrayPush([result3], action.args));
      }, result2);
    }
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }
    function toLower(value) {
      return toString$1(value).toLowerCase();
    }
    function toPath$1(value) {
      if (isArray(value)) {
        return arrayMap(value, toKey);
      }
      return isSymbol(value) ? [value] : copyArray(stringToPath(toString$1(value)));
    }
    var MAX_SAFE_INTEGER = 9007199254740991;
    function toSafeInteger(value) {
      return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
    }
    function toUpper(value) {
      return toString$1(value).toUpperCase();
    }
    function transform$3(object2, iteratee2, accumulator) {
      var isArr = isArray(object2), isArrLike = isArr || isBuffer(object2) || isTypedArray(object2);
      iteratee2 = baseIteratee(iteratee2);
      if (accumulator == null) {
        var Ctor = object2 && object2.constructor;
        if (isArrLike) {
          accumulator = isArr ? new Ctor() : [];
        } else if (isObject$3(object2)) {
          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object2)) : {};
        } else {
          accumulator = {};
        }
      }
      (isArrLike ? arrayEach : baseForOwn)(object2, function(value, index, object3) {
        return iteratee2(accumulator, value, index, object3);
      });
      return accumulator;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index = strSymbols.length;
      while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index = -1, length = strSymbols.length;
      while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function trim(string2, chars, guard) {
      string2 = toString$1(string2);
      if (string2 && (guard || chars === void 0)) {
        return baseTrim(string2);
      }
      if (!string2 || !(chars = baseToString(chars))) {
        return string2;
      }
      var strSymbols = stringToArray(string2), chrSymbols = stringToArray(chars), start2 = charsStartIndex(strSymbols, chrSymbols), end2 = charsEndIndex(strSymbols, chrSymbols) + 1;
      return castSlice(strSymbols, start2, end2).join("");
    }
    function trimEnd(string2, chars, guard) {
      string2 = toString$1(string2);
      if (string2 && (guard || chars === void 0)) {
        return string2.slice(0, trimmedEndIndex(string2) + 1);
      }
      if (!string2 || !(chars = baseToString(chars))) {
        return string2;
      }
      var strSymbols = stringToArray(string2), end2 = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
      return castSlice(strSymbols, 0, end2).join("");
    }
    var reTrimStart = /^\s+/;
    function trimStart(string2, chars, guard) {
      string2 = toString$1(string2);
      if (string2 && (guard || chars === void 0)) {
        return string2.replace(reTrimStart, "");
      }
      if (!string2 || !(chars = baseToString(chars))) {
        return string2;
      }
      var strSymbols = stringToArray(string2), start2 = charsStartIndex(strSymbols, stringToArray(chars));
      return castSlice(strSymbols, start2).join("");
    }
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var reFlags = /\w*$/;
    function truncate(string2, options) {
      var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
      if (isObject$3(options)) {
        var separator = "separator" in options ? options.separator : separator;
        length = "length" in options ? toInteger(options.length) : length;
        omission = "omission" in options ? baseToString(options.omission) : omission;
      }
      string2 = toString$1(string2);
      var strLength = string2.length;
      if (hasUnicode(string2)) {
        var strSymbols = stringToArray(string2);
        strLength = strSymbols.length;
      }
      if (length >= strLength) {
        return string2;
      }
      var end2 = length - stringSize(omission);
      if (end2 < 1) {
        return omission;
      }
      var result2 = strSymbols ? castSlice(strSymbols, 0, end2).join("") : string2.slice(0, end2);
      if (separator === void 0) {
        return result2 + omission;
      }
      if (strSymbols) {
        end2 += result2.length - end2;
      }
      if (isRegExp(separator)) {
        if (string2.slice(end2).search(separator)) {
          var match, substring = result2;
          if (!separator.global) {
            separator = RegExp(separator.source, toString$1(reFlags.exec(separator)) + "g");
          }
          separator.lastIndex = 0;
          while (match = separator.exec(substring)) {
            var newEnd = match.index;
          }
          result2 = result2.slice(0, newEnd === void 0 ? end2 : newEnd);
        }
      } else if (string2.indexOf(baseToString(separator), end2) != end2) {
        var index = result2.lastIndexOf(separator);
        if (index > -1) {
          result2 = result2.slice(0, index);
        }
      }
      return result2 + omission;
    }
    function unary(func2) {
      return ary(func2, 1);
    }
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reHasEscapedHtml = RegExp(reEscapedHtml.source);
    function unescape$1(string2) {
      string2 = toString$1(string2);
      return string2 && reHasEscapedHtml.test(string2) ? string2.replace(reEscapedHtml, unescapeHtmlChar) : string2;
    }
    var INFINITY = 1 / 0;
    var createSet = !(Set$1 && 1 / setToArray(new Set$1([, -0]))[1] == INFINITY) ? noop$2 : function(values2) {
      return new Set$1(values2);
    };
    var LARGE_ARRAY_SIZE = 200;
    function baseUniq(array2, iteratee2, comparator) {
      var index = -1, includes2 = arrayIncludes, length = array2.length, isCommon = true, result2 = [], seen = result2;
      if (comparator) {
        isCommon = false;
        includes2 = arrayIncludesWith;
      } else if (length >= LARGE_ARRAY_SIZE) {
        var set2 = iteratee2 ? null : createSet(array2);
        if (set2) {
          return setToArray(set2);
        }
        isCommon = false;
        includes2 = cacheHas;
        seen = new SetCache();
      } else {
        seen = iteratee2 ? [] : result2;
      }
      outer:
        while (++index < length) {
          var value = array2[index], computed2 = iteratee2 ? iteratee2(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed2 === computed2) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed2) {
                continue outer;
              }
            }
            if (iteratee2) {
              seen.push(computed2);
            }
            result2.push(value);
          } else if (!includes2(seen, computed2, comparator)) {
            if (seen !== result2) {
              seen.push(computed2);
            }
            result2.push(value);
          }
        }
      return result2;
    }
    var union = baseRest(function(arrays) {
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
    });
    var unionBy = baseRest(function(arrays) {
      var iteratee2 = last(arrays);
      if (isArrayLikeObject(iteratee2)) {
        iteratee2 = void 0;
      }
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), baseIteratee(iteratee2));
    });
    var unionWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == "function" ? comparator : void 0;
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), void 0, comparator);
    });
    function uniq(array2) {
      return array2 && array2.length ? baseUniq(array2) : [];
    }
    function uniqBy(array2, iteratee2) {
      return array2 && array2.length ? baseUniq(array2, baseIteratee(iteratee2)) : [];
    }
    function uniqWith(array2, comparator) {
      comparator = typeof comparator == "function" ? comparator : void 0;
      return array2 && array2.length ? baseUniq(array2, void 0, comparator) : [];
    }
    var idCounter = 0;
    function uniqueId(prefix) {
      var id = ++idCounter;
      return toString$1(prefix) + id;
    }
    function unset(object2, path) {
      return object2 == null ? true : baseUnset(object2, path);
    }
    var nativeMax$2 = Math.max;
    function unzip(array2) {
      if (!(array2 && array2.length)) {
        return [];
      }
      var length = 0;
      array2 = arrayFilter(array2, function(group) {
        if (isArrayLikeObject(group)) {
          length = nativeMax$2(group.length, length);
          return true;
        }
      });
      return baseTimes(length, function(index) {
        return arrayMap(array2, baseProperty(index));
      });
    }
    function unzipWith(array2, iteratee2) {
      if (!(array2 && array2.length)) {
        return [];
      }
      var result2 = unzip(array2);
      if (iteratee2 == null) {
        return result2;
      }
      return arrayMap(result2, function(group) {
        return apply(iteratee2, void 0, group);
      });
    }
    function baseUpdate(object2, path, updater, customizer) {
      return baseSet(object2, path, updater(baseGet(object2, path)), customizer);
    }
    function update(object2, path, updater) {
      return object2 == null ? object2 : baseUpdate(object2, path, castFunction(updater));
    }
    function updateWith(object2, path, updater, customizer) {
      customizer = typeof customizer == "function" ? customizer : void 0;
      return object2 == null ? object2 : baseUpdate(object2, path, castFunction(updater), customizer);
    }
    var upperCase = createCompounder(function(result2, word, index) {
      return result2 + (index ? " " : "") + word.toUpperCase();
    });
    function valuesIn(object2) {
      return object2 == null ? [] : baseValues(object2, keysIn(object2));
    }
    var without = baseRest(function(array2, values2) {
      return isArrayLikeObject(array2) ? baseDifference(array2, values2) : [];
    });
    function wrap$1(value, wrapper) {
      return partial(castFunction(wrapper), value);
    }
    var wrapperAt = flatRest(function(paths) {
      var length = paths.length, start2 = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object2) {
        return baseAt(object2, paths);
      };
      if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start2)) {
        return this.thru(interceptor);
      }
      value = value.slice(start2, +start2 + (length ? 1 : 0));
      value.__actions__.push({
        "func": thru,
        "args": [interceptor],
        "thisArg": void 0
      });
      return new LodashWrapper(value, this.__chain__).thru(function(array2) {
        if (length && !array2.length) {
          array2.push(void 0);
        }
        return array2;
      });
    });
    function wrapperChain() {
      return chain(this);
    }
    function wrapperReverse() {
      var value = this.__wrapped__;
      if (value instanceof LazyWrapper) {
        var wrapped = value;
        if (this.__actions__.length) {
          wrapped = new LazyWrapper(this);
        }
        wrapped = wrapped.reverse();
        wrapped.__actions__.push({
          "func": thru,
          "args": [reverse],
          "thisArg": void 0
        });
        return new LodashWrapper(wrapped, this.__chain__);
      }
      return this.thru(reverse);
    }
    function baseXor(arrays, iteratee2, comparator) {
      var length = arrays.length;
      if (length < 2) {
        return length ? baseUniq(arrays[0]) : [];
      }
      var index = -1, result2 = Array(length);
      while (++index < length) {
        var array2 = arrays[index], othIndex = -1;
        while (++othIndex < length) {
          if (othIndex != index) {
            result2[index] = baseDifference(result2[index] || array2, arrays[othIndex], iteratee2, comparator);
          }
        }
      }
      return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
    }
    var xor = baseRest(function(arrays) {
      return baseXor(arrayFilter(arrays, isArrayLikeObject));
    });
    var xorBy = baseRest(function(arrays) {
      var iteratee2 = last(arrays);
      if (isArrayLikeObject(iteratee2)) {
        iteratee2 = void 0;
      }
      return baseXor(arrayFilter(arrays, isArrayLikeObject), baseIteratee(iteratee2));
    });
    var xorWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == "function" ? comparator : void 0;
      return baseXor(arrayFilter(arrays, isArrayLikeObject), void 0, comparator);
    });
    var zip = baseRest(unzip);
    function baseZipObject(props, values2, assignFunc) {
      var index = -1, length = props.length, valsLength = values2.length, result2 = {};
      while (++index < length) {
        var value = index < valsLength ? values2[index] : void 0;
        assignFunc(result2, props[index], value);
      }
      return result2;
    }
    function zipObject(props, values2) {
      return baseZipObject(props || [], values2 || [], assignValue);
    }
    function zipObjectDeep(props, values2) {
      return baseZipObject(props || [], values2 || [], baseSet);
    }
    var zipWith = baseRest(function(arrays) {
      var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : void 0;
      iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : void 0;
      return unzipWith(arrays, iteratee2);
    });
    const array = {
      chunk,
      compact,
      concat,
      difference,
      differenceBy,
      differenceWith,
      drop,
      dropRight,
      dropRightWhile,
      dropWhile,
      fill,
      findIndex,
      findLastIndex,
      first: head,
      flatten,
      flattenDeep,
      flattenDepth,
      fromPairs,
      head,
      indexOf: indexOf$1,
      initial,
      intersection,
      intersectionBy,
      intersectionWith,
      join,
      last,
      lastIndexOf,
      nth,
      pull,
      pullAll,
      pullAllBy,
      pullAllWith,
      pullAt,
      remove: remove$2,
      reverse,
      slice,
      sortedIndex,
      sortedIndexBy,
      sortedIndexOf,
      sortedLastIndex,
      sortedLastIndexBy,
      sortedLastIndexOf,
      sortedUniq,
      sortedUniqBy,
      tail,
      take,
      takeRight,
      takeRightWhile,
      takeWhile,
      union,
      unionBy,
      unionWith,
      uniq,
      uniqBy,
      uniqWith,
      unzip,
      unzipWith,
      without,
      xor,
      xorBy,
      xorWith,
      zip,
      zipObject,
      zipObjectDeep,
      zipWith
    };
    const collection = {
      countBy,
      each: forEach,
      eachRight: forEachRight,
      every,
      filter,
      find,
      findLast,
      flatMap,
      flatMapDeep,
      flatMapDepth,
      forEach,
      forEachRight,
      groupBy,
      includes,
      invokeMap,
      keyBy,
      map,
      orderBy,
      partition,
      reduce,
      reduceRight,
      reject,
      sample,
      sampleSize,
      shuffle,
      size,
      some,
      sortBy
    };
    const date = {
      now: now$1
    };
    const func = {
      after,
      ary,
      before,
      bind,
      bindKey,
      curry,
      curryRight,
      debounce: debounce$1,
      defer,
      delay: delay$1,
      flip: flip$3,
      memoize,
      negate,
      once,
      overArgs,
      partial,
      partialRight,
      rearg,
      rest,
      spread,
      throttle,
      unary,
      wrap: wrap$1
    };
    const lang = {
      castArray,
      clone: clone$1,
      cloneDeep,
      cloneDeepWith,
      cloneWith,
      conformsTo,
      eq,
      gt: gt$2,
      gte,
      isArguments,
      isArray,
      isArrayBuffer,
      isArrayLike,
      isArrayLikeObject,
      isBoolean,
      isBuffer,
      isDate,
      isElement: isElement$3,
      isEmpty,
      isEqual,
      isEqualWith,
      isError,
      isFinite: isFinite$1,
      isFunction,
      isInteger,
      isLength,
      isMap,
      isMatch,
      isMatchWith,
      isNaN: isNaN$1,
      isNative,
      isNil,
      isNull,
      isNumber,
      isObject: isObject$3,
      isObjectLike,
      isPlainObject: isPlainObject$2,
      isRegExp,
      isSafeInteger,
      isSet,
      isString,
      isSymbol,
      isTypedArray,
      isUndefined,
      isWeakMap,
      isWeakSet,
      lt: lt$2,
      lte,
      toArray: toArray$3,
      toFinite,
      toInteger,
      toLength,
      toNumber,
      toPlainObject,
      toSafeInteger,
      toString: toString$1
    };
    const math = {
      add,
      ceil,
      divide,
      floor,
      max: max$1,
      maxBy,
      mean,
      meanBy,
      min: min$1,
      minBy,
      multiply,
      round: round$1,
      subtract,
      sum,
      sumBy
    };
    const number = {
      clamp,
      inRange,
      random
    };
    const object = {
      assign: assign$2,
      assignIn,
      assignInWith,
      assignWith,
      at: at$1,
      create,
      defaults: defaults$1,
      defaultsDeep,
      entries: toPairs,
      entriesIn: toPairsIn,
      extend: assignIn,
      extendWith: assignInWith,
      findKey,
      findLastKey,
      forIn,
      forInRight,
      forOwn,
      forOwnRight,
      functions,
      functionsIn,
      get,
      has,
      hasIn,
      invert,
      invertBy,
      invoke,
      keys,
      keysIn,
      mapKeys,
      mapValues,
      merge: merge$1,
      mergeWith,
      omit,
      omitBy,
      pick,
      pickBy,
      result,
      set: set$1,
      setWith,
      toPairs,
      toPairsIn,
      transform: transform$3,
      unset,
      update,
      updateWith,
      values,
      valuesIn
    };
    const seq = {
      at: wrapperAt,
      chain,
      commit: wrapperCommit,
      lodash: lodash$1,
      next: wrapperNext,
      plant: wrapperPlant,
      reverse: wrapperReverse,
      tap,
      thru,
      toIterator: wrapperToIterator,
      toJSON: wrapperValue,
      value: wrapperValue,
      valueOf: wrapperValue,
      wrapperChain
    };
    const string = {
      camelCase,
      capitalize,
      deburr,
      endsWith,
      escape: escape$1,
      escapeRegExp,
      kebabCase,
      lowerCase,
      lowerFirst,
      pad,
      padEnd,
      padStart,
      parseInt: parseInt$1,
      repeat,
      replace,
      snakeCase,
      split,
      startCase,
      startsWith,
      template,
      templateSettings,
      toLower,
      toUpper,
      trim,
      trimEnd,
      trimStart,
      truncate,
      unescape: unescape$1,
      upperCase,
      upperFirst,
      words
    };
    const util = {
      attempt,
      bindAll,
      cond,
      conforms,
      constant,
      defaultTo,
      flow,
      flowRight,
      identity,
      iteratee,
      matches,
      matchesProperty,
      method,
      methodOf,
      mixin: mixin$1,
      noop: noop$2,
      nthArg,
      over,
      overEvery,
      overSome,
      property,
      propertyOf,
      range,
      rangeRight,
      stubArray,
      stubFalse,
      stubObject,
      stubString,
      stubTrue,
      times,
      toPath: toPath$1,
      uniqueId
    };
    function lazyClone() {
      var result2 = new LazyWrapper(this.__wrapped__);
      result2.__actions__ = copyArray(this.__actions__);
      result2.__dir__ = this.__dir__;
      result2.__filtered__ = this.__filtered__;
      result2.__iteratees__ = copyArray(this.__iteratees__);
      result2.__takeCount__ = this.__takeCount__;
      result2.__views__ = copyArray(this.__views__);
      return result2;
    }
    function lazyReverse() {
      if (this.__filtered__) {
        var result2 = new LazyWrapper(this);
        result2.__dir__ = -1;
        result2.__filtered__ = true;
      } else {
        result2 = this.clone();
        result2.__dir__ *= -1;
      }
      return result2;
    }
    var nativeMax$1 = Math.max, nativeMin$2 = Math.min;
    function getView(start2, end2, transforms) {
      var index = -1, length = transforms.length;
      while (++index < length) {
        var data = transforms[index], size2 = data.size;
        switch (data.type) {
          case "drop":
            start2 += size2;
            break;
          case "dropRight":
            end2 -= size2;
            break;
          case "take":
            end2 = nativeMin$2(end2, start2 + size2);
            break;
          case "takeRight":
            start2 = nativeMax$1(start2, end2 - size2);
            break;
        }
      }
      return { "start": start2, "end": end2 };
    }
    var LAZY_FILTER_FLAG$1 = 1, LAZY_MAP_FLAG = 2;
    var nativeMin$1 = Math.min;
    function lazyValue() {
      var array2 = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array2), isRight = dir < 0, arrLength = isArr ? array2.length : 0, view = getView(0, arrLength, this.__views__), start2 = view.start, end2 = view.end, length = end2 - start2, index = isRight ? end2 : start2 - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin$1(length, this.__takeCount__);
      if (!isArr || !isRight && arrLength == length && takeCount == length) {
        return baseWrapperValue(array2, this.__actions__);
      }
      var result2 = [];
      outer:
        while (length-- && resIndex < takeCount) {
          index += dir;
          var iterIndex = -1, value = array2[index];
          while (++iterIndex < iterLength) {
            var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed2 = iteratee2(value);
            if (type == LAZY_MAP_FLAG) {
              value = computed2;
            } else if (!computed2) {
              if (type == LAZY_FILTER_FLAG$1) {
                continue outer;
              } else {
                break outer;
              }
            }
          }
          result2[resIndex++] = value;
        }
      return result2;
    }
    /**
     * @license
     * Lodash (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="es" -o ./`
     * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
     * Released under MIT license <https://lodash.com/license>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     */
    var VERSION = "4.17.21";
    var WRAP_BIND_KEY_FLAG = 2;
    var LAZY_FILTER_FLAG = 1, LAZY_WHILE_FLAG = 3;
    var MAX_ARRAY_LENGTH = 4294967295;
    var arrayProto = Array.prototype, objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var symIterator = Symbol$1 ? Symbol$1.iterator : void 0;
    var nativeMax = Math.max, nativeMin = Math.min;
    var mixin = /* @__PURE__ */ function(func2) {
      return function(object2, source, options) {
        if (options == null) {
          var isObj = isObject$3(source), props = isObj && keys(source), methodNames = props && props.length && baseFunctions(source, props);
          if (!(methodNames ? methodNames.length : isObj)) {
            options = source;
            source = object2;
            object2 = this;
          }
        }
        return func2(object2, source, options);
      };
    }(mixin$1);
    lodash$1.after = func.after;
    lodash$1.ary = func.ary;
    lodash$1.assign = object.assign;
    lodash$1.assignIn = object.assignIn;
    lodash$1.assignInWith = object.assignInWith;
    lodash$1.assignWith = object.assignWith;
    lodash$1.at = object.at;
    lodash$1.before = func.before;
    lodash$1.bind = func.bind;
    lodash$1.bindAll = util.bindAll;
    lodash$1.bindKey = func.bindKey;
    lodash$1.castArray = lang.castArray;
    lodash$1.chain = seq.chain;
    lodash$1.chunk = array.chunk;
    lodash$1.compact = array.compact;
    lodash$1.concat = array.concat;
    lodash$1.cond = util.cond;
    lodash$1.conforms = util.conforms;
    lodash$1.constant = util.constant;
    lodash$1.countBy = collection.countBy;
    lodash$1.create = object.create;
    lodash$1.curry = func.curry;
    lodash$1.curryRight = func.curryRight;
    lodash$1.debounce = func.debounce;
    lodash$1.defaults = object.defaults;
    lodash$1.defaultsDeep = object.defaultsDeep;
    lodash$1.defer = func.defer;
    lodash$1.delay = func.delay;
    lodash$1.difference = array.difference;
    lodash$1.differenceBy = array.differenceBy;
    lodash$1.differenceWith = array.differenceWith;
    lodash$1.drop = array.drop;
    lodash$1.dropRight = array.dropRight;
    lodash$1.dropRightWhile = array.dropRightWhile;
    lodash$1.dropWhile = array.dropWhile;
    lodash$1.fill = array.fill;
    lodash$1.filter = collection.filter;
    lodash$1.flatMap = collection.flatMap;
    lodash$1.flatMapDeep = collection.flatMapDeep;
    lodash$1.flatMapDepth = collection.flatMapDepth;
    lodash$1.flatten = array.flatten;
    lodash$1.flattenDeep = array.flattenDeep;
    lodash$1.flattenDepth = array.flattenDepth;
    lodash$1.flip = func.flip;
    lodash$1.flow = util.flow;
    lodash$1.flowRight = util.flowRight;
    lodash$1.fromPairs = array.fromPairs;
    lodash$1.functions = object.functions;
    lodash$1.functionsIn = object.functionsIn;
    lodash$1.groupBy = collection.groupBy;
    lodash$1.initial = array.initial;
    lodash$1.intersection = array.intersection;
    lodash$1.intersectionBy = array.intersectionBy;
    lodash$1.intersectionWith = array.intersectionWith;
    lodash$1.invert = object.invert;
    lodash$1.invertBy = object.invertBy;
    lodash$1.invokeMap = collection.invokeMap;
    lodash$1.iteratee = util.iteratee;
    lodash$1.keyBy = collection.keyBy;
    lodash$1.keys = keys;
    lodash$1.keysIn = object.keysIn;
    lodash$1.map = collection.map;
    lodash$1.mapKeys = object.mapKeys;
    lodash$1.mapValues = object.mapValues;
    lodash$1.matches = util.matches;
    lodash$1.matchesProperty = util.matchesProperty;
    lodash$1.memoize = func.memoize;
    lodash$1.merge = object.merge;
    lodash$1.mergeWith = object.mergeWith;
    lodash$1.method = util.method;
    lodash$1.methodOf = util.methodOf;
    lodash$1.mixin = mixin;
    lodash$1.negate = negate;
    lodash$1.nthArg = util.nthArg;
    lodash$1.omit = object.omit;
    lodash$1.omitBy = object.omitBy;
    lodash$1.once = func.once;
    lodash$1.orderBy = collection.orderBy;
    lodash$1.over = util.over;
    lodash$1.overArgs = func.overArgs;
    lodash$1.overEvery = util.overEvery;
    lodash$1.overSome = util.overSome;
    lodash$1.partial = func.partial;
    lodash$1.partialRight = func.partialRight;
    lodash$1.partition = collection.partition;
    lodash$1.pick = object.pick;
    lodash$1.pickBy = object.pickBy;
    lodash$1.property = util.property;
    lodash$1.propertyOf = util.propertyOf;
    lodash$1.pull = array.pull;
    lodash$1.pullAll = array.pullAll;
    lodash$1.pullAllBy = array.pullAllBy;
    lodash$1.pullAllWith = array.pullAllWith;
    lodash$1.pullAt = array.pullAt;
    lodash$1.range = util.range;
    lodash$1.rangeRight = util.rangeRight;
    lodash$1.rearg = func.rearg;
    lodash$1.reject = collection.reject;
    lodash$1.remove = array.remove;
    lodash$1.rest = func.rest;
    lodash$1.reverse = array.reverse;
    lodash$1.sampleSize = collection.sampleSize;
    lodash$1.set = object.set;
    lodash$1.setWith = object.setWith;
    lodash$1.shuffle = collection.shuffle;
    lodash$1.slice = array.slice;
    lodash$1.sortBy = collection.sortBy;
    lodash$1.sortedUniq = array.sortedUniq;
    lodash$1.sortedUniqBy = array.sortedUniqBy;
    lodash$1.split = string.split;
    lodash$1.spread = func.spread;
    lodash$1.tail = array.tail;
    lodash$1.take = array.take;
    lodash$1.takeRight = array.takeRight;
    lodash$1.takeRightWhile = array.takeRightWhile;
    lodash$1.takeWhile = array.takeWhile;
    lodash$1.tap = seq.tap;
    lodash$1.throttle = func.throttle;
    lodash$1.thru = thru;
    lodash$1.toArray = lang.toArray;
    lodash$1.toPairs = object.toPairs;
    lodash$1.toPairsIn = object.toPairsIn;
    lodash$1.toPath = util.toPath;
    lodash$1.toPlainObject = lang.toPlainObject;
    lodash$1.transform = object.transform;
    lodash$1.unary = func.unary;
    lodash$1.union = array.union;
    lodash$1.unionBy = array.unionBy;
    lodash$1.unionWith = array.unionWith;
    lodash$1.uniq = array.uniq;
    lodash$1.uniqBy = array.uniqBy;
    lodash$1.uniqWith = array.uniqWith;
    lodash$1.unset = object.unset;
    lodash$1.unzip = array.unzip;
    lodash$1.unzipWith = array.unzipWith;
    lodash$1.update = object.update;
    lodash$1.updateWith = object.updateWith;
    lodash$1.values = object.values;
    lodash$1.valuesIn = object.valuesIn;
    lodash$1.without = array.without;
    lodash$1.words = string.words;
    lodash$1.wrap = func.wrap;
    lodash$1.xor = array.xor;
    lodash$1.xorBy = array.xorBy;
    lodash$1.xorWith = array.xorWith;
    lodash$1.zip = array.zip;
    lodash$1.zipObject = array.zipObject;
    lodash$1.zipObjectDeep = array.zipObjectDeep;
    lodash$1.zipWith = array.zipWith;
    lodash$1.entries = object.toPairs;
    lodash$1.entriesIn = object.toPairsIn;
    lodash$1.extend = object.assignIn;
    lodash$1.extendWith = object.assignInWith;
    mixin(lodash$1, lodash$1);
    lodash$1.add = math.add;
    lodash$1.attempt = util.attempt;
    lodash$1.camelCase = string.camelCase;
    lodash$1.capitalize = string.capitalize;
    lodash$1.ceil = math.ceil;
    lodash$1.clamp = number.clamp;
    lodash$1.clone = lang.clone;
    lodash$1.cloneDeep = lang.cloneDeep;
    lodash$1.cloneDeepWith = lang.cloneDeepWith;
    lodash$1.cloneWith = lang.cloneWith;
    lodash$1.conformsTo = lang.conformsTo;
    lodash$1.deburr = string.deburr;
    lodash$1.defaultTo = util.defaultTo;
    lodash$1.divide = math.divide;
    lodash$1.endsWith = string.endsWith;
    lodash$1.eq = lang.eq;
    lodash$1.escape = string.escape;
    lodash$1.escapeRegExp = string.escapeRegExp;
    lodash$1.every = collection.every;
    lodash$1.find = collection.find;
    lodash$1.findIndex = array.findIndex;
    lodash$1.findKey = object.findKey;
    lodash$1.findLast = collection.findLast;
    lodash$1.findLastIndex = array.findLastIndex;
    lodash$1.findLastKey = object.findLastKey;
    lodash$1.floor = math.floor;
    lodash$1.forEach = collection.forEach;
    lodash$1.forEachRight = collection.forEachRight;
    lodash$1.forIn = object.forIn;
    lodash$1.forInRight = object.forInRight;
    lodash$1.forOwn = object.forOwn;
    lodash$1.forOwnRight = object.forOwnRight;
    lodash$1.get = object.get;
    lodash$1.gt = lang.gt;
    lodash$1.gte = lang.gte;
    lodash$1.has = object.has;
    lodash$1.hasIn = object.hasIn;
    lodash$1.head = array.head;
    lodash$1.identity = identity;
    lodash$1.includes = collection.includes;
    lodash$1.indexOf = array.indexOf;
    lodash$1.inRange = number.inRange;
    lodash$1.invoke = object.invoke;
    lodash$1.isArguments = lang.isArguments;
    lodash$1.isArray = isArray;
    lodash$1.isArrayBuffer = lang.isArrayBuffer;
    lodash$1.isArrayLike = lang.isArrayLike;
    lodash$1.isArrayLikeObject = lang.isArrayLikeObject;
    lodash$1.isBoolean = lang.isBoolean;
    lodash$1.isBuffer = lang.isBuffer;
    lodash$1.isDate = lang.isDate;
    lodash$1.isElement = lang.isElement;
    lodash$1.isEmpty = lang.isEmpty;
    lodash$1.isEqual = lang.isEqual;
    lodash$1.isEqualWith = lang.isEqualWith;
    lodash$1.isError = lang.isError;
    lodash$1.isFinite = lang.isFinite;
    lodash$1.isFunction = lang.isFunction;
    lodash$1.isInteger = lang.isInteger;
    lodash$1.isLength = lang.isLength;
    lodash$1.isMap = lang.isMap;
    lodash$1.isMatch = lang.isMatch;
    lodash$1.isMatchWith = lang.isMatchWith;
    lodash$1.isNaN = lang.isNaN;
    lodash$1.isNative = lang.isNative;
    lodash$1.isNil = lang.isNil;
    lodash$1.isNull = lang.isNull;
    lodash$1.isNumber = lang.isNumber;
    lodash$1.isObject = isObject$3;
    lodash$1.isObjectLike = lang.isObjectLike;
    lodash$1.isPlainObject = lang.isPlainObject;
    lodash$1.isRegExp = lang.isRegExp;
    lodash$1.isSafeInteger = lang.isSafeInteger;
    lodash$1.isSet = lang.isSet;
    lodash$1.isString = lang.isString;
    lodash$1.isSymbol = lang.isSymbol;
    lodash$1.isTypedArray = lang.isTypedArray;
    lodash$1.isUndefined = lang.isUndefined;
    lodash$1.isWeakMap = lang.isWeakMap;
    lodash$1.isWeakSet = lang.isWeakSet;
    lodash$1.join = array.join;
    lodash$1.kebabCase = string.kebabCase;
    lodash$1.last = last;
    lodash$1.lastIndexOf = array.lastIndexOf;
    lodash$1.lowerCase = string.lowerCase;
    lodash$1.lowerFirst = string.lowerFirst;
    lodash$1.lt = lang.lt;
    lodash$1.lte = lang.lte;
    lodash$1.max = math.max;
    lodash$1.maxBy = math.maxBy;
    lodash$1.mean = math.mean;
    lodash$1.meanBy = math.meanBy;
    lodash$1.min = math.min;
    lodash$1.minBy = math.minBy;
    lodash$1.stubArray = util.stubArray;
    lodash$1.stubFalse = util.stubFalse;
    lodash$1.stubObject = util.stubObject;
    lodash$1.stubString = util.stubString;
    lodash$1.stubTrue = util.stubTrue;
    lodash$1.multiply = math.multiply;
    lodash$1.nth = array.nth;
    lodash$1.noop = util.noop;
    lodash$1.now = date.now;
    lodash$1.pad = string.pad;
    lodash$1.padEnd = string.padEnd;
    lodash$1.padStart = string.padStart;
    lodash$1.parseInt = string.parseInt;
    lodash$1.random = number.random;
    lodash$1.reduce = collection.reduce;
    lodash$1.reduceRight = collection.reduceRight;
    lodash$1.repeat = string.repeat;
    lodash$1.replace = string.replace;
    lodash$1.result = object.result;
    lodash$1.round = math.round;
    lodash$1.sample = collection.sample;
    lodash$1.size = collection.size;
    lodash$1.snakeCase = string.snakeCase;
    lodash$1.some = collection.some;
    lodash$1.sortedIndex = array.sortedIndex;
    lodash$1.sortedIndexBy = array.sortedIndexBy;
    lodash$1.sortedIndexOf = array.sortedIndexOf;
    lodash$1.sortedLastIndex = array.sortedLastIndex;
    lodash$1.sortedLastIndexBy = array.sortedLastIndexBy;
    lodash$1.sortedLastIndexOf = array.sortedLastIndexOf;
    lodash$1.startCase = string.startCase;
    lodash$1.startsWith = string.startsWith;
    lodash$1.subtract = math.subtract;
    lodash$1.sum = math.sum;
    lodash$1.sumBy = math.sumBy;
    lodash$1.template = string.template;
    lodash$1.times = util.times;
    lodash$1.toFinite = lang.toFinite;
    lodash$1.toInteger = toInteger;
    lodash$1.toLength = lang.toLength;
    lodash$1.toLower = string.toLower;
    lodash$1.toNumber = lang.toNumber;
    lodash$1.toSafeInteger = lang.toSafeInteger;
    lodash$1.toString = lang.toString;
    lodash$1.toUpper = string.toUpper;
    lodash$1.trim = string.trim;
    lodash$1.trimEnd = string.trimEnd;
    lodash$1.trimStart = string.trimStart;
    lodash$1.truncate = string.truncate;
    lodash$1.unescape = string.unescape;
    lodash$1.uniqueId = util.uniqueId;
    lodash$1.upperCase = string.upperCase;
    lodash$1.upperFirst = string.upperFirst;
    lodash$1.each = collection.forEach;
    lodash$1.eachRight = collection.forEachRight;
    lodash$1.first = array.head;
    mixin(lodash$1, function() {
      var source = {};
      baseForOwn(lodash$1, function(func2, methodName) {
        if (!hasOwnProperty.call(lodash$1.prototype, methodName)) {
          source[methodName] = func2;
        }
      });
      return source;
    }(), { "chain": false });
    lodash$1.VERSION = VERSION;
    (lodash$1.templateSettings = string.templateSettings).imports._ = lodash$1;
    arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
      lodash$1[methodName].placeholder = lodash$1;
    });
    arrayEach(["drop", "take"], function(methodName, index) {
      LazyWrapper.prototype[methodName] = function(n2) {
        n2 = n2 === void 0 ? 1 : nativeMax(toInteger(n2), 0);
        var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
        if (result2.__filtered__) {
          result2.__takeCount__ = nativeMin(n2, result2.__takeCount__);
        } else {
          result2.__views__.push({
            "size": nativeMin(n2, MAX_ARRAY_LENGTH),
            "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
          });
        }
        return result2;
      };
      LazyWrapper.prototype[methodName + "Right"] = function(n2) {
        return this.reverse()[methodName](n2).reverse();
      };
    });
    arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
      var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
      LazyWrapper.prototype[methodName] = function(iteratee2) {
        var result2 = this.clone();
        result2.__iteratees__.push({
          "iteratee": baseIteratee(iteratee2),
          "type": type
        });
        result2.__filtered__ = result2.__filtered__ || isFilter;
        return result2;
      };
    });
    arrayEach(["head", "last"], function(methodName, index) {
      var takeName = "take" + (index ? "Right" : "");
      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });
    arrayEach(["initial", "tail"], function(methodName, index) {
      var dropName = "drop" + (index ? "" : "Right");
      LazyWrapper.prototype[methodName] = function() {
        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
      };
    });
    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };
    LazyWrapper.prototype.find = function(predicate) {
      return this.filter(predicate).head();
    };
    LazyWrapper.prototype.findLast = function(predicate) {
      return this.reverse().find(predicate);
    };
    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
      if (typeof path == "function") {
        return new LazyWrapper(this);
      }
      return this.map(function(value) {
        return baseInvoke(value, path, args);
      });
    });
    LazyWrapper.prototype.reject = function(predicate) {
      return this.filter(negate(baseIteratee(predicate)));
    };
    LazyWrapper.prototype.slice = function(start2, end2) {
      start2 = toInteger(start2);
      var result2 = this;
      if (result2.__filtered__ && (start2 > 0 || end2 < 0)) {
        return new LazyWrapper(result2);
      }
      if (start2 < 0) {
        result2 = result2.takeRight(-start2);
      } else if (start2) {
        result2 = result2.drop(start2);
      }
      if (end2 !== void 0) {
        end2 = toInteger(end2);
        result2 = end2 < 0 ? result2.dropRight(-end2) : result2.take(end2 - start2);
      }
      return result2;
    };
    LazyWrapper.prototype.takeRightWhile = function(predicate) {
      return this.reverse().takeWhile(predicate).reverse();
    };
    LazyWrapper.prototype.toArray = function() {
      return this.take(MAX_ARRAY_LENGTH);
    };
    baseForOwn(LazyWrapper.prototype, function(func2, methodName) {
      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash$1[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
      if (!lodashFunc) {
        return;
      }
      lodash$1.prototype[methodName] = function() {
        var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
        var interceptor = function(value2) {
          var result3 = lodashFunc.apply(lodash$1, arrayPush([value2], args));
          return isTaker && chainAll ? result3[0] : result3;
        };
        if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
          isLazy = useLazy = false;
        }
        var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
        if (!retUnwrapped && useLazy) {
          value = onlyLazy ? value : new LazyWrapper(this);
          var result2 = func2.apply(value, args);
          result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": void 0 });
          return new LodashWrapper(result2, chainAll);
        }
        if (isUnwrapped && onlyLazy) {
          return func2.apply(this, args);
        }
        result2 = this.thru(interceptor);
        return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
      };
    });
    arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
      var func2 = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
      lodash$1.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          var value = this.value();
          return func2.apply(isArray(value) ? value : [], args);
        }
        return this[chainName](function(value2) {
          return func2.apply(isArray(value2) ? value2 : [], args);
        });
      };
    });
    baseForOwn(LazyWrapper.prototype, function(func2, methodName) {
      var lodashFunc = lodash$1[methodName];
      if (lodashFunc) {
        var key = lodashFunc.name + "";
        if (!hasOwnProperty.call(realNames, key)) {
          realNames[key] = [];
        }
        realNames[key].push({ "name": methodName, "func": lodashFunc });
      }
    });
    realNames[createHybrid(void 0, WRAP_BIND_KEY_FLAG).name] = [{
      "name": "wrapper",
      "func": void 0
    }];
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;
    lodash$1.prototype.at = seq.at;
    lodash$1.prototype.chain = seq.wrapperChain;
    lodash$1.prototype.commit = seq.commit;
    lodash$1.prototype.next = seq.next;
    lodash$1.prototype.plant = seq.plant;
    lodash$1.prototype.reverse = seq.reverse;
    lodash$1.prototype.toJSON = lodash$1.prototype.valueOf = lodash$1.prototype.value = seq.value;
    lodash$1.prototype.first = lodash$1.prototype.head;
    if (symIterator) {
      lodash$1.prototype[symIterator] = seq.toIterator;
    }
    /**
     * @license
     * Lodash (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="es" -o ./`
     * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
     * Released under MIT license <https://lodash.com/license>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     */
    const lodash = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      add,
      after,
      ary,
      assign: assign$2,
      assignIn,
      assignInWith,
      assignWith,
      at: at$1,
      attempt,
      before,
      bind,
      bindAll,
      bindKey,
      camelCase,
      capitalize,
      castArray,
      ceil,
      chain,
      chunk,
      clamp,
      clone: clone$1,
      cloneDeep,
      cloneDeepWith,
      cloneWith,
      commit: wrapperCommit,
      compact,
      concat,
      cond,
      conforms,
      conformsTo,
      constant,
      countBy,
      create,
      curry,
      curryRight,
      debounce: debounce$1,
      deburr,
      default: lodash$1,
      defaultTo,
      defaults: defaults$1,
      defaultsDeep,
      defer,
      delay: delay$1,
      difference,
      differenceBy,
      differenceWith,
      divide,
      drop,
      dropRight,
      dropRightWhile,
      dropWhile,
      each: forEach,
      eachRight: forEachRight,
      endsWith,
      entries: toPairs,
      entriesIn: toPairsIn,
      eq,
      escape: escape$1,
      escapeRegExp,
      every,
      extend: assignIn,
      extendWith: assignInWith,
      fill,
      filter,
      find,
      findIndex,
      findKey,
      findLast,
      findLastIndex,
      findLastKey,
      first: head,
      flatMap,
      flatMapDeep,
      flatMapDepth,
      flatten,
      flattenDeep,
      flattenDepth,
      flip: flip$3,
      floor,
      flow,
      flowRight,
      forEach,
      forEachRight,
      forIn,
      forInRight,
      forOwn,
      forOwnRight,
      fromPairs,
      functions,
      functionsIn,
      get,
      groupBy,
      gt: gt$2,
      gte,
      has,
      hasIn,
      head,
      identity,
      inRange,
      includes,
      indexOf: indexOf$1,
      initial,
      intersection,
      intersectionBy,
      intersectionWith,
      invert,
      invertBy,
      invoke,
      invokeMap,
      isArguments,
      isArray,
      isArrayBuffer,
      isArrayLike,
      isArrayLikeObject,
      isBoolean,
      isBuffer,
      isDate,
      isElement: isElement$3,
      isEmpty,
      isEqual,
      isEqualWith,
      isError,
      isFinite: isFinite$1,
      isFunction,
      isInteger,
      isLength,
      isMap,
      isMatch,
      isMatchWith,
      isNaN: isNaN$1,
      isNative,
      isNil,
      isNull,
      isNumber,
      isObject: isObject$3,
      isObjectLike,
      isPlainObject: isPlainObject$2,
      isRegExp,
      isSafeInteger,
      isSet,
      isString,
      isSymbol,
      isTypedArray,
      isUndefined,
      isWeakMap,
      isWeakSet,
      iteratee,
      join,
      kebabCase,
      keyBy,
      keys,
      keysIn,
      last,
      lastIndexOf,
      lodash: lodash$1,
      lowerCase,
      lowerFirst,
      lt: lt$2,
      lte,
      map,
      mapKeys,
      mapValues,
      matches,
      matchesProperty,
      max: max$1,
      maxBy,
      mean,
      meanBy,
      memoize,
      merge: merge$1,
      mergeWith,
      method,
      methodOf,
      min: min$1,
      minBy,
      mixin: mixin$1,
      multiply,
      negate,
      next: wrapperNext,
      noop: noop$2,
      now: now$1,
      nth,
      nthArg,
      omit,
      omitBy,
      once,
      orderBy,
      over,
      overArgs,
      overEvery,
      overSome,
      pad,
      padEnd,
      padStart,
      parseInt: parseInt$1,
      partial,
      partialRight,
      partition,
      pick,
      pickBy,
      plant: wrapperPlant,
      property,
      propertyOf,
      pull,
      pullAll,
      pullAllBy,
      pullAllWith,
      pullAt,
      random,
      range,
      rangeRight,
      rearg,
      reduce,
      reduceRight,
      reject,
      remove: remove$2,
      repeat,
      replace,
      rest,
      result,
      reverse,
      round: round$1,
      sample,
      sampleSize,
      set: set$1,
      setWith,
      shuffle,
      size,
      slice,
      snakeCase,
      some,
      sortBy,
      sortedIndex,
      sortedIndexBy,
      sortedIndexOf,
      sortedLastIndex,
      sortedLastIndexBy,
      sortedLastIndexOf,
      sortedUniq,
      sortedUniqBy,
      split,
      spread,
      startCase,
      startsWith,
      stubArray,
      stubFalse,
      stubObject,
      stubString,
      stubTrue,
      subtract,
      sum,
      sumBy,
      tail,
      take,
      takeRight,
      takeRightWhile,
      takeWhile,
      tap,
      template,
      templateSettings,
      throttle,
      thru,
      times,
      toArray: toArray$3,
      toFinite,
      toInteger,
      toIterator: wrapperToIterator,
      toJSON: wrapperValue,
      toLength,
      toLower,
      toNumber,
      toPairs,
      toPairsIn,
      toPath: toPath$1,
      toPlainObject,
      toSafeInteger,
      toString: toString$1,
      toUpper,
      transform: transform$3,
      trim,
      trimEnd,
      trimStart,
      truncate,
      unary,
      unescape: unescape$1,
      union,
      unionBy,
      unionWith,
      uniq,
      uniqBy,
      uniqWith,
      uniqueId,
      unset,
      unzip,
      unzipWith,
      update,
      updateWith,
      upperCase,
      upperFirst,
      value: wrapperValue,
      valueOf: wrapperValue,
      values,
      valuesIn,
      without,
      words,
      wrap: wrap$1,
      wrapperAt,
      wrapperChain,
      wrapperCommit,
      wrapperLodash: lodash$1,
      wrapperNext,
      wrapperPlant,
      wrapperReverse,
      wrapperToIterator,
      wrapperValue,
      xor,
      xorBy,
      xorWith,
      zip,
      zipObject,
      zipObjectDeep,
      zipWith
    }, Symbol.toStringTag, { value: "Module" }));
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    let globalVar;
    try {
      globalVar = {
        window,
        document
      };
    } catch (e2) {
      /* istanbul ignore next -- @preserve */
      globalVar = {
        window: {},
        document: {}
      };
    }
    var global$1 = globalVar;
    function getUserAgent() {
      try {
        return navigator.userAgent.toLowerCase();
      } catch (e2) {
        return "";
      }
    }
    const userAgent = /* @__PURE__ */ getUserAgent();
    const env = {
      isMac: /* @__PURE__ */ isMac(userAgent),
      isWindows: /* @__PURE__ */ isWindows(userAgent),
      isGecko: /* @__PURE__ */ isGecko(userAgent),
      isSafari: /* @__PURE__ */ isSafari(userAgent),
      isiOS: /* @__PURE__ */ isiOS(userAgent),
      isAndroid: /* @__PURE__ */ isAndroid(userAgent),
      isBlink: /* @__PURE__ */ isBlink(userAgent),
      get isMediaForcedColors() {
        return isMediaForcedColors();
      },
      get isMotionReduced() {
        return isMotionReduced();
      },
      features: {
        isRegExpUnicodePropertySupported: /* @__PURE__ */ isRegExpUnicodePropertySupported()
      }
    };
    function isMac(userAgent2) {
      return userAgent2.indexOf("macintosh") > -1;
    }
    function isWindows(userAgent2) {
      return userAgent2.indexOf("windows") > -1;
    }
    function isGecko(userAgent2) {
      return !!userAgent2.match(/gecko\/\d+/);
    }
    function isSafari(userAgent2) {
      return userAgent2.indexOf(" applewebkit/") > -1 && userAgent2.indexOf("chrome") === -1;
    }
    function isiOS(userAgent2) {
      return !!userAgent2.match(/iphone|ipad/i) || isMac(userAgent2) && navigator.maxTouchPoints > 0;
    }
    function isAndroid(userAgent2) {
      return userAgent2.indexOf("android") > -1;
    }
    function isBlink(userAgent2) {
      return userAgent2.indexOf("chrome/") > -1 && userAgent2.indexOf("edge/") < 0;
    }
    function isRegExpUnicodePropertySupported() {
      let isSupported = false;
      try {
        isSupported = "".search(new RegExp("[\\p{L}]", "u")) === 0;
      } catch (error) {
      }
      return isSupported;
    }
    function isMediaForcedColors() {
      return global$1.window.matchMedia ? global$1.window.matchMedia("(forced-colors: active)").matches : false;
    }
    function isMotionReduced() {
      return global$1.window.matchMedia ? global$1.window.matchMedia("(prefers-reduced-motion)").matches : false;
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function fastDiff(a2, b2, cmp, atomicChanges) {
      cmp = cmp || function(a3, b3) {
        return a3 === b3;
      };
      const arrayA = Array.isArray(a2) ? a2 : Array.prototype.slice.call(a2);
      const arrayB = Array.isArray(b2) ? b2 : Array.prototype.slice.call(b2);
      const changeIndexes = findChangeBoundaryIndexes(arrayA, arrayB, cmp);
      const result2 = atomicChanges ? changeIndexesToAtomicChanges(changeIndexes, arrayB.length) : changeIndexesToChanges(arrayB, changeIndexes);
      return result2;
    }
    function findChangeBoundaryIndexes(arr1, arr2, cmp) {
      const firstIndex = findFirstDifferenceIndex(arr1, arr2, cmp);
      if (firstIndex === -1) {
        return {
          firstIndex: -1,
          lastIndexOld: -1,
          lastIndexNew: -1
        };
      }
      const oldArrayReversed = cutAndReverse(arr1, firstIndex);
      const newArrayReversed = cutAndReverse(arr2, firstIndex);
      const lastIndex = findFirstDifferenceIndex(oldArrayReversed, newArrayReversed, cmp);
      const lastIndexOld = arr1.length - lastIndex;
      const lastIndexNew = arr2.length - lastIndex;
      return {
        firstIndex,
        lastIndexOld,
        lastIndexNew
      };
    }
    function findFirstDifferenceIndex(arr1, arr2, cmp) {
      for (let i2 = 0; i2 < Math.max(arr1.length, arr2.length); i2++) {
        if (arr1[i2] === void 0 || arr2[i2] === void 0 || !cmp(arr1[i2], arr2[i2])) {
          return i2;
        }
      }
      return -1;
    }
    function cutAndReverse(arr, howMany) {
      return arr.slice(howMany).reverse();
    }
    function changeIndexesToChanges(newArray, changeIndexes) {
      const result2 = [];
      const { firstIndex, lastIndexOld, lastIndexNew } = changeIndexes;
      if (lastIndexNew - firstIndex > 0) {
        result2.push({
          index: firstIndex,
          type: "insert",
          values: newArray.slice(firstIndex, lastIndexNew)
        });
      }
      if (lastIndexOld - firstIndex > 0) {
        result2.push({
          index: firstIndex + (lastIndexNew - firstIndex),
          type: "delete",
          howMany: lastIndexOld - firstIndex
        });
      }
      return result2;
    }
    function changeIndexesToAtomicChanges(changeIndexes, newLength) {
      const { firstIndex, lastIndexOld, lastIndexNew } = changeIndexes;
      if (firstIndex === -1) {
        return Array(newLength).fill("equal");
      }
      let result2 = [];
      if (firstIndex > 0) {
        result2 = result2.concat(Array(firstIndex).fill("equal"));
      }
      if (lastIndexNew - firstIndex > 0) {
        result2 = result2.concat(Array(lastIndexNew - firstIndex).fill("insert"));
      }
      if (lastIndexOld - firstIndex > 0) {
        result2 = result2.concat(Array(lastIndexOld - firstIndex).fill("delete"));
      }
      if (lastIndexNew < newLength) {
        result2 = result2.concat(Array(newLength - lastIndexNew).fill("equal"));
      }
      return result2;
    }
    function diff(a2, b2, cmp) {
      cmp = cmp || function(a3, b3) {
        return a3 === b3;
      };
      const aLength = a2.length;
      const bLength = b2.length;
      if (aLength > 200 || bLength > 200 || aLength + bLength > 300) {
        return diff.fastDiff(a2, b2, cmp, true);
      }
      let _insert2, _delete;
      if (bLength < aLength) {
        const tmp = a2;
        a2 = b2;
        b2 = tmp;
        _insert2 = "delete";
        _delete = "insert";
      } else {
        _insert2 = "insert";
        _delete = "delete";
      }
      const m2 = a2.length;
      const n2 = b2.length;
      const delta = n2 - m2;
      const es2 = {};
      const fp = {};
      function snake(k3) {
        const y1 = (fp[k3 - 1] !== void 0 ? fp[k3 - 1] : -1) + 1;
        const y2 = fp[k3 + 1] !== void 0 ? fp[k3 + 1] : -1;
        const dir = y1 > y2 ? -1 : 1;
        if (es2[k3 + dir]) {
          es2[k3] = es2[k3 + dir].slice(0);
        }
        if (!es2[k3]) {
          es2[k3] = [];
        }
        es2[k3].push(y1 > y2 ? _insert2 : _delete);
        let y3 = Math.max(y1, y2);
        let x2 = y3 - k3;
        while (x2 < m2 && y3 < n2 && cmp(a2[x2], b2[y3])) {
          x2++;
          y3++;
          es2[k3].push("equal");
        }
        return y3;
      }
      let p2 = 0;
      let k2;
      do {
        for (k2 = -p2; k2 < delta; k2++) {
          fp[k2] = snake(k2);
        }
        for (k2 = delta + p2; k2 > delta; k2--) {
          fp[k2] = snake(k2);
        }
        fp[delta] = snake(delta);
        p2++;
      } while (fp[delta] !== n2);
      return es2[delta].slice(1);
    }
    diff.fastDiff = fastDiff;
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function spy() {
      return function spy2() {
        spy2.called = true;
      };
    }
    class EventInfo {
      /**
      * @param source The emitter.
      * @param name The event name.
      */
      constructor(source, name) {
        /**
        * The object that fired the event.
        */
        __publicField(this, "source");
        /**
        * The event name.
        */
        __publicField(this, "name");
        /**
        * Path this event has followed. See {@link module:utils/emittermixin~Emitter#delegate}.
        */
        __publicField(this, "path");
        /**
        * Stops the event emitter to call further callbacks for this event interaction.
        */
        __publicField(this, "stop");
        /**
        * Removes the current callback from future interactions of this event.
        */
        __publicField(this, "off");
        /**
        * The value which will be returned by {@link module:utils/emittermixin~Emitter#fire}.
        *
        * It's `undefined` by default and can be changed by an event listener:
        *
        * ```ts
        * dataController.fire( 'getSelectedContent', ( evt ) => {
        * 	// This listener will make `dataController.fire( 'getSelectedContent' )`
        * 	// always return an empty DocumentFragment.
        * 	evt.return = new DocumentFragment();
        *
        * 	// Make sure no other listeners are executed.
        * 	evt.stop();
        * } );
        * ```
        */
        __publicField(this, "return");
        this.source = source;
        this.name = name;
        this.path = [];
        this.stop = spy();
        this.off = spy();
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    const HEX_NUMBERS = new Array(256).fill("").map((_2, index) => ("0" + index.toString(16)).slice(-2));
    function uid() {
      const [r1, r2, r3, r4] = crypto.getRandomValues(new Uint32Array(4));
      return "e" + HEX_NUMBERS[r1 >> 0 & 255] + HEX_NUMBERS[r1 >> 8 & 255] + HEX_NUMBERS[r1 >> 16 & 255] + HEX_NUMBERS[r1 >> 24 & 255] + HEX_NUMBERS[r2 >> 0 & 255] + HEX_NUMBERS[r2 >> 8 & 255] + HEX_NUMBERS[r2 >> 16 & 255] + HEX_NUMBERS[r2 >> 24 & 255] + HEX_NUMBERS[r3 >> 0 & 255] + HEX_NUMBERS[r3 >> 8 & 255] + HEX_NUMBERS[r3 >> 16 & 255] + HEX_NUMBERS[r3 >> 24 & 255] + HEX_NUMBERS[r4 >> 0 & 255] + HEX_NUMBERS[r4 >> 8 & 255] + HEX_NUMBERS[r4 >> 16 & 255] + HEX_NUMBERS[r4 >> 24 & 255];
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    const priorities = {
      get(priority = "normal") {
        if (typeof priority != "number") {
          return this[priority] || this.normal;
        } else {
          return priority;
        }
      },
      highest: 1e5,
      high: 1e3,
      normal: 0,
      low: -1e3,
      lowest: -1e5
    };
    function insertToPriorityArray(objects, objectToInsert) {
      const priority = priorities.get(objectToInsert.priority);
      for (let i2 = 0; i2 < objects.length; i2++) {
        if (priorities.get(objects[i2].priority) < priority) {
          objects.splice(i2, 0, objectToInsert);
          return;
        }
      }
      objects.push(objectToInsert);
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    const DOCUMENTATION_URL = "https://ckeditor.com/docs/ckeditor5/latest/support/error-codes.html";
    class CKEditorError extends Error {
      /**
      * Creates an instance of the CKEditorError class.
      *
      * @param errorName The error id in an `error-name` format. A link to this error documentation page will be added
      * to the thrown error's `message`.
      * @param context A context of the error by which the {@link module:watchdog/watchdog~Watchdog watchdog}
      * is able to determine which editor crashed. It should be an editor instance or a property connected to it. It can be also
      * a `null` value if the editor should not be restarted in case of the error (e.g. during the editor initialization).
      * The error context should be checked using the `areConnectedThroughProperties( editor, context )` utility
      * to check if the object works as the context.
      * @param data Additional data describing the error. A stringified version of this object
      * will be appended to the error message, so the data are quickly visible in the console. The original
      * data object will also be later available under the {@link #data} property.
      */
      constructor(errorName, context, data) {
        super(getErrorMessage(errorName, data));
        /**
        * A context of the error by which the Watchdog is able to determine which editor crashed.
        */
        __publicField(this, "context");
        /**
        * The additional error data passed to the constructor. Undefined if none was passed.
        */
        __publicField(this, "data");
        this.name = "CKEditorError";
        this.context = context;
        this.data = data;
      }
      /**
      * Checks if the error is of the `CKEditorError` type.
      */
      is(type) {
        return type === "CKEditorError";
      }
      /**
      * A utility that ensures that the thrown error is a {@link module:utils/ckeditorerror~CKEditorError} one.
      * It is useful when combined with the {@link module:watchdog/watchdog~Watchdog} feature, which can restart the editor in case
      * of a {@link module:utils/ckeditorerror~CKEditorError} error.
      *
      * @param err The error to rethrow.
      * @param context An object connected through properties with the editor instance. This context will be used
      * by the watchdog to verify which editor should be restarted.
      */
      static rethrowUnexpectedError(err, context) {
        if (err.is && err.is("CKEditorError")) {
          throw err;
        }
        const error = new CKEditorError(err.message, context);
        error.stack = err.stack;
        throw error;
      }
    }
    function logWarning(errorName, data) {
      console.warn(...formatConsoleArguments(errorName, data));
    }
    function getLinkToDocumentationMessage(errorName) {
      return `
Read more: ${DOCUMENTATION_URL}#error-${errorName}`;
    }
    function getErrorMessage(errorName, data) {
      const processedObjects = /* @__PURE__ */ new WeakSet();
      const circularReferencesReplacer = (key, value) => {
        if (typeof value === "object" && value !== null) {
          if (processedObjects.has(value)) {
            return `[object ${value.constructor.name}]`;
          }
          processedObjects.add(value);
        }
        return value;
      };
      const stringifiedData = data ? ` ${JSON.stringify(data, circularReferencesReplacer)}` : "";
      const documentationLink = getLinkToDocumentationMessage(errorName);
      return errorName + stringifiedData + documentationLink;
    }
    function formatConsoleArguments(errorName, data) {
      const documentationMessage = getLinkToDocumentationMessage(errorName);
      return data ? [
        errorName,
        data,
        documentationMessage
      ] : [
        errorName,
        documentationMessage
      ];
    }
    const version = "43.3.1";
    const releaseDate = new Date(2024, 10, 6);
    /* istanbul ignore next -- @preserve */
    if (globalThis.CKEDITOR_VERSION) {
      throw new CKEditorError("ckeditor-duplicated-modules", null);
    } else {
      globalThis.CKEDITOR_VERSION = version;
    }
    const _listeningTo = Symbol("listeningTo");
    const _emitterId = Symbol("emitterId");
    const _delegations = Symbol("delegations");
    const defaultEmitterClass$1 = /* @__PURE__ */ EmitterMixin(Object);
    function EmitterMixin(base) {
      if (!base) {
        return defaultEmitterClass$1;
      }
      class Mixin extends base {
        on(event, callback, options) {
          this.listenTo(this, event, callback, options);
        }
        once(event, callback, options) {
          let wasFired = false;
          const onceCallback = (event2, ...args) => {
            if (!wasFired) {
              wasFired = true;
              event2.off();
              callback.call(this, event2, ...args);
            }
          };
          this.listenTo(this, event, onceCallback, options);
        }
        off(event, callback) {
          this.stopListening(this, event, callback);
        }
        listenTo(emitter, event, callback, options = {}) {
          let emitterInfo, eventCallbacks;
          if (!this[_listeningTo]) {
            this[_listeningTo] = {};
          }
          const emitters = this[_listeningTo];
          if (!_getEmitterId(emitter)) {
            _setEmitterId(emitter);
          }
          const emitterId = _getEmitterId(emitter);
          if (!(emitterInfo = emitters[emitterId])) {
            emitterInfo = emitters[emitterId] = {
              emitter,
              callbacks: {}
            };
          }
          if (!(eventCallbacks = emitterInfo.callbacks[event])) {
            eventCallbacks = emitterInfo.callbacks[event] = [];
          }
          eventCallbacks.push(callback);
          addEventListener(this, emitter, event, callback, options);
        }
        stopListening(emitter, event, callback) {
          const emitters = this[_listeningTo];
          let emitterId = emitter && _getEmitterId(emitter);
          const emitterInfo = emitters && emitterId ? emitters[emitterId] : void 0;
          const eventCallbacks = emitterInfo && event ? emitterInfo.callbacks[event] : void 0;
          if (!emitters || emitter && !emitterInfo || event && !eventCallbacks) {
            return;
          }
          if (callback) {
            removeEventListener(this, emitter, event, callback);
            const index = eventCallbacks.indexOf(callback);
            if (index !== -1) {
              if (eventCallbacks.length === 1) {
                delete emitterInfo.callbacks[event];
              } else {
                removeEventListener(this, emitter, event, callback);
              }
            }
          } else if (eventCallbacks) {
            while (callback = eventCallbacks.pop()) {
              removeEventListener(this, emitter, event, callback);
            }
            delete emitterInfo.callbacks[event];
          } else if (emitterInfo) {
            for (event in emitterInfo.callbacks) {
              this.stopListening(emitter, event);
            }
            delete emitters[emitterId];
          } else {
            for (emitterId in emitters) {
              this.stopListening(emitters[emitterId].emitter);
            }
            delete this[_listeningTo];
          }
        }
        fire(eventOrInfo, ...args) {
          try {
            const eventInfo = eventOrInfo instanceof EventInfo ? eventOrInfo : new EventInfo(this, eventOrInfo);
            const event = eventInfo.name;
            let callbacks = getCallbacksForEvent(this, event);
            eventInfo.path.push(this);
            if (callbacks) {
              const callbackArgs = [
                eventInfo,
                ...args
              ];
              callbacks = Array.from(callbacks);
              for (let i2 = 0; i2 < callbacks.length; i2++) {
                callbacks[i2].callback.apply(this, callbackArgs);
                if (eventInfo.off.called) {
                  delete eventInfo.off.called;
                  this._removeEventListener(event, callbacks[i2].callback);
                }
                if (eventInfo.stop.called) {
                  break;
                }
              }
            }
            const delegations = this[_delegations];
            if (delegations) {
              const destinations = delegations.get(event);
              const passAllDestinations = delegations.get("*");
              if (destinations) {
                fireDelegatedEvents(destinations, eventInfo, args);
              }
              if (passAllDestinations) {
                fireDelegatedEvents(passAllDestinations, eventInfo, args);
              }
            }
            return eventInfo.return;
          } catch (err) {
            /* istanbul ignore next -- @preserve */
            CKEditorError.rethrowUnexpectedError(err, this);
          }
        }
        delegate(...events) {
          return {
            to: (emitter, nameOrFunction) => {
              if (!this[_delegations]) {
                this[_delegations] = /* @__PURE__ */ new Map();
              }
              events.forEach((eventName) => {
                const destinations = this[_delegations].get(eventName);
                if (!destinations) {
                  this[_delegations].set(eventName, /* @__PURE__ */ new Map([
                    [
                      emitter,
                      nameOrFunction
                    ]
                  ]));
                } else {
                  destinations.set(emitter, nameOrFunction);
                }
              });
            }
          };
        }
        stopDelegating(event, emitter) {
          if (!this[_delegations]) {
            return;
          }
          if (!event) {
            this[_delegations].clear();
          } else if (!emitter) {
            this[_delegations].delete(event);
          } else {
            const destinations = this[_delegations].get(event);
            if (destinations) {
              destinations.delete(emitter);
            }
          }
        }
        _addEventListener(event, callback, options) {
          createEventNamespace(this, event);
          const lists = getCallbacksListsForNamespace(this, event);
          const priority = priorities.get(options.priority);
          const callbackDefinition = {
            callback,
            priority
          };
          for (const callbacks of lists) {
            insertToPriorityArray(callbacks, callbackDefinition);
          }
        }
        _removeEventListener(event, callback) {
          const lists = getCallbacksListsForNamespace(this, event);
          for (const callbacks of lists) {
            for (let i2 = 0; i2 < callbacks.length; i2++) {
              if (callbacks[i2].callback == callback) {
                callbacks.splice(i2, 1);
                i2--;
              }
            }
          }
        }
      }
      return Mixin;
    }
    [
      "on",
      "once",
      "off",
      "listenTo",
      "stopListening",
      "fire",
      "delegate",
      "stopDelegating",
      "_addEventListener",
      "_removeEventListener"
    ].forEach((key) => {
      EmitterMixin[key] = defaultEmitterClass$1.prototype[key];
    });
    function _getEmitterListenedTo(listeningEmitter, listenedToEmitterId) {
      const listeningTo = listeningEmitter[_listeningTo];
      if (listeningTo && listeningTo[listenedToEmitterId]) {
        return listeningTo[listenedToEmitterId].emitter;
      }
      return null;
    }
    function _setEmitterId(emitter, id) {
      if (!emitter[_emitterId]) {
        emitter[_emitterId] = id || uid();
      }
    }
    function _getEmitterId(emitter) {
      return emitter[_emitterId];
    }
    function getEvents(source) {
      if (!source._events) {
        Object.defineProperty(source, "_events", {
          value: {}
        });
      }
      return source._events;
    }
    function makeEventNode() {
      return {
        callbacks: [],
        childEvents: []
      };
    }
    function createEventNamespace(source, eventName) {
      const events = getEvents(source);
      if (events[eventName]) {
        return;
      }
      let name = eventName;
      let childEventName = null;
      const newEventNodes = [];
      while (name !== "") {
        if (events[name]) {
          break;
        }
        events[name] = makeEventNode();
        newEventNodes.push(events[name]);
        if (childEventName) {
          events[name].childEvents.push(childEventName);
        }
        childEventName = name;
        name = name.substr(0, name.lastIndexOf(":"));
      }
      if (name !== "") {
        for (const node of newEventNodes) {
          node.callbacks = events[name].callbacks.slice();
        }
        events[name].childEvents.push(childEventName);
      }
    }
    function getCallbacksListsForNamespace(source, eventName) {
      const eventNode = getEvents(source)[eventName];
      if (!eventNode) {
        return [];
      }
      let callbacksLists = [
        eventNode.callbacks
      ];
      for (let i2 = 0; i2 < eventNode.childEvents.length; i2++) {
        const childCallbacksLists = getCallbacksListsForNamespace(source, eventNode.childEvents[i2]);
        callbacksLists = callbacksLists.concat(childCallbacksLists);
      }
      return callbacksLists;
    }
    function getCallbacksForEvent(source, eventName) {
      let event;
      if (!source._events || !(event = source._events[eventName]) || !event.callbacks.length) {
        if (eventName.indexOf(":") > -1) {
          return getCallbacksForEvent(source, eventName.substr(0, eventName.lastIndexOf(":")));
        } else {
          return null;
        }
      }
      return event.callbacks;
    }
    function fireDelegatedEvents(destinations, eventInfo, fireArgs) {
      for (let [emitter, name] of destinations) {
        if (!name) {
          name = eventInfo.name;
        } else if (typeof name == "function") {
          name = name(eventInfo.name);
        }
        const delegatedInfo = new EventInfo(eventInfo.source, name);
        delegatedInfo.path = [
          ...eventInfo.path
        ];
        emitter.fire(delegatedInfo, ...fireArgs);
      }
    }
    function addEventListener(listener, emitter, event, callback, options) {
      if (emitter._addEventListener) {
        emitter._addEventListener(event, callback, options);
      } else {
        listener._addEventListener.call(emitter, event, callback, options);
      }
    }
    function removeEventListener(listener, emitter, event, callback) {
      if (emitter._removeEventListener) {
        emitter._removeEventListener(event, callback);
      } else {
        listener._removeEventListener.call(emitter, event, callback);
      }
    }
    const observablePropertiesSymbol = Symbol("observableProperties");
    const boundObservablesSymbol = Symbol("boundObservables");
    const boundPropertiesSymbol = Symbol("boundProperties");
    const decoratedMethods = Symbol("decoratedMethods");
    const decoratedOriginal = Symbol("decoratedOriginal");
    const defaultObservableClass = /* @__PURE__ */ ObservableMixin(/* @__PURE__ */ EmitterMixin());
    function ObservableMixin(base) {
      var _a2, _b2, _c2, _d2, _e3;
      if (!base) {
        return defaultObservableClass;
      }
      class Mixin extends (_e3 = base, _d2 = observablePropertiesSymbol, _c2 = decoratedMethods, _b2 = boundPropertiesSymbol, _a2 = boundObservablesSymbol, _e3) {
        constructor() {
          super(...arguments);
          __publicField(this, _d2);
          __publicField(this, _c2);
          __publicField(this, _b2);
          __publicField(this, _a2);
        }
        set(name, value) {
          if (isObject$3(name)) {
            Object.keys(name).forEach((property2) => {
              this.set(property2, name[property2]);
            }, this);
            return;
          }
          initObservable(this);
          const properties = this[observablePropertiesSymbol];
          if (name in this && !properties.has(name)) {
            throw new CKEditorError("observable-set-cannot-override", this);
          }
          Object.defineProperty(this, name, {
            enumerable: true,
            configurable: true,
            get() {
              return properties.get(name);
            },
            set(value2) {
              const oldValue = properties.get(name);
              let newValue = this.fire(`set:${name}`, name, value2, oldValue);
              if (newValue === void 0) {
                newValue = value2;
              }
              if (oldValue !== newValue || !properties.has(name)) {
                properties.set(name, newValue);
                this.fire(`change:${name}`, name, newValue, oldValue);
              }
            }
          });
          this[name] = value;
        }
        bind(...bindProperties) {
          if (!bindProperties.length || !isStringArray$1(bindProperties)) {
            throw new CKEditorError("observable-bind-wrong-properties", this);
          }
          if (new Set(bindProperties).size !== bindProperties.length) {
            throw new CKEditorError("observable-bind-duplicate-properties", this);
          }
          initObservable(this);
          const boundProperties = this[boundPropertiesSymbol];
          bindProperties.forEach((propertyName) => {
            if (boundProperties.has(propertyName)) {
              throw new CKEditorError("observable-bind-rebind", this);
            }
          });
          const bindings = /* @__PURE__ */ new Map();
          bindProperties.forEach((a2) => {
            const binding = {
              property: a2,
              to: []
            };
            boundProperties.set(a2, binding);
            bindings.set(a2, binding);
          });
          return {
            to: bindTo,
            toMany: bindToMany,
            _observable: this,
            _bindProperties: bindProperties,
            _to: [],
            _bindings: bindings
          };
        }
        unbind(...unbindProperties) {
          if (!this[observablePropertiesSymbol]) {
            return;
          }
          const boundProperties = this[boundPropertiesSymbol];
          const boundObservables = this[boundObservablesSymbol];
          if (unbindProperties.length) {
            if (!isStringArray$1(unbindProperties)) {
              throw new CKEditorError("observable-unbind-wrong-properties", this);
            }
            unbindProperties.forEach((propertyName) => {
              const binding = boundProperties.get(propertyName);
              if (!binding) {
                return;
              }
              binding.to.forEach(([toObservable, toProperty]) => {
                const toProperties = boundObservables.get(toObservable);
                const toPropertyBindings = toProperties[toProperty];
                toPropertyBindings.delete(binding);
                if (!toPropertyBindings.size) {
                  delete toProperties[toProperty];
                }
                if (!Object.keys(toProperties).length) {
                  boundObservables.delete(toObservable);
                  this.stopListening(toObservable, "change");
                }
              });
              boundProperties.delete(propertyName);
            });
          } else {
            boundObservables.forEach((bindings, boundObservable) => {
              this.stopListening(boundObservable, "change");
            });
            boundObservables.clear();
            boundProperties.clear();
          }
        }
        decorate(methodName) {
          initObservable(this);
          const originalMethod = this[methodName];
          if (!originalMethod) {
            throw new CKEditorError("observablemixin-cannot-decorate-undefined", this, {
              object: this,
              methodName
            });
          }
          this.on(methodName, (evt, args) => {
            evt.return = originalMethod.apply(this, args);
          });
          this[methodName] = function(...args) {
            return this.fire(methodName, args);
          };
          this[methodName][decoratedOriginal] = originalMethod;
          if (!this[decoratedMethods]) {
            this[decoratedMethods] = [];
          }
          this[decoratedMethods].push(methodName);
        }
        // Override the EmitterMixin stopListening method to be able to clean (and restore) decorated methods.
        // This is needed in case of:
        //  1. Have x.foo() decorated.
        //  2. Call x.stopListening()
        //  3. Call x.foo(). Problem: nothing happens (the original foo() method is not executed)
        stopListening(emitter, event, callback) {
          if (!emitter && this[decoratedMethods]) {
            for (const methodName of this[decoratedMethods]) {
              this[methodName] = this[methodName][decoratedOriginal];
            }
            delete this[decoratedMethods];
          }
          super.stopListening(emitter, event, callback);
        }
      }
      return Mixin;
    }
    [
      "set",
      "bind",
      "unbind",
      "decorate",
      "on",
      "once",
      "off",
      "listenTo",
      "stopListening",
      "fire",
      "delegate",
      "stopDelegating",
      "_addEventListener",
      "_removeEventListener"
    ].forEach((key) => {
      ObservableMixin[key] = defaultObservableClass.prototype[key];
    });
    function initObservable(observable) {
      if (observable[observablePropertiesSymbol]) {
        return;
      }
      Object.defineProperty(observable, observablePropertiesSymbol, {
        value: /* @__PURE__ */ new Map()
      });
      Object.defineProperty(observable, boundObservablesSymbol, {
        value: /* @__PURE__ */ new Map()
      });
      Object.defineProperty(observable, boundPropertiesSymbol, {
        value: /* @__PURE__ */ new Map()
      });
    }
    function bindTo(...args) {
      const parsedArgs = parseBindToArgs(...args);
      const bindingsKeys = Array.from(this._bindings.keys());
      const numberOfBindings = bindingsKeys.length;
      if (!parsedArgs.callback && parsedArgs.to.length > 1) {
        throw new CKEditorError("observable-bind-to-no-callback", this);
      }
      if (numberOfBindings > 1 && parsedArgs.callback) {
        throw new CKEditorError("observable-bind-to-extra-callback", this);
      }
      parsedArgs.to.forEach((to2) => {
        if (to2.properties.length && to2.properties.length !== numberOfBindings) {
          throw new CKEditorError("observable-bind-to-properties-length", this);
        }
        if (!to2.properties.length) {
          to2.properties = this._bindProperties;
        }
      });
      this._to = parsedArgs.to;
      if (parsedArgs.callback) {
        this._bindings.get(bindingsKeys[0]).callback = parsedArgs.callback;
      }
      attachBindToListeners(this._observable, this._to);
      updateBindToBound(this);
      this._bindProperties.forEach((propertyName) => {
        updateBoundObservableProperty(this._observable, propertyName);
      });
    }
    function bindToMany(observables, attribute, callback) {
      if (this._bindings.size > 1) {
        throw new CKEditorError("observable-bind-to-many-not-one-binding", this);
      }
      this.to(
        ...getBindingTargets(observables, attribute),
        // ...using given callback to parse attribute values.
        callback
      );
    }
    function getBindingTargets(observables, attribute) {
      const observableAndAttributePairs = observables.map((observable) => [
        observable,
        attribute
      ]);
      return Array.prototype.concat.apply([], observableAndAttributePairs);
    }
    function isStringArray$1(arr) {
      return arr.every((a2) => typeof a2 == "string");
    }
    function parseBindToArgs(...args) {
      if (!args.length) {
        throw new CKEditorError("observable-bind-to-parse-error", null);
      }
      const parsed = {
        to: []
      };
      let lastObservable;
      if (typeof args[args.length - 1] == "function") {
        parsed.callback = args.pop();
      }
      args.forEach((a2) => {
        if (typeof a2 == "string") {
          lastObservable.properties.push(a2);
        } else if (typeof a2 == "object") {
          lastObservable = {
            observable: a2,
            properties: []
          };
          parsed.to.push(lastObservable);
        } else {
          throw new CKEditorError("observable-bind-to-parse-error", null);
        }
      });
      return parsed;
    }
    function updateBoundObservables(observable, binding, toObservable, toPropertyName) {
      const boundObservables = observable[boundObservablesSymbol];
      const bindingsToObservable = boundObservables.get(toObservable);
      const bindings = bindingsToObservable || {};
      if (!bindings[toPropertyName]) {
        bindings[toPropertyName] = /* @__PURE__ */ new Set();
      }
      bindings[toPropertyName].add(binding);
      if (!bindingsToObservable) {
        boundObservables.set(toObservable, bindings);
      }
    }
    function updateBindToBound(chain2) {
      let toProperty;
      chain2._bindings.forEach((binding, propertyName) => {
        chain2._to.forEach((to2) => {
          toProperty = to2.properties[binding.callback ? 0 : chain2._bindProperties.indexOf(propertyName)];
          binding.to.push([
            to2.observable,
            toProperty
          ]);
          updateBoundObservables(chain2._observable, binding, to2.observable, toProperty);
        });
      });
    }
    function updateBoundObservableProperty(observable, propertyName) {
      const boundProperties = observable[boundPropertiesSymbol];
      const binding = boundProperties.get(propertyName);
      let propertyValue;
      if (binding.callback) {
        propertyValue = binding.callback.apply(observable, binding.to.map((to2) => to2[0][to2[1]]));
      } else {
        propertyValue = binding.to[0];
        propertyValue = propertyValue[0][propertyValue[1]];
      }
      if (Object.prototype.hasOwnProperty.call(observable, propertyName)) {
        observable[propertyName] = propertyValue;
      } else {
        observable.set(propertyName, propertyValue);
      }
    }
    function attachBindToListeners(observable, toBindings) {
      toBindings.forEach((to2) => {
        const boundObservables = observable[boundObservablesSymbol];
        let bindings;
        if (!boundObservables.get(to2.observable)) {
          observable.listenTo(to2.observable, "change", (evt, propertyName) => {
            bindings = boundObservables.get(to2.observable)[propertyName];
            if (bindings) {
              bindings.forEach((binding) => {
                updateBoundObservableProperty(observable, binding.property);
              });
            }
          });
        }
      });
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class ElementReplacer {
      constructor() {
        /**
        * The elements replaced by {@link #replace} and their replacements.
        */
        __publicField(this, "_replacedElements");
        this._replacedElements = [];
      }
      /**
      * Hides the `element` and, if specified, inserts the the given element next to it.
      *
      * The effect of this method can be reverted by {@link #restore}.
      *
      * @param element The element to replace.
      * @param newElement The replacement element. If not passed, then the `element` will just be hidden.
      */
      replace(element, newElement) {
        this._replacedElements.push({
          element,
          newElement
        });
        element.style.display = "none";
        if (newElement) {
          element.parentNode.insertBefore(newElement, element.nextSibling);
        }
      }
      /**
      * Restores what {@link #replace} did.
      */
      restore() {
        this._replacedElements.forEach(({ element, newElement }) => {
          element.style.display = "";
          if (newElement) {
            newElement.remove();
          }
        });
        this._replacedElements = [];
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function count(iterable) {
      let count2 = 0;
      for (const _2 of iterable) {
        count2++;
      }
      return count2;
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function compareArrays(a2, b2) {
      const minLen = Math.min(a2.length, b2.length);
      for (let i2 = 0; i2 < minLen; i2++) {
        if (a2[i2] != b2[i2]) {
          return i2;
        }
      }
      if (a2.length == b2.length) {
        return "same";
      } else if (a2.length < b2.length) {
        return "prefix";
      } else {
        return "extension";
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function isIterable(value) {
      return !!(value && value[Symbol.iterator]);
    }
    function createElement(doc, name, attributes = {}, children = []) {
      const namespace = attributes && attributes.xmlns;
      const element = namespace ? doc.createElementNS(namespace, name) : doc.createElement(name);
      for (const key in attributes) {
        element.setAttribute(key, attributes[key]);
      }
      if (isString(children) || !isIterable(children)) {
        children = [
          children
        ];
      }
      for (let child of children) {
        if (isString(child)) {
          child = doc.createTextNode(child);
        }
        element.appendChild(child);
      }
      return element;
    }
    class Config {
      /**
      * Creates an instance of the {@link ~Config} class.
      *
      * @param configurations The initial configurations to be set. Usually, provided by the user.
      * @param defaultConfigurations The default configurations. Usually, provided by the system.
      */
      constructor(configurations, defaultConfigurations) {
        /**
        * Store for the whole configuration.
        */
        __publicField(this, "_config");
        this._config = /* @__PURE__ */ Object.create(null);
        if (defaultConfigurations) {
          this.define(cloneConfig(defaultConfigurations));
        }
        if (configurations) {
          this._setObjectToTarget(this._config, configurations);
        }
      }
      set(name, value) {
        this._setToTarget(this._config, name, value);
      }
      define(name, value) {
        const isDefine = true;
        this._setToTarget(this._config, name, value, isDefine);
      }
      /**
      * Gets the value for a configuration entry.
      *
      * ```ts
      * config.get( 'name' );
      * ```
      *
      * Deep configurations can be retrieved by separating each part with a dot.
      *
      * ```ts
      * config.get( 'toolbar.collapsed' );
      * ```
      *
      * @param name The configuration name. Configuration names are case-sensitive.
      * @returns The configuration value or `undefined` if the configuration entry was not found.
      */
      get(name) {
        return this._getFromSource(this._config, name);
      }
      /**
      * Iterates over all top level configuration names.
      */
      *names() {
        for (const name of Object.keys(this._config)) {
          yield name;
        }
      }
      /**
      * Saves passed configuration to the specified target (nested object).
      *
      * @param target Nested config object.
      * @param name The configuration name or an object from which take properties as
      * configuration entries. Configuration names are case-sensitive.
      * @param value The configuration value. Used if a name is passed.
      * @param isDefine Define if passed configuration should overwrite existing one.
      */
      _setToTarget(target, name, value, isDefine = false) {
        if (isPlainObject$2(name)) {
          this._setObjectToTarget(target, name, isDefine);
          return;
        }
        const parts = name.split(".");
        name = parts.pop();
        for (const part of parts) {
          if (!isPlainObject$2(target[part])) {
            target[part] = /* @__PURE__ */ Object.create(null);
          }
          target = target[part];
        }
        if (isPlainObject$2(value)) {
          if (!isPlainObject$2(target[name])) {
            target[name] = /* @__PURE__ */ Object.create(null);
          }
          target = target[name];
          this._setObjectToTarget(target, value, isDefine);
          return;
        }
        if (isDefine && typeof target[name] != "undefined") {
          return;
        }
        target[name] = value;
      }
      /**
      * Get specified configuration from specified source (nested object).
      *
      * @param source level of nested object.
      * @param name The configuration name. Configuration names are case-sensitive.
      * @returns The configuration value or `undefined` if the configuration entry was not found.
      */
      _getFromSource(source, name) {
        const parts = name.split(".");
        name = parts.pop();
        for (const part of parts) {
          if (!isPlainObject$2(source[part])) {
            source = null;
            break;
          }
          source = source[part];
        }
        return source ? cloneConfig(source[name]) : void 0;
      }
      /**
      * Iterates through passed object and calls {@link #_setToTarget} method with object key and value for each property.
      *
      * @param target Nested config object.
      * @param configuration Configuration data set
      * @param isDefine Defines if passed configuration is default configuration or not.
      */
      _setObjectToTarget(target, configuration, isDefine) {
        Object.keys(configuration).forEach((key) => {
          this._setToTarget(target, key, configuration[key], isDefine);
        });
      }
    }
    function cloneConfig(source) {
      return cloneDeepWith(source, leaveItemReferences);
    }
    function leaveItemReferences(value) {
      return isElement$3(value) || typeof value === "function" ? value : void 0;
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function isNode(obj) {
      if (obj) {
        if (obj.defaultView) {
          return obj instanceof obj.defaultView.Document;
        } else if (obj.ownerDocument && obj.ownerDocument.defaultView) {
          return obj instanceof obj.ownerDocument.defaultView.Node;
        }
      }
      return false;
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function isWindow(obj) {
      const stringifiedObject = Object.prototype.toString.apply(obj);
      if (stringifiedObject == "[object Window]") {
        return true;
      }
      if (stringifiedObject == "[object global]") {
        return true;
      }
      return false;
    }
    const defaultEmitterClass = /* @__PURE__ */ DomEmitterMixin(/* @__PURE__ */ EmitterMixin());
    function DomEmitterMixin(base) {
      if (!base) {
        return defaultEmitterClass;
      }
      class Mixin extends base {
        listenTo(emitter, event, callback, options = {}) {
          if (isNode(emitter) || isWindow(emitter)) {
            const proxyOptions = {
              capture: !!options.useCapture,
              passive: !!options.usePassive
            };
            const proxyEmitter = this._getProxyEmitter(emitter, proxyOptions) || new ProxyEmitter(emitter, proxyOptions);
            this.listenTo(proxyEmitter, event, callback, options);
          } else {
            super.listenTo(emitter, event, callback, options);
          }
        }
        stopListening(emitter, event, callback) {
          if (isNode(emitter) || isWindow(emitter)) {
            const proxyEmitters = this._getAllProxyEmitters(emitter);
            for (const proxy of proxyEmitters) {
              this.stopListening(proxy, event, callback);
            }
          } else {
            super.stopListening(emitter, event, callback);
          }
        }
        /**
        * Retrieves ProxyEmitter instance for given DOM Node residing in this Host and given options.
        *
        * @param node DOM Node of the ProxyEmitter.
        * @param options Additional options.
        * @param options.useCapture Indicates that events of this type will be dispatched to the registered
        * listener before being dispatched to any EventTarget beneath it in the DOM tree.
        * @param options.usePassive Indicates that the function specified by listener will never call preventDefault()
        * and prevents blocking browser's main thread by this event handler.
        * @returns ProxyEmitter instance bound to the DOM Node.
        */
        _getProxyEmitter(node, options) {
          return _getEmitterListenedTo(this, getProxyEmitterId(node, options));
        }
        /**
        * Retrieves all the ProxyEmitter instances for given DOM Node residing in this Host.
        *
        * @param node DOM Node of the ProxyEmitter.
        */
        _getAllProxyEmitters(node) {
          return [
            {
              capture: false,
              passive: false
            },
            {
              capture: false,
              passive: true
            },
            {
              capture: true,
              passive: false
            },
            {
              capture: true,
              passive: true
            }
          ].map((options) => this._getProxyEmitter(node, options)).filter((proxy) => !!proxy);
        }
      }
      return Mixin;
    }
    [
      "_getProxyEmitter",
      "_getAllProxyEmitters",
      "on",
      "once",
      "off",
      "listenTo",
      "stopListening",
      "fire",
      "delegate",
      "stopDelegating",
      "_addEventListener",
      "_removeEventListener"
    ].forEach((key) => {
      DomEmitterMixin[key] = defaultEmitterClass.prototype[key];
    });
    class ProxyEmitter extends (/* @__PURE__ */ EmitterMixin()) {
      /**
      * @param node DOM Node that fires events.
      * @param options Additional options.
      * @param options.useCapture Indicates that events of this type will be dispatched to the registered
      * listener before being dispatched to any EventTarget beneath it in the DOM tree.
      * @param options.usePassive Indicates that the function specified by listener will never call preventDefault()
      * and prevents blocking browser's main thread by this event handler.
      */
      constructor(node, options) {
        super();
        __publicField(this, "_domNode");
        __publicField(this, "_options");
        /**
        * Collection of native DOM listeners.
        */
        __publicField(this, "_domListeners");
        _setEmitterId(this, getProxyEmitterId(node, options));
        this._domNode = node;
        this._options = options;
      }
      /**
      * Registers a callback function to be executed when an event is fired.
      *
      * It attaches a native DOM listener to the DOM Node. When fired,
      * a corresponding Emitter event will also fire with DOM Event object as an argument.
      *
      * **Note**: This is automatically called by the
      * {@link module:utils/emittermixin~Emitter#listenTo `Emitter#listenTo()`}.
      *
      * @param event The name of the event.
      */
      attach(event) {
        if (this._domListeners && this._domListeners[event]) {
          return;
        }
        const domListener = this._createDomListener(event);
        this._domNode.addEventListener(event, domListener, this._options);
        if (!this._domListeners) {
          this._domListeners = {};
        }
        this._domListeners[event] = domListener;
      }
      /**
      * Stops executing the callback on the given event.
      *
      * **Note**: This is automatically called by the
      * {@link module:utils/emittermixin~Emitter#stopListening `Emitter#stopListening()`}.
      *
      * @param event The name of the event.
      */
      detach(event) {
        let events;
        if (this._domListeners[event] && (!(events = this._events[event]) || !events.callbacks.length)) {
          this._domListeners[event].removeListener();
        }
      }
      /**
      * Adds callback to emitter for given event.
      *
      * @internal
      * @param event The name of the event.
      * @param callback The function to be called on event.
      * @param options Additional options.
      */
      _addEventListener(event, callback, options) {
        this.attach(event);
        EmitterMixin().prototype._addEventListener.call(this, event, callback, options);
      }
      /**
      * Removes callback from emitter for given event.
      *
      * @internal
      * @param event The name of the event.
      * @param callback The function to stop being called.
      */
      _removeEventListener(event, callback) {
        EmitterMixin().prototype._removeEventListener.call(this, event, callback);
        this.detach(event);
      }
      /**
      * Creates a native DOM listener callback. When the native DOM event
      * is fired it will fire corresponding event on this ProxyEmitter.
      * Note: A native DOM Event is passed as an argument.
      *
      * @param event The name of the event.
      * @returns The DOM listener callback.
      */
      _createDomListener(event) {
        const domListener = (domEvt) => {
          this.fire(event, domEvt);
        };
        domListener.removeListener = () => {
          this._domNode.removeEventListener(event, domListener, this._options);
          delete this._domListeners[event];
        };
        return domListener;
      }
    }
    function getNodeUID(node) {
      return node["data-ck-expando"] || (node["data-ck-expando"] = uid());
    }
    function getProxyEmitterId(node, options) {
      let id = getNodeUID(node);
      for (const option of Object.keys(options).sort()) {
        if (options[option]) {
          id += "-" + option;
        }
      }
      return id;
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function getAncestors(node) {
      const nodes = [];
      let currentNode = node;
      while (currentNode && currentNode.nodeType != Node.DOCUMENT_NODE) {
        nodes.unshift(currentNode);
        currentNode = currentNode.parentNode;
      }
      return nodes;
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function getDataFromElement(el) {
      if (el instanceof HTMLTextAreaElement) {
        return el.value;
      }
      return el.innerHTML;
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function getBorderWidths(element) {
      const style = element.ownerDocument.defaultView.getComputedStyle(element);
      return {
        top: parseInt(style.borderTopWidth, 10),
        right: parseInt(style.borderRightWidth, 10),
        bottom: parseInt(style.borderBottomWidth, 10),
        left: parseInt(style.borderLeftWidth, 10)
      };
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function getRangeFromMouseEvent(domEvent) {
      if (!domEvent.target) {
        return null;
      }
      const domDoc = domEvent.target.ownerDocument;
      const x2 = domEvent.clientX;
      const y2 = domEvent.clientY;
      let domRange = null;
      if (domDoc.caretRangeFromPoint && domDoc.caretRangeFromPoint(x2, y2)) {
        domRange = domDoc.caretRangeFromPoint(x2, y2);
      } else if (domEvent.rangeParent) {
        domRange = domDoc.createRange();
        domRange.setStart(domEvent.rangeParent, domEvent.rangeOffset);
        domRange.collapse(true);
      }
      return domRange;
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function isText(obj) {
      return Object.prototype.toString.call(obj) == "[object Text]";
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function isRange(obj) {
      return Object.prototype.toString.apply(obj) == "[object Range]";
    }
    function getPositionedAncestor(element) {
      if (!element || !element.parentNode) {
        return null;
      }
      if (element.offsetParent === global$1.document.body) {
        return null;
      }
      return element.offsetParent;
    }
    const rectProperties = [
      "top",
      "right",
      "bottom",
      "left",
      "width",
      "height"
    ];
    class Rect {
      /**
      * Creates an instance of rect.
      *
      * ```ts
      * // Rect of an HTMLElement.
      * const rectA = new Rect( document.body );
      *
      * // Rect of a DOM Range.
      * const rectB = new Rect( document.getSelection().getRangeAt( 0 ) );
      *
      * // Rect of a window (web browser viewport).
      * const rectC = new Rect( window );
      *
      * // Rect out of an object.
      * const rectD = new Rect( { top: 0, right: 10, bottom: 10, left: 0, width: 10, height: 10 } );
      *
      * // Rect out of another Rect instance.
      * const rectE = new Rect( rectD );
      *
      * // Rect out of a ClientRect.
      * const rectF = new Rect( document.body.getClientRects().item( 0 ) );
      * ```
      *
      * **Note**: By default a rect of an HTML element includes its CSS borders and scrollbars (if any)
      * ant the rect of a `window` includes scrollbars too. Use {@link #excludeScrollbarsAndBorders}
      * to get the inner part of the rect.
      *
      * @param source A source object to create the rect.
      */
      constructor(source) {
        /**
        * The "top" value of the rect.
        *
        * @readonly
        */
        __publicField(this, "top");
        /**
        * The "right" value of the rect.
        *
        * @readonly
        */
        __publicField(this, "right");
        /**
        * The "bottom" value of the rect.
        *
        * @readonly
        */
        __publicField(this, "bottom");
        /**
        * The "left" value of the rect.
        *
        * @readonly
        */
        __publicField(this, "left");
        /**
        * The "width" value of the rect.
        *
        * @readonly
        */
        __publicField(this, "width");
        /**
        * The "height" value of the rect.
        *
        * @readonly
        */
        __publicField(this, "height");
        /**
        * The object this rect is for.
        *
        * @readonly
        */
        __publicField(this, "_source");
        const isSourceRange = isRange(source);
        Object.defineProperty(this, "_source", {
          // If the source is a Rect instance, copy it's #_source.
          value: source._source || source,
          writable: true,
          enumerable: false
        });
        if (isDomElement(source) || isSourceRange) {
          if (isSourceRange) {
            const rangeRects = Rect.getDomRangeRects(source);
            copyRectProperties(this, Rect.getBoundingRect(rangeRects));
          } else {
            copyRectProperties(this, source.getBoundingClientRect());
          }
        } else if (isWindow(source)) {
          const { innerWidth, innerHeight } = source;
          copyRectProperties(this, {
            top: 0,
            right: innerWidth,
            bottom: innerHeight,
            left: 0,
            width: innerWidth,
            height: innerHeight
          });
        } else {
          copyRectProperties(this, source);
        }
      }
      /**
      * Returns a clone of the rect.
      *
      * @returns A cloned rect.
      */
      clone() {
        return new Rect(this);
      }
      /**
      * Moves the rect so that its upperleft corner lands in desired `[ x, y ]` location.
      *
      * @param x Desired horizontal location.
      * @param y Desired vertical location.
      * @returns A rect which has been moved.
      */
      moveTo(x2, y2) {
        this.top = y2;
        this.right = x2 + this.width;
        this.bottom = y2 + this.height;
        this.left = x2;
        return this;
      }
      /**
      * Moves the rect inplace by a dedicated offset.
      *
      * @param x A horizontal offset.
      * @param y A vertical offset
      * @returns A rect which has been moved.
      */
      moveBy(x2, y2) {
        this.top += y2;
        this.right += x2;
        this.left += x2;
        this.bottom += y2;
        return this;
      }
      /**
      * Returns a new rect a a result of intersection with another rect.
      */
      getIntersection(anotherRect) {
        const rect = {
          top: Math.max(this.top, anotherRect.top),
          right: Math.min(this.right, anotherRect.right),
          bottom: Math.min(this.bottom, anotherRect.bottom),
          left: Math.max(this.left, anotherRect.left),
          width: 0,
          height: 0
        };
        rect.width = rect.right - rect.left;
        rect.height = rect.bottom - rect.top;
        if (rect.width < 0 || rect.height < 0) {
          return null;
        } else {
          const newRect = new Rect(rect);
          newRect._source = this._source;
          return newRect;
        }
      }
      /**
      * Returns the area of intersection with another rect.
      *
      * @returns Area of intersection.
      */
      getIntersectionArea(anotherRect) {
        const rect = this.getIntersection(anotherRect);
        if (rect) {
          return rect.getArea();
        } else {
          return 0;
        }
      }
      /**
      * Returns the area of the rect.
      */
      getArea() {
        return this.width * this.height;
      }
      /**
      * Returns a new rect, a part of the original rect, which is actually visible to the user and is relative to the,`body`,
      * e.g. an original rect cropped by parent element rects which have `overflow` set in CSS
      * other than `"visible"`.
      *
      * If there's no such visible rect, which is when the rect is limited by one or many of
      * the ancestors, `null` is returned.
      *
      * **Note**: This method does not consider the boundaries of the viewport (window).
      * To get a rect cropped by all ancestors and the viewport, use an intersection such as:
      *
      * ```ts
      * const visibleInViewportRect = new Rect( window ).getIntersection( new Rect( source ).getVisible() );
      * ```
      *
      * @returns A visible rect instance or `null`, if there's none.
      */
      getVisible() {
        const source = this._source;
        let visibleRect = this.clone();
        if (isBody(source)) {
          return visibleRect;
        }
        let child = source;
        let parent2 = source.parentNode || source.commonAncestorContainer;
        let absolutelyPositionedChildElement;
        while (parent2 && !isBody(parent2)) {
          const isParentOverflowVisible = getElementOverflow(parent2) === "visible";
          if (child instanceof HTMLElement && getElementPosition(child) === "absolute") {
            absolutelyPositionedChildElement = child;
          }
          const parentElementPosition = getElementPosition(parent2);
          if (isParentOverflowVisible || absolutelyPositionedChildElement && (parentElementPosition === "relative" && isParentOverflowVisible || parentElementPosition !== "relative")) {
            child = parent2;
            parent2 = parent2.parentNode;
            continue;
          }
          const parentRect = new Rect(parent2);
          const intersectionRect = visibleRect.getIntersection(parentRect);
          if (intersectionRect) {
            if (intersectionRect.getArea() < visibleRect.getArea()) {
              visibleRect = intersectionRect;
            }
          } else {
            return null;
          }
          child = parent2;
          parent2 = parent2.parentNode;
        }
        return visibleRect;
      }
      /**
      * Checks if all property values ({@link #top}, {@link #left}, {@link #right},
      * {@link #bottom}, {@link #width} and {@link #height}) are the equal in both rect
      * instances.
      *
      * @param anotherRect A rect instance to compare with.
      * @returns `true` when Rects are equal. `false` otherwise.
      */
      isEqual(anotherRect) {
        for (const prop of rectProperties) {
          if (this[prop] !== anotherRect[prop]) {
            return false;
          }
        }
        return true;
      }
      /**
      * Checks whether a rect fully contains another rect instance.
      *
      * @param anotherRect
      * @returns `true` if contains, `false` otherwise.
      */
      contains(anotherRect) {
        const intersectRect = this.getIntersection(anotherRect);
        return !!(intersectRect && intersectRect.isEqual(anotherRect));
      }
      /**
      * Recalculates screen coordinates to coordinates relative to the positioned ancestor offset.
      */
      toAbsoluteRect() {
        const { scrollX, scrollY } = global$1.window;
        const absoluteRect = this.clone().moveBy(scrollX, scrollY);
        if (isDomElement(absoluteRect._source)) {
          const positionedAncestor = getPositionedAncestor(absoluteRect._source);
          if (positionedAncestor) {
            shiftRectToCompensatePositionedAncestor(absoluteRect, positionedAncestor);
          }
        }
        return absoluteRect;
      }
      /**
      * Excludes scrollbars and CSS borders from the rect.
      *
      * * Borders are removed when {@link #_source} is an HTML element.
      * * Scrollbars are excluded from HTML elements and the `window`.
      *
      * @returns A rect which has been updated.
      */
      excludeScrollbarsAndBorders() {
        const source = this._source;
        let scrollBarWidth, scrollBarHeight, direction;
        if (isWindow(source)) {
          scrollBarWidth = source.innerWidth - source.document.documentElement.clientWidth;
          scrollBarHeight = source.innerHeight - source.document.documentElement.clientHeight;
          direction = source.getComputedStyle(source.document.documentElement).direction;
        } else {
          const borderWidths = getBorderWidths(source);
          scrollBarWidth = source.offsetWidth - source.clientWidth - borderWidths.left - borderWidths.right;
          scrollBarHeight = source.offsetHeight - source.clientHeight - borderWidths.top - borderWidths.bottom;
          direction = source.ownerDocument.defaultView.getComputedStyle(source).direction;
          this.left += borderWidths.left;
          this.top += borderWidths.top;
          this.right -= borderWidths.right;
          this.bottom -= borderWidths.bottom;
          this.width = this.right - this.left;
          this.height = this.bottom - this.top;
        }
        this.width -= scrollBarWidth;
        if (direction === "ltr") {
          this.right -= scrollBarWidth;
        } else {
          this.left += scrollBarWidth;
        }
        this.height -= scrollBarHeight;
        this.bottom -= scrollBarHeight;
        return this;
      }
      /**
      * Returns an array of rects of the given native DOM Range.
      *
      * @param range A native DOM range.
      * @returns DOM Range rects.
      */
      static getDomRangeRects(range2) {
        const rects = [];
        const clientRects = Array.from(range2.getClientRects());
        if (clientRects.length) {
          for (const rect of clientRects) {
            rects.push(new Rect(rect));
          }
        } else {
          let startContainer = range2.startContainer;
          if (isText(startContainer)) {
            startContainer = startContainer.parentNode;
          }
          const rect = new Rect(startContainer.getBoundingClientRect());
          rect.right = rect.left;
          rect.width = 0;
          rects.push(rect);
        }
        return rects;
      }
      /**
      * Returns a bounding rectangle that contains all the given `rects`.
      *
      * @param rects A list of rectangles that should be contained in the result rectangle.
      * @returns Bounding rectangle or `null` if no `rects` were given.
      */
      static getBoundingRect(rects) {
        const boundingRectData = {
          left: Number.POSITIVE_INFINITY,
          top: Number.POSITIVE_INFINITY,
          right: Number.NEGATIVE_INFINITY,
          bottom: Number.NEGATIVE_INFINITY,
          width: 0,
          height: 0
        };
        let rectangleCount = 0;
        for (const rect of rects) {
          rectangleCount++;
          boundingRectData.left = Math.min(boundingRectData.left, rect.left);
          boundingRectData.top = Math.min(boundingRectData.top, rect.top);
          boundingRectData.right = Math.max(boundingRectData.right, rect.right);
          boundingRectData.bottom = Math.max(boundingRectData.bottom, rect.bottom);
        }
        if (rectangleCount == 0) {
          return null;
        }
        boundingRectData.width = boundingRectData.right - boundingRectData.left;
        boundingRectData.height = boundingRectData.bottom - boundingRectData.top;
        return new Rect(boundingRectData);
      }
    }
    function copyRectProperties(rect, source) {
      for (const p2 of rectProperties) {
        rect[p2] = source[p2];
      }
    }
    function isBody(value) {
      if (!isDomElement(value)) {
        return false;
      }
      return value === value.ownerDocument.body;
    }
    function isDomElement(value) {
      return value !== null && typeof value === "object" && value.nodeType === 1 && typeof value.getBoundingClientRect === "function";
    }
    function getElementPosition(element) {
      return element instanceof HTMLElement ? element.ownerDocument.defaultView.getComputedStyle(element).position : "static";
    }
    function getElementOverflow(element) {
      return element instanceof HTMLElement ? element.ownerDocument.defaultView.getComputedStyle(element).overflow : "visible";
    }
    function shiftRectToCompensatePositionedAncestor(rect, positionedElementAncestor) {
      const ancestorPosition = new Rect(positionedElementAncestor);
      const ancestorBorderWidths = getBorderWidths(positionedElementAncestor);
      let moveX = 0;
      let moveY = 0;
      moveX -= ancestorPosition.left;
      moveY -= ancestorPosition.top;
      moveX += positionedElementAncestor.scrollLeft;
      moveY += positionedElementAncestor.scrollTop;
      moveX -= ancestorBorderWidths.left;
      moveY -= ancestorBorderWidths.top;
      rect.moveBy(moveX, moveY);
    }
    let ResizeObserver$1 = (_a = class {
      /**
      * Creates an instance of the `ResizeObserver` class.
      *
      * @param element A DOM element that is to be observed for resizing. Note that
      * the element must be visible (i.e. not detached from DOM) for the observer to work.
      * @param callback A function called when the observed element was resized. It passes
      * the [`ResizeObserverEntry`](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserverEntry)
      * object with information about the resize event.
      */
      constructor(element, callback) {
        /**
        * The element observed by this observer.
        */
        __publicField(this, "_element");
        /**
        * The callback executed each time {@link #_element} is resized.
        */
        __publicField(this, "_callback");
        if (!_a._observerInstance) {
          _a._createObserver();
        }
        this._element = element;
        this._callback = callback;
        _a._addElementCallback(element, callback);
        _a._observerInstance.observe(element);
      }
      /**
      * The element observed by this observer.
      */
      get element() {
        return this._element;
      }
      /**
      * Destroys the observer which disables the `callback` passed to the {@link #constructor}.
      */
      destroy() {
        _a._deleteElementCallback(this._element, this._callback);
      }
      /**
      * Registers a new resize callback for the DOM element.
      */
      static _addElementCallback(element, callback) {
        if (!_a._elementCallbacks) {
          _a._elementCallbacks = /* @__PURE__ */ new Map();
        }
        let callbacks = _a._elementCallbacks.get(element);
        if (!callbacks) {
          callbacks = /* @__PURE__ */ new Set();
          _a._elementCallbacks.set(element, callbacks);
        }
        callbacks.add(callback);
      }
      /**
      * Removes a resize callback from the DOM element. If no callbacks are left
      * for the element, it removes the element from the native observer.
      */
      static _deleteElementCallback(element, callback) {
        const callbacks = _a._getElementCallbacks(element);
        if (callbacks) {
          callbacks.delete(callback);
          if (!callbacks.size) {
            _a._elementCallbacks.delete(element);
            _a._observerInstance.unobserve(element);
          }
        }
        if (_a._elementCallbacks && !_a._elementCallbacks.size) {
          _a._observerInstance = null;
          _a._elementCallbacks = null;
        }
      }
      /**
      * Returns are registered resize callbacks for the DOM element.
      */
      static _getElementCallbacks(element) {
        if (!_a._elementCallbacks) {
          return null;
        }
        return _a._elementCallbacks.get(element);
      }
      /**
      * Creates the single native observer shared across all `ResizeObserver` instances.
      */
      static _createObserver() {
        _a._observerInstance = new global$1.window.ResizeObserver((entries) => {
          for (const entry of entries) {
            const callbacks = _a._getElementCallbacks(entry.target);
            if (callbacks) {
              for (const callback of callbacks) {
                callback(entry);
              }
            }
          }
        });
      }
    }, /**
    * The single native observer instance shared across all {@link module:utils/dom/resizeobserver~ResizeObserver} instances.
    */
    __publicField(_a, "_observerInstance", null), /**
    * A mapping of native DOM elements and their callbacks shared across all
    * {@link module:utils/dom/resizeobserver~ResizeObserver} instances.
    */
    __publicField(_a, "_elementCallbacks", null), _a);
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function setDataInElement(el, data) {
      if (el instanceof HTMLTextAreaElement) {
        el.value = data;
      }
      el.innerHTML = data;
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function toUnit(unit) {
      return (value) => value + unit;
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function indexOf(node) {
      let index = 0;
      while (node.previousSibling) {
        node = node.previousSibling;
        index++;
      }
      return index;
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function insertAt(parentElement, index, nodeToInsert) {
      parentElement.insertBefore(nodeToInsert, parentElement.childNodes[index] || null);
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function isComment(obj) {
      return obj && obj.nodeType === Node.COMMENT_NODE;
    }
    function isValidAttributeName(name) {
      try {
        global$1.document.createAttribute(name);
      } catch (error) {
        return false;
      }
      return true;
    }
    function isVisible(element) {
      if (!element) {
        return false;
      }
      if (isText(element)) {
        return isVisible(element.parentElement);
      }
      if (element.getClientRects) {
        return !!element.getClientRects().length;
      }
      return false;
    }
    function getOptimalPosition({ element, target, positions, limiter, fitInViewport, viewportOffsetConfig }) {
      if (isFunction(target)) {
        target = target();
      }
      if (isFunction(limiter)) {
        limiter = limiter();
      }
      const positionedElementAncestor = getPositionedAncestor(element);
      const constrainedViewportRect = getConstrainedViewportRect(viewportOffsetConfig);
      const elementRect = new Rect(element);
      const visibleTargetRect = getVisibleViewportIntersectionRect(target, constrainedViewportRect);
      let bestPosition;
      if (!visibleTargetRect || !constrainedViewportRect.getIntersection(visibleTargetRect)) {
        return null;
      }
      const positionOptions = {
        targetRect: visibleTargetRect,
        elementRect,
        positionedElementAncestor,
        viewportRect: constrainedViewportRect
      };
      if (!limiter && !fitInViewport) {
        bestPosition = new PositionObject(positions[0], positionOptions);
      } else {
        if (limiter) {
          const visibleLimiterRect = getVisibleViewportIntersectionRect(limiter, constrainedViewportRect);
          if (visibleLimiterRect) {
            positionOptions.limiterRect = visibleLimiterRect;
          }
        }
        bestPosition = getBestPosition(positions, positionOptions);
      }
      return bestPosition;
    }
    function getVisibleViewportIntersectionRect(source, viewportRect) {
      const visibleSourceRect = new Rect(source).getVisible();
      if (!visibleSourceRect) {
        return null;
      }
      return visibleSourceRect.getIntersection(viewportRect);
    }
    function getConstrainedViewportRect(viewportOffsetConfig) {
      viewportOffsetConfig = Object.assign({
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      }, viewportOffsetConfig);
      const viewportRect = new Rect(global$1.window);
      viewportRect.top += viewportOffsetConfig.top;
      viewportRect.height -= viewportOffsetConfig.top;
      viewportRect.bottom -= viewportOffsetConfig.bottom;
      viewportRect.height -= viewportOffsetConfig.bottom;
      return viewportRect;
    }
    function getBestPosition(positions, options) {
      const { elementRect } = options;
      const elementRectArea = elementRect.getArea();
      const positionInstances = positions.map((positioningFunction) => new PositionObject(positioningFunction, options)).filter((position) => !!position.name);
      let maxFitFactor = 0;
      let bestPosition = null;
      for (const position of positionInstances) {
        const { limiterIntersectionArea, viewportIntersectionArea } = position;
        if (limiterIntersectionArea === elementRectArea) {
          return position;
        }
        const fitFactor = viewportIntersectionArea ** 2 + limiterIntersectionArea ** 2;
        if (fitFactor > maxFitFactor) {
          maxFitFactor = fitFactor;
          bestPosition = position;
        }
      }
      return bestPosition;
    }
    class PositionObject {
      /**
      * Creates an instance of the {@link module:utils/dom/position~PositionObject} class.
      *
      * @param positioningFunction function The function that defines the expected
      * coordinates the positioned element should move to.
      * @param options options object.
      * @param options.elementRect The positioned element rect.
      * @param options.targetRect The target element rect.
      * @param options.viewportRect The viewport rect.
      * @param options.limiterRect The limiter rect.
      * @param options.positionedElementAncestor Nearest element ancestor element which CSS position is not "static".
      */
      constructor(positioningFunction, options) {
        __publicField(this, "name");
        __publicField(this, "config");
        __publicField(this, "_positioningFunctionCoordinates");
        __publicField(this, "_options");
        __publicField(this, "_cachedRect");
        __publicField(this, "_cachedAbsoluteRect");
        const positioningFunctionOutput = positioningFunction(options.targetRect, options.elementRect, options.viewportRect, options.limiterRect);
        if (!positioningFunctionOutput) {
          return;
        }
        const { left: left2, top: top2, name, config: config2 } = positioningFunctionOutput;
        this.name = name;
        this.config = config2;
        this._positioningFunctionCoordinates = {
          left: left2,
          top: top2
        };
        this._options = options;
      }
      /**
      * The left value in pixels in the CSS `position: absolute` coordinate system.
      * Set it on the positioned element in DOM to move it to the position.
      */
      get left() {
        return this._absoluteRect.left;
      }
      /**
      * The top value in pixels in the CSS `position: absolute` coordinate system.
      * Set it on the positioned element in DOM to move it to the position.
      */
      get top() {
        return this._absoluteRect.top;
      }
      /**
      * An intersection area between positioned element and limiter within viewport constraints.
      */
      get limiterIntersectionArea() {
        const limiterRect = this._options.limiterRect;
        if (limiterRect) {
          return limiterRect.getIntersectionArea(this._rect);
        }
        return 0;
      }
      /**
      * An intersection area between positioned element and viewport.
      */
      get viewportIntersectionArea() {
        const viewportRect = this._options.viewportRect;
        return viewportRect.getIntersectionArea(this._rect);
      }
      /**
      * An already positioned element rect. A clone of the element rect passed to the constructor
      * but placed in the viewport according to the positioning function.
      */
      get _rect() {
        if (this._cachedRect) {
          return this._cachedRect;
        }
        this._cachedRect = this._options.elementRect.clone().moveTo(this._positioningFunctionCoordinates.left, this._positioningFunctionCoordinates.top);
        return this._cachedRect;
      }
      /**
      * An already absolutely positioned element rect. See ({@link #_rect}).
      */
      get _absoluteRect() {
        if (this._cachedAbsoluteRect) {
          return this._cachedAbsoluteRect;
        }
        this._cachedAbsoluteRect = this._rect.toAbsoluteRect();
        return this._cachedAbsoluteRect;
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function remove$1(node) {
      const parent2 = node.parentNode;
      if (parent2) {
        parent2.removeChild(node);
      }
    }
    function scrollViewportToShowTarget({ target, viewportOffset = 0, ancestorOffset = 0, alignToTop, forceScroll }) {
      const targetWindow = getWindow$1(target);
      let currentWindow = targetWindow;
      let currentFrame = null;
      viewportOffset = normalizeViewportOffset(viewportOffset);
      while (currentWindow) {
        let firstAncestorToScroll;
        if (currentWindow == targetWindow) {
          firstAncestorToScroll = getParentElement(target);
        } else {
          firstAncestorToScroll = getParentElement(currentFrame);
        }
        scrollAncestorsToShowRect({
          parent: firstAncestorToScroll,
          getRect: () => {
            return getRectRelativeToWindow(target, currentWindow);
          },
          alignToTop,
          ancestorOffset,
          forceScroll
        });
        const targetRect = getRectRelativeToWindow(target, currentWindow);
        scrollWindowToShowRect({
          window: currentWindow,
          rect: targetRect,
          viewportOffset,
          alignToTop,
          forceScroll
        });
        if (currentWindow.parent != currentWindow) {
          currentFrame = currentWindow.frameElement;
          currentWindow = currentWindow.parent;
          if (!currentFrame) {
            return;
          }
        } else {
          currentWindow = null;
        }
      }
    }
    function scrollWindowToShowRect({ window: window2, rect, alignToTop, forceScroll, viewportOffset }) {
      const targetShiftedDownRect = rect.clone().moveBy(0, viewportOffset.bottom);
      const targetShiftedUpRect = rect.clone().moveBy(0, -viewportOffset.top);
      const viewportRect = new Rect(window2).excludeScrollbarsAndBorders();
      const rects = [
        targetShiftedUpRect,
        targetShiftedDownRect
      ];
      const forceScrollToTop = alignToTop && forceScroll;
      const allRectsFitInViewport = rects.every((rect2) => viewportRect.contains(rect2));
      let { scrollX, scrollY } = window2;
      const initialScrollX = scrollX;
      const initialScrollY = scrollY;
      if (forceScrollToTop) {
        scrollY -= viewportRect.top - rect.top + viewportOffset.top;
      } else if (!allRectsFitInViewport) {
        if (isAbove(targetShiftedUpRect, viewportRect)) {
          scrollY -= viewportRect.top - rect.top + viewportOffset.top;
        } else if (isBelow(targetShiftedDownRect, viewportRect)) {
          if (alignToTop) {
            scrollY += rect.top - viewportRect.top - viewportOffset.top;
          } else {
            scrollY += rect.bottom - viewportRect.bottom + viewportOffset.bottom;
          }
        }
      }
      if (!allRectsFitInViewport) {
        if (isLeftOf(rect, viewportRect)) {
          scrollX -= viewportRect.left - rect.left + viewportOffset.left;
        } else if (isRightOf(rect, viewportRect)) {
          scrollX += rect.right - viewportRect.right + viewportOffset.right;
        }
      }
      if (scrollX != initialScrollX || scrollY !== initialScrollY) {
        window2.scrollTo(scrollX, scrollY);
      }
    }
    function scrollAncestorsToShowRect({ parent: parent2, getRect, alignToTop, forceScroll, ancestorOffset = 0, limiterElement }) {
      const parentWindow = getWindow$1(parent2);
      const forceScrollToTop = alignToTop && forceScroll;
      let parentRect, targetRect, targetFitsInTarget;
      const limiter = limiterElement || parentWindow.document.body;
      while (parent2 != limiter) {
        targetRect = getRect();
        parentRect = new Rect(parent2).excludeScrollbarsAndBorders();
        targetFitsInTarget = parentRect.contains(targetRect);
        if (forceScrollToTop) {
          parent2.scrollTop -= parentRect.top - targetRect.top + ancestorOffset;
        } else if (!targetFitsInTarget) {
          if (isAbove(targetRect, parentRect)) {
            parent2.scrollTop -= parentRect.top - targetRect.top + ancestorOffset;
          } else if (isBelow(targetRect, parentRect)) {
            if (alignToTop) {
              parent2.scrollTop += targetRect.top - parentRect.top - ancestorOffset;
            } else {
              parent2.scrollTop += targetRect.bottom - parentRect.bottom + ancestorOffset;
            }
          }
        }
        if (!targetFitsInTarget) {
          if (isLeftOf(targetRect, parentRect)) {
            parent2.scrollLeft -= parentRect.left - targetRect.left + ancestorOffset;
          } else if (isRightOf(targetRect, parentRect)) {
            parent2.scrollLeft += targetRect.right - parentRect.right + ancestorOffset;
          }
        }
        parent2 = parent2.parentNode;
      }
    }
    function isBelow(firstRect, secondRect) {
      return firstRect.bottom > secondRect.bottom;
    }
    function isAbove(firstRect, secondRect) {
      return firstRect.top < secondRect.top;
    }
    function isLeftOf(firstRect, secondRect) {
      return firstRect.left < secondRect.left;
    }
    function isRightOf(firstRect, secondRect) {
      return firstRect.right > secondRect.right;
    }
    function getWindow$1(elementOrRange) {
      if (isRange(elementOrRange)) {
        return elementOrRange.startContainer.ownerDocument.defaultView;
      } else {
        return elementOrRange.ownerDocument.defaultView;
      }
    }
    function getParentElement(elementOrRange) {
      if (isRange(elementOrRange)) {
        let parent2 = elementOrRange.commonAncestorContainer;
        if (isText(parent2)) {
          parent2 = parent2.parentNode;
        }
        return parent2;
      } else {
        return elementOrRange.parentNode;
      }
    }
    function getRectRelativeToWindow(target, relativeWindow) {
      const targetWindow = getWindow$1(target);
      const rect = new Rect(target);
      if (targetWindow === relativeWindow) {
        return rect;
      } else {
        let currentWindow = targetWindow;
        while (currentWindow != relativeWindow) {
          const frame = currentWindow.frameElement;
          const frameRect = new Rect(frame).excludeScrollbarsAndBorders();
          rect.moveBy(frameRect.left, frameRect.top);
          currentWindow = currentWindow.parent;
        }
      }
      return rect;
    }
    function normalizeViewportOffset(viewportOffset) {
      if (typeof viewportOffset === "number") {
        return {
          top: viewportOffset,
          bottom: viewportOffset,
          left: viewportOffset,
          right: viewportOffset
        };
      }
      return viewportOffset;
    }
    const modifiersToGlyphsMac = {
      ctrl: "",
      cmd: "",
      alt: "",
      shift: ""
    };
    const modifiersToGlyphsNonMac = {
      ctrl: "Ctrl+",
      alt: "Alt+",
      shift: "Shift+"
    };
    const keyCodesToGlyphs = {
      37: "",
      38: "",
      39: "",
      40: "",
      9: "",
      33: "Page Up",
      34: "Page Down"
    };
    const keyCodes = /* @__PURE__ */ generateKnownKeyCodes();
    const keyCodeNames = /* @__PURE__ */ Object.fromEntries(/* @__PURE__ */ Object.entries(keyCodes).map(([name, code]) => {
      let prettyKeyName;
      if (code in keyCodesToGlyphs) {
        prettyKeyName = keyCodesToGlyphs[code];
      } else {
        prettyKeyName = name.charAt(0).toUpperCase() + name.slice(1);
      }
      return [
        code,
        prettyKeyName
      ];
    }));
    function getCode(key) {
      let keyCode;
      if (typeof key == "string") {
        keyCode = keyCodes[key.toLowerCase()];
        if (!keyCode) {
          throw new CKEditorError("keyboard-unknown-key", null, {
            key
          });
        }
      } else {
        keyCode = key.keyCode + (key.altKey ? keyCodes.alt : 0) + (key.ctrlKey ? keyCodes.ctrl : 0) + (key.shiftKey ? keyCodes.shift : 0) + (key.metaKey ? keyCodes.cmd : 0);
      }
      return keyCode;
    }
    function parseKeystroke(keystroke) {
      if (typeof keystroke == "string") {
        keystroke = splitKeystrokeText(keystroke);
      }
      return keystroke.map((key) => typeof key == "string" ? getEnvKeyCode(key) : key).reduce((key, sum2) => sum2 + key, 0);
    }
    function getEnvKeystrokeText(keystroke) {
      let keystrokeCode = parseKeystroke(keystroke);
      const modifiersToGlyphs = Object.entries(env.isMac || env.isiOS ? modifiersToGlyphsMac : modifiersToGlyphsNonMac);
      const modifiers = modifiersToGlyphs.reduce((modifiers2, [name, glyph]) => {
        if ((keystrokeCode & keyCodes[name]) != 0) {
          keystrokeCode &= ~keyCodes[name];
          modifiers2 += glyph;
        }
        return modifiers2;
      }, "");
      return modifiers + (keystrokeCode ? keyCodeNames[keystrokeCode] : "");
    }
    function isArrowKeyCode(keyCode) {
      return keyCode == keyCodes.arrowright || keyCode == keyCodes.arrowleft || keyCode == keyCodes.arrowup || keyCode == keyCodes.arrowdown;
    }
    function getLocalizedArrowKeyCodeDirection(keyCode, contentLanguageDirection) {
      const isLtrContent = contentLanguageDirection === "ltr";
      switch (keyCode) {
        case keyCodes.arrowleft:
          return isLtrContent ? "left" : "right";
        case keyCodes.arrowright:
          return isLtrContent ? "right" : "left";
        case keyCodes.arrowup:
          return "up";
        case keyCodes.arrowdown:
          return "down";
      }
    }
    function getEnvKeyCode(key) {
      if (key.endsWith("!")) {
        return getCode(key.slice(0, -1));
      }
      const code = getCode(key);
      return (env.isMac || env.isiOS) && code == keyCodes.ctrl ? keyCodes.cmd : code;
    }
    function isForwardArrowKeyCode(keyCode, contentLanguageDirection) {
      const localizedKeyCodeDirection = getLocalizedArrowKeyCodeDirection(keyCode, contentLanguageDirection);
      return localizedKeyCodeDirection === "down" || localizedKeyCodeDirection === "right";
    }
    function generateKnownKeyCodes() {
      const keyCodes2 = {
        pageup: 33,
        pagedown: 34,
        arrowleft: 37,
        arrowup: 38,
        arrowright: 39,
        arrowdown: 40,
        backspace: 8,
        delete: 46,
        enter: 13,
        space: 32,
        esc: 27,
        tab: 9,
        // The idea about these numbers is that they do not collide with any real key codes, so we can use them
        // like bit masks.
        ctrl: 1114112,
        shift: 2228224,
        alt: 4456448,
        cmd: 8912896
      };
      for (let code = 65; code <= 90; code++) {
        const letter = String.fromCharCode(code);
        keyCodes2[letter.toLowerCase()] = code;
      }
      for (let code = 48; code <= 57; code++) {
        keyCodes2[code - 48] = code;
      }
      for (let code = 112; code <= 123; code++) {
        keyCodes2["f" + (code - 111)] = code;
      }
      Object.assign(keyCodes2, {
        "'": 222,
        ",": 108,
        "-": 109,
        ".": 110,
        "/": 111,
        ";": 186,
        "=": 187,
        "[": 219,
        "\\": 220,
        "]": 221,
        "`": 223
      });
      return keyCodes2;
    }
    function splitKeystrokeText(keystroke) {
      return keystroke.split("+").map((key) => key.trim());
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    const RTL_LANGUAGE_CODES = [
      "ar",
      "ara",
      "dv",
      "div",
      "fa",
      "per",
      "fas",
      "he",
      "heb",
      "ku",
      "kur",
      "ug",
      "uig"
      // Uighur, Uyghur
    ];
    function getLanguageDirection(languageCode) {
      return RTL_LANGUAGE_CODES.includes(languageCode) ? "rtl" : "ltr";
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function toArray$2(data) {
      return Array.isArray(data) ? data : [
        data
      ];
    }
    /* istanbul ignore else -- @preserve */
    if (!global$1.window.CKEDITOR_TRANSLATIONS) {
      global$1.window.CKEDITOR_TRANSLATIONS = {};
    }
    function _translate(language, message, quantity = 1, translations) {
      if (typeof quantity !== "number") {
        throw new CKEditorError("translation-service-quantity-not-a-number", null, {
          quantity
        });
      }
      const normalizedTranslations = translations || global$1.window.CKEDITOR_TRANSLATIONS;
      const numberOfLanguages = getNumberOfLanguages(normalizedTranslations);
      if (numberOfLanguages === 1) {
        language = Object.keys(normalizedTranslations)[0];
      }
      const messageId = message.id || message.string;
      if (numberOfLanguages === 0 || !hasTranslation(language, messageId, normalizedTranslations)) {
        if (quantity !== 1) {
          return message.plural;
        }
        return message.string;
      }
      const dictionary = normalizedTranslations[language].dictionary;
      const getPluralForm = normalizedTranslations[language].getPluralForm || ((n2) => n2 === 1 ? 0 : 1);
      const translation = dictionary[messageId];
      if (typeof translation === "string") {
        return translation;
      }
      const pluralFormIndex = Number(getPluralForm(quantity));
      return translation[pluralFormIndex];
    }
    function _unifyTranslations(translations) {
      return Array.isArray(translations) ? translations.reduce((acc, translation) => merge$1(acc, translation)) : translations;
    }
    function hasTranslation(language, messageId, translations) {
      return !!translations[language] && !!translations[language].dictionary[messageId];
    }
    function getNumberOfLanguages(translations) {
      return Object.keys(translations).length;
    }
    class Locale {
      /**
      * Creates a new instance of the locale class. Learn more about
      * {@glink getting-started/setup/ui-language configuring the language of the editor}.
      *
      * @param options Locale configuration.
      * @param options.uiLanguage The editor UI language code in the
      * [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) format. See {@link #uiLanguage}.
      * @param options.contentLanguage The editor content language code in the
      * [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) format. If not specified, the same as `options.language`.
      * See {@link #contentLanguage}.
      * @param translations Translations passed as a editor config parameter.
      */
      constructor({ uiLanguage = "en", contentLanguage, translations } = {}) {
        /**
        * The editor UI language code in the [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) format.
        *
        * If the {@link #contentLanguage content language} was not specified in the `Locale` constructor,
        * it also defines the language of the content.
        */
        __publicField(this, "uiLanguage");
        /**
        * Text direction of the {@link #uiLanguage editor UI language}. Either `'ltr'` or `'rtl'`.
        */
        __publicField(this, "uiLanguageDirection");
        /**
        * The editor content language code in the [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) format.
        *
        * Usually the same as the {@link #uiLanguage editor language}, it can be customized by passing an optional
        * argument to the `Locale` constructor.
        */
        __publicField(this, "contentLanguage");
        /**
        * Text direction of the {@link #contentLanguage editor content language}.
        *
        * If the content language was passed directly to the `Locale` constructor, this property represents the
        * direction of that language.
        *
        * If the {@link #contentLanguage editor content language} was derived from the {@link #uiLanguage editor language},
        * the content language direction is the same as the {@link #uiLanguageDirection UI language direction}.
        *
        * The value is either `'ltr'` or `'rtl'`.
        */
        __publicField(this, "contentLanguageDirection");
        /**
        * Translates the given message to the {@link #uiLanguage}. This method is also available in
        * {@link module:core/editor/editor~Editor#t `Editor`} and {@link module:ui/view~View#t `View`}.
        *
        * This method's context is statically bound to the `Locale` instance and **should always be called as a function**:
        *
        * ```ts
        * const t = locale.t;
        * t( 'Label' );
        * ```
        *
        * The message can be either a string or an object implementing the {@link module:utils/translation-service~Message} interface.
        *
        * The message may contain placeholders (`%<index>`) for value(s) that are passed as a `values` parameter.
        * For an array of values, the `%<index>` will be changed to an element of that array at the given index.
        * For a single value passed as the second argument, only the `%0` placeholders will be changed to the provided value.
        *
        * ```ts
        * t( 'Created file "%0" in %1ms.', [ fileName, timeTaken ] );
        * t( 'Created file "%0", fileName );
        * ```
        *
        * The message supports plural forms. To specify the plural form, use the `plural` property. Singular or plural form
        * will be chosen depending on the first value from the passed `values`. The value of the `plural` property is used
        * as a default plural translation when the translation for the target language is missing.
        *
        * ```ts
        * t( { string: 'Add a space', plural: 'Add %0 spaces' }, 1 ); // 'Add a space' for the English language.
        * t( { string: 'Add a space', plural: 'Add %0 spaces' }, 5 ); // 'Add 5 spaces' for the English language.
        * t( { string: '%1 a space', plural: '%1 %0 spaces' }, [ 2, 'Add' ] ); // 'Add 2 spaces' for the English language.
        *
        * t( { string: 'Add a space', plural: 'Add %0 spaces' }, 1 ); // 'Dodaj spacj' for the Polish language.
        * t( { string: 'Add a space', plural: 'Add %0 spaces' }, 5 ); // 'Dodaj 5 spacji' for the Polish language.
        * t( { string: '%1 a space', plural: '%1 %0 spaces' }, [ 2, 'Add' ] ); // 'Dodaj 2 spacje' for the Polish language.
        * ```
        *
        *  * The message should provide an ID using the `id` property when the message strings are not unique and their
        * translations should be different.
        *
        * ```ts
        * translate( 'en', { string: 'image', id: 'ADD_IMAGE' } );
        * translate( 'en', { string: 'image', id: 'AN_IMAGE' } );
        * ```
        */
        __publicField(this, "t");
        /**
        * Object that contains translations.
        */
        __publicField(this, "translations");
        this.uiLanguage = uiLanguage;
        this.contentLanguage = contentLanguage || this.uiLanguage;
        this.uiLanguageDirection = getLanguageDirection(this.uiLanguage);
        this.contentLanguageDirection = getLanguageDirection(this.contentLanguage);
        this.translations = _unifyTranslations(translations);
        this.t = (message, values2) => this._t(message, values2);
      }
      /**
      * The editor UI language code in the [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) format.
      *
      * **Note**: This property was deprecated. Please use {@link #uiLanguage} and {@link #contentLanguage}
      * properties instead.
      *
      * @deprecated
      */
      get language() {
        console.warn("locale-deprecated-language-property: The Locale#language property has been deprecated and will be removed in the near future. Please use #uiLanguage and #contentLanguage properties instead.");
        return this.uiLanguage;
      }
      /**
      * An unbound version of the {@link #t} method.
      */
      _t(message, values2 = []) {
        values2 = toArray$2(values2);
        if (typeof message === "string") {
          message = {
            string: message
          };
        }
        const hasPluralForm = !!message.plural;
        const quantity = hasPluralForm ? values2[0] : 1;
        const translatedString = _translate(this.uiLanguage, message, quantity, this.translations);
        return interpolateString(translatedString, values2);
      }
    }
    function interpolateString(string2, values2) {
      return string2.replace(/%(\d+)/g, (match, index) => {
        return index < values2.length ? values2[index] : match;
      });
    }
    class Collection extends (/* @__PURE__ */ EmitterMixin()) {
      constructor(initialItemsOrOptions = {}, options = {}) {
        super();
        /**
        * The internal list of items in the collection.
        */
        __publicField(this, "_items");
        /**
        * The internal map of items in the collection.
        */
        __publicField(this, "_itemMap");
        /**
        * The name of the property which is considered to identify an item.
        */
        __publicField(this, "_idProperty");
        /**
        * A collection instance this collection is bound to as a result
        * of calling {@link #bindTo} method.
        */
        __publicField(this, "_bindToCollection");
        /**
        * A helper mapping external items of a bound collection ({@link #bindTo})
        * and actual items of this collection. It provides information
        * necessary to properly remove items bound to another collection.
        *
        * See {@link #_bindToInternalToExternalMap}.
        */
        __publicField(this, "_bindToExternalToInternalMap");
        /**
        * A helper mapping items of this collection to external items of a bound collection
        * ({@link #bindTo}). It provides information necessary to manage the bindings, e.g.
        * to avoid loops in twoway bindings.
        *
        * See {@link #_bindToExternalToInternalMap}.
        */
        __publicField(this, "_bindToInternalToExternalMap");
        /**
        * Stores indexes of skipped items from bound external collection.
        */
        __publicField(this, "_skippedIndexesFromExternal");
        const hasInitialItems = isIterable(initialItemsOrOptions);
        if (!hasInitialItems) {
          options = initialItemsOrOptions;
        }
        this._items = [];
        this._itemMap = /* @__PURE__ */ new Map();
        this._idProperty = options.idProperty || "id";
        this._bindToExternalToInternalMap = /* @__PURE__ */ new WeakMap();
        this._bindToInternalToExternalMap = /* @__PURE__ */ new WeakMap();
        this._skippedIndexesFromExternal = [];
        if (hasInitialItems) {
          for (const item of initialItemsOrOptions) {
            this._items.push(item);
            this._itemMap.set(this._getItemIdBeforeAdding(item), item);
          }
        }
      }
      /**
      * The number of items available in the collection.
      */
      get length() {
        return this._items.length;
      }
      /**
      * Returns the first item from the collection or null when collection is empty.
      */
      get first() {
        return this._items[0] || null;
      }
      /**
      * Returns the last item from the collection or null when collection is empty.
      */
      get last() {
        return this._items[this.length - 1] || null;
      }
      /**
      * Adds an item into the collection.
      *
      * If the item does not have an id, then it will be automatically generated and set on the item.
      *
      * @param item
      * @param index The position of the item in the collection. The item
      * is pushed to the collection when `index` not specified.
      * @fires add
      * @fires change
      */
      add(item, index) {
        return this.addMany([
          item
        ], index);
      }
      /**
      * Adds multiple items into the collection.
      *
      * Any item not containing an id will get an automatically generated one.
      *
      * @param items
      * @param index The position of the insertion. Items will be appended if no `index` is specified.
      * @fires add
      * @fires change
      */
      addMany(items, index) {
        if (index === void 0) {
          index = this._items.length;
        } else if (index > this._items.length || index < 0) {
          throw new CKEditorError("collection-add-item-invalid-index", this);
        }
        let offset2 = 0;
        for (const item of items) {
          const itemId = this._getItemIdBeforeAdding(item);
          const currentItemIndex = index + offset2;
          this._items.splice(currentItemIndex, 0, item);
          this._itemMap.set(itemId, item);
          this.fire("add", item, currentItemIndex);
          offset2++;
        }
        this.fire("change", {
          added: items,
          removed: [],
          index
        });
        return this;
      }
      /**
      * Gets an item by its ID or index.
      *
      * @param idOrIndex The item ID or index in the collection.
      * @returns The requested item or `null` if such item does not exist.
      */
      get(idOrIndex) {
        let item;
        if (typeof idOrIndex == "string") {
          item = this._itemMap.get(idOrIndex);
        } else if (typeof idOrIndex == "number") {
          item = this._items[idOrIndex];
        } else {
          throw new CKEditorError("collection-get-invalid-arg", this);
        }
        return item || null;
      }
      /**
      * Returns a Boolean indicating whether the collection contains an item.
      *
      * @param itemOrId The item or its ID in the collection.
      * @returns `true` if the collection contains the item, `false` otherwise.
      */
      has(itemOrId) {
        if (typeof itemOrId == "string") {
          return this._itemMap.has(itemOrId);
        } else {
          const idProperty = this._idProperty;
          const id = itemOrId[idProperty];
          return id && this._itemMap.has(id);
        }
      }
      /**
      * Gets an index of an item in the collection.
      * When an item is not defined in the collection, the index will equal -1.
      *
      * @param itemOrId The item or its ID in the collection.
      * @returns The index of a given item.
      */
      getIndex(itemOrId) {
        let item;
        if (typeof itemOrId == "string") {
          item = this._itemMap.get(itemOrId);
        } else {
          item = itemOrId;
        }
        return item ? this._items.indexOf(item) : -1;
      }
      /**
      * Removes an item from the collection.
      *
      * @param subject The item to remove, its ID or index in the collection.
      * @returns The removed item.
      * @fires remove
      * @fires change
      */
      remove(subject) {
        const [item, index] = this._remove(subject);
        this.fire("change", {
          added: [],
          removed: [
            item
          ],
          index
        });
        return item;
      }
      /**
      * Executes the callback for each item in the collection and composes an array or values returned by this callback.
      *
      * @typeParam U The result type of the callback.
      * @param callback
      * @param ctx Context in which the `callback` will be called.
      * @returns The result of mapping.
      */
      map(callback, ctx) {
        return this._items.map(callback, ctx);
      }
      /**
      * Performs the specified action for each item in the collection.
      *
      * @param ctx Context in which the `callback` will be called.
      */
      forEach(callback, ctx) {
        this._items.forEach(callback, ctx);
      }
      /**
      * Finds the first item in the collection for which the `callback` returns a true value.
      *
      * @param callback
      * @param ctx Context in which the `callback` will be called.
      * @returns The item for which `callback` returned a true value.
      */
      find(callback, ctx) {
        return this._items.find(callback, ctx);
      }
      /**
      * Returns an array with items for which the `callback` returned a true value.
      *
      * @param callback
      * @param ctx Context in which the `callback` will be called.
      * @returns The array with matching items.
      */
      filter(callback, ctx) {
        return this._items.filter(callback, ctx);
      }
      /**
      * Removes all items from the collection and destroys the binding created using
      * {@link #bindTo}.
      *
      * @fires remove
      * @fires change
      */
      clear() {
        if (this._bindToCollection) {
          this.stopListening(this._bindToCollection);
          this._bindToCollection = null;
        }
        const removedItems = Array.from(this._items);
        while (this.length) {
          this._remove(0);
        }
        this.fire("change", {
          added: [],
          removed: removedItems,
          index: 0
        });
      }
      /**
      * Binds and synchronizes the collection with another one.
      *
      * The binding can be a simple factory:
      *
      * ```ts
      * class FactoryClass {
      * 	public label: string;
      *
      * 	constructor( data: { label: string } ) {
      * 		this.label = data.label;
      * 	}
      * }
      *
      * const source = new Collection<{ label: string }>( { idProperty: 'label' } );
      * const target = new Collection<FactoryClass>();
      *
      * target.bindTo( source ).as( FactoryClass );
      *
      * source.add( { label: 'foo' } );
      * source.add( { label: 'bar' } );
      *
      * console.log( target.length ); // 2
      * console.log( target.get( 1 ).label ); // 'bar'
      *
      * source.remove( 0 );
      * console.log( target.length ); // 1
      * console.log( target.get( 0 ).label ); // 'bar'
      * ```
      *
      * or the factory driven by a custom callback:
      *
      * ```ts
      * class FooClass {
      * 	public label: string;
      *
      * 	constructor( data: { label: string } ) {
      * 		this.label = data.label;
      * 	}
      * }
      *
      * class BarClass {
      * 	public label: string;
      *
      * 	constructor( data: { label: string } ) {
      * 		this.label = data.label;
      * 	}
      * }
      *
      * const source = new Collection<{ label: string }>( { idProperty: 'label' } );
      * const target = new Collection<FooClass | BarClass>();
      *
      * target.bindTo( source ).using( ( item ) => {
      * 	if ( item.label == 'foo' ) {
      * 		return new FooClass( item );
      * 	} else {
      * 		return new BarClass( item );
      * 	}
      * } );
      *
      * source.add( { label: 'foo' } );
      * source.add( { label: 'bar' } );
      *
      * console.log( target.length ); // 2
      * console.log( target.get( 0 ) instanceof FooClass ); // true
      * console.log( target.get( 1 ) instanceof BarClass ); // true
      * ```
      *
      * or the factory out of property name:
      *
      * ```ts
      * const source = new Collection<{ nested: { value: string } }>();
      * const target = new Collection<{ value: string }>();
      *
      * target.bindTo( source ).using( 'nested' );
      *
      * source.add( { nested: { value: 'foo' } } );
      * source.add( { nested: { value: 'bar' } } );
      *
      * console.log( target.length ); // 2
      * console.log( target.get( 0 ).value ); // 'foo'
      * console.log( target.get( 1 ).value ); // 'bar'
      * ```
      *
      * It's possible to skip specified items by returning null value:
      *
      * ```ts
      * const source = new Collection<{ hidden: boolean }>();
      * const target = new Collection<{ hidden: boolean }>();
      *
      * target.bindTo( source ).using( item => {
      * 	if ( item.hidden ) {
      * 		return null;
      * 	}
      *
      * 	return item;
      * } );
      *
      * source.add( { hidden: true } );
      * source.add( { hidden: false } );
      *
      * console.log( source.length ); // 2
      * console.log( target.length ); // 1
      * ```
      *
      * **Note**: {@link #clear} can be used to break the binding.
      *
      * @typeParam S The type of `externalCollection` element.
      * @param externalCollection A collection to be bound.
      * @returns The binding chain object.
      */
      bindTo(externalCollection) {
        if (this._bindToCollection) {
          throw new CKEditorError("collection-bind-to-rebind", this);
        }
        this._bindToCollection = externalCollection;
        return {
          as: (Class) => {
            this._setUpBindToBinding((item) => new Class(item));
          },
          using: (callbackOrProperty) => {
            if (typeof callbackOrProperty == "function") {
              this._setUpBindToBinding(callbackOrProperty);
            } else {
              this._setUpBindToBinding((item) => item[callbackOrProperty]);
            }
          }
        };
      }
      /**
      * Finalizes and activates a binding initiated by {@link #bindTo}.
      *
      * @param factory A function which produces collection items.
      */
      _setUpBindToBinding(factory) {
        const externalCollection = this._bindToCollection;
        const addItem = (evt, externalItem, index) => {
          const isExternalBoundToThis = externalCollection._bindToCollection == this;
          const externalItemBound = externalCollection._bindToInternalToExternalMap.get(externalItem);
          if (isExternalBoundToThis && externalItemBound) {
            this._bindToExternalToInternalMap.set(externalItem, externalItemBound);
            this._bindToInternalToExternalMap.set(externalItemBound, externalItem);
          } else {
            const item = factory(externalItem);
            if (!item) {
              this._skippedIndexesFromExternal.push(index);
              return;
            }
            let finalIndex = index;
            for (const skipped of this._skippedIndexesFromExternal) {
              if (index > skipped) {
                finalIndex--;
              }
            }
            for (const skipped of externalCollection._skippedIndexesFromExternal) {
              if (finalIndex >= skipped) {
                finalIndex++;
              }
            }
            this._bindToExternalToInternalMap.set(externalItem, item);
            this._bindToInternalToExternalMap.set(item, externalItem);
            this.add(item, finalIndex);
            for (let i2 = 0; i2 < externalCollection._skippedIndexesFromExternal.length; i2++) {
              if (finalIndex <= externalCollection._skippedIndexesFromExternal[i2]) {
                externalCollection._skippedIndexesFromExternal[i2]++;
              }
            }
          }
        };
        for (const externalItem of externalCollection) {
          addItem(null, externalItem, externalCollection.getIndex(externalItem));
        }
        this.listenTo(externalCollection, "add", addItem);
        this.listenTo(externalCollection, "remove", (evt, externalItem, index) => {
          const item = this._bindToExternalToInternalMap.get(externalItem);
          if (item) {
            this.remove(item);
          }
          this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce((result2, skipped) => {
            if (index < skipped) {
              result2.push(skipped - 1);
            }
            if (index > skipped) {
              result2.push(skipped);
            }
            return result2;
          }, []);
        });
      }
      /**
      * Returns an unique id property for a given `item`.
      *
      * The method will generate new id and assign it to the `item` if it doesn't have any.
      *
      * @param item Item to be added.
      */
      _getItemIdBeforeAdding(item) {
        const idProperty = this._idProperty;
        let itemId;
        if (idProperty in item) {
          itemId = item[idProperty];
          if (typeof itemId != "string") {
            throw new CKEditorError("collection-add-invalid-id", this);
          }
          if (this.get(itemId)) {
            throw new CKEditorError("collection-add-item-already-exists", this);
          }
        } else {
          item[idProperty] = itemId = uid();
        }
        return itemId;
      }
      /**
      * Core {@link #remove} method implementation shared in other functions.
      *
      * In contrast this method **does not** fire the {@link #event:change} event.
      *
      * @param subject The item to remove, its id or index in the collection.
      * @returns Returns an array with the removed item and its index.
      * @fires remove
      */
      _remove(subject) {
        let index, id, item;
        let itemDoesNotExist = false;
        const idProperty = this._idProperty;
        if (typeof subject == "string") {
          id = subject;
          item = this._itemMap.get(id);
          itemDoesNotExist = !item;
          if (item) {
            index = this._items.indexOf(item);
          }
        } else if (typeof subject == "number") {
          index = subject;
          item = this._items[index];
          itemDoesNotExist = !item;
          if (item) {
            id = item[idProperty];
          }
        } else {
          item = subject;
          id = item[idProperty];
          index = this._items.indexOf(item);
          itemDoesNotExist = index == -1 || !this._itemMap.get(id);
        }
        if (itemDoesNotExist) {
          throw new CKEditorError("collection-remove-404", this);
        }
        this._items.splice(index, 1);
        this._itemMap.delete(id);
        const externalItem = this._bindToInternalToExternalMap.get(item);
        this._bindToInternalToExternalMap.delete(item);
        this._bindToExternalToInternalMap.delete(externalItem);
        this.fire("remove", item, index);
        return [
          item,
          index
        ];
      }
      /**
      * Iterable interface.
      */
      [Symbol.iterator]() {
        return this._items[Symbol.iterator]();
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function first(iterator) {
      const iteratorItem = iterator.next();
      if (iteratorItem.done) {
        return null;
      }
      return iteratorItem.value;
    }
    class FocusTracker extends (/* @__PURE__ */ DomEmitterMixin(/* @__PURE__ */ ObservableMixin())) {
      // @if CK_DEBUG_FOCUSTRACKER // public _label?: string;
      constructor() {
        super();
        /**
        * List of registered DOM elements.
        *
        * @internal
        */
        __publicField(this, "_elements", /* @__PURE__ */ new Set());
        /**
        * List of views with external focus trackers that contribute to the state of this focus tracker.
        *
        * @internal
        */
        __publicField(this, "_externalViews", /* @__PURE__ */ new Set());
        /**
        * Asynchronous blur event timeout.
        */
        __publicField(this, "_blurTimeout", null);
        this.set("isFocused", false);
        this.set("focusedElement", null);
      }
      /**
      * List of registered DOM elements.
      *
      * **Note**: The list does do not include elements from {@link #externalViews}.
      */
      get elements() {
        return Array.from(this._elements.values());
      }
      /**
      * List of external focusable views that contribute to the state of this focus tracker. See {@link #add} to learn more.
      */
      get externalViews() {
        return Array.from(this._externalViews.values());
      }
      /**
      * Starts tracking a specified DOM element or a {@link module:ui/view~View} instance.
      *
      * * If a DOM element is passed, the focus tracker listens to the `focus` and `blur` events on this element.
      * Tracked elements are listed in {@link #elements}.
      * * If a {@link module:ui/view~View} instance is passed that has a `FocusTracker` instance ({@link ~ViewWithFocusTracker}),
      * the external focus tracker's state ({@link #isFocused}, {@link #focusedElement}) starts contributing to the current tracker instance.
      * This allows for increasing the "reach" of a focus tracker instance, by connecting two or more focus trackers together when DOM
      * elements they track are located in different subtrees in DOM. External focus trackers are listed in {@link #externalViews}.
      * * If a {@link module:ui/view~View} instance is passed that has no `FocusTracker` (**not** a {@link ~ViewWithFocusTracker}),
      * its {@link module:ui/view~View#element} is used to track focus like any other DOM element.
      */
      add(elementOrView) {
        if (isElement$2(elementOrView)) {
          this._addElement(elementOrView);
        } else {
          if (isViewWithFocusTracker(elementOrView)) {
            this._addView(elementOrView);
          } else {
            if (!elementOrView.element) {
              throw new CKEditorError("focustracker-add-view-missing-element", {
                focusTracker: this,
                view: elementOrView
              });
            }
            this._addElement(elementOrView.element);
          }
        }
      }
      /**
      * Stops tracking focus in the specified DOM element or a {@link module:ui/view~View view instance}. See {@link #add} to learn more.
      */
      remove(elementOrView) {
        if (isElement$2(elementOrView)) {
          this._removeElement(elementOrView);
        } else {
          if (isViewWithFocusTracker(elementOrView)) {
            this._removeView(elementOrView);
          } else {
            this._removeElement(elementOrView.element);
          }
        }
      }
      /**
      * Adds a DOM element to the focus tracker and starts listening to the `focus` and `blur` events on it.
      */
      _addElement(element) {
        if (this._elements.has(element)) {
          throw new CKEditorError("focustracker-add-element-already-exist", this);
        }
        this.listenTo(element, "focus", () => {
          const externalFocusedViewInSubtree = this.externalViews.find((view) => isExternalViewSubtreeFocused(element, view));
          if (externalFocusedViewInSubtree) {
            this._focus(externalFocusedViewInSubtree.element);
          } else {
            this._focus(element);
          }
        }, {
          useCapture: true
        });
        this.listenTo(element, "blur", () => {
          this._blur();
        }, {
          useCapture: true
        });
        this._elements.add(element);
      }
      /**
      * Removes a DOM element from the focus tracker.
      */
      _removeElement(element) {
        if (this._elements.has(element)) {
          this.stopListening(element);
          this._elements.delete(element);
        }
        if (element === this.focusedElement) {
          this._blur();
        }
      }
      /**
      * Adds an external {@link module:ui/view~View view instance} to this focus tracker and makes it contribute to this focus tracker's
      * state either by its `View#element` or by its `View#focusTracker` instance.
      */
      _addView(view) {
        if (view.element) {
          this._addElement(view.element);
        }
        this.listenTo(view.focusTracker, "change:focusedElement", () => {
          if (view.focusTracker.focusedElement) {
            if (view.element) {
              this._focus(view.element);
            }
          } else {
            this._blur();
          }
        });
        this._externalViews.add(view);
      }
      /**
      * Removes an external {@link module:ui/view~View view instance} from this focus tracker.
      */
      _removeView(view) {
        if (view.element) {
          this._removeElement(view.element);
        }
        this.stopListening(view.focusTracker);
        this._externalViews.delete(view);
      }
      /**
      * Destroys the focus tracker by:
      * - Disabling all event listeners attached to tracked elements or external views.
      * - Removing all tracked elements and views that were previously added.
      */
      destroy() {
        this.stopListening();
        this._elements.clear();
        this._externalViews.clear();
        this.isFocused = false;
        this.focusedElement = null;
      }
      /**
      * Stores currently focused element as {@link #focusedElement} and sets {@link #isFocused} `true`.
      */
      _focus(element) {
        this._clearBlurTimeout();
        this.focusedElement = element;
        this.isFocused = true;
      }
      /**
      * Clears currently {@link #focusedElement} and sets {@link #isFocused} `false`.
      *
      * This method uses `setTimeout()` to change order of `blur` and `focus` events calls, ensuring that moving focus between
      * two elements within a single focus tracker's scope, will not cause `[ blurA, focusB ]` sequence but just `[ focusB ]`.
      * The former would cause a momentary change of `#isFocused` to `false` which is not desired because any logic listening to
      * a focus tracker state would experience UI flashes and glitches as the user focus travels across the UI.
      */
      _blur() {
        const isAnyElementFocused = this.elements.find((element) => element.contains(document.activeElement));
        if (isAnyElementFocused) {
          return;
        }
        const isAnyExternalViewFocused = this.externalViews.find((view) => {
          return view.focusTracker.isFocused && !view.focusTracker._blurTimeout;
        });
        if (isAnyExternalViewFocused) {
          return;
        }
        this._clearBlurTimeout();
        this._blurTimeout = setTimeout(() => {
          this.focusedElement = null;
          this.isFocused = false;
        }, 0);
      }
      /**
      * Clears the asynchronous blur event timeout on demand. See {@link #_blur} to learn more.
      */
      _clearBlurTimeout() {
        clearTimeout(this._blurTimeout);
        this._blurTimeout = null;
      }
    }
    function isViewWithFocusTracker(view) {
      return "focusTracker" in view && view.focusTracker instanceof FocusTracker;
    }
    function isElement$2(value) {
      return isElement$3(value);
    }
    function isExternalViewSubtreeFocused(subTreeRoot, view) {
      if (isFocusedView(subTreeRoot, view)) {
        return true;
      }
      return !!view.focusTracker.externalViews.find((view2) => isFocusedView(subTreeRoot, view2));
    }
    function isFocusedView(subTreeRoot, view) {
      return !!view.element && view.element.contains(document.activeElement) && subTreeRoot.contains(view.element);
    }
    class KeystrokeHandler {
      /**
      * Creates an instance of the keystroke handler.
      */
      constructor() {
        /**
        * Listener used to listen to events for easier keystroke handler destruction.
        */
        __publicField(this, "_listener");
        this._listener = new (DomEmitterMixin())();
      }
      /**
      * Starts listening for `keydown` events from a given emitter.
      */
      listenTo(emitter) {
        this._listener.listenTo(emitter, "keydown", (evt, keyEvtData) => {
          this._listener.fire("_keydown:" + getCode(keyEvtData), keyEvtData);
        });
      }
      /**
      * Registers a handler for the specified keystroke.
      *
      * @param keystroke Keystroke defined in a format accepted by
      * the {@link module:utils/keyboard~parseKeystroke} function.
      * @param callback A function called with the
      * {@link module:engine/view/observer/keyobserver~KeyEventData key event data} object and
      * a helper function to call both `preventDefault()` and `stopPropagation()` on the underlying event.
      * @param options Additional options.
      */
      set(keystroke, callback, options = {}) {
        const keyCode = parseKeystroke(keystroke);
        const priority = options.priority;
        this._listener.listenTo(this._listener, "_keydown:" + keyCode, (evt, keyEvtData) => {
          if (options.filter && !options.filter(keyEvtData)) {
            return;
          }
          callback(keyEvtData, () => {
            keyEvtData.preventDefault();
            keyEvtData.stopPropagation();
            evt.stop();
          });
          evt.return = true;
        }, {
          priority
        });
      }
      /**
      * Triggers a keystroke handler for a specified key combination, if such a keystroke was {@link #set defined}.
      *
      * @param keyEvtData Key event data.
      * @returns Whether the keystroke was handled.
      */
      press(keyEvtData) {
        return !!this._listener.fire("_keydown:" + getCode(keyEvtData), keyEvtData);
      }
      /**
      * Stops listening to `keydown` events from the given emitter.
      */
      stopListening(emitter) {
        this._listener.stopListening(emitter);
      }
      /**
      * Destroys the keystroke handler.
      */
      destroy() {
        this.stopListening();
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function objectToMap(obj) {
      const map2 = /* @__PURE__ */ new Map();
      for (const key in obj) {
        map2.set(key, obj[key]);
      }
      return map2;
    }
    function toMap(data) {
      if (isIterable(data)) {
        return new Map(data);
      } else {
        return objectToMap(data);
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    const BIG_CHUNK_SIZE = 1e4;
    function spliceArray(target, source, start2, count2) {
      if (Math.max(source.length, target.length) > BIG_CHUNK_SIZE) {
        return target.slice(0, start2).concat(source).concat(target.slice(start2 + count2, target.length));
      } else {
        const newTarget = Array.from(target);
        newTarget.splice(start2, count2, ...source);
        return newTarget;
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function delay(func2, wait) {
      let timer;
      function delayed(...args) {
        delayed.cancel();
        timer = setTimeout(() => func2(...args), wait);
      }
      delayed.cancel = () => {
        clearTimeout(timer);
      };
      return delayed;
    }
    function verifyLicense(token) {
      function oldTokenCheck(token2) {
        if (token2.length >= 40 && token2.length <= 255) {
          return "VALID";
        } else {
          return "INVALID";
        }
      }
      if (!token) {
        return "INVALID";
      }
      let decryptedData = "";
      try {
        decryptedData = atob(token);
      } catch (e2) {
        return "INVALID";
      }
      const splittedDecryptedData = decryptedData.split("-");
      const firstElement = splittedDecryptedData[0];
      const secondElement = splittedDecryptedData[1];
      if (!secondElement) {
        return oldTokenCheck(token);
      }
      try {
        atob(secondElement);
      } catch (e2) {
        try {
          atob(firstElement);
          if (!atob(firstElement).length) {
            return oldTokenCheck(token);
          }
        } catch (e3) {
          return oldTokenCheck(token);
        }
      }
      if (firstElement.length < 40 || firstElement.length > 255) {
        return "INVALID";
      }
      let decryptedSecondElement = "";
      try {
        atob(firstElement);
        decryptedSecondElement = atob(secondElement);
      } catch (e2) {
        return "INVALID";
      }
      if (decryptedSecondElement.length !== 8) {
        return "INVALID";
      }
      const year = Number(decryptedSecondElement.substring(0, 4));
      const monthIndex = Number(decryptedSecondElement.substring(4, 6)) - 1;
      const day = Number(decryptedSecondElement.substring(6, 8));
      const date2 = new Date(year, monthIndex, day);
      if (date2 < releaseDate || isNaN(Number(date2))) {
        return "INVALID";
      }
      return "VALID";
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function isCombiningMark(character) {
      return !!character && character.length == 1 && /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(character);
    }
    function isHighSurrogateHalf(character) {
      return !!character && character.length == 1 && /[\ud800-\udbff]/.test(character);
    }
    function isLowSurrogateHalf(character) {
      return !!character && character.length == 1 && /[\udc00-\udfff]/.test(character);
    }
    function isInsideSurrogatePair(string2, offset2) {
      return isHighSurrogateHalf(string2.charAt(offset2 - 1)) && isLowSurrogateHalf(string2.charAt(offset2));
    }
    function isInsideCombinedSymbol(string2, offset2) {
      return isCombiningMark(string2.charAt(offset2));
    }
    const EMOJI_PATTERN = /* @__PURE__ */ buildEmojiRegexp();
    function isInsideEmojiSequence(string2, offset2) {
      const matches2 = String(string2).matchAll(EMOJI_PATTERN);
      return Array.from(matches2).some((match) => match.index < offset2 && offset2 < match.index + match[0].length);
    }
    function buildEmojiRegexp() {
      const parts = [
        // Emoji Tag Sequence (ETS)
        new RegExp("\\p{Emoji}[\\u{E0020}-\\u{E007E}]+\\u{E007F}", "u"),
        // Emoji Keycap Sequence
        new RegExp("\\p{Emoji}\\u{FE0F}?\\u{20E3}", "u"),
        // Emoji Presentation Sequence
        new RegExp("\\p{Emoji}\\u{FE0F}", "u"),
        // Single-Character Emoji / Emoji Modifier Sequence
        new RegExp("(?=\\p{General_Category=Other_Symbol})\\p{Emoji}\\p{Emoji_Modifier}*", "u")
      ];
      const flagSequence = new RegExp("\\p{Regional_Indicator}{2}", "u").source;
      const emoji = "(?:" + parts.map((part) => part.source).join("|") + ")";
      const sequence = `${flagSequence}|${emoji}(?:${emoji})*`;
      return new RegExp(sequence, "ug");
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    const documentPlaceholders = /* @__PURE__ */ new WeakMap();
    let hasDisplayedPlaceholderDeprecationWarning = false;
    function enablePlaceholder({ view, element, text: text2, isDirectHost = true, keepOnFocus = false }) {
      const doc = view.document;
      if (!documentPlaceholders.has(doc)) {
        documentPlaceholders.set(doc, /* @__PURE__ */ new Map());
        doc.registerPostFixer((writer) => updateDocumentPlaceholders(doc, writer));
        doc.on("change:isComposing", () => {
          view.change((writer) => updateDocumentPlaceholders(doc, writer));
        }, {
          priority: "high"
        });
      }
      if (element.is("editableElement")) {
        element.on("change:placeholder", (evtInfo, evt, text3) => {
          setPlaceholder(text3);
        });
      }
      if (element.placeholder) {
        setPlaceholder(element.placeholder);
      } else if (text2) {
        setPlaceholder(text2);
      }
      if (text2) {
        showPlaceholderTextDeprecationWarning();
      }
      function setPlaceholder(text3) {
        documentPlaceholders.get(doc).set(element, {
          text: text3,
          isDirectHost,
          keepOnFocus,
          hostElement: isDirectHost ? element : null
        });
        view.change((writer) => updateDocumentPlaceholders(doc, writer));
      }
    }
    function showPlaceholder(writer, element) {
      if (!element.hasClass("ck-placeholder")) {
        writer.addClass("ck-placeholder", element);
        return true;
      }
      return false;
    }
    function hidePlaceholder(writer, element) {
      if (element.hasClass("ck-placeholder")) {
        writer.removeClass("ck-placeholder", element);
        return true;
      }
      return false;
    }
    function needsPlaceholder(element, keepOnFocus) {
      if (!element.isAttached()) {
        return false;
      }
      const hasContent = Array.from(element.getChildren()).some((element2) => !element2.is("uiElement"));
      if (hasContent) {
        return false;
      }
      const doc = element.document;
      const viewSelection = doc.selection;
      const selectionAnchor = viewSelection.anchor;
      if (doc.isComposing && selectionAnchor && selectionAnchor.parent === element) {
        return false;
      }
      if (keepOnFocus) {
        return true;
      }
      if (!doc.isFocused) {
        return true;
      }
      return !!selectionAnchor && selectionAnchor.parent !== element;
    }
    function updateDocumentPlaceholders(doc, writer) {
      const placeholders = documentPlaceholders.get(doc);
      const directHostElements = [];
      let wasViewModified = false;
      for (const [element, config2] of placeholders) {
        if (config2.isDirectHost) {
          directHostElements.push(element);
          if (updatePlaceholder(writer, element, config2)) {
            wasViewModified = true;
          }
        }
      }
      for (const [element, config2] of placeholders) {
        if (config2.isDirectHost) {
          continue;
        }
        const hostElement = getChildPlaceholderHostSubstitute(element);
        if (!hostElement) {
          continue;
        }
        if (directHostElements.includes(hostElement)) {
          continue;
        }
        config2.hostElement = hostElement;
        if (updatePlaceholder(writer, element, config2)) {
          wasViewModified = true;
        }
      }
      return wasViewModified;
    }
    function updatePlaceholder(writer, element, config2) {
      const { text: text2, isDirectHost, hostElement } = config2;
      let wasViewModified = false;
      if (hostElement.getAttribute("data-placeholder") !== text2) {
        writer.setAttribute("data-placeholder", text2, hostElement);
        wasViewModified = true;
      }
      const isOnlyChild = isDirectHost || element.childCount == 1;
      if (isOnlyChild && needsPlaceholder(hostElement, config2.keepOnFocus)) {
        if (showPlaceholder(writer, hostElement)) {
          wasViewModified = true;
        }
      } else if (hidePlaceholder(writer, hostElement)) {
        wasViewModified = true;
      }
      return wasViewModified;
    }
    function getChildPlaceholderHostSubstitute(parent2) {
      if (parent2.childCount) {
        const firstChild = parent2.getChild(0);
        if (firstChild.is("element") && !firstChild.is("uiElement") && !firstChild.is("attributeElement")) {
          return firstChild;
        }
      }
      return null;
    }
    function showPlaceholderTextDeprecationWarning() {
      if (!hasDisplayedPlaceholderDeprecationWarning) {
        logWarning("enableplaceholder-deprecated-text-option");
      }
      hasDisplayedPlaceholderDeprecationWarning = true;
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    let TypeCheckable$1 = class TypeCheckable {
      /* istanbul ignore next -- @preserve */
      is() {
        throw new Error("is() method is abstract");
      }
    };
    let Node$2 = class Node extends (/* @__PURE__ */ EmitterMixin(TypeCheckable$1)) {
      /**
      * Creates a tree view node.
      *
      * @param document The document instance to which this node belongs.
      */
      constructor(document2) {
        super();
        /**
        * The document instance to which this node belongs.
        */
        __publicField(this, "document");
        /**
        * Parent element. Null by default. Set by {@link module:engine/view/element~Element#_insertChild}.
        */
        __publicField(this, "parent");
        this.document = document2;
        this.parent = null;
      }
      /**
      * Index of the node in the parent element or null if the node has no parent.
      *
      * Accessing this property throws an error if this node's parent element does not contain it.
      * This means that view tree got broken.
      */
      get index() {
        let pos;
        if (!this.parent) {
          return null;
        }
        if ((pos = this.parent.getChildIndex(this)) == -1) {
          throw new CKEditorError("view-node-not-found-in-parent", this);
        }
        return pos;
      }
      /**
      * Node's next sibling, or `null` if it is the last child.
      */
      get nextSibling() {
        const index = this.index;
        return index !== null && this.parent.getChild(index + 1) || null;
      }
      /**
      * Node's previous sibling, or `null` if it is the first child.
      */
      get previousSibling() {
        const index = this.index;
        return index !== null && this.parent.getChild(index - 1) || null;
      }
      /**
      * Top-most ancestor of the node. If the node has no parent it is the root itself.
      */
      get root() {
        let root2 = this;
        while (root2.parent) {
          root2 = root2.parent;
        }
        return root2;
      }
      /**
      * Returns true if the node is in a tree rooted in the document (is a descendant of one of its roots).
      */
      isAttached() {
        return this.root.is("rootElement");
      }
      /**
      * Gets a path to the node. The path is an array containing indices of consecutive ancestors of this node,
      * beginning from {@link module:engine/view/node~Node#root root}, down to this node's index.
      *
      * ```ts
      * const abc = downcastWriter.createText( 'abc' );
      * const foo = downcastWriter.createText( 'foo' );
      * const h1 = downcastWriter.createElement( 'h1', null, downcastWriter.createText( 'header' ) );
      * const p = downcastWriter.createElement( 'p', null, [ abc, foo ] );
      * const div = downcastWriter.createElement( 'div', null, [ h1, p ] );
      * foo.getPath(); // Returns [ 1, 3 ]. `foo` is in `p` which is in `div`. `p` starts at offset 1, while `foo` at 3.
      * h1.getPath(); // Returns [ 0 ].
      * div.getPath(); // Returns [].
      * ```
      *
      * @returns The path.
      */
      getPath() {
        const path = [];
        let node = this;
        while (node.parent) {
          path.unshift(node.index);
          node = node.parent;
        }
        return path;
      }
      /**
      * Returns ancestors array of this node.
      *
      * @param options Options object.
      * @param options.includeSelf When set to `true` this node will be also included in parent's array.
      * @param options.parentFirst When set to `true`, array will be sorted from node's parent to root element,
      * otherwise root element will be the first item in the array.
      * @returns Array with ancestors.
      */
      getAncestors(options = {}) {
        const ancestors = [];
        let parent2 = options.includeSelf ? this : this.parent;
        while (parent2) {
          ancestors[options.parentFirst ? "push" : "unshift"](parent2);
          parent2 = parent2.parent;
        }
        return ancestors;
      }
      /**
      * Returns a {@link module:engine/view/element~Element} or {@link module:engine/view/documentfragment~DocumentFragment}
      * which is a common ancestor of both nodes.
      *
      * @param node The second node.
      * @param options Options object.
      * @param options.includeSelf When set to `true` both nodes will be considered "ancestors" too.
      * Which means that if e.g. node A is inside B, then their common ancestor will be B.
      */
      getCommonAncestor(node, options = {}) {
        const ancestorsA = this.getAncestors(options);
        const ancestorsB = node.getAncestors(options);
        let i2 = 0;
        while (ancestorsA[i2] == ancestorsB[i2] && ancestorsA[i2]) {
          i2++;
        }
        return i2 === 0 ? null : ancestorsA[i2 - 1];
      }
      /**
      * Returns whether this node is before given node. `false` is returned if nodes are in different trees (for example,
      * in different {@link module:engine/view/documentfragment~DocumentFragment}s).
      *
      * @param node Node to compare with.
      */
      isBefore(node) {
        if (this == node) {
          return false;
        }
        if (this.root !== node.root) {
          return false;
        }
        const thisPath = this.getPath();
        const nodePath = node.getPath();
        const result2 = compareArrays(thisPath, nodePath);
        switch (result2) {
          case "prefix":
            return true;
          case "extension":
            return false;
          default:
            return thisPath[result2] < nodePath[result2];
        }
      }
      /**
      * Returns whether this node is after given node. `false` is returned if nodes are in different trees (for example,
      * in different {@link module:engine/view/documentfragment~DocumentFragment}s).
      *
      * @param node Node to compare with.
      */
      isAfter(node) {
        if (this == node) {
          return false;
        }
        if (this.root !== node.root) {
          return false;
        }
        return !this.isBefore(node);
      }
      /**
      * Removes node from parent.
      *
      * @internal
      */
      _remove() {
        this.parent._removeChildren(this.index);
      }
      /**
      * @internal
      * @param type Type of the change.
      * @param node Changed node.
      * @fires change
      */
      _fireChange(type, node) {
        this.fire(`change:${type}`, node);
        if (this.parent) {
          this.parent._fireChange(type, node);
        }
      }
      /**
      * Custom toJSON method to solve child-parent circular dependencies.
      *
      * @returns Clone of this object with the parent property removed.
      */
      toJSON() {
        const json = clone$1(this);
        delete json.parent;
        return json;
      }
    };
    Node$2.prototype.is = function(type) {
      return type === "node" || type === "view:node";
    };
    let Text$1 = class Text2 extends Node$2 {
      /**
      * Creates a tree view text node.
      *
      * @see module:engine/view/downcastwriter~DowncastWriter#createText
      * @internal
      * @param document The document instance to which this text node belongs.
      * @param data The text's data.
      */
      constructor(document2, data) {
        super(document2);
        /**
        * The text content.
        *
        * Setting the data fires the {@link module:engine/view/node~Node#event:change:text change event}.
        */
        __publicField(this, "_textData");
        this._textData = data;
      }
      /**
      * The text content.
      */
      get data() {
        return this._textData;
      }
      /**
      * The `_data` property is controlled by a getter and a setter.
      *
      * The getter is required when using the addition assignment operator on protected property:
      *
      * ```ts
      * const foo = downcastWriter.createText( 'foo' );
      * const bar = downcastWriter.createText( 'bar' );
      *
      * foo._data += bar.data;   // executes: `foo._data = foo._data + bar.data`
      * console.log( foo.data ); // prints: 'foobar'
      * ```
      *
      * If the protected getter didn't exist, `foo._data` will return `undefined` and result of the merge will be invalid.
      *
      * The setter sets data and fires the {@link module:engine/view/node~Node#event:change:text change event}.
      *
      * @internal
      */
      get _data() {
        return this.data;
      }
      set _data(data) {
        this._fireChange("text", this);
        this._textData = data;
      }
      /**
      * Checks if this text node is similar to other text node.
      * Both nodes should have the same data to be considered as similar.
      *
      * @param otherNode Node to check if it is same as this node.
      */
      isSimilar(otherNode) {
        if (!(otherNode instanceof Text2)) {
          return false;
        }
        return this === otherNode || this.data === otherNode.data;
      }
      /**
      * Clones this node.
      *
      * @internal
      * @returns Text node that is a clone of this node.
      */
      _clone() {
        return new Text2(this.document, this.data);
      }
    };
    Text$1.prototype.is = function(type) {
      return type === "$text" || type === "view:$text" || // This are legacy values kept for backward compatibility.
      type === "text" || type === "view:text" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
      type === "node" || type === "view:node";
    };
    let TextProxy$1 = class TextProxy extends TypeCheckable$1 {
      /**
      * Creates a text proxy.
      *
      * @internal
      * @param textNode Text node which part is represented by this text proxy.
      * @param offsetInText Offset in {@link module:engine/view/textproxy~TextProxy#textNode text node}
      * from which the text proxy starts.
      * @param length Text proxy length, that is how many text node's characters, starting from `offsetInText` it represents.
      * @constructor
      */
      constructor(textNode, offsetInText, length) {
        super();
        /**
        * Reference to the {@link module:engine/view/text~Text} element which TextProxy is a substring.
        */
        __publicField(this, "textNode");
        /**
        * Text data represented by this text proxy.
        */
        __publicField(this, "data");
        /**
        * Offset in the `textNode` where this `TextProxy` instance starts.
        */
        __publicField(this, "offsetInText");
        this.textNode = textNode;
        if (offsetInText < 0 || offsetInText > textNode.data.length) {
          throw new CKEditorError("view-textproxy-wrong-offsetintext", this);
        }
        if (length < 0 || offsetInText + length > textNode.data.length) {
          throw new CKEditorError("view-textproxy-wrong-length", this);
        }
        this.data = textNode.data.substring(offsetInText, offsetInText + length);
        this.offsetInText = offsetInText;
      }
      /**
      * Offset size of this node.
      */
      get offsetSize() {
        return this.data.length;
      }
      /**
      * Flag indicating whether `TextProxy` instance covers only part of the original {@link module:engine/view/text~Text text node}
      * (`true`) or the whole text node (`false`).
      *
      * This is `false` when text proxy starts at the very beginning of {@link module:engine/view/textproxy~TextProxy#textNode textNode}
      * ({@link module:engine/view/textproxy~TextProxy#offsetInText offsetInText} equals `0`) and text proxy sizes is equal to
      * text node size.
      */
      get isPartial() {
        return this.data.length !== this.textNode.data.length;
      }
      /**
      * Parent of this text proxy, which is same as parent of text node represented by this text proxy.
      */
      get parent() {
        return this.textNode.parent;
      }
      /**
      * Root of this text proxy, which is same as root of text node represented by this text proxy.
      */
      get root() {
        return this.textNode.root;
      }
      /**
      * {@link module:engine/view/document~Document View document} that owns this text proxy, or `null` if the text proxy is inside
      * {@link module:engine/view/documentfragment~DocumentFragment document fragment}.
      */
      get document() {
        return this.textNode.document;
      }
      /**
      * Returns ancestors array of this text proxy.
      *
      * @param options Options object.
      * @param options.includeSelf When set to `true`, textNode will be also included in parent's array.
      * @param options.parentFirst When set to `true`, array will be sorted from text proxy parent to
      * root element, otherwise root element will be the first item in the array.
      * @returns Array with ancestors.
      */
      getAncestors(options = {}) {
        const ancestors = [];
        let parent2 = options.includeSelf ? this.textNode : this.parent;
        while (parent2 !== null) {
          ancestors[options.parentFirst ? "push" : "unshift"](parent2);
          parent2 = parent2.parent;
        }
        return ancestors;
      }
    };
    TextProxy$1.prototype.is = function(type) {
      return type === "$textProxy" || type === "view:$textProxy" || // This are legacy values kept for backward compatibility.
      type === "textProxy" || type === "view:textProxy";
    };
    class Matcher {
      /**
      * Creates new instance of Matcher.
      *
      * @param pattern Match patterns. See {@link module:engine/view/matcher~Matcher#add add method} for more information.
      */
      constructor(...pattern) {
        __publicField(this, "_patterns", []);
        this.add(...pattern);
      }
      /**
      * Adds pattern or patterns to matcher instance.
      *
      * ```ts
      * // String.
      * matcher.add( 'div' );
      *
      * // Regular expression.
      * matcher.add( /^\w/ );
      *
      * // Single class.
      * matcher.add( {
      * 	classes: 'foobar'
      * } );
      * ```
      *
      * See {@link module:engine/view/matcher~MatcherPattern} for more examples.
      *
      * Multiple patterns can be added in one call:
      *
      * ```ts
      * matcher.add( 'div', { classes: 'foobar' } );
      * ```
      *
      * @param pattern Object describing pattern details. If string or regular expression
      * is provided it will be used to match element's name. Pattern can be also provided in a form
      * of a function - then this function will be called with each {@link module:engine/view/element~Element element} as a parameter.
      * Function's return value will be stored under `match` key of the object returned from
      * {@link module:engine/view/matcher~Matcher#match match} or {@link module:engine/view/matcher~Matcher#matchAll matchAll} methods.
      */
      add(...pattern) {
        for (let item of pattern) {
          if (typeof item == "string" || item instanceof RegExp) {
            item = {
              name: item
            };
          }
          this._patterns.push(item);
        }
      }
      /**
      * Matches elements for currently stored patterns. Returns match information about first found
      * {@link module:engine/view/element~Element element}, otherwise returns `null`.
      *
      * Example of returned object:
      *
      * ```ts
      * {
      * 	element: <instance of found element>,
      * 	pattern: <pattern used to match found element>,
      * 	match: {
      * 		name: true,
      * 		attributes: [ 'title', 'href' ],
      * 		classes: [ 'foo' ],
      * 		styles: [ 'color', 'position' ]
      * 	}
      * }
      * ```
      *
      * @see module:engine/view/matcher~Matcher#add
      * @see module:engine/view/matcher~Matcher#matchAll
      * @param element View element to match against stored patterns.
      */
      match(...element) {
        for (const singleElement of element) {
          for (const pattern of this._patterns) {
            const match = isElementMatching(singleElement, pattern);
            if (match) {
              return {
                element: singleElement,
                pattern,
                match
              };
            }
          }
        }
        return null;
      }
      /**
      * Matches elements for currently stored patterns. Returns array of match information with all found
      * {@link module:engine/view/element~Element elements}. If no element is found - returns `null`.
      *
      * @see module:engine/view/matcher~Matcher#add
      * @see module:engine/view/matcher~Matcher#match
      * @param element View element to match against stored patterns.
      * @returns Array with match information about found elements or `null`. For more information
      * see {@link module:engine/view/matcher~Matcher#match match method} description.
      */
      matchAll(...element) {
        const results = [];
        for (const singleElement of element) {
          for (const pattern of this._patterns) {
            const match = isElementMatching(singleElement, pattern);
            if (match) {
              results.push({
                element: singleElement,
                pattern,
                match
              });
            }
          }
        }
        return results.length > 0 ? results : null;
      }
      /**
      * Returns the name of the element to match if there is exactly one pattern added to the matcher instance
      * and it matches element name defined by `string` (not `RegExp`). Otherwise, returns `null`.
      *
      * @returns Element name trying to match.
      */
      getElementName() {
        if (this._patterns.length !== 1) {
          return null;
        }
        const pattern = this._patterns[0];
        const name = pattern.name;
        return typeof pattern != "function" && name && !(name instanceof RegExp) ? name : null;
      }
    }
    function isElementMatching(element, pattern) {
      if (typeof pattern == "function") {
        return pattern(element);
      }
      const match = {};
      if (pattern.name) {
        match.name = matchName(pattern.name, element.name);
        if (!match.name) {
          return null;
        }
      }
      if (pattern.attributes) {
        match.attributes = matchAttributes(pattern.attributes, element);
        if (!match.attributes) {
          return null;
        }
      }
      if (pattern.classes) {
        match.classes = matchClasses(pattern.classes, element);
        if (!match.classes) {
          return null;
        }
      }
      if (pattern.styles) {
        match.styles = matchStyles(pattern.styles, element);
        if (!match.styles) {
          return null;
        }
      }
      return match;
    }
    function matchName(pattern, name) {
      if (pattern instanceof RegExp) {
        return !!name.match(pattern);
      }
      return pattern === name;
    }
    function matchPatterns(patterns, keys2, valueGetter) {
      const normalizedPatterns = normalizePatterns(patterns);
      const normalizedItems = Array.from(keys2);
      const match = [];
      normalizedPatterns.forEach(([patternKey, patternValue]) => {
        normalizedItems.forEach((itemKey) => {
          if (isKeyMatched(patternKey, itemKey) && isValueMatched(patternValue, itemKey, valueGetter)) {
            match.push(itemKey);
          }
        });
      });
      if (!normalizedPatterns.length || match.length < normalizedPatterns.length) {
        return void 0;
      }
      return match;
    }
    function normalizePatterns(patterns) {
      if (Array.isArray(patterns)) {
        return patterns.map((pattern) => {
          if (isPlainObject$2(pattern)) {
            if (pattern.key === void 0 || pattern.value === void 0) {
              logWarning("matcher-pattern-missing-key-or-value", pattern);
            }
            return [
              pattern.key,
              pattern.value
            ];
          }
          return [
            pattern,
            true
          ];
        });
      }
      if (isPlainObject$2(patterns)) {
        return Object.entries(patterns);
      }
      return [
        [
          patterns,
          true
        ]
      ];
    }
    function isKeyMatched(patternKey, itemKey) {
      return patternKey === true || patternKey === itemKey || patternKey instanceof RegExp && itemKey.match(patternKey);
    }
    function isValueMatched(patternValue, itemKey, valueGetter) {
      if (patternValue === true) {
        return true;
      }
      const itemValue = valueGetter(itemKey);
      return patternValue === itemValue || patternValue instanceof RegExp && !!String(itemValue).match(patternValue);
    }
    function matchAttributes(patterns, element) {
      const attributeKeys = new Set(element.getAttributeKeys());
      if (isPlainObject$2(patterns)) {
        if (patterns.style !== void 0) {
          logWarning("matcher-pattern-deprecated-attributes-style-key", patterns);
        }
        if (patterns.class !== void 0) {
          logWarning("matcher-pattern-deprecated-attributes-class-key", patterns);
        }
      } else {
        attributeKeys.delete("style");
        attributeKeys.delete("class");
      }
      return matchPatterns(patterns, attributeKeys, (key) => element.getAttribute(key));
    }
    function matchClasses(patterns, element) {
      return matchPatterns(
        patterns,
        element.getClassNames(),
        /* istanbul ignore next -- @preserve */
        () => {
        }
      );
    }
    function matchStyles(patterns, element) {
      return matchPatterns(patterns, element.getStyleNames(true), (key) => element.getStyle(key));
    }
    class StylesMap {
      /**
      * Creates Styles instance.
      */
      constructor(styleProcessor) {
        /**
        * Keeps an internal representation of styles map. Normalized styles are kept as object tree to allow unified modification and
        * value access model using lodash's get, set, unset, etc methods.
        *
        * When no style processor rules are defined it acts as simple key-value storage.
        */
        __publicField(this, "_styles");
        /**
        * An instance of the {@link module:engine/view/stylesmap~StylesProcessor}.
        */
        __publicField(this, "_styleProcessor");
        this._styles = {};
        this._styleProcessor = styleProcessor;
      }
      /**
      * Returns true if style map has no styles set.
      */
      get isEmpty() {
        const entries = Object.entries(this._styles);
        return !entries.length;
      }
      /**
      * Number of styles defined.
      */
      get size() {
        if (this.isEmpty) {
          return 0;
        }
        return this.getStyleNames().length;
      }
      /**
      * Set styles map to a new value.
      *
      * ```ts
      * styles.setTo( 'border:1px solid blue;margin-top:1px;' );
      * ```
      */
      setTo(inlineStyle) {
        this.clear();
        const parsedStyles = parseInlineStyles(inlineStyle);
        for (const [key, value] of parsedStyles) {
          this._styleProcessor.toNormalizedForm(key, value, this._styles);
        }
      }
      /**
      * Checks if a given style is set.
      *
      * ```ts
      * styles.setTo( 'margin-left:1px;' );
      *
      * styles.has( 'margin-left' );    // -> true
      * styles.has( 'padding' );        // -> false
      * ```
      *
      * **Note**: This check supports normalized style names.
      *
      * ```ts
      * // Enable 'margin' shorthand processing:
      * editor.data.addStyleProcessorRules( addMarginRules );
      *
      * styles.setTo( 'margin:2px;' );
      *
      * styles.has( 'margin' );         // -> true
      * styles.has( 'margin-top' );     // -> true
      * styles.has( 'margin-left' );    // -> true
      *
      * styles.remove( 'margin-top' );
      *
      * styles.has( 'margin' );         // -> false
      * styles.has( 'margin-top' );     // -> false
      * styles.has( 'margin-left' );    // -> true
      * ```
      *
      * @param name Style name.
      */
      has(name) {
        if (this.isEmpty) {
          return false;
        }
        const styles = this._styleProcessor.getReducedForm(name, this._styles);
        const propertyDescriptor = styles.find(([property2]) => property2 === name);
        return Array.isArray(propertyDescriptor);
      }
      set(nameOrObject, valueOrObject) {
        if (isObject$3(nameOrObject)) {
          for (const [key, value] of Object.entries(nameOrObject)) {
            this._styleProcessor.toNormalizedForm(key, value, this._styles);
          }
        } else {
          this._styleProcessor.toNormalizedForm(nameOrObject, valueOrObject, this._styles);
        }
      }
      /**
      * Removes given style.
      *
      * ```ts
      * styles.setTo( 'background:#f00;margin-right:2px;' );
      *
      * styles.remove( 'background' );
      *
      * styles.toString();   // -> 'margin-right:2px;'
      * ```
      *
      * ***Note**:* This method uses {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules
      * enabled style processor rules} to normalize passed values.
      *
      * ```ts
      * // Enable 'margin' shorthand processing:
      * editor.data.addStyleProcessorRules( addMarginRules );
      *
      * styles.setTo( 'margin:1px' );
      *
      * styles.remove( 'margin-top' );
      * styles.remove( 'margin-right' );
      *
      * styles.toString(); // -> 'margin-bottom:1px;margin-left:1px;'
      * ```
      *
      * @param name Style name.
      */
      remove(name) {
        const path = toPath(name);
        unset(this._styles, path);
        delete this._styles[name];
        this._cleanEmptyObjectsOnPath(path);
      }
      /**
      * Returns a normalized style object or a single value.
      *
      * ```ts
      * // Enable 'margin' shorthand processing:
      * editor.data.addStyleProcessorRules( addMarginRules );
      *
      * const styles = new Styles();
      * styles.setTo( 'margin:1px 2px 3em;' );
      *
      * styles.getNormalized( 'margin' );
      * // will log:
      * // {
      * //     top: '1px',
      * //     right: '2px',
      * //     bottom: '3em',
      * //     left: '2px'     // normalized value from margin shorthand
      * // }
      *
      * styles.getNormalized( 'margin-left' ); // -> '2px'
      * ```
      *
      * **Note**: This method will only return normalized styles if a style processor was defined.
      *
      * @param name Style name.
      */
      getNormalized(name) {
        return this._styleProcessor.getNormalized(name, this._styles);
      }
      /**
      * Returns a normalized style string. Styles are sorted by name.
      *
      * ```ts
      * styles.set( 'margin' , '1px' );
      * styles.set( 'background', '#f00' );
      *
      * styles.toString(); // -> 'background:#f00;margin:1px;'
      * ```
      *
      * **Note**: This method supports normalized styles if defined.
      *
      * ```ts
      * // Enable 'margin' shorthand processing:
      * editor.data.addStyleProcessorRules( addMarginRules );
      *
      * styles.set( 'margin' , '1px' );
      * styles.set( 'background', '#f00' );
      * styles.remove( 'margin-top' );
      * styles.remove( 'margin-right' );
      *
      * styles.toString(); // -> 'background:#f00;margin-bottom:1px;margin-left:1px;'
      * ```
      */
      toString() {
        if (this.isEmpty) {
          return "";
        }
        return this.getStylesEntries().map((arr) => arr.join(":")).sort().join(";") + ";";
      }
      /**
      * Returns property as a value string or undefined if property is not set.
      *
      * ```ts
      * // Enable 'margin' shorthand processing:
      * editor.data.addStyleProcessorRules( addMarginRules );
      *
      * const styles = new Styles();
      * styles.setTo( 'margin:1px;' );
      * styles.set( 'margin-bottom', '3em' );
      *
      * styles.getAsString( 'margin' ); // -> 'margin: 1px 1px 3em;'
      * ```
      *
      * Note, however, that all sub-values must be set for the longhand property name to return a value:
      *
      * ```ts
      * const styles = new Styles();
      * styles.setTo( 'margin:1px;' );
      * styles.remove( 'margin-bottom' );
      *
      * styles.getAsString( 'margin' ); // -> undefined
      * ```
      *
      * In the above scenario, it is not possible to return a `margin` value, so `undefined` is returned.
      * Instead, you should use:
      *
      * ```ts
      * const styles = new Styles();
      * styles.setTo( 'margin:1px;' );
      * styles.remove( 'margin-bottom' );
      *
      * for ( const styleName of styles.getStyleNames() ) {
      * 	console.log( styleName, styles.getAsString( styleName ) );
      * }
      * // 'margin-top', '1px'
      * // 'margin-right', '1px'
      * // 'margin-left', '1px'
      * ```
      *
      * In general, it is recommend to iterate over style names like in the example above. This way, you will always get all
      * the currently set style values. So, if all the 4 margin values would be set
      * the for-of loop above would yield only `'margin'`, `'1px'`:
      *
      * ```ts
      * const styles = new Styles();
      * styles.setTo( 'margin:1px;' );
      *
      * for ( const styleName of styles.getStyleNames() ) {
      * 	console.log( styleName, styles.getAsString( styleName ) );
      * }
      * // 'margin', '1px'
      * ```
      *
      * **Note**: To get a normalized version of a longhand property use the {@link #getNormalized `#getNormalized()`} method.
      */
      getAsString(propertyName) {
        if (this.isEmpty) {
          return;
        }
        if (this._styles[propertyName] && !isObject$3(this._styles[propertyName])) {
          return this._styles[propertyName];
        }
        const styles = this._styleProcessor.getReducedForm(propertyName, this._styles);
        const propertyDescriptor = styles.find(([property2]) => property2 === propertyName);
        if (Array.isArray(propertyDescriptor)) {
          return propertyDescriptor[1];
        }
      }
      /**
      * Returns all style properties names as they would appear when using {@link #toString `#toString()`}.
      *
      * When `expand` is set to true and there's a shorthand style property set, it will also return all equivalent styles:
      *
      * ```ts
      * stylesMap.setTo( 'margin: 1em' )
      * ```
      *
      * will be expanded to:
      *
      * ```ts
      * [ 'margin', 'margin-top', 'margin-right', 'margin-bottom', 'margin-left' ]
      * ```
      *
      * @param expand Expand shorthand style properties and all return equivalent style representations.
      */
      getStyleNames(expand = false) {
        if (this.isEmpty) {
          return [];
        }
        if (expand) {
          return this._styleProcessor.getStyleNames(this._styles);
        }
        const entries = this.getStylesEntries();
        return entries.map(([key]) => key);
      }
      /**
      * Removes all styles.
      */
      clear() {
        this._styles = {};
      }
      /**
      * Returns normalized styles entries for further processing.
      */
      getStylesEntries() {
        const parsed = [];
        const keys2 = Object.keys(this._styles);
        for (const key of keys2) {
          parsed.push(...this._styleProcessor.getReducedForm(key, this._styles));
        }
        return parsed;
      }
      /**
      * Removes empty objects upon removing an entry from internal object.
      */
      _cleanEmptyObjectsOnPath(path) {
        const pathParts = path.split(".");
        const isChildPath = pathParts.length > 1;
        if (!isChildPath) {
          return;
        }
        const parentPath = pathParts.splice(0, pathParts.length - 1).join(".");
        const parentObject = get(this._styles, parentPath);
        if (!parentObject) {
          return;
        }
        const isParentEmpty = !Object.keys(parentObject).length;
        if (isParentEmpty) {
          this.remove(parentPath);
        }
      }
    }
    class StylesProcessor {
      /**
      * Creates StylesProcessor instance.
      *
      * @internal
      */
      constructor() {
        __publicField(this, "_normalizers");
        __publicField(this, "_extractors");
        __publicField(this, "_reducers");
        __publicField(this, "_consumables");
        this._normalizers = /* @__PURE__ */ new Map();
        this._extractors = /* @__PURE__ */ new Map();
        this._reducers = /* @__PURE__ */ new Map();
        this._consumables = /* @__PURE__ */ new Map();
      }
      /**
      * Parse style string value to a normalized object and appends it to styles object.
      *
      * ```ts
      * const styles = {};
      *
      * stylesProcessor.toNormalizedForm( 'margin', '1px', styles );
      *
      * // styles will consist: { margin: { top: '1px', right: '1px', bottom: '1px', left: '1px; } }
      * ```
      *
      * **Note**: To define normalizer callbacks use {@link #setNormalizer}.
      *
      * @param name Name of style property.
      * @param propertyValue Value of style property.
      * @param styles Object holding normalized styles.
      */
      toNormalizedForm(name, propertyValue, styles) {
        if (isObject$3(propertyValue)) {
          appendStyleValue(styles, toPath(name), propertyValue);
          return;
        }
        if (this._normalizers.has(name)) {
          const normalizer = this._normalizers.get(name);
          const { path, value } = normalizer(propertyValue);
          appendStyleValue(styles, path, value);
        } else {
          appendStyleValue(styles, name, propertyValue);
        }
      }
      /**
      * Returns a normalized version of a style property.
      *
      * ```ts
      * const styles = {
      * 	margin: { top: '1px', right: '1px', bottom: '1px', left: '1px; },
      * 	background: { color: '#f00' }
      * };
      *
      * stylesProcessor.getNormalized( 'background' );
      * // will return: { color: '#f00' }
      *
      * stylesProcessor.getNormalized( 'margin-top' );
      * // will return: '1px'
      * ```
      *
      * **Note**: In some cases extracting single value requires defining an extractor callback {@link #setExtractor}.
      *
      * @param name Name of style property.
      * @param styles Object holding normalized styles.
      */
      getNormalized(name, styles) {
        if (!name) {
          return merge$1({}, styles);
        }
        if (styles[name] !== void 0) {
          return styles[name];
        }
        if (this._extractors.has(name)) {
          const extractor = this._extractors.get(name);
          if (typeof extractor === "string") {
            return get(styles, extractor);
          }
          const value = extractor(name, styles);
          if (value) {
            return value;
          }
        }
        return get(styles, toPath(name));
      }
      /**
      * Returns a reduced form of style property form normalized object.
      *
      * For default margin reducer, the below code:
      *
      * ```ts
      * stylesProcessor.getReducedForm( 'margin', {
      * 	margin: { top: '1px', right: '1px', bottom: '2px', left: '1px; }
      * } );
      * ```
      *
      * will return:
      *
      * ```ts
      * [
      * 	[ 'margin', '1px 1px 2px' ]
      * ]
      * ```
      *
      * because it might be represented as a shorthand 'margin' value. However if one of margin long hand values is missing it should return:
      *
      * ```ts
      * [
      * 	[ 'margin-top', '1px' ],
      * 	[ 'margin-right', '1px' ],
      * 	[ 'margin-bottom', '2px' ]
      * 	// the 'left' value is missing - cannot use 'margin' shorthand.
      * ]
      * ```
      *
      * **Note**: To define reducer callbacks use {@link #setReducer}.
      *
      * @param name Name of style property.
      */
      getReducedForm(name, styles) {
        const normalizedValue = this.getNormalized(name, styles);
        if (normalizedValue === void 0) {
          return [];
        }
        if (this._reducers.has(name)) {
          const reducer = this._reducers.get(name);
          return reducer(normalizedValue);
        }
        return [
          [
            name,
            normalizedValue
          ]
        ];
      }
      /**
      * Return all style properties. Also expand shorthand properties (e.g. `margin`, `background`) if respective extractor is available.
      *
      * @param styles Object holding normalized styles.
      */
      getStyleNames(styles) {
        const styleNamesKeysSet = /* @__PURE__ */ new Set();
        for (const name of this._consumables.keys()) {
          const style = this.getNormalized(name, styles);
          if (style && (typeof style != "object" || Object.keys(style).length)) {
            styleNamesKeysSet.add(name);
          }
        }
        for (const name of Object.keys(styles)) {
          styleNamesKeysSet.add(name);
        }
        return Array.from(styleNamesKeysSet);
      }
      /**
      * Returns related style names.
      *
      * ```ts
      * stylesProcessor.getRelatedStyles( 'margin' );
      * // will return: [ 'margin-top', 'margin-right', 'margin-bottom', 'margin-left' ];
      *
      * stylesProcessor.getRelatedStyles( 'margin-top' );
      * // will return: [ 'margin' ];
      * ```
      *
      * **Note**: To define new style relations load an existing style processor or use
      * {@link module:engine/view/stylesmap~StylesProcessor#setStyleRelation `StylesProcessor.setStyleRelation()`}.
      */
      getRelatedStyles(name) {
        return this._consumables.get(name) || [];
      }
      /**
      * Adds a normalizer method for a style property.
      *
      * A normalizer returns describing how the value should be normalized.
      *
      * For instance 'margin' style is a shorthand for four margin values:
      *
      * - 'margin-top'
      * - 'margin-right'
      * - 'margin-bottom'
      * - 'margin-left'
      *
      * and can be written in various ways if some values are equal to others. For instance `'margin: 1px 2em;'` is a shorthand for
      * `'margin-top: 1px;margin-right: 2em;margin-bottom: 1px;margin-left: 2em'`.
      *
      * A normalizer should parse various margin notations as a single object:
      *
      * ```ts
      * const styles = {
      * 	margin: {
      * 		top: '1px',
      * 		right: '2em',
      * 		bottom: '1px',
      * 		left: '2em'
      * 	}
      * };
      * ```
      *
      * Thus a normalizer for 'margin' style should return an object defining style path and value to store:
      *
      * ```ts
      * const returnValue = {
      * 	path: 'margin',
      * 	value: {
      * 		top: '1px',
      * 		right: '2em',
      * 		bottom: '1px',
      * 		left: '2em'
      * 	}
      * };
      * ```
      *
      * Additionally to fully support all margin notations there should be also defined 4 normalizers for longhand margin notations. Below
      * is an example for 'margin-top' style property normalizer:
      *
      * ```ts
      * stylesProcessor.setNormalizer( 'margin-top', valueString => {
      * 	return {
      * 		path: 'margin.top',
      * 		value: valueString
      * 	}
      * } );
      * ```
      */
      setNormalizer(name, callback) {
        this._normalizers.set(name, callback);
      }
      /**
      * Adds a extractor callback for a style property.
      *
      * Most normalized style values are stored as one level objects. It is assumed that `'margin-top'` style will be stored as:
      *
      * ```ts
      * const styles = {
      * 	margin: {
      * 		top: 'value'
      * 	}
      * }
      * ```
      *
      * However, some styles can have conflicting notations and thus it might be harder to extract a style value from shorthand. For instance
      * the 'border-top-style' can be defined using `'border-top:solid'`, `'border-style:solid none none none'` or by `'border:solid'`
      * shorthands. The default border styles processors stores styles as:
      *
      * ```ts
      * const styles = {
      * 	border: {
      * 		style: {
      * 			top: 'solid'
      * 		}
      * 	}
      * }
      * ```
      *
      * as it is better to modify border style independently from other values. On the other part the output of the border might be
      * desired as `border-top`, `border-left`, etc notation.
      *
      * In the above example an extractor should return a side border value that combines style, color and width:
      *
      * ```ts
      * styleProcessor.setExtractor( 'border-top', styles => {
      * 	return {
      * 		color: styles.border.color.top,
      * 		style: styles.border.style.top,
      * 		width: styles.border.width.top
      * 	}
      * } );
      * ```
      *
      * @param callbackOrPath Callback that return a requested value or path string for single values.
      */
      setExtractor(name, callbackOrPath) {
        this._extractors.set(name, callbackOrPath);
      }
      /**
      * Adds a reducer callback for a style property.
      *
      * Reducer returns a minimal notation for given style name. For longhand properties it is not required to write a reducer as
      * by default the direct value from style path is taken.
      *
      * For shorthand styles a reducer should return minimal style notation either by returning single name-value tuple or multiple tuples
      * if a shorthand cannot be used. For instance for a margin shorthand a reducer might return:
      *
      * ```ts
      * const marginShortHandTuple = [
      * 	[ 'margin', '1px 1px 2px' ]
      * ];
      * ```
      *
      * or a longhand tuples for defined values:
      *
      * ```ts
      * // Considering margin.bottom and margin.left are undefined.
      * const marginLonghandsTuples = [
      * 	[ 'margin-top', '1px' ],
      * 	[ 'margin-right', '1px' ]
      * ];
      * ```
      *
      * A reducer obtains a normalized style value:
      *
      * ```ts
      * // Simplified reducer that always outputs 4 values which are always present:
      * stylesProcessor.setReducer( 'margin', margin => {
      * 	return [
      * 		[ 'margin', `${ margin.top } ${ margin.right } ${ margin.bottom } ${ margin.left }` ]
      * 	]
      * } );
      * ```
      */
      setReducer(name, callback) {
        this._reducers.set(name, callback);
      }
      /**
      * Defines a style shorthand relation to other style notations.
      *
      * ```ts
      * stylesProcessor.setStyleRelation( 'margin', [
      * 	'margin-top',
      * 	'margin-right',
      * 	'margin-bottom',
      * 	'margin-left'
      * ] );
      * ```
      *
      * This enables expanding of style names for shorthands. For instance, if defined,
      * {@link module:engine/conversion/viewconsumable~ViewConsumable view consumable} items are automatically created
      * for long-hand margin style notation alongside the `'margin'` item.
      *
      * This means that when an element being converted has a style `margin`, a converter for `margin-left` will work just
      * fine since the view consumable will contain a consumable `margin-left` item (thanks to the relation) and
      * `element.getStyle( 'margin-left' )` will work as well assuming that the style processor was correctly configured.
      * However, once `margin-left` is consumed, `margin` will not be consumable anymore.
      */
      setStyleRelation(shorthandName, styleNames) {
        this._mapStyleNames(shorthandName, styleNames);
        for (const alsoName of styleNames) {
          this._mapStyleNames(alsoName, [
            shorthandName
          ]);
        }
      }
      /**
      * Set two-way binding of style names.
      */
      _mapStyleNames(name, styleNames) {
        if (!this._consumables.has(name)) {
          this._consumables.set(name, []);
        }
        this._consumables.get(name).push(...styleNames);
      }
    }
    function parseInlineStyles(stylesString) {
      let quoteType = null;
      let propertyNameStart = 0;
      let propertyValueStart = 0;
      let propertyName = null;
      const stylesMap = /* @__PURE__ */ new Map();
      if (stylesString === "") {
        return stylesMap;
      }
      if (stylesString.charAt(stylesString.length - 1) != ";") {
        stylesString = stylesString + ";";
      }
      for (let i2 = 0; i2 < stylesString.length; i2++) {
        const char = stylesString.charAt(i2);
        if (quoteType === null) {
          switch (char) {
            case ":":
              if (!propertyName) {
                propertyName = stylesString.substr(propertyNameStart, i2 - propertyNameStart);
                propertyValueStart = i2 + 1;
              }
              break;
            case '"':
            case "'":
              quoteType = char;
              break;
            case ";": {
              const propertyValue = stylesString.substr(propertyValueStart, i2 - propertyValueStart);
              if (propertyName) {
                stylesMap.set(propertyName.trim(), propertyValue.trim());
              }
              propertyName = null;
              propertyNameStart = i2 + 1;
              break;
            }
          }
        } else if (char === quoteType) {
          quoteType = null;
        }
      }
      return stylesMap;
    }
    function toPath(name) {
      return name.replace("-", ".");
    }
    function appendStyleValue(stylesObject, nameOrPath, valueOrObject) {
      let valueToSet = valueOrObject;
      if (isObject$3(valueOrObject)) {
        valueToSet = merge$1({}, get(stylesObject, nameOrPath), valueOrObject);
      }
      set$1(stylesObject, nameOrPath, valueToSet);
    }
    let Element$1 = class Element2 extends Node$2 {
      /**
      * Creates a view element.
      *
      * Attributes can be passed in various formats:
      *
      * ```ts
      * new Element( viewDocument, 'div', { class: 'editor', contentEditable: 'true' } ); // object
      * new Element( viewDocument, 'div', [ [ 'class', 'editor' ], [ 'contentEditable', 'true' ] ] ); // map-like iterator
      * new Element( viewDocument, 'div', mapOfAttributes ); // map
      * ```
      *
      * @internal
      * @param document The document instance to which this element belongs.
      * @param name Node name.
      * @param attrs Collection of attributes.
      * @param children A list of nodes to be inserted into created element.
      */
      constructor(document2, name, attrs, children) {
        super(document2);
        /**
        * Name of the element.
        */
        __publicField(this, "name");
        /**
        * A list of attribute names that should be rendered in the editing pipeline even though filtering mechanisms
        * implemented in the {@link module:engine/view/domconverter~DomConverter} (for instance,
        * {@link module:engine/view/domconverter~DomConverter#shouldRenderAttribute}) would filter them out.
        *
        * These attributes can be specified as an option when the element is created by
        * the {@link module:engine/view/downcastwriter~DowncastWriter}. To check whether an unsafe an attribute should
        * be permitted, use the {@link #shouldRenderUnsafeAttribute} method.
        *
        * @internal
        */
        __publicField(this, "_unsafeAttributesToRender", []);
        /**
        * Map of attributes, where attributes names are keys and attributes values are values.
        */
        __publicField(this, "_attrs");
        /**
        * Array of child nodes.
        */
        __publicField(this, "_children");
        /**
        * Set of classes associated with element instance.
        */
        __publicField(this, "_classes");
        /**
        * Normalized styles.
        */
        __publicField(this, "_styles");
        /**
        * Map of custom properties.
        * Custom properties can be added to element instance, will be cloned but not rendered into DOM.
        */
        __publicField(this, "_customProperties", /* @__PURE__ */ new Map());
        this.name = name;
        this._attrs = parseAttributes(attrs);
        this._children = [];
        if (children) {
          this._insertChild(0, children);
        }
        this._classes = /* @__PURE__ */ new Set();
        if (this._attrs.has("class")) {
          const classString = this._attrs.get("class");
          parseClasses(this._classes, classString);
          this._attrs.delete("class");
        }
        this._styles = new StylesMap(this.document.stylesProcessor);
        if (this._attrs.has("style")) {
          this._styles.setTo(this._attrs.get("style"));
          this._attrs.delete("style");
        }
      }
      /**
      * Number of element's children.
      */
      get childCount() {
        return this._children.length;
      }
      /**
      * Is `true` if there are no nodes inside this element, `false` otherwise.
      */
      get isEmpty() {
        return this._children.length === 0;
      }
      /**
      * Gets child at the given index.
      *
      * @param index Index of child.
      * @returns Child node.
      */
      getChild(index) {
        return this._children[index];
      }
      /**
      * Gets index of the given child node. Returns `-1` if child node is not found.
      *
      * @param node Child node.
      * @returns Index of the child node.
      */
      getChildIndex(node) {
        return this._children.indexOf(node);
      }
      /**
      * Gets child nodes iterator.
      *
      * @returns Child nodes iterator.
      */
      getChildren() {
        return this._children[Symbol.iterator]();
      }
      /**
      * Returns an iterator that contains the keys for attributes. Order of inserting attributes is not preserved.
      *
      * @returns Keys for attributes.
      */
      *getAttributeKeys() {
        if (this._classes.size > 0) {
          yield "class";
        }
        if (!this._styles.isEmpty) {
          yield "style";
        }
        yield* this._attrs.keys();
      }
      /**
      * Returns iterator that iterates over this element's attributes.
      *
      * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.
      * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
      */
      *getAttributes() {
        yield* this._attrs.entries();
        if (this._classes.size > 0) {
          yield [
            "class",
            this.getAttribute("class")
          ];
        }
        if (!this._styles.isEmpty) {
          yield [
            "style",
            this.getAttribute("style")
          ];
        }
      }
      /**
      * Gets attribute by key. If attribute is not present - returns undefined.
      *
      * @param key Attribute key.
      * @returns Attribute value.
      */
      getAttribute(key) {
        if (key == "class") {
          if (this._classes.size > 0) {
            return [
              ...this._classes
            ].join(" ");
          }
          return void 0;
        }
        if (key == "style") {
          const inlineStyle = this._styles.toString();
          return inlineStyle == "" ? void 0 : inlineStyle;
        }
        return this._attrs.get(key);
      }
      /**
      * Returns a boolean indicating whether an attribute with the specified key exists in the element.
      *
      * @param key Attribute key.
      * @returns `true` if attribute with the specified key exists in the element, `false` otherwise.
      */
      hasAttribute(key) {
        if (key == "class") {
          return this._classes.size > 0;
        }
        if (key == "style") {
          return !this._styles.isEmpty;
        }
        return this._attrs.has(key);
      }
      /**
      * Checks if this element is similar to other element.
      * Both elements should have the same name and attributes to be considered as similar. Two similar elements
      * can contain different set of children nodes.
      */
      isSimilar(otherElement) {
        if (!(otherElement instanceof Element2)) {
          return false;
        }
        if (this === otherElement) {
          return true;
        }
        if (this.name != otherElement.name) {
          return false;
        }
        if (this._attrs.size !== otherElement._attrs.size || this._classes.size !== otherElement._classes.size || this._styles.size !== otherElement._styles.size) {
          return false;
        }
        for (const [key, value] of this._attrs) {
          if (!otherElement._attrs.has(key) || otherElement._attrs.get(key) !== value) {
            return false;
          }
        }
        for (const className of this._classes) {
          if (!otherElement._classes.has(className)) {
            return false;
          }
        }
        for (const property2 of this._styles.getStyleNames()) {
          if (!otherElement._styles.has(property2) || otherElement._styles.getAsString(property2) !== this._styles.getAsString(property2)) {
            return false;
          }
        }
        return true;
      }
      /**
      * Returns true if class is present.
      * If more then one class is provided - returns true only when all classes are present.
      *
      * ```ts
      * element.hasClass( 'foo' ); // Returns true if 'foo' class is present.
      * element.hasClass( 'foo', 'bar' ); // Returns true if 'foo' and 'bar' classes are both present.
      * ```
      */
      hasClass(...className) {
        for (const name of className) {
          if (!this._classes.has(name)) {
            return false;
          }
        }
        return true;
      }
      /**
      * Returns iterator that contains all class names.
      */
      getClassNames() {
        return this._classes.keys();
      }
      /**
      * Returns style value for the given property mae.
      * If the style does not exist `undefined` is returned.
      *
      * **Note**: This method can work with normalized style names if
      * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
      * See {@link module:engine/view/stylesmap~StylesMap#getAsString `StylesMap#getAsString()`} for details.
      *
      * For an element with style set to `'margin:1px'`:
      *
      * ```ts
      * // Enable 'margin' shorthand processing:
      * editor.data.addStyleProcessorRules( addMarginRules );
      *
      * const element = view.change( writer => {
      * 	const element = writer.createElement();
      * 	writer.setStyle( 'margin', '1px' );
      * 	writer.setStyle( 'margin-bottom', '3em' );
      *
      * 	return element;
      * } );
      *
      * element.getStyle( 'margin' ); // -> 'margin: 1px 1px 3em;'
      * ```
      */
      getStyle(property2) {
        return this._styles.getAsString(property2);
      }
      /**
      * Returns a normalized style object or single style value.
      *
      * For an element with style set to: margin:1px 2px 3em;
      *
      * ```ts
      * element.getNormalizedStyle( 'margin' ) );
      * ```
      *
      * will return:
      *
      * ```ts
      * {
      * 	top: '1px',
      * 	right: '2px',
      * 	bottom: '3em',
      * 	left: '2px'    // a normalized value from margin shorthand
      * }
      * ```
      *
      * and reading for single style value:
      *
      * ```ts
      * styles.getNormalizedStyle( 'margin-left' );
      * ```
      *
      * Will return a `2px` string.
      *
      * **Note**: This method will return normalized values only if
      * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
      * See {@link module:engine/view/stylesmap~StylesMap#getNormalized `StylesMap#getNormalized()`} for details.
      *
      * @param property Name of CSS property
      */
      getNormalizedStyle(property2) {
        return this._styles.getNormalized(property2);
      }
      /**
      * Returns iterator that contains all style names.
      *
      * @param expand Expand shorthand style properties and return all equivalent style representations.
      */
      getStyleNames(expand) {
        return this._styles.getStyleNames(expand);
      }
      /**
      * Returns true if style keys are present.
      * If more then one style property is provided - returns true only when all properties are present.
      *
      * ```ts
      * element.hasStyle( 'color' ); // Returns true if 'border-top' style is present.
      * element.hasStyle( 'color', 'border-top' ); // Returns true if 'color' and 'border-top' styles are both present.
      * ```
      */
      hasStyle(...property2) {
        for (const name of property2) {
          if (!this._styles.has(name)) {
            return false;
          }
        }
        return true;
      }
      /**
      * Returns ancestor element that match specified pattern.
      * Provided patterns should be compatible with {@link module:engine/view/matcher~Matcher Matcher} as it is used internally.
      *
      * @see module:engine/view/matcher~Matcher
      * @param patterns Patterns used to match correct ancestor. See {@link module:engine/view/matcher~Matcher}.
      * @returns Found element or `null` if no matching ancestor was found.
      */
      findAncestor(...patterns) {
        const matcher = new Matcher(...patterns);
        let parent2 = this.parent;
        while (parent2 && !parent2.is("documentFragment")) {
          if (matcher.match(parent2)) {
            return parent2;
          }
          parent2 = parent2.parent;
        }
        return null;
      }
      /**
      * Returns the custom property value for the given key.
      */
      getCustomProperty(key) {
        return this._customProperties.get(key);
      }
      /**
      * Returns an iterator which iterates over this element's custom properties.
      * Iterator provides `[ key, value ]` pairs for each stored property.
      */
      *getCustomProperties() {
        yield* this._customProperties.entries();
      }
      /**
      * Returns identity string based on element's name, styles, classes and other attributes.
      * Two elements that {@link #isSimilar are similar} will have same identity string.
      * It has the following format:
      *
      * ```ts
      * 'name class="class1,class2" style="style1:value1;style2:value2" attr1="val1" attr2="val2"'
      * ```
       *
      * For example:
      *
      * ```ts
      * const element = writer.createContainerElement( 'foo', {
      * 	banana: '10',
      * 	apple: '20',
      * 	style: 'color: red; border-color: white;',
      * 	class: 'baz'
      * } );
      *
      * // returns 'foo class="baz" style="border-color:white;color:red" apple="20" banana="10"'
      * element.getIdentity();
      * ```
      *
      * **Note**: Classes, styles and other attributes are sorted alphabetically.
      */
      getIdentity() {
        const classes = Array.from(this._classes).sort().join(",");
        const styles = this._styles.toString();
        const attributes = Array.from(this._attrs).map((i2) => `${i2[0]}="${i2[1]}"`).sort().join(" ");
        return this.name + (classes == "" ? "" : ` class="${classes}"`) + (!styles ? "" : ` style="${styles}"`) + (attributes == "" ? "" : ` ${attributes}`);
      }
      /**
      * Decides whether an unsafe attribute is whitelisted and should be rendered in the editing pipeline even though filtering mechanisms
      * like {@link module:engine/view/domconverter~DomConverter#shouldRenderAttribute} say it should not.
      *
      * Unsafe attribute names can be specified when creating an element via {@link module:engine/view/downcastwriter~DowncastWriter}.
      *
      * @param attributeName The name of the attribute to be checked.
      */
      shouldRenderUnsafeAttribute(attributeName) {
        return this._unsafeAttributesToRender.includes(attributeName);
      }
      /**
      * Clones provided element.
      *
      * @internal
      * @param deep If set to `true` clones element and all its children recursively. When set to `false`,
      * element will be cloned without any children.
      * @returns Clone of this element.
      */
      _clone(deep = false) {
        const childrenClone = [];
        if (deep) {
          for (const child of this.getChildren()) {
            childrenClone.push(child._clone(deep));
          }
        }
        const cloned = new this.constructor(this.document, this.name, this._attrs, childrenClone);
        cloned._classes = new Set(this._classes);
        cloned._styles.set(this._styles.getNormalized());
        cloned._customProperties = new Map(this._customProperties);
        cloned.getFillerOffset = this.getFillerOffset;
        cloned._unsafeAttributesToRender = this._unsafeAttributesToRender;
        return cloned;
      }
      /**
      * {@link module:engine/view/element~Element#_insertChild Insert} a child node or a list of child nodes at the end of this node
      * and sets the parent of these nodes to this element.
      *
      * @see module:engine/view/downcastwriter~DowncastWriter#insert
      * @internal
      * @param items Items to be inserted.
      * @fires change
      * @returns Number of appended nodes.
      */
      _appendChild(items) {
        return this._insertChild(this.childCount, items);
      }
      /**
      * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to
      * this element.
      *
      * @internal
      * @see module:engine/view/downcastwriter~DowncastWriter#insert
      * @param index Position where nodes should be inserted.
      * @param items Items to be inserted.
      * @fires change
      * @returns Number of inserted nodes.
      */
      _insertChild(index, items) {
        this._fireChange("children", this);
        let count2 = 0;
        const nodes = normalize$3(this.document, items);
        for (const node of nodes) {
          if (node.parent !== null) {
            node._remove();
          }
          node.parent = this;
          node.document = this.document;
          this._children.splice(index, 0, node);
          index++;
          count2++;
        }
        return count2;
      }
      /**
      * Removes number of child nodes starting at the given index and set the parent of these nodes to `null`.
      *
      * @see module:engine/view/downcastwriter~DowncastWriter#remove
      * @internal
      * @param index Number of the first node to remove.
      * @param howMany Number of nodes to remove.
      * @fires change
      * @returns The array of removed nodes.
      */
      _removeChildren(index, howMany = 1) {
        this._fireChange("children", this);
        for (let i2 = index; i2 < index + howMany; i2++) {
          this._children[i2].parent = null;
        }
        return this._children.splice(index, howMany);
      }
      /**
      * Adds or overwrite attribute with a specified key and value.
      *
      * @see module:engine/view/downcastwriter~DowncastWriter#setAttribute
      * @internal
      * @param key Attribute key.
      * @param value Attribute value.
      * @fires change
      */
      _setAttribute(key, value) {
        const stringValue = String(value);
        this._fireChange("attributes", this);
        if (key == "class") {
          parseClasses(this._classes, stringValue);
        } else if (key == "style") {
          this._styles.setTo(stringValue);
        } else {
          this._attrs.set(key, stringValue);
        }
      }
      /**
      * Removes attribute from the element.
      *
      * @see module:engine/view/downcastwriter~DowncastWriter#removeAttribute
      * @internal
      * @param key Attribute key.
      * @returns Returns true if an attribute existed and has been removed.
      * @fires change
      */
      _removeAttribute(key) {
        this._fireChange("attributes", this);
        if (key == "class") {
          if (this._classes.size > 0) {
            this._classes.clear();
            return true;
          }
          return false;
        }
        if (key == "style") {
          if (!this._styles.isEmpty) {
            this._styles.clear();
            return true;
          }
          return false;
        }
        return this._attrs.delete(key);
      }
      /**
      * Adds specified class.
      *
      * ```ts
      * element._addClass( 'foo' ); // Adds 'foo' class.
      * element._addClass( [ 'foo', 'bar' ] ); // Adds 'foo' and 'bar' classes.
      * ```
      *
      * @see module:engine/view/downcastwriter~DowncastWriter#addClass
      * @internal
      * @fires change
      */
      _addClass(className) {
        this._fireChange("attributes", this);
        for (const name of toArray$2(className)) {
          this._classes.add(name);
        }
      }
      /**
      * Removes specified class.
      *
      * ```ts
      * element._removeClass( 'foo' );  // Removes 'foo' class.
      * element._removeClass( [ 'foo', 'bar' ] ); // Removes both 'foo' and 'bar' classes.
      * ```
      *
      * @see module:engine/view/downcastwriter~DowncastWriter#removeClass
      * @internal
      * @fires change
      */
      _removeClass(className) {
        this._fireChange("attributes", this);
        for (const name of toArray$2(className)) {
          this._classes.delete(name);
        }
      }
      _setStyle(property2, value) {
        this._fireChange("attributes", this);
        if (typeof property2 != "string") {
          this._styles.set(property2);
        } else {
          this._styles.set(property2, value);
        }
      }
      /**
      * Removes specified style.
      *
      * ```ts
      * element._removeStyle( 'color' );  // Removes 'color' style.
      * element._removeStyle( [ 'color', 'border-top' ] ); // Removes both 'color' and 'border-top' styles.
      * ```
      *
      * **Note**: This method can work with normalized style names if
      * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
      * See {@link module:engine/view/stylesmap~StylesMap#remove `StylesMap#remove()`} for details.
      *
      * @see module:engine/view/downcastwriter~DowncastWriter#removeStyle
      * @internal
      * @fires change
      */
      _removeStyle(property2) {
        this._fireChange("attributes", this);
        for (const name of toArray$2(property2)) {
          this._styles.remove(name);
        }
      }
      /**
      * Sets a custom property. Unlike attributes, custom properties are not rendered to the DOM,
      * so they can be used to add special data to elements.
      *
      * @see module:engine/view/downcastwriter~DowncastWriter#setCustomProperty
      * @internal
      */
      _setCustomProperty(key, value) {
        this._customProperties.set(key, value);
      }
      /**
      * Removes the custom property stored under the given key.
      *
      * @see module:engine/view/downcastwriter~DowncastWriter#removeCustomProperty
      * @internal
      * @returns Returns true if property was removed.
      */
      _removeCustomProperty(key) {
        return this._customProperties.delete(key);
      }
    };
    Element$1.prototype.is = function(type, name) {
      if (!name) {
        return type === "element" || type === "view:element" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === "node" || type === "view:node";
      } else {
        return name === this.name && (type === "element" || type === "view:element");
      }
    };
    function parseAttributes(attrs) {
      const attrsMap = toMap(attrs);
      for (const [key, value] of attrsMap) {
        if (value === null) {
          attrsMap.delete(key);
        } else if (typeof value != "string") {
          attrsMap.set(key, String(value));
        }
      }
      return attrsMap;
    }
    function parseClasses(classesSet, classesString) {
      const classArray = classesString.split(/\s+/);
      classesSet.clear();
      classArray.forEach((name) => classesSet.add(name));
    }
    function normalize$3(document2, nodes) {
      if (typeof nodes == "string") {
        return [
          new Text$1(document2, nodes)
        ];
      }
      if (!isIterable(nodes)) {
        nodes = [
          nodes
        ];
      }
      return Array.from(nodes).map((node) => {
        if (typeof node == "string") {
          return new Text$1(document2, node);
        }
        if (node instanceof TextProxy$1) {
          return new Text$1(document2, node.data);
        }
        return node;
      });
    }
    class ContainerElement extends Element$1 {
      /**
      * Creates a container element.
      *
      * @see module:engine/view/downcastwriter~DowncastWriter#createContainerElement
      * @see module:engine/view/element~Element
      * @internal
      * @param document The document instance to which this element belongs.
      * @param name Node name.
      * @param attrs Collection of attributes.
      * @param children A list of nodes to be inserted into created element.
      */
      constructor(document2, name, attrs, children) {
        super(document2, name, attrs, children);
        this.getFillerOffset = getFillerOffset$4;
      }
    }
    ContainerElement.prototype.is = function(type, name) {
      if (!name) {
        return type === "containerElement" || type === "view:containerElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === "element" || type === "view:element" || type === "node" || type === "view:node";
      } else {
        return name === this.name && (type === "containerElement" || type === "view:containerElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === "element" || type === "view:element");
      }
    };
    function getFillerOffset$4() {
      const children = [
        ...this.getChildren()
      ];
      const lastChild = children[this.childCount - 1];
      if (lastChild && lastChild.is("element", "br")) {
        return this.childCount;
      }
      for (const child of children) {
        if (!child.is("uiElement")) {
          return null;
        }
      }
      return this.childCount;
    }
    class EditableElement extends (/* @__PURE__ */ ObservableMixin(ContainerElement)) {
      /**
      * Creates an editable element.
      *
      * @see module:engine/view/downcastwriter~DowncastWriter#createEditableElement
      * @internal
      * @param document The document instance to which this element belongs.
      * @param name Node name.
      * @param attrs Collection of attributes.
      * @param children A list of nodes to be inserted into created element.
      */
      constructor(document2, name, attributes, children) {
        super(document2, name, attributes, children);
        this.set("isReadOnly", false);
        this.set("isFocused", false);
        this.set("placeholder", void 0);
        this.bind("isReadOnly").to(document2);
        this.bind("isFocused").to(document2, "isFocused", (isFocused) => isFocused && document2.selection.editableElement == this);
        this.listenTo(document2.selection, "change", () => {
          this.isFocused = document2.isFocused && document2.selection.editableElement == this;
        });
      }
      destroy() {
        this.stopListening();
      }
    }
    EditableElement.prototype.is = function(type, name) {
      if (!name) {
        return type === "editableElement" || type === "view:editableElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === "containerElement" || type === "view:containerElement" || type === "element" || type === "view:element" || type === "node" || type === "view:node";
      } else {
        return name === this.name && (type === "editableElement" || type === "view:editableElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === "containerElement" || type === "view:containerElement" || type === "element" || type === "view:element");
      }
    };
    const rootNameSymbol = Symbol("rootName");
    class RootEditableElement extends EditableElement {
      /**
      * Creates root editable element.
      *
      * @param document The document instance to which this element belongs.
      * @param name Node name.
      */
      constructor(document2, name) {
        super(document2, name);
        this.rootName = "main";
      }
      /**
      * Name of this root inside {@link module:engine/view/document~Document} that is an owner of this root. If no
      * other name is set, `main` name is used.
      *
      * @readonly
      */
      get rootName() {
        return this.getCustomProperty(rootNameSymbol);
      }
      set rootName(rootName) {
        this._setCustomProperty(rootNameSymbol, rootName);
      }
      /**
      * Overrides old element name and sets new one.
      * This is needed because view roots are created before they are attached to the DOM.
      * The name of the root element is temporary at this stage. It has to be changed when the
      * view root element is attached to the DOM element.
      *
      * @internal
      * @param name The new name of element.
      */
      set _name(name) {
        this.name = name;
      }
    }
    RootEditableElement.prototype.is = function(type, name) {
      if (!name) {
        return type === "rootElement" || type === "view:rootElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === "editableElement" || type === "view:editableElement" || type === "containerElement" || type === "view:containerElement" || type === "element" || type === "view:element" || type === "node" || type === "view:node";
      } else {
        return name === this.name && (type === "rootElement" || type === "view:rootElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === "editableElement" || type === "view:editableElement" || type === "containerElement" || type === "view:containerElement" || type === "element" || type === "view:element");
      }
    };
    let TreeWalker$1 = class TreeWalker {
      /**
      * Creates a range iterator. All parameters are optional, but you have to specify either `boundaries` or `startPosition`.
      *
      * @param options Object with configuration.
      */
      constructor(options = {}) {
        /**
        * Walking direction. Defaults `'forward'`.
        */
        __publicField(this, "direction");
        /**
        * Iterator boundaries.
        *
        * When the iterator is walking `'forward'` on the end of boundary or is walking `'backward'`
        * on the start of boundary, then `{ done: true }` is returned.
        *
        * If boundaries are not defined they are set before first and after last child of the root node.
        */
        __publicField(this, "boundaries");
        /**
        * Flag indicating whether all characters from {@link module:engine/view/text~Text} should be returned as one
        * {@link module:engine/view/text~Text} or one by one as {@link module:engine/view/textproxy~TextProxy}.
        */
        __publicField(this, "singleCharacters");
        /**
        * Flag indicating whether iterator should enter elements or not. If the iterator is shallow child nodes of any
        * iterated node will not be returned along with `elementEnd` tag.
        */
        __publicField(this, "shallow");
        /**
        * Flag indicating whether iterator should ignore `elementEnd` tags. If set to `true`, walker will not
        * return a parent node of the start position. Each {@link module:engine/view/element~Element} will be returned once.
        * When set to `false` each element might be returned twice: for `'elementStart'` and `'elementEnd'`.
        */
        __publicField(this, "ignoreElementEnd");
        /**
        * Iterator position. If start position is not defined then position depends on {@link #direction}. If direction is
        * `'forward'` position starts form the beginning, when direction is `'backward'` position starts from the end.
        */
        __publicField(this, "_position");
        /**
        * Start boundary parent.
        */
        __publicField(this, "_boundaryStartParent");
        /**
        * End boundary parent.
        */
        __publicField(this, "_boundaryEndParent");
        if (!options.boundaries && !options.startPosition) {
          throw new CKEditorError("view-tree-walker-no-start-position", null);
        }
        if (options.direction && options.direction != "forward" && options.direction != "backward") {
          throw new CKEditorError("view-tree-walker-unknown-direction", options.startPosition, {
            direction: options.direction
          });
        }
        this.boundaries = options.boundaries || null;
        if (options.startPosition) {
          this._position = Position$1._createAt(options.startPosition);
        } else {
          this._position = Position$1._createAt(options.boundaries[options.direction == "backward" ? "end" : "start"]);
        }
        this.direction = options.direction || "forward";
        this.singleCharacters = !!options.singleCharacters;
        this.shallow = !!options.shallow;
        this.ignoreElementEnd = !!options.ignoreElementEnd;
        this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;
        this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;
      }
      /**
      * Iterable interface.
      */
      [Symbol.iterator]() {
        return this;
      }
      /**
      * Iterator position. If start position is not defined then position depends on {@link #direction}. If direction is
      * `'forward'` position starts form the beginning, when direction is `'backward'` position starts from the end.
      */
      get position() {
        return this._position;
      }
      /**
      * Moves {@link #position} in the {@link #direction} skipping values as long as the callback function returns `true`.
      *
      * For example:
      *
      * ```ts
      * walker.skip( value => value.type == 'text' ); // <p>{}foo</p> -> <p>foo[]</p>
      * walker.skip( value => true ); // Move the position to the end: <p>{}foo</p> -> <p>foo</p>[]
      * walker.skip( value => false ); // Do not move the position.
      * ```
      *
      * @param skip Callback function. Gets {@link module:engine/view/treewalker~TreeWalkerValue} and should
      * return `true` if the value should be skipped or `false` if not.
      */
      skip(skip) {
        let nextResult;
        let prevPosition;
        do {
          prevPosition = this.position;
          nextResult = this.next();
        } while (!nextResult.done && skip(nextResult.value));
        if (!nextResult.done) {
          this._position = prevPosition;
        }
      }
      /**
      * Gets the next tree walker's value.
      *
      * @returns Object implementing iterator interface, returning
      * information about taken step.
      */
      next() {
        if (this.direction == "forward") {
          return this._next();
        } else {
          return this._previous();
        }
      }
      /**
      * Makes a step forward in view. Moves the {@link #position} to the next position and returns the encountered value.
      */
      _next() {
        let position = this.position.clone();
        const previousPosition = this.position;
        const parent2 = position.parent;
        if (parent2.parent === null && position.offset === parent2.childCount) {
          return {
            done: true,
            value: void 0
          };
        }
        if (parent2 === this._boundaryEndParent && position.offset == this.boundaries.end.offset) {
          return {
            done: true,
            value: void 0
          };
        }
        let node;
        if (parent2 instanceof Text$1) {
          if (position.isAtEnd) {
            this._position = Position$1._createAfter(parent2);
            return this._next();
          }
          node = parent2.data[position.offset];
        } else {
          node = parent2.getChild(position.offset);
        }
        if (node instanceof Element$1) {
          if (!this.shallow) {
            position = new Position$1(node, 0);
          } else {
            if (this.boundaries && this.boundaries.end.isBefore(position)) {
              return {
                done: true,
                value: void 0
              };
            }
            position.offset++;
          }
          this._position = position;
          return this._formatReturnValue("elementStart", node, previousPosition, position, 1);
        }
        if (node instanceof Text$1) {
          if (this.singleCharacters) {
            position = new Position$1(node, 0);
            this._position = position;
            return this._next();
          }
          let charactersCount = node.data.length;
          let item;
          if (node == this._boundaryEndParent) {
            charactersCount = this.boundaries.end.offset;
            item = new TextProxy$1(node, 0, charactersCount);
            position = Position$1._createAfter(item);
          } else {
            item = new TextProxy$1(node, 0, node.data.length);
            position.offset++;
          }
          this._position = position;
          return this._formatReturnValue("text", item, previousPosition, position, charactersCount);
        }
        if (typeof node == "string") {
          let textLength;
          if (this.singleCharacters) {
            textLength = 1;
          } else {
            const endOffset = parent2 === this._boundaryEndParent ? this.boundaries.end.offset : parent2.data.length;
            textLength = endOffset - position.offset;
          }
          const textProxy = new TextProxy$1(parent2, position.offset, textLength);
          position.offset += textLength;
          this._position = position;
          return this._formatReturnValue("text", textProxy, previousPosition, position, textLength);
        }
        position = Position$1._createAfter(parent2);
        this._position = position;
        if (this.ignoreElementEnd) {
          return this._next();
        }
        return this._formatReturnValue("elementEnd", parent2, previousPosition, position);
      }
      /**
      * Makes a step backward in view. Moves the {@link #position} to the previous position and returns the encountered value.
      */
      _previous() {
        let position = this.position.clone();
        const previousPosition = this.position;
        const parent2 = position.parent;
        if (parent2.parent === null && position.offset === 0) {
          return {
            done: true,
            value: void 0
          };
        }
        if (parent2 == this._boundaryStartParent && position.offset == this.boundaries.start.offset) {
          return {
            done: true,
            value: void 0
          };
        }
        let node;
        if (parent2 instanceof Text$1) {
          if (position.isAtStart) {
            this._position = Position$1._createBefore(parent2);
            return this._previous();
          }
          node = parent2.data[position.offset - 1];
        } else {
          node = parent2.getChild(position.offset - 1);
        }
        if (node instanceof Element$1) {
          if (this.shallow) {
            position.offset--;
            this._position = position;
            return this._formatReturnValue("elementStart", node, previousPosition, position, 1);
          }
          position = new Position$1(node, node.childCount);
          this._position = position;
          if (this.ignoreElementEnd) {
            return this._previous();
          }
          return this._formatReturnValue("elementEnd", node, previousPosition, position);
        }
        if (node instanceof Text$1) {
          if (this.singleCharacters) {
            position = new Position$1(node, node.data.length);
            this._position = position;
            return this._previous();
          }
          let charactersCount = node.data.length;
          let item;
          if (node == this._boundaryStartParent) {
            const offset2 = this.boundaries.start.offset;
            item = new TextProxy$1(node, offset2, node.data.length - offset2);
            charactersCount = item.data.length;
            position = Position$1._createBefore(item);
          } else {
            item = new TextProxy$1(node, 0, node.data.length);
            position.offset--;
          }
          this._position = position;
          return this._formatReturnValue("text", item, previousPosition, position, charactersCount);
        }
        if (typeof node == "string") {
          let textLength;
          if (!this.singleCharacters) {
            const startOffset = parent2 === this._boundaryStartParent ? this.boundaries.start.offset : 0;
            textLength = position.offset - startOffset;
          } else {
            textLength = 1;
          }
          position.offset -= textLength;
          const textProxy = new TextProxy$1(parent2, position.offset, textLength);
          this._position = position;
          return this._formatReturnValue("text", textProxy, previousPosition, position, textLength);
        }
        position = Position$1._createBefore(parent2);
        this._position = position;
        return this._formatReturnValue("elementStart", parent2, previousPosition, position, 1);
      }
      /**
      * Format returned data and adjust `previousPosition` and `nextPosition` if reach the bound of the {@link module:engine/view/text~Text}.
      *
      * @param type Type of step.
      * @param item Item between old and new position.
      * @param previousPosition Previous position of iterator.
      * @param nextPosition Next position of iterator.
      * @param length Length of the item.
      */
      _formatReturnValue(type, item, previousPosition, nextPosition, length) {
        if (item instanceof TextProxy$1) {
          if (item.offsetInText + item.data.length == item.textNode.data.length) {
            if (this.direction == "forward" && !(this.boundaries && this.boundaries.end.isEqual(this.position))) {
              nextPosition = Position$1._createAfter(item.textNode);
              this._position = nextPosition;
            } else {
              previousPosition = Position$1._createAfter(item.textNode);
            }
          }
          if (item.offsetInText === 0) {
            if (this.direction == "backward" && !(this.boundaries && this.boundaries.start.isEqual(this.position))) {
              nextPosition = Position$1._createBefore(item.textNode);
              this._position = nextPosition;
            } else {
              previousPosition = Position$1._createBefore(item.textNode);
            }
          }
        }
        return {
          done: false,
          value: {
            type,
            item,
            previousPosition,
            nextPosition,
            length
          }
        };
      }
    };
    let Position$1 = class Position2 extends TypeCheckable$1 {
      /**
      * Creates a position.
      *
      * @param parent Position parent.
      * @param offset Position offset.
      */
      constructor(parent2, offset2) {
        super();
        /**
        * Position parent.
        */
        __publicField(this, "parent");
        /**
        * Position offset.
        */
        __publicField(this, "offset");
        this.parent = parent2;
        this.offset = offset2;
      }
      /**
      * Node directly after the position. Equals `null` when there is no node after position or position is located
      * inside text node.
      */
      get nodeAfter() {
        if (this.parent.is("$text")) {
          return null;
        }
        return this.parent.getChild(this.offset) || null;
      }
      /**
      * Node directly before the position. Equals `null` when there is no node before position or position is located
      * inside text node.
      */
      get nodeBefore() {
        if (this.parent.is("$text")) {
          return null;
        }
        return this.parent.getChild(this.offset - 1) || null;
      }
      /**
      * Is `true` if position is at the beginning of its {@link module:engine/view/position~Position#parent parent}, `false` otherwise.
      */
      get isAtStart() {
        return this.offset === 0;
      }
      /**
      * Is `true` if position is at the end of its {@link module:engine/view/position~Position#parent parent}, `false` otherwise.
      */
      get isAtEnd() {
        const endOffset = this.parent.is("$text") ? this.parent.data.length : this.parent.childCount;
        return this.offset === endOffset;
      }
      /**
      * Position's root, that is the root of the position's parent element.
      */
      get root() {
        return this.parent.root;
      }
      /**
      * {@link module:engine/view/editableelement~EditableElement EditableElement} instance that contains this position, or `null` if
      * position is not inside an editable element.
      */
      get editableElement() {
        let editable = this.parent;
        while (!(editable instanceof EditableElement)) {
          if (editable.parent) {
            editable = editable.parent;
          } else {
            return null;
          }
        }
        return editable;
      }
      /**
      * Returns a new instance of Position with offset incremented by `shift` value.
      *
      * @param shift How position offset should get changed. Accepts negative values.
      * @returns Shifted position.
      */
      getShiftedBy(shift2) {
        const shifted = Position2._createAt(this);
        const offset2 = shifted.offset + shift2;
        shifted.offset = offset2 < 0 ? 0 : offset2;
        return shifted;
      }
      /**
      * Gets the farthest position which matches the callback using
      * {@link module:engine/view/treewalker~TreeWalker TreeWalker}.
      *
      * For example:
      *
      * ```ts
      * getLastMatchingPosition( value => value.type == 'text' ); // <p>{}foo</p> -> <p>foo[]</p>
      * getLastMatchingPosition( value => value.type == 'text', { direction: 'backward' } ); // <p>foo[]</p> -> <p>{}foo</p>
      * getLastMatchingPosition( value => false ); // Do not move the position.
      * ```
      *
      * @param skip Callback function. Gets {@link module:engine/view/treewalker~TreeWalkerValue} and should
      * return `true` if the value should be skipped or `false` if not.
      * @param options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.
      * @returns The position after the last item which matches the `skip` callback test.
      */
      getLastMatchingPosition(skip, options = {}) {
        options.startPosition = this;
        const treeWalker = new TreeWalker$1(options);
        treeWalker.skip(skip);
        return treeWalker.position;
      }
      /**
      * Returns ancestors array of this position, that is this position's parent and it's ancestors.
      *
      * @returns Array with ancestors.
      */
      getAncestors() {
        if (this.parent.is("documentFragment")) {
          return [
            this.parent
          ];
        } else {
          return this.parent.getAncestors({
            includeSelf: true
          });
        }
      }
      /**
      * Returns a {@link module:engine/view/node~Node} or {@link module:engine/view/documentfragment~DocumentFragment}
      * which is a common ancestor of both positions.
      */
      getCommonAncestor(position) {
        const ancestorsA = this.getAncestors();
        const ancestorsB = position.getAncestors();
        let i2 = 0;
        while (ancestorsA[i2] == ancestorsB[i2] && ancestorsA[i2]) {
          i2++;
        }
        return i2 === 0 ? null : ancestorsA[i2 - 1];
      }
      /**
      * Checks whether this position equals given position.
      *
      * @param otherPosition Position to compare with.
      * @returns True if positions are same.
      */
      isEqual(otherPosition) {
        return this.parent == otherPosition.parent && this.offset == otherPosition.offset;
      }
      /**
      * Checks whether this position is located before given position. When method returns `false` it does not mean that
      * this position is after give one. Two positions may be located inside separate roots and in that situation this
      * method will still return `false`.
      *
      * @see module:engine/view/position~Position#isAfter
      * @see module:engine/view/position~Position#compareWith
      * @param otherPosition Position to compare with.
      * @returns Returns `true` if this position is before given position.
      */
      isBefore(otherPosition) {
        return this.compareWith(otherPosition) == "before";
      }
      /**
      * Checks whether this position is located after given position. When method returns `false` it does not mean that
      * this position is before give one. Two positions may be located inside separate roots and in that situation this
      * method will still return `false`.
      *
      * @see module:engine/view/position~Position#isBefore
      * @see module:engine/view/position~Position#compareWith
      * @param otherPosition Position to compare with.
      * @returns Returns `true` if this position is after given position.
      */
      isAfter(otherPosition) {
        return this.compareWith(otherPosition) == "after";
      }
      /**
      * Checks whether this position is before, after or in same position that other position. Two positions may be also
      * different when they are located in separate roots.
      *
      * @param otherPosition Position to compare with.
      */
      compareWith(otherPosition) {
        if (this.root !== otherPosition.root) {
          return "different";
        }
        if (this.isEqual(otherPosition)) {
          return "same";
        }
        const thisPath = this.parent.is("node") ? this.parent.getPath() : [];
        const otherPath = otherPosition.parent.is("node") ? otherPosition.parent.getPath() : [];
        thisPath.push(this.offset);
        otherPath.push(otherPosition.offset);
        const result2 = compareArrays(thisPath, otherPath);
        switch (result2) {
          case "prefix":
            return "before";
          case "extension":
            return "after";
          default:
            return thisPath[result2] < otherPath[result2] ? "before" : "after";
        }
      }
      /**
      * Creates a {@link module:engine/view/treewalker~TreeWalker TreeWalker} instance with this positions as a start position.
      *
      * @param options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}
      */
      getWalker(options = {}) {
        options.startPosition = this;
        return new TreeWalker$1(options);
      }
      /**
      * Clones this position.
      */
      clone() {
        return new Position2(this.parent, this.offset);
      }
      /**
      * Creates position at the given location. The location can be specified as:
      *
      * * a {@link module:engine/view/position~Position position},
      * * parent element and offset (offset defaults to `0`),
      * * parent element and `'end'` (sets position at the end of that element),
      * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).
      *
      * This method is a shortcut to other constructors such as:
      *
      * * {@link module:engine/view/position~Position._createBefore},
      * * {@link module:engine/view/position~Position._createAfter}.
      *
      * @internal
      * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/view/item~Item view item}.
      */
      static _createAt(itemOrPosition, offset2) {
        if (itemOrPosition instanceof Position2) {
          return new this(itemOrPosition.parent, itemOrPosition.offset);
        } else {
          const node = itemOrPosition;
          if (offset2 == "end") {
            offset2 = node.is("$text") ? node.data.length : node.childCount;
          } else if (offset2 == "before") {
            return this._createBefore(node);
          } else if (offset2 == "after") {
            return this._createAfter(node);
          } else if (offset2 !== 0 && !offset2) {
            throw new CKEditorError("view-createpositionat-offset-required", node);
          }
          return new Position2(node, offset2);
        }
      }
      /**
      * Creates a new position after given view item.
      *
      * @internal
      * @param item View item after which the position should be located.
      */
      static _createAfter(item) {
        if (item.is("$textProxy")) {
          return new Position2(item.textNode, item.offsetInText + item.data.length);
        }
        if (!item.parent) {
          throw new CKEditorError("view-position-after-root", item, {
            root: item
          });
        }
        return new Position2(item.parent, item.index + 1);
      }
      /**
      * Creates a new position before given view item.
      *
      * @internal
      * @param item View item before which the position should be located.
      */
      static _createBefore(item) {
        if (item.is("$textProxy")) {
          return new Position2(item.textNode, item.offsetInText);
        }
        if (!item.parent) {
          throw new CKEditorError("view-position-before-root", item, {
            root: item
          });
        }
        return new Position2(item.parent, item.index);
      }
    };
    Position$1.prototype.is = function(type) {
      return type === "position" || type === "view:position";
    };
    let Range$1 = class Range2 extends TypeCheckable$1 {
      /**
      * Creates a range spanning from `start` position to `end` position.
      *
      * **Note:** Constructor creates it's own {@link module:engine/view/position~Position} instances basing on passed values.
      *
      * @param start Start position.
      * @param end End position. If not set, range will be collapsed at the `start` position.
      */
      constructor(start2, end2 = null) {
        super();
        /**
        * Start position.
        */
        __publicField(this, "start");
        /**
        * End position.
        */
        __publicField(this, "end");
        this.start = start2.clone();
        this.end = end2 ? end2.clone() : start2.clone();
      }
      /**
      * Iterable interface.
      *
      * Iterates over all {@link module:engine/view/item~Item view items} that are in this range and returns
      * them together with additional information like length or {@link module:engine/view/position~Position positions},
      * grouped as {@link module:engine/view/treewalker~TreeWalkerValue}.
      *
      * This iterator uses {@link module:engine/view/treewalker~TreeWalker TreeWalker} with `boundaries` set to this range and
      * `ignoreElementEnd` option
      * set to `true`.
      */
      *[Symbol.iterator]() {
        yield* new TreeWalker$1({
          boundaries: this,
          ignoreElementEnd: true
        });
      }
      /**
      * Returns whether the range is collapsed, that is it start and end positions are equal.
      */
      get isCollapsed() {
        return this.start.isEqual(this.end);
      }
      /**
      * Returns whether this range is flat, that is if {@link module:engine/view/range~Range#start start} position and
      * {@link module:engine/view/range~Range#end end} position are in the same {@link module:engine/view/position~Position#parent parent}.
      */
      get isFlat() {
        return this.start.parent === this.end.parent;
      }
      /**
      * Range root element.
      */
      get root() {
        return this.start.root;
      }
      /**
      * Creates a maximal range that has the same content as this range but is expanded in both ways (at the beginning
      * and at the end).
      *
      * For example:
      *
      * ```html
      * <p>Foo</p><p><b>{Bar}</b></p> -> <p>Foo</p>[<p><b>Bar</b>]</p>
      * <p><b>foo</b>{bar}<span></span></p> -> <p><b>foo[</b>bar<span></span>]</p>
      * ```
      *
      * Note that in the sample above:
      *
      * - `<p>` have type of {@link module:engine/view/containerelement~ContainerElement},
      * - `<b>` have type of {@link module:engine/view/attributeelement~AttributeElement},
      * - `<span>` have type of {@link module:engine/view/uielement~UIElement}.
      *
      * @returns Enlarged range.
      */
      getEnlarged() {
        let start2 = this.start.getLastMatchingPosition(enlargeTrimSkip, {
          direction: "backward"
        });
        let end2 = this.end.getLastMatchingPosition(enlargeTrimSkip);
        if (start2.parent.is("$text") && start2.isAtStart) {
          start2 = Position$1._createBefore(start2.parent);
        }
        if (end2.parent.is("$text") && end2.isAtEnd) {
          end2 = Position$1._createAfter(end2.parent);
        }
        return new Range2(start2, end2);
      }
      /**
      * Creates a minimum range that has the same content as this range but is trimmed in both ways (at the beginning
      * and at the end).
      *
      * For example:
      *
      * ```html
      * <p>Foo</p>[<p><b>Bar</b>]</p> -> <p>Foo</p><p><b>{Bar}</b></p>
      * <p><b>foo[</b>bar<span></span>]</p> -> <p><b>foo</b>{bar}<span></span></p>
      * ```
      *
      * Note that in the sample above:
      *
      * - `<p>` have type of {@link module:engine/view/containerelement~ContainerElement},
      * - `<b>` have type of {@link module:engine/view/attributeelement~AttributeElement},
      * - `<span>` have type of {@link module:engine/view/uielement~UIElement}.
      *
      * @returns Shrunk range.
      */
      getTrimmed() {
        let start2 = this.start.getLastMatchingPosition(enlargeTrimSkip);
        if (start2.isAfter(this.end) || start2.isEqual(this.end)) {
          return new Range2(start2, start2);
        }
        let end2 = this.end.getLastMatchingPosition(enlargeTrimSkip, {
          direction: "backward"
        });
        const nodeAfterStart = start2.nodeAfter;
        const nodeBeforeEnd = end2.nodeBefore;
        if (nodeAfterStart && nodeAfterStart.is("$text")) {
          start2 = new Position$1(nodeAfterStart, 0);
        }
        if (nodeBeforeEnd && nodeBeforeEnd.is("$text")) {
          end2 = new Position$1(nodeBeforeEnd, nodeBeforeEnd.data.length);
        }
        return new Range2(start2, end2);
      }
      /**
      * Two ranges are equal if their start and end positions are equal.
      *
      * @param otherRange Range to compare with.
      * @returns `true` if ranges are equal, `false` otherwise
      */
      isEqual(otherRange) {
        return this == otherRange || this.start.isEqual(otherRange.start) && this.end.isEqual(otherRange.end);
      }
      /**
      * Checks whether this range contains given {@link module:engine/view/position~Position position}.
      *
      * @param position Position to check.
      * @returns `true` if given {@link module:engine/view/position~Position position} is contained in this range, `false` otherwise.
      */
      containsPosition(position) {
        return position.isAfter(this.start) && position.isBefore(this.end);
      }
      /**
      * Checks whether this range contains given {@link module:engine/view/range~Range range}.
      *
      * @param otherRange Range to check.
      * @param loose Whether the check is loose or strict. If the check is strict (`false`), compared range cannot
      * start or end at the same position as this range boundaries. If the check is loose (`true`), compared range can start, end or
      * even be equal to this range. Note that collapsed ranges are always compared in strict mode.
      * @returns `true` if given {@link module:engine/view/range~Range range} boundaries are contained by this range, `false`
      * otherwise.
      */
      containsRange(otherRange, loose = false) {
        if (otherRange.isCollapsed) {
          loose = false;
        }
        const containsStart = this.containsPosition(otherRange.start) || loose && this.start.isEqual(otherRange.start);
        const containsEnd = this.containsPosition(otherRange.end) || loose && this.end.isEqual(otherRange.end);
        return containsStart && containsEnd;
      }
      /**
      * Computes which part(s) of this {@link module:engine/view/range~Range range} is not a part of given
      * {@link module:engine/view/range~Range range}.
      * Returned array contains zero, one or two {@link module:engine/view/range~Range ranges}.
      *
      * Examples:
      *
      * ```ts
      * let foo = downcastWriter.createText( 'foo' );
      * let img = downcastWriter.createContainerElement( 'img' );
      * let bar = downcastWriter.createText( 'bar' );
      * let p = downcastWriter.createContainerElement( 'p', null, [ foo, img, bar ] );
      *
      * let range = view.createRange( view.createPositionAt( foo, 2 ), view.createPositionAt( bar, 1 ); // "o", img, "b" are in range.
      * let otherRange = view.createRange( // "oo", img, "ba" are in range.
      * 	view.createPositionAt( foo, 1 ),
      * 	view.createPositionAt( bar, 2 )
      * );
      * let transformed = range.getDifference( otherRange );
      * // transformed array has no ranges because `otherRange` contains `range`
      *
      * otherRange = view.createRange( view.createPositionAt( foo, 1 ), view.createPositionAt( p, 2 ); // "oo", img are in range.
      * transformed = range.getDifference( otherRange );
      * // transformed array has one range: from ( p, 2 ) to ( bar, 1 )
      *
      * otherRange = view.createRange( view.createPositionAt( p, 1 ), view.createPositionAt( p, 2 ) ); // img is in range.
      * transformed = range.getDifference( otherRange );
      * // transformed array has two ranges: from ( foo, 1 ) to ( p, 1 ) and from ( p, 2 ) to ( bar, 1 )
      * ```
      *
      * @param otherRange Range to differentiate against.
      * @returns The difference between ranges.
      */
      getDifference(otherRange) {
        const ranges = [];
        if (this.isIntersecting(otherRange)) {
          if (this.containsPosition(otherRange.start)) {
            ranges.push(new Range2(this.start, otherRange.start));
          }
          if (this.containsPosition(otherRange.end)) {
            ranges.push(new Range2(otherRange.end, this.end));
          }
        } else {
          ranges.push(this.clone());
        }
        return ranges;
      }
      /**
      * Returns an intersection of this {@link module:engine/view/range~Range range} and given {@link module:engine/view/range~Range range}.
      * Intersection is a common part of both of those ranges. If ranges has no common part, returns `null`.
      *
      * Examples:
      *
      * ```ts
      * let foo = downcastWriter.createText( 'foo' );
      * let img = downcastWriter.createContainerElement( 'img' );
      * let bar = downcastWriter.createText( 'bar' );
      * let p = downcastWriter.createContainerElement( 'p', null, [ foo, img, bar ] );
      *
      * let range = view.createRange( view.createPositionAt( foo, 2 ), view.createPositionAt( bar, 1 ); // "o", img, "b" are in range.
      * let otherRange = view.createRange( view.createPositionAt( foo, 1 ), view.createPositionAt( p, 2 ); // "oo", img are in range.
      * let transformed = range.getIntersection( otherRange ); // range from ( foo, 1 ) to ( p, 2 ).
      *
      * otherRange = view.createRange( view.createPositionAt( bar, 1 ), view.createPositionAt( bar, 3 ); "ar" is in range.
      * transformed = range.getIntersection( otherRange ); // null - no common part.
      * ```
      *
      * @param otherRange Range to check for intersection.
      * @returns A common part of given ranges or `null` if ranges have no common part.
      */
      getIntersection(otherRange) {
        if (this.isIntersecting(otherRange)) {
          let commonRangeStart = this.start;
          let commonRangeEnd = this.end;
          if (this.containsPosition(otherRange.start)) {
            commonRangeStart = otherRange.start;
          }
          if (this.containsPosition(otherRange.end)) {
            commonRangeEnd = otherRange.end;
          }
          return new Range2(commonRangeStart, commonRangeEnd);
        }
        return null;
      }
      /**
      * Creates a {@link module:engine/view/treewalker~TreeWalker TreeWalker} instance with this range as a boundary.
      *
      * @param options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.
      */
      getWalker(options = {}) {
        options.boundaries = this;
        return new TreeWalker$1(options);
      }
      /**
      * Returns a {@link module:engine/view/node~Node} or {@link module:engine/view/documentfragment~DocumentFragment}
      * which is a common ancestor of range's both ends (in which the entire range is contained).
      */
      getCommonAncestor() {
        return this.start.getCommonAncestor(this.end);
      }
      /**
      * Returns an {@link module:engine/view/element~Element Element} contained by the range.
      * The element will be returned when it is the **only** node within the range and **fullycontained**
      * at the same time.
      */
      getContainedElement() {
        if (this.isCollapsed) {
          return null;
        }
        let nodeAfterStart = this.start.nodeAfter;
        let nodeBeforeEnd = this.end.nodeBefore;
        if (this.start.parent.is("$text") && this.start.isAtEnd && this.start.parent.nextSibling) {
          nodeAfterStart = this.start.parent.nextSibling;
        }
        if (this.end.parent.is("$text") && this.end.isAtStart && this.end.parent.previousSibling) {
          nodeBeforeEnd = this.end.parent.previousSibling;
        }
        if (nodeAfterStart && nodeAfterStart.is("element") && nodeAfterStart === nodeBeforeEnd) {
          return nodeAfterStart;
        }
        return null;
      }
      /**
      * Clones this range.
      */
      clone() {
        return new Range2(this.start, this.end);
      }
      /**
      * Returns an iterator that iterates over all {@link module:engine/view/item~Item view items} that are in this range and returns
      * them.
      *
      * This method uses {@link module:engine/view/treewalker~TreeWalker} with `boundaries` set to this range and `ignoreElementEnd` option
      * set to `true`. However it returns only {@link module:engine/view/item~Item items},
      * not {@link module:engine/view/treewalker~TreeWalkerValue}.
      *
      * You may specify additional options for the tree walker. See {@link module:engine/view/treewalker~TreeWalker} for
      * a full list of available options.
      *
      * @param options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.
      */
      *getItems(options = {}) {
        options.boundaries = this;
        options.ignoreElementEnd = true;
        const treeWalker = new TreeWalker$1(options);
        for (const value of treeWalker) {
          yield value.item;
        }
      }
      /**
      * Returns an iterator that iterates over all {@link module:engine/view/position~Position positions} that are boundaries or
      * contained in this range.
      *
      * This method uses {@link module:engine/view/treewalker~TreeWalker} with `boundaries` set to this range. However it returns only
      * {@link module:engine/view/position~Position positions}, not {@link module:engine/view/treewalker~TreeWalkerValue}.
      *
      * You may specify additional options for the tree walker. See {@link module:engine/view/treewalker~TreeWalker} for
      * a full list of available options.
      *
      * @param options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.
      */
      *getPositions(options = {}) {
        options.boundaries = this;
        const treeWalker = new TreeWalker$1(options);
        yield treeWalker.position;
        for (const value of treeWalker) {
          yield value.nextPosition;
        }
      }
      /**
      * Checks and returns whether this range intersects with the given range.
      *
      * @param otherRange Range to compare with.
      * @returns True if ranges intersect.
      */
      isIntersecting(otherRange) {
        return this.start.isBefore(otherRange.end) && this.end.isAfter(otherRange.start);
      }
      /**
      * Creates a range from the given parents and offsets.
      *
      * @internal
      * @param startElement Start position parent element.
      * @param startOffset Start position offset.
      * @param endElement End position parent element.
      * @param endOffset End position offset.
      * @returns Created range.
      */
      static _createFromParentsAndOffsets(startElement, startOffset, endElement, endOffset) {
        return new this(new Position$1(startElement, startOffset), new Position$1(endElement, endOffset));
      }
      /**
      * Creates a new range, spreading from specified {@link module:engine/view/position~Position position} to a position moved by
      * given `shift`. If `shift` is a negative value, shifted position is treated as the beginning of the range.
      *
      * @internal
      * @param position Beginning of the range.
      * @param shift How long the range should be.
      */
      static _createFromPositionAndShift(position, shift2) {
        const start2 = position;
        const end2 = position.getShiftedBy(shift2);
        return shift2 > 0 ? new this(start2, end2) : new this(end2, start2);
      }
      /**
      * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
      * that element and ends after the last child of that element.
      *
      * @internal
      * @param element Element which is a parent for the range.
      */
      static _createIn(element) {
        return this._createFromParentsAndOffsets(element, 0, element, element.childCount);
      }
      /**
      * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.
      *
      * @internal
      */
      static _createOn(item) {
        const size2 = item.is("$textProxy") ? item.offsetSize : 1;
        return this._createFromPositionAndShift(Position$1._createBefore(item), size2);
      }
    };
    Range$1.prototype.is = function(type) {
      return type === "range" || type === "view:range";
    };
    function enlargeTrimSkip(value) {
      if (value.item.is("attributeElement") || value.item.is("uiElement")) {
        return true;
      }
      return false;
    }
    let Selection$1 = class Selection2 extends (/* @__PURE__ */ EmitterMixin(TypeCheckable$1)) {
      /**
      * Creates new selection instance.
      *
      * **Note**: The selection constructor is available as a factory method:
      *
      * * {@link module:engine/view/view~View#createSelection `View#createSelection()`},
      * * {@link module:engine/view/upcastwriter~UpcastWriter#createSelection `UpcastWriter#createSelection()`}.
      *
      * ```ts
      * // Creates empty selection without ranges.
      * const selection = writer.createSelection();
      *
      * // Creates selection at the given range.
      * const range = writer.createRange( start, end );
      * const selection = writer.createSelection( range );
      *
      * // Creates selection at the given ranges
      * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];
      * const selection = writer.createSelection( ranges );
      *
      * // Creates selection from the other selection.
      * const otherSelection = writer.createSelection();
      * const selection = writer.createSelection( otherSelection );
      *
      * // Creates selection from the document selection.
      * const selection = writer.createSelection( editor.editing.view.document.selection );
      *
      * // Creates selection at the given position.
      * const position = writer.createPositionFromPath( root, path );
      * const selection = writer.createSelection( position );
      *
      * // Creates collapsed selection at the position of given item and offset.
      * const paragraph = writer.createContainerElement( 'paragraph' );
      * const selection = writer.createSelection( paragraph, offset );
      *
      * // Creates a range inside an {@link module:engine/view/element~Element element} which starts before the
      * // first child of that element and ends after the last child of that element.
      * const selection = writer.createSelection( paragraph, 'in' );
      *
      * // Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends
      * // just after the item.
      * const selection = writer.createSelection( paragraph, 'on' );
      * ```
      *
      * `Selection`'s constructor allow passing additional options (`backward`, `fake` and `label`) as the last argument.
      *
      * ```ts
      * // Creates backward selection.
      * const selection = writer.createSelection( range, { backward: true } );
      * ```
      *
      * Fake selection does not render as browser native selection over selected elements and is hidden to the user.
      * This way, no native selection UI artifacts are displayed to the user and selection over elements can be
      * represented in other way, for example by applying proper CSS class.
      *
      * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM
      * (and be  properly handled by screen readers).
      *
      * ```ts
      * // Creates fake selection with label.
      * const selection = writer.createSelection( range, { fake: true, label: 'foo' } );
      * ```
      *
      * @internal
      */
      constructor(...args) {
        super();
        /**
        * Stores all ranges that are selected.
        */
        __publicField(this, "_ranges");
        /**
        * Specifies whether the last added range was added as a backward or forward range.
        */
        __publicField(this, "_lastRangeBackward");
        /**
        * Specifies whether selection instance is fake.
        */
        __publicField(this, "_isFake");
        /**
        * Fake selection's label.
        */
        __publicField(this, "_fakeSelectionLabel");
        this._ranges = [];
        this._lastRangeBackward = false;
        this._isFake = false;
        this._fakeSelectionLabel = "";
        if (args.length) {
          this.setTo(...args);
        }
      }
      /**
      * Returns true if selection instance is marked as `fake`.
      *
      * @see #setTo
      */
      get isFake() {
        return this._isFake;
      }
      /**
      * Returns fake selection label.
      *
      * @see #setTo
      */
      get fakeSelectionLabel() {
        return this._fakeSelectionLabel;
      }
      /**
      * Selection anchor. Anchor may be described as a position where the selection starts. Together with
      * {@link #focus focus} they define the direction of selection, which is important
      * when expanding/shrinking selection. Anchor is always the start or end of the most recent added range.
      * It may be a bit unintuitive when there are multiple ranges in selection.
      *
      * @see #focus
      */
      get anchor() {
        if (!this._ranges.length) {
          return null;
        }
        const range2 = this._ranges[this._ranges.length - 1];
        const anchor = this._lastRangeBackward ? range2.end : range2.start;
        return anchor.clone();
      }
      /**
      * Selection focus. Focus is a position where the selection ends.
      *
      * @see #anchor
      */
      get focus() {
        if (!this._ranges.length) {
          return null;
        }
        const range2 = this._ranges[this._ranges.length - 1];
        const focus = this._lastRangeBackward ? range2.start : range2.end;
        return focus.clone();
      }
      /**
      * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is
      * collapsed.
      */
      get isCollapsed() {
        return this.rangeCount === 1 && this._ranges[0].isCollapsed;
      }
      /**
      * Returns number of ranges in selection.
      */
      get rangeCount() {
        return this._ranges.length;
      }
      /**
      * Specifies whether the {@link #focus} precedes {@link #anchor}.
      */
      get isBackward() {
        return !this.isCollapsed && this._lastRangeBackward;
      }
      /**
      * {@link module:engine/view/editableelement~EditableElement EditableElement} instance that contains this selection, or `null`
      * if the selection is not inside an editable element.
      */
      get editableElement() {
        if (this.anchor) {
          return this.anchor.editableElement;
        }
        return null;
      }
      /**
      * Returns an iterable that contains copies of all ranges added to the selection.
      */
      *getRanges() {
        for (const range2 of this._ranges) {
          yield range2.clone();
        }
      }
      /**
      * Returns copy of the first range in the selection. First range is the one which
      * {@link module:engine/view/range~Range#start start} position {@link module:engine/view/position~Position#isBefore is before} start
      * position of all other ranges (not to confuse with the first range added to the selection).
      * Returns `null` if no ranges are added to selection.
      */
      getFirstRange() {
        let first2 = null;
        for (const range2 of this._ranges) {
          if (!first2 || range2.start.isBefore(first2.start)) {
            first2 = range2;
          }
        }
        return first2 ? first2.clone() : null;
      }
      /**
      * Returns copy of the last range in the selection. Last range is the one which {@link module:engine/view/range~Range#end end}
      * position {@link module:engine/view/position~Position#isAfter is after} end position of all other ranges (not to confuse
      * with the last range added to the selection). Returns `null` if no ranges are added to selection.
      */
      getLastRange() {
        let last2 = null;
        for (const range2 of this._ranges) {
          if (!last2 || range2.end.isAfter(last2.end)) {
            last2 = range2;
          }
        }
        return last2 ? last2.clone() : null;
      }
      /**
      * Returns copy of the first position in the selection. First position is the position that
      * {@link module:engine/view/position~Position#isBefore is before} any other position in the selection ranges.
      * Returns `null` if no ranges are added to selection.
      */
      getFirstPosition() {
        const firstRange = this.getFirstRange();
        return firstRange ? firstRange.start.clone() : null;
      }
      /**
      * Returns copy of the last position in the selection. Last position is the position that
      * {@link module:engine/view/position~Position#isAfter is after} any other position in the selection ranges.
      * Returns `null` if no ranges are added to selection.
      */
      getLastPosition() {
        const lastRange = this.getLastRange();
        return lastRange ? lastRange.end.clone() : null;
      }
      /**
      * Checks whether, this selection is equal to given selection. Selections are equal if they have same directions,
      * same number of ranges and all ranges from one selection equal to a range from other selection.
      *
      * @param otherSelection Selection to compare with.
      * @returns `true` if selections are equal, `false` otherwise.
      */
      isEqual(otherSelection) {
        if (this.isFake != otherSelection.isFake) {
          return false;
        }
        if (this.isFake && this.fakeSelectionLabel != otherSelection.fakeSelectionLabel) {
          return false;
        }
        if (this.rangeCount != otherSelection.rangeCount) {
          return false;
        } else if (this.rangeCount === 0) {
          return true;
        }
        if (!this.anchor.isEqual(otherSelection.anchor) || !this.focus.isEqual(otherSelection.focus)) {
          return false;
        }
        for (const thisRange of this._ranges) {
          let found = false;
          for (const otherRange of otherSelection._ranges) {
            if (thisRange.isEqual(otherRange)) {
              found = true;
              break;
            }
          }
          if (!found) {
            return false;
          }
        }
        return true;
      }
      /**
      * Checks whether this selection is similar to given selection. Selections are similar if they have same directions, same
      * number of ranges, and all {@link module:engine/view/range~Range#getTrimmed trimmed} ranges from one selection are
      * equal to any trimmed range from other selection.
      *
      * @param otherSelection Selection to compare with.
      * @returns `true` if selections are similar, `false` otherwise.
      */
      isSimilar(otherSelection) {
        if (this.isBackward != otherSelection.isBackward) {
          return false;
        }
        const numOfRangesA = count(this.getRanges());
        const numOfRangesB = count(otherSelection.getRanges());
        if (numOfRangesA != numOfRangesB) {
          return false;
        }
        if (numOfRangesA == 0) {
          return true;
        }
        for (let rangeA of this.getRanges()) {
          rangeA = rangeA.getTrimmed();
          let found = false;
          for (let rangeB of otherSelection.getRanges()) {
            rangeB = rangeB.getTrimmed();
            if (rangeA.start.isEqual(rangeB.start) && rangeA.end.isEqual(rangeB.end)) {
              found = true;
              break;
            }
          }
          if (!found) {
            return false;
          }
        }
        return true;
      }
      /**
      * Returns the selected element. {@link module:engine/view/element~Element Element} is considered as selected if there is only
      * one range in the selection, and that range contains exactly one element.
      * Returns `null` if there is no selected element.
      */
      getSelectedElement() {
        if (this.rangeCount !== 1) {
          return null;
        }
        return this.getFirstRange().getContainedElement();
      }
      /**
      * Sets this selection's ranges and direction to the specified location based on the given
      * {@link module:engine/view/selection~Selectable selectable}.
      *
      * ```ts
      * // Sets selection to the given range.
      * const range = writer.createRange( start, end );
      * selection.setTo( range );
      *
      * // Sets selection to given ranges.
      * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];
      * selection.setTo( range );
      *
      * // Sets selection to the other selection.
      * const otherSelection = writer.createSelection();
      * selection.setTo( otherSelection );
      *
      * // Sets selection to contents of DocumentSelection.
      * selection.setTo( editor.editing.view.document.selection );
      *
      * // Sets collapsed selection at the given position.
      * const position = writer.createPositionAt( root, path );
      * selection.setTo( position );
      *
      * // Sets collapsed selection at the position of given item and offset.
      * selection.setTo( paragraph, offset );
      * ```
      *
      * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
      * that element and ends after the last child of that element.
      *
      * ```ts
      * selection.setTo( paragraph, 'in' );
      * ```
      *
      * Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends just after the item.
      *
      * ```ts
      * selection.setTo( paragraph, 'on' );
      *
      * // Clears selection. Removes all ranges.
      * selection.setTo( null );
      * ```
      *
      * `Selection#setTo()` method allow passing additional options (`backward`, `fake` and `label`) as the last argument.
      *
      * ```ts
      * // Sets selection as backward.
      * selection.setTo( range, { backward: true } );
      * ```
      *
      * Fake selection does not render as browser native selection over selected elements and is hidden to the user.
      * This way, no native selection UI artifacts are displayed to the user and selection over elements can be
      * represented in other way, for example by applying proper CSS class.
      *
      * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM
      * (and be  properly handled by screen readers).
      *
      * ```ts
      * // Creates fake selection with label.
      * selection.setTo( range, { fake: true, label: 'foo' } );
      * ```
      *
      * @fires change
      */
      setTo(...args) {
        let [selectable, placeOrOffset, options] = args;
        if (typeof placeOrOffset == "object") {
          options = placeOrOffset;
          placeOrOffset = void 0;
        }
        if (selectable === null) {
          this._setRanges([]);
          this._setFakeOptions(options);
        } else if (selectable instanceof Selection2 || selectable instanceof DocumentSelection$1) {
          this._setRanges(selectable.getRanges(), selectable.isBackward);
          this._setFakeOptions({
            fake: selectable.isFake,
            label: selectable.fakeSelectionLabel
          });
        } else if (selectable instanceof Range$1) {
          this._setRanges([
            selectable
          ], options && options.backward);
          this._setFakeOptions(options);
        } else if (selectable instanceof Position$1) {
          this._setRanges([
            new Range$1(selectable)
          ]);
          this._setFakeOptions(options);
        } else if (selectable instanceof Node$2) {
          const backward = !!options && !!options.backward;
          let range2;
          if (placeOrOffset === void 0) {
            throw new CKEditorError("view-selection-setto-required-second-parameter", this);
          } else if (placeOrOffset == "in") {
            range2 = Range$1._createIn(selectable);
          } else if (placeOrOffset == "on") {
            range2 = Range$1._createOn(selectable);
          } else {
            range2 = new Range$1(Position$1._createAt(selectable, placeOrOffset));
          }
          this._setRanges([
            range2
          ], backward);
          this._setFakeOptions(options);
        } else if (isIterable(selectable)) {
          this._setRanges(selectable, options && options.backward);
          this._setFakeOptions(options);
        } else {
          throw new CKEditorError("view-selection-setto-not-selectable", this);
        }
        this.fire("change");
      }
      /**
      * Moves {@link #focus} to the specified location.
      *
      * The location can be specified in the same form as {@link module:engine/view/view~View#createPositionAt view.createPositionAt()}
      * parameters.
      *
      * @fires change
      * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/view/item~Item view item}.
      */
      setFocus(itemOrPosition, offset2) {
        if (this.anchor === null) {
          throw new CKEditorError("view-selection-setfocus-no-ranges", this);
        }
        const newFocus = Position$1._createAt(itemOrPosition, offset2);
        if (newFocus.compareWith(this.focus) == "same") {
          return;
        }
        const anchor = this.anchor;
        this._ranges.pop();
        if (newFocus.compareWith(anchor) == "before") {
          this._addRange(new Range$1(newFocus, anchor), true);
        } else {
          this._addRange(new Range$1(anchor, newFocus));
        }
        this.fire("change");
      }
      /**
      * Replaces all ranges that were added to the selection with given array of ranges. Last range of the array
      * is treated like the last added range and is used to set {@link #anchor anchor} and {@link #focus focus}.
      * Accepts a flag describing in which way the selection is made.
      *
      * @param newRanges Iterable object of ranges to set.
      * @param isLastBackward Flag describing if last added range was selected forward - from start to end
      * (`false`) or backward - from end to start (`true`). Defaults to `false`.
      */
      _setRanges(newRanges, isLastBackward = false) {
        newRanges = Array.from(newRanges);
        this._ranges = [];
        for (const range2 of newRanges) {
          this._addRange(range2);
        }
        this._lastRangeBackward = !!isLastBackward;
      }
      /**
      * Sets this selection instance to be marked as `fake`. A fake selection does not render as browser native selection
      * over selected elements and is hidden to the user. This way, no native selection UI artifacts are displayed to
      * the user and selection over elements can be represented in other way, for example by applying proper CSS class.
      *
      * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM (and be
      * properly handled by screen readers).
      */
      _setFakeOptions(options = {}) {
        this._isFake = !!options.fake;
        this._fakeSelectionLabel = options.fake ? options.label || "" : "";
      }
      /**
      * Adds a range to the selection. Added range is copied. This means that passed range is not saved in the
      * selection instance and you can safely operate on it.
      *
      * Accepts a flag describing in which way the selection is made - passed range might be selected from
      * {@link module:engine/view/range~Range#start start} to {@link module:engine/view/range~Range#end end}
      * or from {@link module:engine/view/range~Range#end end} to {@link module:engine/view/range~Range#start start}.
      * The flag is used to set {@link #anchor anchor} and {@link #focus focus} properties.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-selection-range-intersects` if added range intersects
      * with ranges already stored in Selection instance.
      */
      _addRange(range2, isBackward = false) {
        if (!(range2 instanceof Range$1)) {
          throw new CKEditorError("view-selection-add-range-not-range", this);
        }
        this._pushRange(range2);
        this._lastRangeBackward = !!isBackward;
      }
      /**
      * Adds range to selection - creates copy of given range so it can be safely used and modified.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-selection-range-intersects` if added range intersects
      * with ranges already stored in selection instance.
      */
      _pushRange(range2) {
        for (const storedRange of this._ranges) {
          if (range2.isIntersecting(storedRange)) {
            throw new CKEditorError("view-selection-range-intersects", this, {
              addedRange: range2,
              intersectingRange: storedRange
            });
          }
        }
        this._ranges.push(new Range$1(range2.start, range2.end));
      }
    };
    Selection$1.prototype.is = function(type) {
      return type === "selection" || type === "view:selection";
    };
    let DocumentSelection$1 = class DocumentSelection extends (/* @__PURE__ */ EmitterMixin(TypeCheckable$1)) {
      constructor(...args) {
        super();
        /**
        * Selection is used internally (`DocumentSelection` is a proxy to that selection).
        */
        __publicField(this, "_selection");
        this._selection = new Selection$1();
        this._selection.delegate("change").to(this);
        if (args.length) {
          this._selection.setTo(...args);
        }
      }
      /**
      * Returns true if selection instance is marked as `fake`.
      *
      * @see #_setTo
      */
      get isFake() {
        return this._selection.isFake;
      }
      /**
      * Returns fake selection label.
      *
      * @see #_setTo
      */
      get fakeSelectionLabel() {
        return this._selection.fakeSelectionLabel;
      }
      /**
      * Selection anchor. Anchor may be described as a position where the selection starts. Together with
      * {@link #focus focus} they define the direction of selection, which is important
      * when expanding/shrinking selection. Anchor is always the start or end of the most recent added range.
      * It may be a bit unintuitive when there are multiple ranges in selection.
      *
      * @see #focus
      */
      get anchor() {
        return this._selection.anchor;
      }
      /**
      * Selection focus. Focus is a position where the selection ends.
      *
      * @see #anchor
      */
      get focus() {
        return this._selection.focus;
      }
      /**
      * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is
      * collapsed.
      */
      get isCollapsed() {
        return this._selection.isCollapsed;
      }
      /**
      * Returns number of ranges in selection.
      */
      get rangeCount() {
        return this._selection.rangeCount;
      }
      /**
      * Specifies whether the {@link #focus} precedes {@link #anchor}.
      */
      get isBackward() {
        return this._selection.isBackward;
      }
      /**
      * {@link module:engine/view/editableelement~EditableElement EditableElement} instance that contains this selection, or `null`
      * if the selection is not inside an editable element.
      */
      get editableElement() {
        return this._selection.editableElement;
      }
      /**
      * Used for the compatibility with the {@link module:engine/view/selection~Selection#isEqual} method.
      *
      * @internal
      */
      get _ranges() {
        return this._selection._ranges;
      }
      /**
      * Returns an iterable that contains copies of all ranges added to the selection.
      */
      *getRanges() {
        yield* this._selection.getRanges();
      }
      /**
      * Returns copy of the first range in the selection. First range is the one which
      * {@link module:engine/view/range~Range#start start} position {@link module:engine/view/position~Position#isBefore is before} start
      * position of all other ranges (not to confuse with the first range added to the selection).
      * Returns `null` if no ranges are added to selection.
      */
      getFirstRange() {
        return this._selection.getFirstRange();
      }
      /**
      * Returns copy of the last range in the selection. Last range is the one which {@link module:engine/view/range~Range#end end}
      * position {@link module:engine/view/position~Position#isAfter is after} end position of all other ranges (not to confuse
      * with the last range added to the selection). Returns `null` if no ranges are added to selection.
      */
      getLastRange() {
        return this._selection.getLastRange();
      }
      /**
      * Returns copy of the first position in the selection. First position is the position that
      * {@link module:engine/view/position~Position#isBefore is before} any other position in the selection ranges.
      * Returns `null` if no ranges are added to selection.
      */
      getFirstPosition() {
        return this._selection.getFirstPosition();
      }
      /**
      * Returns copy of the last position in the selection. Last position is the position that
      * {@link module:engine/view/position~Position#isAfter is after} any other position in the selection ranges.
      * Returns `null` if no ranges are added to selection.
      */
      getLastPosition() {
        return this._selection.getLastPosition();
      }
      /**
      * Returns the selected element. {@link module:engine/view/element~Element Element} is considered as selected if there is only
      * one range in the selection, and that range contains exactly one element.
      * Returns `null` if there is no selected element.
      */
      getSelectedElement() {
        return this._selection.getSelectedElement();
      }
      /**
      * Checks whether, this selection is equal to given selection. Selections are equal if they have same directions,
      * same number of ranges and all ranges from one selection equal to a range from other selection.
      *
      * @param otherSelection Selection to compare with.
      * @returns `true` if selections are equal, `false` otherwise.
      */
      isEqual(otherSelection) {
        return this._selection.isEqual(otherSelection);
      }
      /**
      * Checks whether this selection is similar to given selection. Selections are similar if they have same directions, same
      * number of ranges, and all {@link module:engine/view/range~Range#getTrimmed trimmed} ranges from one selection are
      * equal to any trimmed range from other selection.
      *
      * @param otherSelection Selection to compare with.
      * @returns `true` if selections are similar, `false` otherwise.
      */
      isSimilar(otherSelection) {
        return this._selection.isSimilar(otherSelection);
      }
      /**
      * Sets this selection's ranges and direction to the specified location based on the given
      * {@link module:engine/view/selection~Selectable selectable}.
      *
      * ```ts
      * // Sets selection to the given range.
      * const range = writer.createRange( start, end );
      * documentSelection._setTo( range );
      *
      * // Sets selection to given ranges.
      * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( start2, end2 ) ];
      * documentSelection._setTo( range );
      *
      * // Sets selection to the other selection.
      * const otherSelection = writer.createSelection();
      * documentSelection._setTo( otherSelection );
      *
      * // Sets collapsed selection at the given position.
      * const position = writer.createPositionAt( root, offset );
      * documentSelection._setTo( position );
      *
      * // Sets collapsed selection at the position of given item and offset.
      * documentSelection._setTo( paragraph, offset );
      * ```
      *
      * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
      * that element and ends after the last child of that element.
      *
      * ```ts
      * documentSelection._setTo( paragraph, 'in' );
      * ```
      *
      * Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends just after the item.
      *
      * ```ts
      * documentSelection._setTo( paragraph, 'on' );
      *
      * // Clears selection. Removes all ranges.
      * documentSelection._setTo( null );
      * ```
      *
      * `Selection#_setTo()` method allow passing additional options (`backward`, `fake` and `label`) as the last argument.
      *
      * ```ts
      * // Sets selection as backward.
      * documentSelection._setTo( range, { backward: true } );
      * ```
      *
      * Fake selection does not render as browser native selection over selected elements and is hidden to the user.
      * This way, no native selection UI artifacts are displayed to the user and selection over elements can be
      * represented in other way, for example by applying proper CSS class.
      *
      * Additionally fake's selection label can be provided. It will be used to des cribe fake selection in DOM
      * (and be  properly handled by screen readers).
      *
      * ```ts
      * // Creates fake selection with label.
      * documentSelection._setTo( range, { fake: true, label: 'foo' } );
      * ```
      *
      * @internal
      * @fires change
      */
      _setTo(...args) {
        this._selection.setTo(...args);
      }
      /**
      * Moves {@link #focus} to the specified location.
      *
      * The location can be specified in the same form as {@link module:engine/view/view~View#createPositionAt view.createPositionAt()}
      * parameters.
      *
      * @internal
      * @fires change
      * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/view/item~Item view item}.
      */
      _setFocus(itemOrPosition, offset2) {
        this._selection.setFocus(itemOrPosition, offset2);
      }
    };
    DocumentSelection$1.prototype.is = function(type) {
      return type === "selection" || type == "documentSelection" || type == "view:selection" || type == "view:documentSelection";
    };
    class BubblingEventInfo extends EventInfo {
      /**
      * @param source The emitter.
      * @param name The event name.
      * @param startRange The view range that the bubbling should start from.
      */
      constructor(source, name, startRange) {
        super(source, name);
        /**
        * The view range that the bubbling should start from.
        */
        __publicField(this, "startRange");
        /**
        * The current event phase.
        */
        __publicField(this, "_eventPhase");
        /**
        * The current bubbling target.
        */
        __publicField(this, "_currentTarget");
        this.startRange = startRange;
        this._eventPhase = "none";
        this._currentTarget = null;
      }
      /**
      * The current event phase.
      */
      get eventPhase() {
        return this._eventPhase;
      }
      /**
      * The current bubbling target.
      */
      get currentTarget() {
        return this._currentTarget;
      }
    }
    const contextsSymbol = Symbol("bubbling contexts");
    function BubblingEmitterMixin(base) {
      class Mixin extends base {
        fire(eventOrInfo, ...eventArgs) {
          try {
            const eventInfo = eventOrInfo instanceof EventInfo ? eventOrInfo : new EventInfo(this, eventOrInfo);
            const eventContexts = getBubblingContexts(this);
            if (!eventContexts.size) {
              return;
            }
            updateEventInfo(eventInfo, "capturing", this);
            if (fireListenerFor(eventContexts, "$capture", eventInfo, ...eventArgs)) {
              return eventInfo.return;
            }
            const startRange = eventInfo.startRange || this.selection.getFirstRange();
            const selectedElement = startRange ? startRange.getContainedElement() : null;
            const isCustomContext = selectedElement ? Boolean(getCustomContext(eventContexts, selectedElement)) : false;
            let node = selectedElement || getDeeperRangeParent(startRange);
            updateEventInfo(eventInfo, "atTarget", node);
            if (!isCustomContext) {
              if (fireListenerFor(eventContexts, "$text", eventInfo, ...eventArgs)) {
                return eventInfo.return;
              }
              updateEventInfo(eventInfo, "bubbling", node);
            }
            while (node) {
              if (node.is("rootElement")) {
                if (fireListenerFor(eventContexts, "$root", eventInfo, ...eventArgs)) {
                  return eventInfo.return;
                }
              } else if (node.is("element")) {
                if (fireListenerFor(eventContexts, node.name, eventInfo, ...eventArgs)) {
                  return eventInfo.return;
                }
              }
              if (fireListenerFor(eventContexts, node, eventInfo, ...eventArgs)) {
                return eventInfo.return;
              }
              node = node.parent;
              updateEventInfo(eventInfo, "bubbling", node);
            }
            updateEventInfo(eventInfo, "bubbling", this);
            fireListenerFor(eventContexts, "$document", eventInfo, ...eventArgs);
            return eventInfo.return;
          } catch (err) {
            /* istanbul ignore next -- @preserve */
            CKEditorError.rethrowUnexpectedError(err, this);
          }
        }
        _addEventListener(event, callback, options) {
          const contexts = toArray$2(options.context || "$document");
          const eventContexts = getBubblingContexts(this);
          for (const context of contexts) {
            let emitter = eventContexts.get(context);
            if (!emitter) {
              emitter = new (EmitterMixin())();
              eventContexts.set(context, emitter);
            }
            this.listenTo(emitter, event, callback, options);
          }
        }
        _removeEventListener(event, callback) {
          const eventContexts = getBubblingContexts(this);
          for (const emitter of eventContexts.values()) {
            this.stopListening(emitter, event, callback);
          }
        }
      }
      return Mixin;
    }
    {
      const mixin2 = BubblingEmitterMixin(Object);
      [
        "fire",
        "_addEventListener",
        "_removeEventListener"
      ].forEach((key) => {
        BubblingEmitterMixin[key] = mixin2.prototype[key];
      });
    }
    function updateEventInfo(eventInfo, eventPhase, currentTarget) {
      if (eventInfo instanceof BubblingEventInfo) {
        eventInfo._eventPhase = eventPhase;
        eventInfo._currentTarget = currentTarget;
      }
    }
    function fireListenerFor(eventContexts, context, eventInfo, ...eventArgs) {
      const emitter = typeof context == "string" ? eventContexts.get(context) : getCustomContext(eventContexts, context);
      if (!emitter) {
        return false;
      }
      emitter.fire(eventInfo, ...eventArgs);
      return eventInfo.stop.called;
    }
    function getCustomContext(eventContexts, node) {
      for (const [context, emitter] of eventContexts) {
        if (typeof context == "function" && context(node)) {
          return emitter;
        }
      }
      return null;
    }
    function getBubblingContexts(source) {
      if (!source[contextsSymbol]) {
        source[contextsSymbol] = /* @__PURE__ */ new Map();
      }
      return source[contextsSymbol];
    }
    function getDeeperRangeParent(range2) {
      if (!range2) {
        return null;
      }
      const startParent = range2.start.parent;
      const endParent = range2.end.parent;
      const startPath = startParent.getPath();
      const endPath = endParent.getPath();
      return startPath.length > endPath.length ? startParent : endParent;
    }
    let Document$1 = class Document extends (/* @__PURE__ */ BubblingEmitterMixin(/* @__PURE__ */ ObservableMixin())) {
      /**
      * Creates a Document instance.
      *
      * @param stylesProcessor The styles processor instance.
      */
      constructor(stylesProcessor) {
        super();
        /**
        * Selection done on this document.
        */
        __publicField(this, "selection");
        /**
        * Roots of the view tree. Collection of the {@link module:engine/view/element~Element view elements}.
        *
        * View roots are created as a result of binding between {@link module:engine/view/document~Document#roots} and
        * {@link module:engine/model/document~Document#roots} and this is handled by
        * {@link module:engine/controller/editingcontroller~EditingController}, so to create view root we need to create
        * model root using {@link module:engine/model/document~Document#createRoot}.
        */
        __publicField(this, "roots");
        /**
        * The styles processor instance used by this document when normalizing styles.
        */
        __publicField(this, "stylesProcessor");
        /**
        * Post-fixer callbacks registered to the view document.
        */
        __publicField(this, "_postFixers", /* @__PURE__ */ new Set());
        this.selection = new DocumentSelection$1();
        this.roots = new Collection({
          idProperty: "rootName"
        });
        this.stylesProcessor = stylesProcessor;
        this.set("isReadOnly", false);
        this.set("isFocused", false);
        this.set("isSelecting", false);
        this.set("isComposing", false);
      }
      /**
      * Gets a {@link module:engine/view/document~Document#roots view root element} with the specified name. If the name is not
      * specific "main" root is returned.
      *
      * @param name Name of the root.
      * @returns The view root element with the specified name or null when there is no root of given name.
      */
      getRoot(name = "main") {
        return this.roots.get(name);
      }
      /**
      * Allows registering post-fixer callbacks. A post-fixers mechanism allows to update the view tree just before it is rendered
      * to the DOM.
      *
      * Post-fixers are executed right after all changes from the outermost change block were applied but
      * before the {@link module:engine/view/view~View#event:render render event} is fired. If a post-fixer callback made
      * a change, it should return `true`. When this happens, all post-fixers are fired again to check if something else should
      * not be fixed in the new document tree state.
      *
      * View post-fixers are useful when you want to apply some fixes whenever the view structure changes. Keep in mind that
      * changes executed in a view post-fixer should not break model-view mapping.
      *
      * The types of changes which should be safe:
      *
      * * adding or removing attribute from elements,
      * * changes inside of {@link module:engine/view/uielement~UIElement UI elements},
      * * {@link module:engine/controller/editingcontroller~EditingController#reconvertItem marking some of the model elements to be
      * re-converted}.
      *
      * Try to avoid changes which touch view structure:
      *
      * * you should not add or remove nor wrap or unwrap any view elements,
      * * you should not change the editor data model in a view post-fixer.
      *
      * As a parameter, a post-fixer callback receives a {@link module:engine/view/downcastwriter~DowncastWriter downcast writer}.
      *
      * Typically, a post-fixer will look like this:
      *
      * ```ts
      * editor.editing.view.document.registerPostFixer( writer => {
      * 	if ( checkSomeCondition() ) {
      * 		writer.doSomething();
      *
      * 		// Let other post-fixers know that something changed.
      * 		return true;
      * 	}
      *
      * 	return false;
      * } );
      * ```
      *
      * Note that nothing happens right after you register a post-fixer (e.g. execute such a code in the console).
      * That is because adding a post-fixer does not execute it.
      * The post-fixer will be executed as soon as any change in the document needs to cause its rendering.
      * If you want to re-render the editor's view after registering the post-fixer then you should do it manually by calling
      * {@link module:engine/view/view~View#forceRender `view.forceRender()`}.
      *
      * If you need to register a callback which is executed when DOM elements are already updated,
      * use {@link module:engine/view/view~View#event:render render event}.
      */
      registerPostFixer(postFixer) {
        this._postFixers.add(postFixer);
      }
      /**
      * Destroys this instance. Makes sure that all observers are destroyed and listeners removed.
      */
      destroy() {
        this.roots.forEach((root2) => root2.destroy());
        this.stopListening();
      }
      /**
      * Performs post-fixer loops. Executes post-fixer callbacks as long as none of them has done any changes to the model.
      *
      * @internal
      */
      _callPostFixers(writer) {
        let wasFixed = false;
        do {
          for (const callback of this._postFixers) {
            wasFixed = callback(writer);
            if (wasFixed) {
              break;
            }
          }
        } while (wasFixed);
      }
    };
    const DEFAULT_PRIORITY = 10;
    class AttributeElement extends Element$1 {
      /**
      * Creates an attribute element.
      *
      * @see module:engine/view/downcastwriter~DowncastWriter#createAttributeElement
      * @see module:engine/view/element~Element
      * @protected
      * @param document The document instance to which this element belongs.
      * @param name Node name.
      * @param attrs Collection of attributes.
      * @param children A list of nodes to be inserted into created element.
      */
      constructor(document2, name, attrs, children) {
        super(document2, name, attrs, children);
        /**
        * Element priority. Decides in what order elements are wrapped by {@link module:engine/view/downcastwriter~DowncastWriter}.
        *
        * @internal
        * @readonly
        */
        __publicField(this, "_priority", DEFAULT_PRIORITY);
        /**
        * Element identifier. If set, it is used by {@link module:engine/view/element~Element#isSimilar},
        * and then two elements are considered similar if, and only if they have the same `_id`.
        *
        * @internal
        * @readonly
        */
        __publicField(this, "_id", null);
        /**
        * Keeps all the attribute elements that have the same {@link module:engine/view/attributeelement~AttributeElement#id ids}
        * and still exist in the view tree.
        *
        * This property is managed by {@link module:engine/view/downcastwriter~DowncastWriter}.
        */
        __publicField(this, "_clonesGroup", null);
        this.getFillerOffset = getFillerOffset$3;
      }
      /**
      * Element priority. Decides in what order elements are wrapped by {@link module:engine/view/downcastwriter~DowncastWriter}.
      */
      get priority() {
        return this._priority;
      }
      /**
      * Element identifier. If set, it is used by {@link module:engine/view/element~Element#isSimilar},
      * and then two elements are considered similar if, and only if they have the same `id`.
      */
      get id() {
        return this._id;
      }
      /**
      * Returns all {@link module:engine/view/attributeelement~AttributeElement attribute elements} that has the
      * same {@link module:engine/view/attributeelement~AttributeElement#id id} and are in the view tree (were not removed).
      *
      * Note: If this element has been removed from the tree, returned set will not include it.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError attribute-element-get-elements-with-same-id-no-id}
      * if this element has no `id`.
      *
      * @returns Set containing all the attribute elements
      * with the same `id` that were added and not removed from the view tree.
      */
      getElementsWithSameId() {
        if (this.id === null) {
          throw new CKEditorError("attribute-element-get-elements-with-same-id-no-id", this);
        }
        return new Set(this._clonesGroup);
      }
      /**
      * Checks if this element is similar to other element.
      *
      * If none of elements has set {@link module:engine/view/attributeelement~AttributeElement#id}, then both elements
      * should have the same name, attributes and priority to be considered as similar. Two similar elements can contain
      * different set of children nodes.
      *
      * If at least one element has {@link module:engine/view/attributeelement~AttributeElement#id} set, then both
      * elements have to have the same {@link module:engine/view/attributeelement~AttributeElement#id} value to be
      * considered similar.
      *
      * Similarity is important for {@link module:engine/view/downcastwriter~DowncastWriter}. For example:
      *
      * * two following similar elements can be merged together into one, longer element,
      * * {@link module:engine/view/downcastwriter~DowncastWriter#unwrap} checks similarity of passed element and processed element to
      * decide whether processed element should be unwrapped,
      * * etc.
      */
      isSimilar(otherElement) {
        if (this.id !== null || otherElement.id !== null) {
          return this.id === otherElement.id;
        }
        return super.isSimilar(otherElement) && this.priority == otherElement.priority;
      }
      /**
      * Clones provided element with priority.
      *
      * @internal
      * @param deep If set to `true` clones element and all its children recursively. When set to `false`,
      * element will be cloned without any children.
      * @returns Clone of this element.
      */
      _clone(deep = false) {
        const cloned = super._clone(deep);
        cloned._priority = this._priority;
        cloned._id = this._id;
        return cloned;
      }
    }
    __publicField(AttributeElement, "DEFAULT_PRIORITY", DEFAULT_PRIORITY);
    AttributeElement.prototype.is = function(type, name) {
      if (!name) {
        return type === "attributeElement" || type === "view:attributeElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === "element" || type === "view:element" || type === "node" || type === "view:node";
      } else {
        return name === this.name && (type === "attributeElement" || type === "view:attributeElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === "element" || type === "view:element");
      }
    };
    function getFillerOffset$3() {
      if (nonUiChildrenCount(this)) {
        return null;
      }
      let element = this.parent;
      while (element && element.is("attributeElement")) {
        if (nonUiChildrenCount(element) > 1) {
          return null;
        }
        element = element.parent;
      }
      if (!element || nonUiChildrenCount(element) > 1) {
        return null;
      }
      return this.childCount;
    }
    function nonUiChildrenCount(element) {
      return Array.from(element.getChildren()).filter((element2) => !element2.is("uiElement")).length;
    }
    class EmptyElement extends Element$1 {
      /**
      * Creates new instance of EmptyElement.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-emptyelement-cannot-add` when third parameter is passed,
      * to inform that usage of EmptyElement is incorrect (adding child nodes to EmptyElement is forbidden).
      *
      * @see module:engine/view/downcastwriter~DowncastWriter#createEmptyElement
      * @internal
      * @param document The document instance to which this element belongs.
      * @param name Node name.
      * @param attrs Collection of attributes.
      * @param children A list of nodes to be inserted into created element.
      */
      constructor(document2, name, attributes, children) {
        super(document2, name, attributes, children);
        this.getFillerOffset = getFillerOffset$2;
      }
      /**
      * Overrides {@link module:engine/view/element~Element#_insertChild} method.
      * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-emptyelement-cannot-add` to prevent
      * adding any child nodes to EmptyElement.
      *
      * @internal
      */
      _insertChild(index, items) {
        if (items && (items instanceof Node$2 || Array.from(items).length > 0)) {
          throw new CKEditorError("view-emptyelement-cannot-add", [
            this,
            items
          ]);
        }
        return 0;
      }
    }
    EmptyElement.prototype.is = function(type, name) {
      if (!name) {
        return type === "emptyElement" || type === "view:emptyElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === "element" || type === "view:element" || type === "node" || type === "view:node";
      } else {
        return name === this.name && (type === "emptyElement" || type === "view:emptyElement" || type === "element" || type === "view:element");
      }
    };
    function getFillerOffset$2() {
      return null;
    }
    class UIElement extends Element$1 {
      /**
      * Creates new instance of UIElement.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-uielement-cannot-add` when third parameter is passed,
      * to inform that usage of UIElement is incorrect (adding child nodes to UIElement is forbidden).
      *
      * @see module:engine/view/downcastwriter~DowncastWriter#createUIElement
      * @internal
      * @param document The document instance to which this element belongs.
      * @param name Node name.
      * @param attrs Collection of attributes.
      * @param children A list of nodes to be inserted into created element.
      */
      constructor(document2, name, attrs, children) {
        super(document2, name, attrs, children);
        this.getFillerOffset = getFillerOffset$1;
      }
      /**
      * Overrides {@link module:engine/view/element~Element#_insertChild} method.
      * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-uielement-cannot-add` to prevent adding any child nodes
      * to UIElement.
      *
      * @internal
      */
      _insertChild(index, items) {
        if (items && (items instanceof Node$2 || Array.from(items).length > 0)) {
          throw new CKEditorError("view-uielement-cannot-add", [
            this,
            items
          ]);
        }
        return 0;
      }
      /**
      * Renders this {@link module:engine/view/uielement~UIElement} to DOM. This method is called by
      * {@link module:engine/view/domconverter~DomConverter}.
      * Do not use inheritance to create custom rendering method, replace `render()` method instead:
      *
      * ```ts
      * const myUIElement = downcastWriter.createUIElement( 'span' );
      * myUIElement.render = function( domDocument, domConverter ) {
      * 	const domElement = this.toDomElement( domDocument );
      *
      * 	domConverter.setContentOf( domElement, '<b>this is ui element</b>' );
      *
      * 	return domElement;
      * };
      * ```
      *
      * If changes in your UI element should trigger some editor UI update you should call
      * the {@link module:ui/editorui/editorui~EditorUI#update `editor.ui.update()`} method
      * after rendering your UI element.
      *
      * @param domConverter Instance of the DomConverter used to optimize the output.
      */
      render(domDocument, domConverter) {
        return this.toDomElement(domDocument);
      }
      /**
      * Creates DOM element based on this view UIElement.
      * Note that each time this method is called new DOM element is created.
      */
      toDomElement(domDocument) {
        const domElement = domDocument.createElement(this.name);
        for (const key of this.getAttributeKeys()) {
          domElement.setAttribute(key, this.getAttribute(key));
        }
        return domElement;
      }
    }
    UIElement.prototype.is = function(type, name) {
      if (!name) {
        return type === "uiElement" || type === "view:uiElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === "element" || type === "view:element" || type === "node" || type === "view:node";
      } else {
        return name === this.name && (type === "uiElement" || type === "view:uiElement" || type === "element" || type === "view:element");
      }
    };
    function injectUiElementHandling(view) {
      view.document.on("arrowKey", (evt, data) => jumpOverUiElement(evt, data, view.domConverter), {
        priority: "low"
      });
    }
    function getFillerOffset$1() {
      return null;
    }
    function jumpOverUiElement(evt, data, domConverter) {
      if (data.keyCode == keyCodes.arrowright) {
        const domSelection = data.domTarget.ownerDocument.defaultView.getSelection();
        const domSelectionCollapsed = domSelection.rangeCount == 1 && domSelection.getRangeAt(0).collapsed;
        if (domSelectionCollapsed || data.shiftKey) {
          const domParent = domSelection.focusNode;
          const domOffset = domSelection.focusOffset;
          const viewPosition = domConverter.domPositionToView(domParent, domOffset);
          if (viewPosition === null) {
            return;
          }
          let jumpedOverAnyUiElement = false;
          const nextViewPosition = viewPosition.getLastMatchingPosition((value) => {
            if (value.item.is("uiElement")) {
              jumpedOverAnyUiElement = true;
            }
            if (value.item.is("uiElement") || value.item.is("attributeElement")) {
              return true;
            }
            return false;
          });
          if (jumpedOverAnyUiElement) {
            const newDomPosition = domConverter.viewPositionToDom(nextViewPosition);
            if (domSelectionCollapsed) {
              domSelection.collapse(newDomPosition.parent, newDomPosition.offset);
            } else {
              domSelection.extend(newDomPosition.parent, newDomPosition.offset);
            }
          }
        }
      }
    }
    class RawElement extends Element$1 {
      /**
      * Creates a new instance of a raw element.
      *
      * Throws the `view-rawelement-cannot-add` {@link module:utils/ckeditorerror~CKEditorError CKEditorError} when the `children`
      * parameter is passed to inform that the usage of `RawElement` is incorrect (adding child nodes to `RawElement` is forbidden).
      *
      * @see module:engine/view/downcastwriter~DowncastWriter#createRawElement
      * @internal
      * @param document The document instance to which this element belongs.
      * @param name Node name.
      * @param attrs Collection of attributes.
      * @param children A list of nodes to be inserted into created element.
      */
      constructor(document2, name, attrs, children) {
        super(document2, name, attrs, children);
        this.getFillerOffset = getFillerOffset;
      }
      /**
      * Overrides the {@link module:engine/view/element~Element#_insertChild} method.
      * Throws the `view-rawelement-cannot-add` {@link module:utils/ckeditorerror~CKEditorError CKEditorError} to prevent
      * adding any child nodes to a raw element.
      *
      * @internal
      */
      _insertChild(index, items) {
        if (items && (items instanceof Node$2 || Array.from(items).length > 0)) {
          throw new CKEditorError("view-rawelement-cannot-add", [
            this,
            items
          ]);
        }
        return 0;
      }
      /**
      * This allows rendering the children of a {@link module:engine/view/rawelement~RawElement} on the DOM level.
      * This method is called by the {@link module:engine/view/domconverter~DomConverter} with the raw DOM element
      * passed as an argument, leaving the number and shape of the children up to the integrator.
      *
      * This method **must be defined** for the raw element to work:
      *
      * ```ts
      * const myRawElement = downcastWriter.createRawElement( 'div' );
      *
      * myRawElement.render = function( domElement, domConverter ) {
      * 	domConverter.setContentOf( domElement, '<b>This is the raw content of myRawElement.</b>' );
      * };
      * ```
      *
      * @param domElement The native DOM element representing the raw view element.
      * @param domConverter Instance of the DomConverter used to optimize the output.
      */
      render(domElement, domConverter) {
      }
    }
    RawElement.prototype.is = function(type, name) {
      if (!name) {
        return type === "rawElement" || type === "view:rawElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === this.name || type === "view:" + this.name || type === "element" || type === "view:element" || type === "node" || type === "view:node";
      } else {
        return name === this.name && (type === "rawElement" || type === "view:rawElement" || type === "element" || type === "view:element");
      }
    };
    function getFillerOffset() {
      return null;
    }
    let DocumentFragment$1 = class DocumentFragment extends (/* @__PURE__ */ EmitterMixin(TypeCheckable$1)) {
      /**
      * Creates new DocumentFragment instance.
      *
      * @internal
      * @param document The document to which this document fragment belongs.
      * @param children A list of nodes to be inserted into the created document fragment.
      */
      constructor(document2, children) {
        super();
        /**
        * The document to which this document fragment belongs.
        */
        __publicField(this, "document");
        /**
        * Array of child nodes.
        */
        __publicField(this, "_children", []);
        /**
        * Map of custom properties.
        * Custom properties can be added to document fragment instance.
        */
        __publicField(this, "_customProperties", /* @__PURE__ */ new Map());
        this.document = document2;
        if (children) {
          this._insertChild(0, children);
        }
      }
      /**
      * Iterable interface.
      *
      * Iterates over nodes added to this document fragment.
      */
      [Symbol.iterator]() {
        return this._children[Symbol.iterator]();
      }
      /**
      * Number of child nodes in this document fragment.
      */
      get childCount() {
        return this._children.length;
      }
      /**
      * Is `true` if there are no nodes inside this document fragment, `false` otherwise.
      */
      get isEmpty() {
        return this.childCount === 0;
      }
      /**
      * Artificial root of `DocumentFragment`. Returns itself. Added for compatibility reasons.
      */
      get root() {
        return this;
      }
      /**
      * Artificial parent of `DocumentFragment`. Returns `null`. Added for compatibility reasons.
      */
      get parent() {
        return null;
      }
      /**
      * Artificial element name. Returns `undefined`. Added for compatibility reasons.
      */
      get name() {
        return void 0;
      }
      /**
      * Artificial element getFillerOffset. Returns `undefined`. Added for compatibility reasons.
      */
      get getFillerOffset() {
        return void 0;
      }
      /**
      * Returns the custom property value for the given key.
      */
      getCustomProperty(key) {
        return this._customProperties.get(key);
      }
      /**
      * Returns an iterator which iterates over this document fragment's custom properties.
      * Iterator provides `[ key, value ]` pairs for each stored property.
      */
      *getCustomProperties() {
        yield* this._customProperties.entries();
      }
      /**
      * {@link module:engine/view/documentfragment~DocumentFragment#_insertChild Insert} a child node or a list of child nodes at the end
      * and sets the parent of these nodes to this fragment.
      *
      * @internal
      * @param items Items to be inserted.
      * @returns Number of appended nodes.
      */
      _appendChild(items) {
        return this._insertChild(this.childCount, items);
      }
      /**
      * Gets child at the given index.
      *
      * @param index Index of child.
      * @returns Child node.
      */
      getChild(index) {
        return this._children[index];
      }
      /**
      * Gets index of the given child node. Returns `-1` if child node is not found.
      *
      * @param node Child node.
      * @returns Index of the child node.
      */
      getChildIndex(node) {
        return this._children.indexOf(node);
      }
      /**
      * Gets child nodes iterator.
      *
      * @returns Child nodes iterator.
      */
      getChildren() {
        return this._children[Symbol.iterator]();
      }
      /**
      * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to
      * this fragment.
      *
      * @internal
      * @param index Position where nodes should be inserted.
      * @param items Items to be inserted.
      * @returns Number of inserted nodes.
      */
      _insertChild(index, items) {
        this._fireChange("children", this);
        let count2 = 0;
        const nodes = normalize$2(this.document, items);
        for (const node of nodes) {
          if (node.parent !== null) {
            node._remove();
          }
          node.parent = this;
          this._children.splice(index, 0, node);
          index++;
          count2++;
        }
        return count2;
      }
      /**
      * Removes number of child nodes starting at the given index and set the parent of these nodes to `null`.
      *
      * @internal
      * @param index Number of the first node to remove.
      * @param howMany Number of nodes to remove.
      * @returns The array of removed nodes.
      */
      _removeChildren(index, howMany = 1) {
        this._fireChange("children", this);
        for (let i2 = index; i2 < index + howMany; i2++) {
          this._children[i2].parent = null;
        }
        return this._children.splice(index, howMany);
      }
      /**
      * Fires `change` event with given type of the change.
      *
      * @internal
      * @param type Type of the change.
      * @param node Changed node.
      */
      _fireChange(type, node) {
        this.fire("change:" + type, node);
      }
      /**
      * Sets a custom property. They can be used to add special data to elements.
      *
      * @see module:engine/view/downcastwriter~DowncastWriter#setCustomProperty
      * @internal
      */
      _setCustomProperty(key, value) {
        this._customProperties.set(key, value);
      }
      /**
      * Removes the custom property stored under the given key.
      *
      * @see module:engine/view/downcastwriter~DowncastWriter#removeCustomProperty
      * @internal
      * @returns Returns true if property was removed.
      */
      _removeCustomProperty(key) {
        return this._customProperties.delete(key);
      }
    };
    DocumentFragment$1.prototype.is = function(type) {
      return type === "documentFragment" || type === "view:documentFragment";
    };
    function normalize$2(document2, nodes) {
      if (typeof nodes == "string") {
        return [
          new Text$1(document2, nodes)
        ];
      }
      if (!isIterable(nodes)) {
        nodes = [
          nodes
        ];
      }
      return Array.from(nodes).map((node) => {
        if (typeof node == "string") {
          return new Text$1(document2, node);
        }
        if (node instanceof TextProxy$1) {
          return new Text$1(document2, node.data);
        }
        return node;
      });
    }
    class DowncastWriter {
      /**
      * @param document The view document instance.
      */
      constructor(document2) {
        /**
        * The view document instance in which this writer operates.
        */
        __publicField(this, "document");
        /**
        * Holds references to the attribute groups that share the same {@link module:engine/view/attributeelement~AttributeElement#id id}.
        * The keys are `id`s, the values are `Set`s holding {@link module:engine/view/attributeelement~AttributeElement}s.
        */
        __publicField(this, "_cloneGroups", /* @__PURE__ */ new Map());
        /**
        * The slot factory used by the `elementToStructure` downcast helper.
        */
        __publicField(this, "_slotFactory", null);
        this.document = document2;
      }
      setSelection(...args) {
        this.document.selection._setTo(...args);
      }
      /**
      * Moves {@link module:engine/view/documentselection~DocumentSelection#focus selection's focus} to the specified location.
      *
      * The location can be specified in the same form as {@link module:engine/view/view~View#createPositionAt view.createPositionAt()}
      * parameters.
      *
      * @param Offset or one of the flags. Used only when the first parameter is a {@link module:engine/view/item~Item view item}.
      */
      setSelectionFocus(itemOrPosition, offset2) {
        this.document.selection._setFocus(itemOrPosition, offset2);
      }
      /**
      * Creates a new {@link module:engine/view/documentfragment~DocumentFragment} instance.
      *
      * @param children A list of nodes to be inserted into the created document fragment.
      * @returns The created document fragment.
      */
      createDocumentFragment(children) {
        return new DocumentFragment$1(this.document, children);
      }
      /**
      * Creates a new {@link module:engine/view/text~Text text node}.
      *
      * ```ts
      * writer.createText( 'foo' );
      * ```
      *
      * @param data The text's data.
      * @returns The created text node.
      */
      createText(data) {
        return new Text$1(this.document, data);
      }
      /**
      * Creates a new {@link module:engine/view/attributeelement~AttributeElement}.
      *
      * ```ts
      * writer.createAttributeElement( 'strong' );
      * writer.createAttributeElement( 'a', { href: 'foo.bar' } );
      *
      * // Make `<a>` element contain other attributes element so the `<a>` element is not broken.
      * writer.createAttributeElement( 'a', { href: 'foo.bar' }, { priority: 5 } );
      *
      * // Set `id` of a marker element so it is not joined or merged with "normal" elements.
      * writer.createAttributeElement( 'span', { class: 'my-marker' }, { id: 'marker:my' } );
      * ```
      *
      * @param name Name of the element.
      * @param attributes Element's attributes.
      * @param options Element's options.
      * @param options.priority Element's {@link module:engine/view/attributeelement~AttributeElement#priority priority}.
      * @param options.id Element's {@link module:engine/view/attributeelement~AttributeElement#id id}.
      * @param options.renderUnsafeAttributes A list of attribute names that should be rendered in the editing
      * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.
      * @returns Created element.
      */
      createAttributeElement(name, attributes, options = {}) {
        const attributeElement = new AttributeElement(this.document, name, attributes);
        if (typeof options.priority === "number") {
          attributeElement._priority = options.priority;
        }
        if (options.id) {
          attributeElement._id = options.id;
        }
        if (options.renderUnsafeAttributes) {
          attributeElement._unsafeAttributesToRender.push(...options.renderUnsafeAttributes);
        }
        return attributeElement;
      }
      createContainerElement(name, attributes, childrenOrOptions = {}, options = {}) {
        let children = null;
        if (isPlainObject$2(childrenOrOptions)) {
          options = childrenOrOptions;
        } else {
          children = childrenOrOptions;
        }
        const containerElement = new ContainerElement(this.document, name, attributes, children);
        if (options.renderUnsafeAttributes) {
          containerElement._unsafeAttributesToRender.push(...options.renderUnsafeAttributes);
        }
        return containerElement;
      }
      /**
      * Creates a new {@link module:engine/view/editableelement~EditableElement}.
      *
      * ```ts
      * writer.createEditableElement( 'div' );
      * writer.createEditableElement( 'div', { id: 'foo-1234' } );
      * ```
      *
      * Note: The editable element is to be used in the editing pipeline. Usually, together with
      * {@link module:widget/utils~toWidgetEditable `toWidgetEditable()`}.
      *
      * @param name Name of the element.
      * @param attributes Elements attributes.
      * @param options Element's options.
      * @param options.renderUnsafeAttributes A list of attribute names that should be rendered in the editing
      * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.
      * @returns Created element.
      */
      createEditableElement(name, attributes, options = {}) {
        const editableElement = new EditableElement(this.document, name, attributes);
        if (options.renderUnsafeAttributes) {
          editableElement._unsafeAttributesToRender.push(...options.renderUnsafeAttributes);
        }
        return editableElement;
      }
      /**
      * Creates a new {@link module:engine/view/emptyelement~EmptyElement}.
      *
      * ```ts
      * writer.createEmptyElement( 'img' );
      * writer.createEmptyElement( 'img', { id: 'foo-1234' } );
      * ```
      *
      * @param name Name of the element.
      * @param attributes Elements attributes.
      * @param options Element's options.
      * @param options.renderUnsafeAttributes A list of attribute names that should be rendered in the editing
      * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.
      * @returns Created element.
      */
      createEmptyElement(name, attributes, options = {}) {
        const emptyElement = new EmptyElement(this.document, name, attributes);
        if (options.renderUnsafeAttributes) {
          emptyElement._unsafeAttributesToRender.push(...options.renderUnsafeAttributes);
        }
        return emptyElement;
      }
      /**
      * Creates a new {@link module:engine/view/uielement~UIElement}.
      *
      * ```ts
      * writer.createUIElement( 'span' );
      * writer.createUIElement( 'span', { id: 'foo-1234' } );
      * ```
      *
      * A custom render function can be provided as the third parameter:
      *
      * ```ts
      * writer.createUIElement( 'span', null, function( domDocument ) {
      * 	const domElement = this.toDomElement( domDocument );
      * 	domElement.innerHTML = '<b>this is ui element</b>';
      *
      * 	return domElement;
      * } );
      * ```
      *
      * Unlike {@link #createRawElement raw elements}, UI elements are by no means editor content, for instance,
      * they are ignored by the editor selection system.
      *
      * You should not use UI elements as data containers. Check out {@link #createRawElement} instead.
      *
      * @param name The name of the element.
      * @param attributes Element attributes.
      * @param renderFunction A custom render function.
      * @returns The created element.
      */
      createUIElement(name, attributes, renderFunction) {
        const uiElement = new UIElement(this.document, name, attributes);
        if (renderFunction) {
          uiElement.render = renderFunction;
        }
        return uiElement;
      }
      /**
      * Creates a new {@link module:engine/view/rawelement~RawElement}.
      *
      * ```ts
      * writer.createRawElement( 'span', { id: 'foo-1234' }, function( domElement ) {
      * 	domElement.innerHTML = '<b>This is the raw content of the raw element.</b>';
      * } );
      * ```
      *
      * Raw elements work as data containers ("wrappers", "sandboxes") but their children are not managed or
      * even recognized by the editor. This encapsulation allows integrations to maintain custom DOM structures
      * in the editor content without, for instance, worrying about compatibility with other editor features.
      * Raw elements are a perfect tool for integration with external frameworks and data sources.
      *
      * Unlike {@link #createUIElement UI elements}, raw elements act like "real" editor content (similar to
      * {@link module:engine/view/containerelement~ContainerElement} or {@link module:engine/view/emptyelement~EmptyElement}),
      * and they are considered by the editor selection.
      *
      * You should not use raw elements to render the UI in the editor content. Check out {@link #createUIElement `#createUIElement()`}
      * instead.
      *
      * @param name The name of the element.
      * @param attributes Element attributes.
      * @param renderFunction A custom render function.
      * @param options Element's options.
      * @param options.renderUnsafeAttributes A list of attribute names that should be rendered in the editing
      * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.
      * @returns The created element.
      */
      createRawElement(name, attributes, renderFunction, options = {}) {
        const rawElement = new RawElement(this.document, name, attributes);
        if (renderFunction) {
          rawElement.render = renderFunction;
        }
        if (options.renderUnsafeAttributes) {
          rawElement._unsafeAttributesToRender.push(...options.renderUnsafeAttributes);
        }
        return rawElement;
      }
      /**
      * Adds or overwrites the element's attribute with a specified key and value.
      *
      * ```ts
      * writer.setAttribute( 'href', 'http://ckeditor.com', linkElement );
      * ```
      *
      * @param key The attribute key.
      * @param value The attribute value.
      */
      setAttribute(key, value, element) {
        element._setAttribute(key, value);
      }
      /**
      * Removes attribute from the element.
      *
      * ```ts
      * writer.removeAttribute( 'href', linkElement );
      * ```
      *
      * @param key Attribute key.
      */
      removeAttribute(key, element) {
        element._removeAttribute(key);
      }
      /**
      * Adds specified class to the element.
      *
      * ```ts
      * writer.addClass( 'foo', linkElement );
      * writer.addClass( [ 'foo', 'bar' ], linkElement );
      * ```
      */
      addClass(className, element) {
        element._addClass(className);
      }
      /**
      * Removes specified class from the element.
      *
      * ```ts
      * writer.removeClass( 'foo', linkElement );
      * writer.removeClass( [ 'foo', 'bar' ], linkElement );
      * ```
      */
      removeClass(className, element) {
        element._removeClass(className);
      }
      setStyle(property2, value, element) {
        if (isPlainObject$2(property2) && element === void 0) {
          value._setStyle(property2);
        } else {
          element._setStyle(property2, value);
        }
      }
      /**
      * Removes specified style from the element.
      *
      * ```ts
      * writer.removeStyle( 'color', element ); // Removes 'color' style.
      * writer.removeStyle( [ 'color', 'border-top' ], element ); // Removes both 'color' and 'border-top' styles.
      * ```
      *
      * **Note**: This method can work with normalized style names if
      * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
      * See {@link module:engine/view/stylesmap~StylesMap#remove `StylesMap#remove()`} for details.
      */
      removeStyle(property2, element) {
        element._removeStyle(property2);
      }
      /**
      * Sets a custom property on element. Unlike attributes, custom properties are not rendered to the DOM,
      * so they can be used to add special data to elements.
      */
      setCustomProperty(key, value, element) {
        element._setCustomProperty(key, value);
      }
      /**
      * Removes a custom property stored under the given key.
      *
      * @returns Returns true if property was removed.
      */
      removeCustomProperty(key, element) {
        return element._removeCustomProperty(key);
      }
      /**
      * Breaks attribute elements at the provided position or at the boundaries of a provided range. It breaks attribute elements
      * up to their first ancestor that is a container element.
      *
      * In following examples `<p>` is a container, `<b>` and `<u>` are attribute elements:
      *
      * ```html
      * <p>foo<b><u>bar{}</u></b></p> -> <p>foo<b><u>bar</u></b>[]</p>
      * <p>foo<b><u>{}bar</u></b></p> -> <p>foo{}<b><u>bar</u></b></p>
      * <p>foo<b><u>b{}ar</u></b></p> -> <p>foo<b><u>b</u></b>[]<b><u>ar</u></b></p>
      * <p><b>fo{o</b><u>ba}r</u></p> -> <p><b>fo</b><b>o</b><u>ba</u><u>r</u></b></p>
      * ```
      *
      * **Note:** {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment} is treated like a container.
      *
      * **Note:** The difference between {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes breakAttributes()} and
      * {@link module:engine/view/downcastwriter~DowncastWriter#breakContainer breakContainer()} is that `breakAttributes()` breaks all
      * {@link module:engine/view/attributeelement~AttributeElement attribute elements} that are ancestors of a given `position`,
      * up to the first encountered {@link module:engine/view/containerelement~ContainerElement container element}.
      * `breakContainer()` assumes that a given `position` is directly in the container element and breaks that container element.
      *
      * Throws the `view-writer-invalid-range-container` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}
      * when the {@link module:engine/view/range~Range#start start}
      * and {@link module:engine/view/range~Range#end end} positions of a passed range are not placed inside same parent container.
      *
      * Throws the `view-writer-cannot-break-empty-element` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}
      * when trying to break attributes inside an {@link module:engine/view/emptyelement~EmptyElement EmptyElement}.
      *
      * Throws the `view-writer-cannot-break-ui-element` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}
      * when trying to break attributes inside a {@link module:engine/view/uielement~UIElement UIElement}.
      *
      * @see module:engine/view/attributeelement~AttributeElement
      * @see module:engine/view/containerelement~ContainerElement
      * @see module:engine/view/downcastwriter~DowncastWriter#breakContainer
      * @param positionOrRange The position where to break attribute elements.
      * @returns The new position or range, after breaking the attribute elements.
      */
      breakAttributes(positionOrRange) {
        if (positionOrRange instanceof Position$1) {
          return this._breakAttributes(positionOrRange);
        } else {
          return this._breakAttributesRange(positionOrRange);
        }
      }
      /**
      * Breaks a {@link module:engine/view/containerelement~ContainerElement container view element} into two, at the given position.
      * The position has to be directly inside the container element and cannot be in the root. It does not break the conrainer view element
      * if the position is at the beginning or at the end of its parent element.
      *
      * ```html
      * <p>foo^bar</p> -> <p>foo</p><p>bar</p>
      * <div><p>foo</p>^<p>bar</p></div> -> <div><p>foo</p></div><div><p>bar</p></div>
      * <p>^foobar</p> -> ^<p>foobar</p>
      * <p>foobar^</p> -> <p>foobar</p>^
      * ```
      *
      * **Note:** The difference between {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes breakAttributes()} and
      * {@link module:engine/view/downcastwriter~DowncastWriter#breakContainer breakContainer()} is that `breakAttributes()` breaks all
      * {@link module:engine/view/attributeelement~AttributeElement attribute elements} that are ancestors of a given `position`,
      * up to the first encountered {@link module:engine/view/containerelement~ContainerElement container element}.
      * `breakContainer()` assumes that the given `position` is directly in the container element and breaks that container element.
      *
      * @see module:engine/view/attributeelement~AttributeElement
      * @see module:engine/view/containerelement~ContainerElement
      * @see module:engine/view/downcastwriter~DowncastWriter#breakAttributes
      * @param position The position where to break the element.
      * @returns The position between broken elements. If an element has not been broken,
      * the returned position is placed either before or after it.
      */
      breakContainer(position) {
        const element = position.parent;
        if (!element.is("containerElement")) {
          throw new CKEditorError("view-writer-break-non-container-element", this.document);
        }
        if (!element.parent) {
          throw new CKEditorError("view-writer-break-root", this.document);
        }
        if (position.isAtStart) {
          return Position$1._createBefore(element);
        } else if (!position.isAtEnd) {
          const newElement = element._clone(false);
          this.insert(Position$1._createAfter(element), newElement);
          const sourceRange = new Range$1(position, Position$1._createAt(element, "end"));
          const targetPosition = new Position$1(newElement, 0);
          this.move(sourceRange, targetPosition);
        }
        return Position$1._createAfter(element);
      }
      /**
      * Merges {@link module:engine/view/attributeelement~AttributeElement attribute elements}. It also merges text nodes if needed.
      * Only {@link module:engine/view/attributeelement~AttributeElement#isSimilar similar} attribute elements can be merged.
      *
      * In following examples `<p>` is a container and `<b>` is an attribute element:
      *
      * ```html
      * <p>foo[]bar</p> -> <p>foo{}bar</p>
      * <p><b>foo</b>[]<b>bar</b></p> -> <p><b>foo{}bar</b></p>
      * <p><b foo="bar">a</b>[]<b foo="baz">b</b></p> -> <p><b foo="bar">a</b>[]<b foo="baz">b</b></p>
      * ```
      *
      * It will also take care about empty attributes when merging:
      *
      * ```html
      * <p><b>[]</b></p> -> <p>[]</p>
      * <p><b>foo</b><i>[]</i><b>bar</b></p> -> <p><b>foo{}bar</b></p>
      * ```
      *
      * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#mergeAttributes mergeAttributes} and
      * {@link module:engine/view/downcastwriter~DowncastWriter#mergeContainers mergeContainers} is that `mergeAttributes` merges two
      * {@link module:engine/view/attributeelement~AttributeElement attribute elements} or {@link module:engine/view/text~Text text nodes}
      * while `mergeContainer` merges two {@link module:engine/view/containerelement~ContainerElement container elements}.
      *
      * @see module:engine/view/attributeelement~AttributeElement
      * @see module:engine/view/containerelement~ContainerElement
      * @see module:engine/view/downcastwriter~DowncastWriter#mergeContainers
      * @param position Merge position.
      * @returns Position after merge.
      */
      mergeAttributes(position) {
        const positionOffset = position.offset;
        const positionParent = position.parent;
        if (positionParent.is("$text")) {
          return position;
        }
        if (positionParent.is("attributeElement") && positionParent.childCount === 0) {
          const parent2 = positionParent.parent;
          const offset2 = positionParent.index;
          positionParent._remove();
          this._removeFromClonedElementsGroup(positionParent);
          return this.mergeAttributes(new Position$1(parent2, offset2));
        }
        const nodeBefore = positionParent.getChild(positionOffset - 1);
        const nodeAfter = positionParent.getChild(positionOffset);
        if (!nodeBefore || !nodeAfter) {
          return position;
        }
        if (nodeBefore.is("$text") && nodeAfter.is("$text")) {
          return mergeTextNodes(nodeBefore, nodeAfter);
        } else if (nodeBefore.is("attributeElement") && nodeAfter.is("attributeElement") && nodeBefore.isSimilar(nodeAfter)) {
          const count2 = nodeBefore.childCount;
          nodeBefore._appendChild(nodeAfter.getChildren());
          nodeAfter._remove();
          this._removeFromClonedElementsGroup(nodeAfter);
          return this.mergeAttributes(new Position$1(nodeBefore, count2));
        }
        return position;
      }
      /**
      * Merges two {@link module:engine/view/containerelement~ContainerElement container elements} that are before and after given position.
      * Precisely, the element after the position is removed and it's contents are moved to element before the position.
      *
      * ```html
      * <p>foo</p>^<p>bar</p> -> <p>foo^bar</p>
      * <div>foo</div>^<p>bar</p> -> <div>foo^bar</div>
      * ```
      *
      * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#mergeAttributes mergeAttributes} and
      * {@link module:engine/view/downcastwriter~DowncastWriter#mergeContainers mergeContainers} is that `mergeAttributes` merges two
      * {@link module:engine/view/attributeelement~AttributeElement attribute elements} or {@link module:engine/view/text~Text text nodes}
      * while `mergeContainer` merges two {@link module:engine/view/containerelement~ContainerElement container elements}.
      *
      * @see module:engine/view/attributeelement~AttributeElement
      * @see module:engine/view/containerelement~ContainerElement
      * @see module:engine/view/downcastwriter~DowncastWriter#mergeAttributes
      * @param position Merge position.
      * @returns Position after merge.
      */
      mergeContainers(position) {
        const prev = position.nodeBefore;
        const next = position.nodeAfter;
        if (!prev || !next || !prev.is("containerElement") || !next.is("containerElement")) {
          throw new CKEditorError("view-writer-merge-containers-invalid-position", this.document);
        }
        const lastChild = prev.getChild(prev.childCount - 1);
        const newPosition = lastChild instanceof Text$1 ? Position$1._createAt(lastChild, "end") : Position$1._createAt(prev, "end");
        this.move(Range$1._createIn(next), Position$1._createAt(prev, "end"));
        this.remove(Range$1._createOn(next));
        return newPosition;
      }
      /**
      * Inserts a node or nodes at specified position. Takes care about breaking attributes before insertion
      * and merging them afterwards.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-insert-invalid-node` when nodes to insert
      * contains instances that are not {@link module:engine/view/text~Text Texts},
      * {@link module:engine/view/attributeelement~AttributeElement AttributeElements},
      * {@link module:engine/view/containerelement~ContainerElement ContainerElements},
      * {@link module:engine/view/emptyelement~EmptyElement EmptyElements},
      * {@link module:engine/view/rawelement~RawElement RawElements} or
      * {@link module:engine/view/uielement~UIElement UIElements}.
      *
      * @param position Insertion position.
      * @param nodes Node or nodes to insert.
      * @returns Range around inserted nodes.
      */
      insert(position, nodes) {
        nodes = isIterable(nodes) ? [
          ...nodes
        ] : [
          nodes
        ];
        validateNodesToInsert(nodes, this.document);
        const nodeGroups = nodes.reduce((groups, node) => {
          const lastGroup = groups[groups.length - 1];
          const breakAttributes = !node.is("uiElement");
          if (!lastGroup || lastGroup.breakAttributes != breakAttributes) {
            groups.push({
              breakAttributes,
              nodes: [
                node
              ]
            });
          } else {
            lastGroup.nodes.push(node);
          }
          return groups;
        }, []);
        let start2 = null;
        let end2 = position;
        for (const { nodes: nodes2, breakAttributes } of nodeGroups) {
          const range2 = this._insertNodes(end2, nodes2, breakAttributes);
          if (!start2) {
            start2 = range2.start;
          }
          end2 = range2.end;
        }
        if (!start2) {
          return new Range$1(position);
        }
        return new Range$1(start2, end2);
      }
      /**
      * Removes provided range from the container.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when
      * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside
      * same parent container.
      *
      * @param rangeOrItem Range to remove from container
      * or an {@link module:engine/view/item~Item item} to remove. If range is provided, after removing, it will be updated
      * to a collapsed range showing the new position.
      * @returns Document fragment containing removed nodes.
      */
      remove(rangeOrItem) {
        const range2 = rangeOrItem instanceof Range$1 ? rangeOrItem : Range$1._createOn(rangeOrItem);
        validateRangeContainer(range2, this.document);
        if (range2.isCollapsed) {
          return new DocumentFragment$1(this.document);
        }
        const { start: breakStart, end: breakEnd } = this._breakAttributesRange(range2, true);
        const parentContainer = breakStart.parent;
        const count2 = breakEnd.offset - breakStart.offset;
        const removed = parentContainer._removeChildren(breakStart.offset, count2);
        for (const node of removed) {
          this._removeFromClonedElementsGroup(node);
        }
        const mergePosition = this.mergeAttributes(breakStart);
        range2.start = mergePosition;
        range2.end = mergePosition.clone();
        return new DocumentFragment$1(this.document, removed);
      }
      /**
      * Removes matching elements from given range.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when
      * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside
      * same parent container.
      *
      * @param range Range to clear.
      * @param element Element to remove.
      */
      clear(range2, element) {
        validateRangeContainer(range2, this.document);
        const walker = range2.getWalker({
          direction: "backward",
          ignoreElementEnd: true
        });
        for (const current of walker) {
          const item = current.item;
          let rangeToRemove;
          if (item.is("element") && element.isSimilar(item)) {
            rangeToRemove = Range$1._createOn(item);
          } else if (!current.nextPosition.isAfter(range2.start) && item.is("$textProxy")) {
            const parentElement = item.getAncestors().find((ancestor) => {
              return ancestor.is("element") && element.isSimilar(ancestor);
            });
            if (parentElement) {
              rangeToRemove = Range$1._createIn(parentElement);
            }
          }
          if (rangeToRemove) {
            if (rangeToRemove.end.isAfter(range2.end)) {
              rangeToRemove.end = range2.end;
            }
            if (rangeToRemove.start.isBefore(range2.start)) {
              rangeToRemove.start = range2.start;
            }
            this.remove(rangeToRemove);
          }
        }
      }
      /**
      * Moves nodes from provided range to target position.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when
      * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside
      * same parent container.
      *
      * @param sourceRange Range containing nodes to move.
      * @param targetPosition Position to insert.
      * @returns Range in target container. Inserted nodes are placed between
      * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions.
      */
      move(sourceRange, targetPosition) {
        let nodes;
        if (targetPosition.isAfter(sourceRange.end)) {
          targetPosition = this._breakAttributes(targetPosition, true);
          const parent2 = targetPosition.parent;
          const countBefore = parent2.childCount;
          sourceRange = this._breakAttributesRange(sourceRange, true);
          nodes = this.remove(sourceRange);
          targetPosition.offset += parent2.childCount - countBefore;
        } else {
          nodes = this.remove(sourceRange);
        }
        return this.insert(targetPosition, nodes);
      }
      /**
      * Wraps elements within range with provided {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.
      * If a collapsed range is provided, it will be wrapped only if it is equal to view selection.
      *
      * If a collapsed range was passed and is same as selection, the selection
      * will be moved to the inside of the wrapped attribute element.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-invalid-range-container`
      * when {@link module:engine/view/range~Range#start}
      * and {@link module:engine/view/range~Range#end} positions are not placed inside same parent container.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not
      * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-nonselection-collapsed-range` when passed range
      * is collapsed and different than view selection.
      *
      * @param range Range to wrap.
      * @param attribute Attribute element to use as wrapper.
      * @returns range Range after wrapping, spanning over wrapping attribute element.
      */
      wrap(range2, attribute) {
        if (!(attribute instanceof AttributeElement)) {
          throw new CKEditorError("view-writer-wrap-invalid-attribute", this.document);
        }
        validateRangeContainer(range2, this.document);
        if (!range2.isCollapsed) {
          return this._wrapRange(range2, attribute);
        } else {
          let position = range2.start;
          if (position.parent.is("element") && !_hasNonUiChildren(position.parent)) {
            position = position.getLastMatchingPosition((value) => value.item.is("uiElement"));
          }
          position = this._wrapPosition(position, attribute);
          const viewSelection = this.document.selection;
          if (viewSelection.isCollapsed && viewSelection.getFirstPosition().isEqual(range2.start)) {
            this.setSelection(position);
          }
          return new Range$1(position);
        }
      }
      /**
      * Unwraps nodes within provided range from attribute element.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when
      * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside
      * same parent container.
      */
      unwrap(range2, attribute) {
        if (!(attribute instanceof AttributeElement)) {
          throw new CKEditorError("view-writer-unwrap-invalid-attribute", this.document);
        }
        validateRangeContainer(range2, this.document);
        if (range2.isCollapsed) {
          return range2;
        }
        const { start: breakStart, end: breakEnd } = this._breakAttributesRange(range2, true);
        const parentContainer = breakStart.parent;
        const newRange = this._unwrapChildren(parentContainer, breakStart.offset, breakEnd.offset, attribute);
        const start2 = this.mergeAttributes(newRange.start);
        if (!start2.isEqual(newRange.start)) {
          newRange.end.offset--;
        }
        const end2 = this.mergeAttributes(newRange.end);
        return new Range$1(start2, end2);
      }
      /**
      * Renames element by creating a copy of renamed element but with changed name and then moving contents of the
      * old element to the new one. Keep in mind that this will invalidate all {@link module:engine/view/position~Position positions} which
      * has renamed element as {@link module:engine/view/position~Position#parent a parent}.
      *
      * New element has to be created because `Element#tagName` property in DOM is readonly.
      *
      * Since this function creates a new element and removes the given one, the new element is returned to keep reference.
      *
      * @param newName New name for element.
      * @param viewElement Element to be renamed.
      * @returns Element created due to rename.
      */
      rename(newName, viewElement) {
        const newElement = new ContainerElement(this.document, newName, viewElement.getAttributes());
        this.insert(Position$1._createAfter(viewElement), newElement);
        this.move(Range$1._createIn(viewElement), Position$1._createAt(newElement, 0));
        this.remove(Range$1._createOn(viewElement));
        return newElement;
      }
      /**
      * Cleans up memory by removing obsolete cloned elements group from the writer.
      *
      * Should be used whenever all {@link module:engine/view/attributeelement~AttributeElement attribute elements}
      * with the same {@link module:engine/view/attributeelement~AttributeElement#id id} are going to be removed from the view and
      * the group will no longer be needed.
      *
      * Cloned elements group are not removed automatically in case if the group is still needed after all its elements
      * were removed from the view.
      *
      * Keep in mind that group names are equal to the `id` property of the attribute element.
      *
      * @param groupName Name of the group to clear.
      */
      clearClonedElementsGroup(groupName) {
        this._cloneGroups.delete(groupName);
      }
      /**
      * Creates position at the given location. The location can be specified as:
      *
      * * a {@link module:engine/view/position~Position position},
      * * parent element and offset (offset defaults to `0`),
      * * parent element and `'end'` (sets position at the end of that element),
      * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).
      *
      * This method is a shortcut to other constructors such as:
      *
      * * {@link #createPositionBefore},
      * * {@link #createPositionAfter},
      *
      * @param offset Offset or one of the flags. Used only when the first parameter is a {@link module:engine/view/item~Item view item}.
      */
      createPositionAt(itemOrPosition, offset2) {
        return Position$1._createAt(itemOrPosition, offset2);
      }
      /**
      * Creates a new position after given view item.
      *
      * @param item View item after which the position should be located.
      */
      createPositionAfter(item) {
        return Position$1._createAfter(item);
      }
      /**
      * Creates a new position before given view item.
      *
      * @param item View item before which the position should be located.
      */
      createPositionBefore(item) {
        return Position$1._createBefore(item);
      }
      /**
      * Creates a range spanning from `start` position to `end` position.
      *
      * **Note:** This factory method creates its own {@link module:engine/view/position~Position} instances basing on passed values.
      *
      * @param start Start position.
      * @param end End position. If not set, range will be collapsed at `start` position.
      */
      createRange(start2, end2) {
        return new Range$1(start2, end2);
      }
      /**
      * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.
      */
      createRangeOn(item) {
        return Range$1._createOn(item);
      }
      /**
      * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
      * that element and ends after the last child of that element.
      *
      * @param element Element which is a parent for the range.
      */
      createRangeIn(element) {
        return Range$1._createIn(element);
      }
      createSelection(...args) {
        return new Selection$1(...args);
      }
      /**
      * Creates placeholders for child elements of the {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure
      * `elementToStructure()`} conversion helper.
      *
      * ```ts
      * const viewSlot = conversionApi.writer.createSlot();
      * const viewPosition = conversionApi.writer.createPositionAt( viewElement, 0 );
      *
      * conversionApi.writer.insert( viewPosition, viewSlot );
      * ```
      *
      * It could be filtered down to a specific subset of children (only `<foo>` model elements in this case):
      *
      * ```ts
      * const viewSlot = conversionApi.writer.createSlot( node => node.is( 'element', 'foo' ) );
      * const viewPosition = conversionApi.writer.createPositionAt( viewElement, 0 );
      *
      * conversionApi.writer.insert( viewPosition, viewSlot );
      * ```
      *
      * While providing a filtered slot, make sure to provide slots for all child nodes. A single node can not be downcasted into
      * multiple slots.
      *
      * **Note**: You should not change the order of nodes. View elements should be in the same order as model nodes.
      *
      * @param modeOrFilter The filter for child nodes.
      * @returns The slot element to be placed in to the view structure while processing
      * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure `elementToStructure()`}.
      */
      createSlot(modeOrFilter = "children") {
        if (!this._slotFactory) {
          throw new CKEditorError("view-writer-invalid-create-slot-context", this.document);
        }
        return this._slotFactory(this, modeOrFilter);
      }
      /**
      * Registers a slot factory.
      *
      * @internal
      * @param slotFactory The slot factory.
      */
      _registerSlotFactory(slotFactory) {
        this._slotFactory = slotFactory;
      }
      /**
      * Clears the registered slot factory.
      *
      * @internal
      */
      _clearSlotFactory() {
        this._slotFactory = null;
      }
      /**
      * Inserts a node or nodes at the specified position. Takes care of breaking attributes before insertion
      * and merging them afterwards if requested by the breakAttributes param.
      *
      * @param position Insertion position.
      * @param nodes Node or nodes to insert.
      * @param breakAttributes Whether attributes should be broken.
      * @returns Range around inserted nodes.
      */
      _insertNodes(position, nodes, breakAttributes) {
        let parentElement;
        if (breakAttributes) {
          parentElement = getParentContainer(position);
        } else {
          parentElement = position.parent.is("$text") ? position.parent.parent : position.parent;
        }
        if (!parentElement) {
          throw new CKEditorError("view-writer-invalid-position-container", this.document);
        }
        let insertionPosition;
        if (breakAttributes) {
          insertionPosition = this._breakAttributes(position, true);
        } else {
          insertionPosition = position.parent.is("$text") ? breakTextNode(position) : position;
        }
        const length = parentElement._insertChild(insertionPosition.offset, nodes);
        for (const node of nodes) {
          this._addToClonedElementsGroup(node);
        }
        const endPosition = insertionPosition.getShiftedBy(length);
        const start2 = this.mergeAttributes(insertionPosition);
        if (!start2.isEqual(insertionPosition)) {
          endPosition.offset--;
        }
        const end2 = this.mergeAttributes(endPosition);
        return new Range$1(start2, end2);
      }
      /**
      * Wraps children with provided `wrapElement`. Only children contained in `parent` element between
      * `startOffset` and `endOffset` will be wrapped.
      */
      _wrapChildren(parent2, startOffset, endOffset, wrapElement) {
        let i2 = startOffset;
        const wrapPositions = [];
        while (i2 < endOffset) {
          const child = parent2.getChild(i2);
          const isText2 = child.is("$text");
          const isAttribute = child.is("attributeElement");
          if (isAttribute && this._wrapAttributeElement(wrapElement, child)) {
            wrapPositions.push(new Position$1(parent2, i2));
          } else if (isText2 || !isAttribute || shouldABeOutsideB(wrapElement, child)) {
            const newAttribute = wrapElement._clone();
            child._remove();
            newAttribute._appendChild(child);
            parent2._insertChild(i2, newAttribute);
            this._addToClonedElementsGroup(newAttribute);
            wrapPositions.push(new Position$1(parent2, i2));
          } else {
            this._wrapChildren(child, 0, child.childCount, wrapElement);
          }
          i2++;
        }
        let offsetChange = 0;
        for (const position of wrapPositions) {
          position.offset -= offsetChange;
          if (position.offset == startOffset) {
            continue;
          }
          const newPosition = this.mergeAttributes(position);
          if (!newPosition.isEqual(position)) {
            offsetChange++;
            endOffset--;
          }
        }
        return Range$1._createFromParentsAndOffsets(parent2, startOffset, parent2, endOffset);
      }
      /**
      * Unwraps children from provided `unwrapElement`. Only children contained in `parent` element between
      * `startOffset` and `endOffset` will be unwrapped.
      */
      _unwrapChildren(parent2, startOffset, endOffset, unwrapElement2) {
        let i2 = startOffset;
        const unwrapPositions = [];
        while (i2 < endOffset) {
          const child = parent2.getChild(i2);
          if (!child.is("attributeElement")) {
            i2++;
            continue;
          }
          if (child.isSimilar(unwrapElement2)) {
            const unwrapped = child.getChildren();
            const count2 = child.childCount;
            child._remove();
            parent2._insertChild(i2, unwrapped);
            this._removeFromClonedElementsGroup(child);
            unwrapPositions.push(new Position$1(parent2, i2), new Position$1(parent2, i2 + count2));
            i2 += count2;
            endOffset += count2 - 1;
            continue;
          }
          if (this._unwrapAttributeElement(unwrapElement2, child)) {
            unwrapPositions.push(new Position$1(parent2, i2), new Position$1(parent2, i2 + 1));
            i2++;
            continue;
          }
          this._unwrapChildren(child, 0, child.childCount, unwrapElement2);
          i2++;
        }
        let offsetChange = 0;
        for (const position of unwrapPositions) {
          position.offset -= offsetChange;
          if (position.offset == startOffset || position.offset == endOffset) {
            continue;
          }
          const newPosition = this.mergeAttributes(position);
          if (!newPosition.isEqual(position)) {
            offsetChange++;
            endOffset--;
          }
        }
        return Range$1._createFromParentsAndOffsets(parent2, startOffset, parent2, endOffset);
      }
      /**
      * Helper function for `view.writer.wrap`. Wraps range with provided attribute element.
      * This method will also merge newly added attribute element with its siblings whenever possible.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not
      * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.
      *
      * @returns New range after wrapping, spanning over wrapping attribute element.
      */
      _wrapRange(range2, attribute) {
        const { start: breakStart, end: breakEnd } = this._breakAttributesRange(range2, true);
        const parentContainer = breakStart.parent;
        const newRange = this._wrapChildren(parentContainer, breakStart.offset, breakEnd.offset, attribute);
        const start2 = this.mergeAttributes(newRange.start);
        if (!start2.isEqual(newRange.start)) {
          newRange.end.offset--;
        }
        const end2 = this.mergeAttributes(newRange.end);
        return new Range$1(start2, end2);
      }
      /**
      * Helper function for {@link #wrap}. Wraps position with provided attribute element.
      * This method will also merge newly added attribute element with its siblings whenever possible.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not
      * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.
      *
      * @returns New position after wrapping.
      */
      _wrapPosition(position, attribute) {
        if (attribute.isSimilar(position.parent)) {
          return movePositionToTextNode(position.clone());
        }
        if (position.parent.is("$text")) {
          position = breakTextNode(position);
        }
        const fakeElement = this.createAttributeElement("_wrapPosition-fake-element");
        fakeElement._priority = Number.POSITIVE_INFINITY;
        fakeElement.isSimilar = () => false;
        position.parent._insertChild(position.offset, fakeElement);
        const wrapRange = new Range$1(position, position.getShiftedBy(1));
        this.wrap(wrapRange, attribute);
        const newPosition = new Position$1(fakeElement.parent, fakeElement.index);
        fakeElement._remove();
        const nodeBefore = newPosition.nodeBefore;
        const nodeAfter = newPosition.nodeAfter;
        if (nodeBefore instanceof Text$1 && nodeAfter instanceof Text$1) {
          return mergeTextNodes(nodeBefore, nodeAfter);
        }
        return movePositionToTextNode(newPosition);
      }
      /**
      * Wraps one {@link module:engine/view/attributeelement~AttributeElement AttributeElement} into another by
      * merging them if possible. When merging is possible - all attributes, styles and classes are moved from wrapper
      * element to element being wrapped.
      *
      * @param wrapper Wrapper AttributeElement.
      * @param toWrap AttributeElement to wrap using wrapper element.
      * @returns Returns `true` if elements are merged.
      */
      _wrapAttributeElement(wrapper, toWrap) {
        if (!canBeJoined(wrapper, toWrap)) {
          return false;
        }
        if (wrapper.name !== toWrap.name || wrapper.priority !== toWrap.priority) {
          return false;
        }
        for (const key of wrapper.getAttributeKeys()) {
          if (key === "class" || key === "style") {
            continue;
          }
          if (toWrap.hasAttribute(key) && toWrap.getAttribute(key) !== wrapper.getAttribute(key)) {
            return false;
          }
        }
        for (const key of wrapper.getStyleNames()) {
          if (toWrap.hasStyle(key) && toWrap.getStyle(key) !== wrapper.getStyle(key)) {
            return false;
          }
        }
        for (const key of wrapper.getAttributeKeys()) {
          if (key === "class" || key === "style") {
            continue;
          }
          if (!toWrap.hasAttribute(key)) {
            this.setAttribute(key, wrapper.getAttribute(key), toWrap);
          }
        }
        for (const key of wrapper.getStyleNames()) {
          if (!toWrap.hasStyle(key)) {
            this.setStyle(key, wrapper.getStyle(key), toWrap);
          }
        }
        for (const key of wrapper.getClassNames()) {
          if (!toWrap.hasClass(key)) {
            this.addClass(key, toWrap);
          }
        }
        return true;
      }
      /**
      * Unwraps {@link module:engine/view/attributeelement~AttributeElement AttributeElement} from another by removing
      * corresponding attributes, classes and styles. All attributes, classes and styles from wrapper should be present
      * inside element being unwrapped.
      *
      * @param wrapper Wrapper AttributeElement.
      * @param toUnwrap AttributeElement to unwrap using wrapper element.
      * @returns Returns `true` if elements are unwrapped.
      **/
      _unwrapAttributeElement(wrapper, toUnwrap) {
        if (!canBeJoined(wrapper, toUnwrap)) {
          return false;
        }
        if (wrapper.name !== toUnwrap.name || wrapper.priority !== toUnwrap.priority) {
          return false;
        }
        for (const key of wrapper.getAttributeKeys()) {
          if (key === "class" || key === "style") {
            continue;
          }
          if (!toUnwrap.hasAttribute(key) || toUnwrap.getAttribute(key) !== wrapper.getAttribute(key)) {
            return false;
          }
        }
        if (!toUnwrap.hasClass(...wrapper.getClassNames())) {
          return false;
        }
        for (const key of wrapper.getStyleNames()) {
          if (!toUnwrap.hasStyle(key) || toUnwrap.getStyle(key) !== wrapper.getStyle(key)) {
            return false;
          }
        }
        for (const key of wrapper.getAttributeKeys()) {
          if (key === "class" || key === "style") {
            continue;
          }
          this.removeAttribute(key, toUnwrap);
        }
        this.removeClass(Array.from(wrapper.getClassNames()), toUnwrap);
        this.removeStyle(Array.from(wrapper.getStyleNames()), toUnwrap);
        return true;
      }
      /**
      * Helper function used by other `DowncastWriter` methods. Breaks attribute elements at the boundaries of given range.
      *
      * @param range Range which `start` and `end` positions will be used to break attributes.
      * @param forceSplitText If set to `true`, will break text nodes even if they are directly in container element.
      * This behavior will result in incorrect view state, but is needed by other view writing methods which then fixes view state.
      * @returns New range with located at break positions.
      */
      _breakAttributesRange(range2, forceSplitText = false) {
        const rangeStart = range2.start;
        const rangeEnd = range2.end;
        validateRangeContainer(range2, this.document);
        if (range2.isCollapsed) {
          const position = this._breakAttributes(range2.start, forceSplitText);
          return new Range$1(position, position);
        }
        const breakEnd = this._breakAttributes(rangeEnd, forceSplitText);
        const count2 = breakEnd.parent.childCount;
        const breakStart = this._breakAttributes(rangeStart, forceSplitText);
        breakEnd.offset += breakEnd.parent.childCount - count2;
        return new Range$1(breakStart, breakEnd);
      }
      /**
      * Helper function used by other `DowncastWriter` methods. Breaks attribute elements at given position.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-empty-element` when break position
      * is placed inside {@link module:engine/view/emptyelement~EmptyElement EmptyElement}.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-ui-element` when break position
      * is placed inside {@link module:engine/view/uielement~UIElement UIElement}.
      *
      * @param position Position where to break attributes.
      * @param forceSplitText If set to `true`, will break text nodes even if they are directly in container element.
      * This behavior will result in incorrect view state, but is needed by other view writing methods which then fixes view state.
      * @returns New position after breaking the attributes.
      */
      _breakAttributes(position, forceSplitText = false) {
        const positionOffset = position.offset;
        const positionParent = position.parent;
        if (position.parent.is("emptyElement")) {
          throw new CKEditorError("view-writer-cannot-break-empty-element", this.document);
        }
        if (position.parent.is("uiElement")) {
          throw new CKEditorError("view-writer-cannot-break-ui-element", this.document);
        }
        if (position.parent.is("rawElement")) {
          throw new CKEditorError("view-writer-cannot-break-raw-element", this.document);
        }
        if (!forceSplitText && positionParent.is("$text") && isContainerOrFragment(positionParent.parent)) {
          return position.clone();
        }
        if (isContainerOrFragment(positionParent)) {
          return position.clone();
        }
        if (positionParent.is("$text")) {
          return this._breakAttributes(breakTextNode(position), forceSplitText);
        }
        const length = positionParent.childCount;
        if (positionOffset == length) {
          const newPosition = new Position$1(positionParent.parent, positionParent.index + 1);
          return this._breakAttributes(newPosition, forceSplitText);
        } else {
          if (positionOffset === 0) {
            const newPosition = new Position$1(positionParent.parent, positionParent.index);
            return this._breakAttributes(newPosition, forceSplitText);
          } else {
            const offsetAfter = positionParent.index + 1;
            const clonedNode = positionParent._clone();
            positionParent.parent._insertChild(offsetAfter, clonedNode);
            this._addToClonedElementsGroup(clonedNode);
            const count2 = positionParent.childCount - positionOffset;
            const nodesToMove = positionParent._removeChildren(positionOffset, count2);
            clonedNode._appendChild(nodesToMove);
            const newPosition = new Position$1(positionParent.parent, offsetAfter);
            return this._breakAttributes(newPosition, forceSplitText);
          }
        }
      }
      /**
      * Stores the information that an {@link module:engine/view/attributeelement~AttributeElement attribute element} was
      * added to the tree. Saves the reference to the group in the given element and updates the group, so other elements
      * from the group now keep a reference to the given attribute element.
      *
      * The clones group can be obtained using {@link module:engine/view/attributeelement~AttributeElement#getElementsWithSameId}.
      *
      * Does nothing if added element has no {@link module:engine/view/attributeelement~AttributeElement#id id}.
      *
      * @param element Attribute element to save.
      */
      _addToClonedElementsGroup(element) {
        if (!element.root.is("rootElement")) {
          return;
        }
        if (element.is("element")) {
          for (const child of element.getChildren()) {
            this._addToClonedElementsGroup(child);
          }
        }
        const id = element.id;
        if (!id) {
          return;
        }
        let group = this._cloneGroups.get(id);
        if (!group) {
          group = /* @__PURE__ */ new Set();
          this._cloneGroups.set(id, group);
        }
        group.add(element);
        element._clonesGroup = group;
      }
      /**
      * Removes all the information about the given {@link module:engine/view/attributeelement~AttributeElement attribute element}
      * from its clones group.
      *
      * Keep in mind, that the element will still keep a reference to the group (but the group will not keep a reference to it).
      * This allows to reference the whole group even if the element was already removed from the tree.
      *
      * Does nothing if the element has no {@link module:engine/view/attributeelement~AttributeElement#id id}.
      *
      * @param element Attribute element to remove.
      */
      _removeFromClonedElementsGroup(element) {
        if (element.is("element")) {
          for (const child of element.getChildren()) {
            this._removeFromClonedElementsGroup(child);
          }
        }
        const id = element.id;
        if (!id) {
          return;
        }
        const group = this._cloneGroups.get(id);
        if (!group) {
          return;
        }
        group.delete(element);
      }
    }
    function _hasNonUiChildren(parent2) {
      return Array.from(parent2.getChildren()).some((child) => !child.is("uiElement"));
    }
    function getParentContainer(position) {
      let parent2 = position.parent;
      while (!isContainerOrFragment(parent2)) {
        if (!parent2) {
          return void 0;
        }
        parent2 = parent2.parent;
      }
      return parent2;
    }
    function shouldABeOutsideB(a2, b2) {
      if (a2.priority < b2.priority) {
        return true;
      } else if (a2.priority > b2.priority) {
        return false;
      }
      return a2.getIdentity() < b2.getIdentity();
    }
    function movePositionToTextNode(position) {
      const nodeBefore = position.nodeBefore;
      if (nodeBefore && nodeBefore.is("$text")) {
        return new Position$1(nodeBefore, nodeBefore.data.length);
      }
      const nodeAfter = position.nodeAfter;
      if (nodeAfter && nodeAfter.is("$text")) {
        return new Position$1(nodeAfter, 0);
      }
      return position;
    }
    function breakTextNode(position) {
      if (position.offset == position.parent.data.length) {
        return new Position$1(position.parent.parent, position.parent.index + 1);
      }
      if (position.offset === 0) {
        return new Position$1(position.parent.parent, position.parent.index);
      }
      const textToMove = position.parent.data.slice(position.offset);
      position.parent._data = position.parent.data.slice(0, position.offset);
      position.parent.parent._insertChild(position.parent.index + 1, new Text$1(position.root.document, textToMove));
      return new Position$1(position.parent.parent, position.parent.index + 1);
    }
    function mergeTextNodes(t1, t2) {
      const nodeBeforeLength = t1.data.length;
      t1._data += t2.data;
      t2._remove();
      return new Position$1(t1, nodeBeforeLength);
    }
    const validNodesToInsert = [
      Text$1,
      AttributeElement,
      ContainerElement,
      EmptyElement,
      RawElement,
      UIElement
    ];
    function validateNodesToInsert(nodes, errorContext) {
      for (const node of nodes) {
        if (!validNodesToInsert.some((validNode) => node instanceof validNode)) {
          throw new CKEditorError("view-writer-insert-invalid-node-type", errorContext);
        }
        if (!node.is("$text")) {
          validateNodesToInsert(node.getChildren(), errorContext);
        }
      }
    }
    function isContainerOrFragment(node) {
      return node && (node.is("containerElement") || node.is("documentFragment"));
    }
    function validateRangeContainer(range2, errorContext) {
      const startContainer = getParentContainer(range2.start);
      const endContainer = getParentContainer(range2.end);
      if (!startContainer || !endContainer || startContainer !== endContainer) {
        throw new CKEditorError("view-writer-invalid-range-container", errorContext);
      }
    }
    function canBeJoined(a2, b2) {
      return a2.id === null && b2.id === null;
    }
    const NBSP_FILLER = (domDocument) => domDocument.createTextNode("");
    const MARKED_NBSP_FILLER = (domDocument) => {
      const span = domDocument.createElement("span");
      span.dataset.ckeFiller = "true";
      span.innerText = "";
      return span;
    };
    const BR_FILLER = (domDocument) => {
      const fillerBr = domDocument.createElement("br");
      fillerBr.dataset.ckeFiller = "true";
      return fillerBr;
    };
    const INLINE_FILLER_LENGTH = 7;
    const INLINE_FILLER = "".repeat(INLINE_FILLER_LENGTH);
    function startsWithFiller(domNode) {
      if (typeof domNode == "string") {
        return domNode.substr(0, INLINE_FILLER_LENGTH) === INLINE_FILLER;
      }
      return isText(domNode) && domNode.data.substr(0, INLINE_FILLER_LENGTH) === INLINE_FILLER;
    }
    function isInlineFiller(domText) {
      return domText.data.length == INLINE_FILLER_LENGTH && startsWithFiller(domText);
    }
    function getDataWithoutFiller(domText) {
      const data = typeof domText == "string" ? domText : domText.data;
      if (startsWithFiller(domText)) {
        return data.slice(INLINE_FILLER_LENGTH);
      }
      return data;
    }
    function injectQuirksHandling(view) {
      view.document.on("arrowKey", jumpOverInlineFiller, {
        priority: "low"
      });
    }
    function jumpOverInlineFiller(evt, data) {
      if (data.keyCode == keyCodes.arrowleft) {
        const domSelection = data.domTarget.ownerDocument.defaultView.getSelection();
        if (domSelection.rangeCount == 1 && domSelection.getRangeAt(0).collapsed) {
          const domParent = domSelection.getRangeAt(0).startContainer;
          const domOffset = domSelection.getRangeAt(0).startOffset;
          if (startsWithFiller(domParent) && domOffset <= INLINE_FILLER_LENGTH) {
            domSelection.collapse(domParent, 0);
          }
        }
      }
    }
    let Renderer$1 = class Renderer extends (/* @__PURE__ */ ObservableMixin()) {
      /**
      * Creates a renderer instance.
      *
      * @param domConverter Converter instance.
      * @param selection View selection.
      */
      constructor(domConverter, selection) {
        super();
        /**
        * Set of DOM Documents instances.
        */
        __publicField(this, "domDocuments", /* @__PURE__ */ new Set());
        /**
        * Converter instance.
        */
        __publicField(this, "domConverter");
        /**
        * Set of nodes which attributes changed and may need to be rendered.
        */
        __publicField(this, "markedAttributes", /* @__PURE__ */ new Set());
        /**
        * Set of elements which child lists changed and may need to be rendered.
        */
        __publicField(this, "markedChildren", /* @__PURE__ */ new Set());
        /**
        * Set of text nodes which text data changed and may need to be rendered.
        */
        __publicField(this, "markedTexts", /* @__PURE__ */ new Set());
        /**
        * View selection. Renderer updates DOM selection based on the view selection.
        */
        __publicField(this, "selection");
        /**
        * The text node in which the inline filler was rendered.
        */
        __publicField(this, "_inlineFiller", null);
        /**
        * DOM element containing fake selection.
        */
        __publicField(this, "_fakeSelectionContainer", null);
        this.domConverter = domConverter;
        this.selection = selection;
        this.set("isFocused", false);
        this.set("isSelecting", false);
        this.set("isComposing", false);
        if (env.isBlink && !env.isAndroid) {
          this.on("change:isSelecting", () => {
            if (!this.isSelecting) {
              this.render();
            }
          });
        }
      }
      /**
      * Marks a view node to be updated in the DOM by {@link #render `render()`}.
      *
      * Note that only view nodes whose parents have corresponding DOM elements need to be marked to be synchronized.
      *
      * @see #markedAttributes
      * @see #markedChildren
      * @see #markedTexts
      *
      * @param type Type of the change.
      * @param node ViewNode to be marked.
      */
      markToSync(type, node) {
        if (type === "text") {
          if (this.domConverter.mapViewToDom(node.parent)) {
            this.markedTexts.add(node);
          }
        } else {
          if (!this.domConverter.mapViewToDom(node)) {
            return;
          }
          if (type === "attributes") {
            this.markedAttributes.add(node);
          } else if (type === "children") {
            this.markedChildren.add(node);
          } else {
            throw new CKEditorError("view-renderer-unknown-type", this);
          }
        }
      }
      /**
      * Renders all buffered changes ({@link #markedAttributes}, {@link #markedChildren} and {@link #markedTexts}) and
      * the current view selection (if needed) to the DOM by applying a minimal set of changes to it.
      *
      * Renderer tries not to break the text composition (e.g. IME) and x-index of the selection,
      * so it does as little as it is needed to update the DOM.
      *
      * Renderer also handles {@link module:engine/view/filler fillers}. Especially, it checks if the inline filler is needed
      * at the selection position and adds or removes it. To prevent breaking text composition inline filler will not be
      * removed as long as the selection is in the text node which needed it at first.
      */
      render() {
        if (this.isComposing && !env.isAndroid) {
          return;
        }
        let inlineFillerPosition = null;
        const isInlineFillerRenderingPossible = env.isBlink && !env.isAndroid ? !this.isSelecting : true;
        for (const element of this.markedChildren) {
          this._updateChildrenMappings(element);
        }
        if (isInlineFillerRenderingPossible) {
          if (this._inlineFiller && !this._isSelectionInInlineFiller()) {
            this._removeInlineFiller();
          }
          if (this._inlineFiller) {
            inlineFillerPosition = this._getInlineFillerPosition();
          } else if (this._needsInlineFillerAtSelection()) {
            inlineFillerPosition = this.selection.getFirstPosition();
            this.markedChildren.add(inlineFillerPosition.parent);
          }
        } else if (this._inlineFiller && this._inlineFiller.parentNode) {
          inlineFillerPosition = this.domConverter.domPositionToView(this._inlineFiller);
          if (inlineFillerPosition && inlineFillerPosition.parent.is("$text")) {
            inlineFillerPosition = Position$1._createBefore(inlineFillerPosition.parent);
          }
        }
        for (const element of this.markedAttributes) {
          this._updateAttrs(element);
        }
        for (const element of this.markedChildren) {
          this._updateChildren(element, {
            inlineFillerPosition
          });
        }
        for (const node of this.markedTexts) {
          if (!this.markedChildren.has(node.parent) && this.domConverter.mapViewToDom(node.parent)) {
            this._updateText(node, {
              inlineFillerPosition
            });
          }
        }
        if (isInlineFillerRenderingPossible) {
          if (inlineFillerPosition) {
            const fillerDomPosition = this.domConverter.viewPositionToDom(inlineFillerPosition);
            const domDocument = fillerDomPosition.parent.ownerDocument;
            if (!startsWithFiller(fillerDomPosition.parent)) {
              this._inlineFiller = addInlineFiller(domDocument, fillerDomPosition.parent, fillerDomPosition.offset);
            } else {
              this._inlineFiller = fillerDomPosition.parent;
            }
          } else {
            this._inlineFiller = null;
          }
        }
        this._updateFocus();
        this._updateSelection();
        this.domConverter._clearTemporaryCustomProperties();
        this.markedTexts.clear();
        this.markedAttributes.clear();
        this.markedChildren.clear();
      }
      /**
      * Updates mappings of view element's children.
      *
      * Children that were replaced in the view structure by similar elements (same tag name) are treated as 'replaced'.
      * This means that their mappings can be updated so the new view elements are mapped to the existing DOM elements.
      * Thanks to that these elements do not need to be re-rendered completely.
      *
      * @param viewElement The view element whose children mappings will be updated.
      */
      _updateChildrenMappings(viewElement) {
        const domElement = this.domConverter.mapViewToDom(viewElement);
        if (!domElement) {
          return;
        }
        const actualDomChildren = Array.from(domElement.childNodes);
        const expectedDomChildren = Array.from(this.domConverter.viewChildrenToDom(viewElement, {
          withChildren: false
        }));
        const diff2 = this._diffNodeLists(actualDomChildren, expectedDomChildren);
        const actions = this._findUpdateActions(diff2, actualDomChildren, expectedDomChildren, areSimilarElements);
        if (actions.indexOf("update") !== -1) {
          const counter = {
            equal: 0,
            insert: 0,
            delete: 0
          };
          for (const action of actions) {
            if (action === "update") {
              const insertIndex = counter.equal + counter.insert;
              const deleteIndex = counter.equal + counter.delete;
              const viewChild = viewElement.getChild(insertIndex);
              if (viewChild && !viewChild.is("uiElement") && !viewChild.is("rawElement")) {
                this._updateElementMappings(viewChild, actualDomChildren[deleteIndex]);
              }
              remove$1(expectedDomChildren[insertIndex]);
              counter.equal++;
            } else {
              counter[action]++;
            }
          }
        }
      }
      /**
      * Updates mappings of a given view element.
      *
      * @param viewElement The view element whose mappings will be updated.
      * @param domElement The DOM element representing the given view element.
      */
      _updateElementMappings(viewElement, domElement) {
        this.domConverter.unbindDomElement(domElement);
        this.domConverter.bindElements(domElement, viewElement);
        this.markedChildren.add(viewElement);
        this.markedAttributes.add(viewElement);
      }
      /**
      * Gets the position of the inline filler based on the current selection.
      * Here, we assume that we know that the filler is needed and
      * {@link #_isSelectionInInlineFiller is at the selection position}, and, since it is needed,
      * it is somewhere at the selection position.
      *
      * Note: The filler position cannot be restored based on the filler's DOM text node, because
      * when this method is called (before rendering), the bindings will often be broken. View-to-DOM
      * bindings are only dependable after rendering.
      */
      _getInlineFillerPosition() {
        const firstPos = this.selection.getFirstPosition();
        if (firstPos.parent.is("$text")) {
          return Position$1._createBefore(firstPos.parent);
        } else {
          return firstPos;
        }
      }
      /**
      * Returns `true` if the selection has not left the inline filler's text node.
      * If it is `true`, it means that the filler had been added for a reason and the selection did not
      * leave the filler's text node. For example, the user can be in the middle of a composition so it should not be touched.
      *
      * @returns `true` if the inline filler and selection are in the same place.
      */
      _isSelectionInInlineFiller() {
        if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {
          return false;
        }
        const selectionPosition = this.selection.getFirstPosition();
        const position = this.domConverter.viewPositionToDom(selectionPosition);
        if (position && isText(position.parent) && startsWithFiller(position.parent)) {
          return true;
        }
        return false;
      }
      /**
      * Removes the inline filler.
      */
      _removeInlineFiller() {
        const domFillerNode = this._inlineFiller;
        if (!startsWithFiller(domFillerNode)) {
          throw new CKEditorError("view-renderer-filler-was-lost", this);
        }
        if (isInlineFiller(domFillerNode)) {
          domFillerNode.remove();
        } else {
          domFillerNode.data = domFillerNode.data.substr(INLINE_FILLER_LENGTH);
        }
        this._inlineFiller = null;
      }
      /**
      * Checks if the inline {@link module:engine/view/filler filler} should be added.
      *
      * @returns `true` if the inline filler should be added.
      */
      _needsInlineFillerAtSelection() {
        if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {
          return false;
        }
        const selectionPosition = this.selection.getFirstPosition();
        const selectionParent = selectionPosition.parent;
        const selectionOffset = selectionPosition.offset;
        if (!this.domConverter.mapViewToDom(selectionParent.root)) {
          return false;
        }
        if (!selectionParent.is("element")) {
          return false;
        }
        if (!isEditable(selectionParent)) {
          return false;
        }
        const nodeBefore = selectionPosition.nodeBefore;
        const nodeAfter = selectionPosition.nodeAfter;
        if (nodeBefore instanceof Text$1 || nodeAfter instanceof Text$1) {
          return false;
        }
        if (selectionOffset === selectionParent.getFillerOffset() && (!nodeBefore || !nodeBefore.is("element", "br"))) {
          return false;
        }
        if (env.isAndroid && (nodeBefore || nodeAfter)) {
          return false;
        }
        return true;
      }
      /**
      * Checks if text needs to be updated and possibly updates it.
      *
      * @param viewText View text to update.
      * @param options.inlineFillerPosition The position where the inline filler should be rendered.
      */
      _updateText(viewText, options) {
        const domText = this.domConverter.findCorrespondingDomText(viewText);
        const newDomText = this.domConverter.viewToDom(viewText);
        let expectedText = newDomText.data;
        const filler = options.inlineFillerPosition;
        if (filler && filler.parent == viewText.parent && filler.offset == viewText.index) {
          expectedText = INLINE_FILLER + expectedText;
        }
        this._updateTextNode(domText, expectedText);
      }
      /**
      * Checks if attribute list needs to be updated and possibly updates it.
      *
      * @param viewElement The view element to update.
      */
      _updateAttrs(viewElement) {
        const domElement = this.domConverter.mapViewToDom(viewElement);
        if (!domElement) {
          return;
        }
        for (const domAttr of domElement.attributes) {
          const key = domAttr.name;
          if (!viewElement.hasAttribute(key)) {
            this.domConverter.removeDomElementAttribute(domElement, key);
          }
        }
        for (const key of viewElement.getAttributeKeys()) {
          this.domConverter.setDomElementAttribute(domElement, key, viewElement.getAttribute(key), viewElement);
        }
      }
      /**
      * Checks if elements child list needs to be updated and possibly updates it.
      *
      * Note that on Android, to reduce the risk of composition breaks, it tries to update data of an existing
      * child text nodes instead of replacing them completely.
      *
      * @param viewElement View element to update.
      * @param options.inlineFillerPosition The position where the inline filler should be rendered.
      */
      _updateChildren(viewElement, options) {
        const domElement = this.domConverter.mapViewToDom(viewElement);
        if (!domElement) {
          return;
        }
        if (env.isAndroid) {
          let previousDomNode = null;
          for (const domNode of Array.from(domElement.childNodes)) {
            if (previousDomNode && isText(previousDomNode) && isText(domNode)) {
              domElement.normalize();
              break;
            }
            previousDomNode = domNode;
          }
        }
        const inlineFillerPosition = options.inlineFillerPosition;
        const actualDomChildren = domElement.childNodes;
        const expectedDomChildren = Array.from(this.domConverter.viewChildrenToDom(viewElement, {
          bind: true
        }));
        if (inlineFillerPosition && inlineFillerPosition.parent === viewElement) {
          addInlineFiller(domElement.ownerDocument, expectedDomChildren, inlineFillerPosition.offset);
        }
        const diff2 = this._diffNodeLists(actualDomChildren, expectedDomChildren);
        const actions = this._findUpdateActions(diff2, actualDomChildren, expectedDomChildren, areTextNodes);
        let i2 = 0;
        const nodesToUnbind = /* @__PURE__ */ new Set();
        for (const action of actions) {
          if (action === "delete") {
            nodesToUnbind.add(actualDomChildren[i2]);
            remove$1(actualDomChildren[i2]);
          } else if (action === "equal" || action === "update") {
            i2++;
          }
        }
        i2 = 0;
        for (const action of actions) {
          if (action === "insert") {
            insertAt(domElement, i2, expectedDomChildren[i2]);
            i2++;
          } else if (action === "update") {
            this._updateTextNode(actualDomChildren[i2], expectedDomChildren[i2].data);
            i2++;
          } else if (action === "equal") {
            this._markDescendantTextToSync(this.domConverter.domToView(expectedDomChildren[i2]));
            i2++;
          }
        }
        for (const node of nodesToUnbind) {
          if (!node.parentNode) {
            this.domConverter.unbindDomElement(node);
          }
        }
      }
      /**
      * Shorthand for diffing two arrays or node lists of DOM nodes.
      *
      * @param actualDomChildren Actual DOM children
      * @param expectedDomChildren Expected DOM children.
      * @returns The list of actions based on the {@link module:utils/diff~diff} function.
      */
      _diffNodeLists(actualDomChildren, expectedDomChildren) {
        actualDomChildren = filterOutFakeSelectionContainer(actualDomChildren, this._fakeSelectionContainer);
        return diff(actualDomChildren, expectedDomChildren, sameNodes$1.bind(null, this.domConverter));
      }
      /**
      * Finds DOM nodes that were replaced with the similar nodes (same tag name) in the view. All nodes are compared
      * within one `insert`/`delete` action group, for example:
      *
      * ```
      * Actual DOM:		<p><b>Foo</b>Bar<i>Baz</i><b>Bax</b></p>
      * Expected DOM:	<p>Bar<b>123</b><i>Baz</i><b>456</b></p>
      * Input actions:	[ insert, insert, delete, delete, equal, insert, delete ]
      * Output actions:	[ insert, replace, delete, equal, replace ]
      * ```
      *
      * @param actions Actions array which is a result of the {@link module:utils/diff~diff} function.
      * @param actualDom Actual DOM children
      * @param expectedDom Expected DOM children.
      * @param comparator A comparator function that should return `true` if the given node should be reused
      * (either by the update of a text node data or an element children list for similar elements).
      * @returns Actions array modified with the `update` actions.
      */
      _findUpdateActions(actions, actualDom, expectedDom, comparator) {
        if (actions.indexOf("insert") === -1 || actions.indexOf("delete") === -1) {
          return actions;
        }
        let newActions = [];
        let actualSlice = [];
        let expectedSlice = [];
        const counter = {
          equal: 0,
          insert: 0,
          delete: 0
        };
        for (const action of actions) {
          if (action === "insert") {
            expectedSlice.push(expectedDom[counter.equal + counter.insert]);
          } else if (action === "delete") {
            actualSlice.push(actualDom[counter.equal + counter.delete]);
          } else {
            newActions = newActions.concat(diff(actualSlice, expectedSlice, comparator).map((action2) => action2 === "equal" ? "update" : action2));
            newActions.push("equal");
            actualSlice = [];
            expectedSlice = [];
          }
          counter[action]++;
        }
        return newActions.concat(diff(actualSlice, expectedSlice, comparator).map((action) => action === "equal" ? "update" : action));
      }
      /**
      * Checks if text needs to be updated and possibly updates it by removing and inserting only parts
      * of the data from the existing text node to reduce impact on the IME composition.
      *
      * @param domText DOM text node to update.
      * @param expectedText The expected data of a text node.
      */
      _updateTextNode(domText, expectedText) {
        const actualText = domText.data;
        if (actualText == expectedText) {
          return;
        }
        if (env.isAndroid && this.isComposing && actualText.replace(/\u00A0/g, " ") == expectedText.replace(/\u00A0/g, " ")) {
          return;
        }
        this._updateTextNodeInternal(domText, expectedText);
      }
      /**
      * Part of the `_updateTextNode` method extracted for easier testing.
      */
      _updateTextNodeInternal(domText, expectedText) {
        const actions = fastDiff(domText.data, expectedText);
        for (const action of actions) {
          if (action.type === "insert") {
            domText.insertData(action.index, action.values.join(""));
          } else {
            domText.deleteData(action.index, action.howMany);
          }
        }
      }
      /**
      * Marks text nodes to be synchronized.
      *
      * If a text node is passed, it will be marked. If an element is passed, all descendant text nodes inside it will be marked.
      *
      * @param viewNode View node to sync.
      */
      _markDescendantTextToSync(viewNode) {
        if (!viewNode) {
          return;
        }
        if (viewNode.is("$text")) {
          this.markedTexts.add(viewNode);
        } else if (viewNode.is("element")) {
          for (const child of viewNode.getChildren()) {
            this._markDescendantTextToSync(child);
          }
        }
      }
      /**
      * Checks if the selection needs to be updated and possibly updates it.
      */
      _updateSelection() {
        if (env.isBlink && !env.isAndroid && this.isSelecting && !this.markedChildren.size) {
          return;
        }
        if (this.selection.rangeCount === 0) {
          this._removeDomSelection();
          this._removeFakeSelection();
          return;
        }
        const domRoot = this.domConverter.mapViewToDom(this.selection.editableElement);
        if (!this.isFocused || !domRoot) {
          return;
        }
        if (this.selection.isFake) {
          this._updateFakeSelection(domRoot);
        } else if (this._fakeSelectionContainer && this._fakeSelectionContainer.isConnected) {
          this._removeFakeSelection();
          this._updateDomSelection(domRoot);
        } else if (!(this.isComposing && env.isAndroid)) {
          this._updateDomSelection(domRoot);
        }
      }
      /**
      * Updates the fake selection.
      *
      * @param domRoot A valid DOM root where the fake selection container should be added.
      */
      _updateFakeSelection(domRoot) {
        const domDocument = domRoot.ownerDocument;
        if (!this._fakeSelectionContainer) {
          this._fakeSelectionContainer = createFakeSelectionContainer(domDocument);
        }
        const container2 = this._fakeSelectionContainer;
        this.domConverter.bindFakeSelection(container2, this.selection);
        if (!this._fakeSelectionNeedsUpdate(domRoot)) {
          return;
        }
        if (!container2.parentElement || container2.parentElement != domRoot) {
          domRoot.appendChild(container2);
        }
        container2.textContent = this.selection.fakeSelectionLabel || "";
        const domSelection = domDocument.getSelection();
        const domRange = domDocument.createRange();
        domSelection.removeAllRanges();
        domRange.selectNodeContents(container2);
        domSelection.addRange(domRange);
      }
      /**
      * Updates the DOM selection.
      *
      * @param domRoot A valid DOM root where the DOM selection should be rendered.
      */
      _updateDomSelection(domRoot) {
        const domSelection = domRoot.ownerDocument.defaultView.getSelection();
        if (!this._domSelectionNeedsUpdate(domSelection)) {
          return;
        }
        const anchor = this.domConverter.viewPositionToDom(this.selection.anchor);
        const focus = this.domConverter.viewPositionToDom(this.selection.focus);
        domSelection.setBaseAndExtent(anchor.parent, anchor.offset, focus.parent, focus.offset);
        if (env.isGecko) {
          fixGeckoSelectionAfterBr(focus, domSelection);
        }
      }
      /**
      * Checks whether a given DOM selection needs to be updated.
      *
      * @param domSelection The DOM selection to check.
      */
      _domSelectionNeedsUpdate(domSelection) {
        if (!this.domConverter.isDomSelectionCorrect(domSelection)) {
          return true;
        }
        const oldViewSelection = domSelection && this.domConverter.domSelectionToView(domSelection);
        if (oldViewSelection && this.selection.isEqual(oldViewSelection)) {
          return false;
        }
        if (!this.selection.isCollapsed && this.selection.isSimilar(oldViewSelection)) {
          return false;
        }
        return true;
      }
      /**
      * Checks whether the fake selection needs to be updated.
      *
      * @param domRoot A valid DOM root where a new fake selection container should be added.
      */
      _fakeSelectionNeedsUpdate(domRoot) {
        const container2 = this._fakeSelectionContainer;
        const domSelection = domRoot.ownerDocument.getSelection();
        if (!container2 || container2.parentElement !== domRoot) {
          return true;
        }
        if (domSelection.anchorNode !== container2 && !container2.contains(domSelection.anchorNode)) {
          return true;
        }
        return container2.textContent !== this.selection.fakeSelectionLabel;
      }
      /**
      * Removes the DOM selection.
      */
      _removeDomSelection() {
        for (const doc of this.domDocuments) {
          const domSelection = doc.getSelection();
          if (domSelection.rangeCount) {
            const activeDomElement = doc.activeElement;
            const viewElement = this.domConverter.mapDomToView(activeDomElement);
            if (activeDomElement && viewElement) {
              domSelection.removeAllRanges();
            }
          }
        }
      }
      /**
      * Removes the fake selection.
      */
      _removeFakeSelection() {
        const container2 = this._fakeSelectionContainer;
        if (container2) {
          container2.remove();
        }
      }
      /**
      * Checks if focus needs to be updated and possibly updates it.
      */
      _updateFocus() {
        if (this.isFocused) {
          const editable = this.selection.editableElement;
          if (editable) {
            this.domConverter.focus(editable);
          }
        }
      }
    };
    function isEditable(element) {
      if (element.getAttribute("contenteditable") == "false") {
        return false;
      }
      const parent2 = element.findAncestor((element2) => element2.hasAttribute("contenteditable"));
      return !parent2 || parent2.getAttribute("contenteditable") == "true";
    }
    function addInlineFiller(domDocument, domParentOrArray, offset2) {
      const childNodes = domParentOrArray instanceof Array ? domParentOrArray : domParentOrArray.childNodes;
      const nodeAfterFiller = childNodes[offset2];
      if (isText(nodeAfterFiller)) {
        nodeAfterFiller.data = INLINE_FILLER + nodeAfterFiller.data;
        return nodeAfterFiller;
      } else {
        const fillerNode = domDocument.createTextNode(INLINE_FILLER);
        if (Array.isArray(domParentOrArray)) {
          childNodes.splice(offset2, 0, fillerNode);
        } else {
          insertAt(domParentOrArray, offset2, fillerNode);
        }
        return fillerNode;
      }
    }
    function areSimilarElements(node1, node2) {
      return isNode(node1) && isNode(node2) && !isText(node1) && !isText(node2) && !isComment(node1) && !isComment(node2) && node1.tagName.toLowerCase() === node2.tagName.toLowerCase();
    }
    function areTextNodes(node1, node2) {
      return isNode(node1) && isNode(node2) && isText(node1) && isText(node2);
    }
    function sameNodes$1(domConverter, actualDomChild, expectedDomChild) {
      if (actualDomChild === expectedDomChild) {
        return true;
      } else if (isText(actualDomChild) && isText(expectedDomChild)) {
        return actualDomChild.data === expectedDomChild.data;
      } else if (domConverter.isBlockFiller(actualDomChild) && domConverter.isBlockFiller(expectedDomChild)) {
        return true;
      }
      return false;
    }
    function fixGeckoSelectionAfterBr(focus, domSelection) {
      let parent2 = focus.parent;
      let offset2 = focus.offset;
      if (isText(parent2) && isInlineFiller(parent2)) {
        offset2 = indexOf(parent2) + 1;
        parent2 = parent2.parentNode;
      }
      if (parent2.nodeType != Node.ELEMENT_NODE || offset2 != parent2.childNodes.length - 1) {
        return;
      }
      const childAtOffset = parent2.childNodes[offset2];
      if (childAtOffset && childAtOffset.tagName == "BR") {
        domSelection.addRange(domSelection.getRangeAt(0));
      }
    }
    function filterOutFakeSelectionContainer(domChildList, fakeSelectionContainer) {
      const childList = Array.from(domChildList);
      if (childList.length == 0 || !fakeSelectionContainer) {
        return childList;
      }
      const last2 = childList[childList.length - 1];
      if (last2 == fakeSelectionContainer) {
        childList.pop();
      }
      return childList;
    }
    function createFakeSelectionContainer(domDocument) {
      const container2 = domDocument.createElement("div");
      container2.className = "ck-fake-selection-container";
      Object.assign(container2.style, {
        position: "fixed",
        top: 0,
        left: "-9999px",
        // See https://github.com/ckeditor/ckeditor5/issues/752.
        width: "42px"
      });
      container2.textContent = "";
      return container2;
    }
    const BR_FILLER_REF = BR_FILLER(global$1.document);
    const NBSP_FILLER_REF = NBSP_FILLER(global$1.document);
    const MARKED_NBSP_FILLER_REF = MARKED_NBSP_FILLER(global$1.document);
    const UNSAFE_ATTRIBUTE_NAME_PREFIX = "data-ck-unsafe-attribute-";
    const UNSAFE_ELEMENT_REPLACEMENT_ATTRIBUTE = "data-ck-unsafe-element";
    class DomConverter {
      /**
      * Creates a DOM converter.
      *
      * @param document The view document instance.
      * @param options An object with configuration options.
      * @param options.blockFillerMode The type of the block filler to use.
      * Default value depends on the options.renderingMode:
      *  'nbsp' when options.renderingMode == 'data',
      *  'br' when options.renderingMode == 'editing'.
      * @param options.renderingMode Whether to leave the View-to-DOM conversion result unchanged
      * or improve editing experience by filtering out interactive data.
      */
      constructor(document2, { blockFillerMode, renderingMode = "editing" } = {}) {
        __publicField(this, "document");
        /**
        * Whether to leave the View-to-DOM conversion result unchanged or improve editing experience by filtering out interactive data.
        */
        __publicField(this, "renderingMode");
        /**
        * The mode of a block filler used by the DOM converter.
        */
        __publicField(this, "blockFillerMode");
        /**
        * Elements which are considered pre-formatted elements.
        */
        __publicField(this, "preElements");
        /**
        * Elements which are considered block elements (and hence should be filled with a
        * {@link #isBlockFiller block filler}).
        *
        * Whether an element is considered a block element also affects handling of trailing whitespaces.
        *
        * You can extend this array if you introduce support for block elements which are not yet recognized here.
        */
        __publicField(this, "blockElements");
        /**
        * A list of elements that exist inline (in text) but their inner structure cannot be edited because
        * of the way they are rendered by the browser. They are mostly HTML form elements but there are other
        * elements such as `<img>` or `<iframe>` that also have non-editable children or no children whatsoever.
        *
        * Whether an element is considered an inline object has an impact on white space rendering (trimming)
        * around (and inside of it). In short, white spaces in text nodes next to inline objects are not trimmed.
        *
        * You can extend this array if you introduce support for inline object elements which are not yet recognized here.
        */
        __publicField(this, "inlineObjectElements");
        /**
        * A list of elements which may affect the editing experience. To avoid this, those elements are replaced with
        * `<span data-ck-unsafe-element="[element name]"></span>` while rendering in the editing mode.
        */
        __publicField(this, "unsafeElements");
        /**
        * The DOM Document used to create DOM nodes.
        */
        __publicField(this, "_domDocument");
        /**
        * The DOM-to-view mapping.
        */
        __publicField(this, "_domToViewMapping", /* @__PURE__ */ new WeakMap());
        /**
        * The view-to-DOM mapping.
        */
        __publicField(this, "_viewToDomMapping", /* @__PURE__ */ new WeakMap());
        /**
        * Holds the mapping between fake selection containers and corresponding view selections.
        */
        __publicField(this, "_fakeSelectionMapping", /* @__PURE__ */ new WeakMap());
        /**
        * Matcher for view elements whose content should be treated as raw data
        * and not processed during the conversion from DOM nodes to view elements.
        */
        __publicField(this, "_rawContentElementMatcher", new Matcher());
        /**
        * Matcher for inline object view elements. This is an extension of a simple {@link #inlineObjectElements} array of element names.
        */
        __publicField(this, "_inlineObjectElementMatcher", new Matcher());
        /**
        * Set of elements with temporary custom properties that require clearing after render.
        */
        __publicField(this, "_elementsWithTemporaryCustomProperties", /* @__PURE__ */ new Set());
        this.document = document2;
        this.renderingMode = renderingMode;
        this.blockFillerMode = blockFillerMode || (renderingMode === "editing" ? "br" : "nbsp");
        this.preElements = [
          "pre",
          "textarea"
        ];
        this.blockElements = [
          "address",
          "article",
          "aside",
          "blockquote",
          "caption",
          "center",
          "dd",
          "details",
          "dir",
          "div",
          "dl",
          "dt",
          "fieldset",
          "figcaption",
          "figure",
          "footer",
          "form",
          "h1",
          "h2",
          "h3",
          "h4",
          "h5",
          "h6",
          "header",
          "hgroup",
          "legend",
          "li",
          "main",
          "menu",
          "nav",
          "ol",
          "p",
          "pre",
          "section",
          "summary",
          "table",
          "tbody",
          "td",
          "tfoot",
          "th",
          "thead",
          "tr",
          "ul"
        ];
        this.inlineObjectElements = [
          "object",
          "iframe",
          "input",
          "button",
          "textarea",
          "select",
          "option",
          "video",
          "embed",
          "audio",
          "img",
          "canvas"
        ];
        this.unsafeElements = [
          "script",
          "style"
        ];
        this._domDocument = this.renderingMode === "editing" ? global$1.document : global$1.document.implementation.createHTMLDocument("");
      }
      /**
      * Binds a given DOM element that represents fake selection to a **position** of a
      * {@link module:engine/view/documentselection~DocumentSelection document selection}.
      * Document selection copy is stored and can be retrieved by the
      * {@link module:engine/view/domconverter~DomConverter#fakeSelectionToView} method.
      */
      bindFakeSelection(domElement, viewDocumentSelection) {
        this._fakeSelectionMapping.set(domElement, new Selection$1(viewDocumentSelection));
      }
      /**
      * Returns a {@link module:engine/view/selection~Selection view selection} instance corresponding to a given
      * DOM element that represents fake selection. Returns `undefined` if binding to the given DOM element does not exist.
      */
      fakeSelectionToView(domElement) {
        return this._fakeSelectionMapping.get(domElement);
      }
      /**
      * Binds DOM and view elements, so it will be possible to get corresponding elements using
      * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and
      * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.
      *
      * @param domElement The DOM element to bind.
      * @param viewElement The view element to bind.
      */
      bindElements(domElement, viewElement) {
        this._domToViewMapping.set(domElement, viewElement);
        this._viewToDomMapping.set(viewElement, domElement);
      }
      /**
      * Unbinds a given DOM element from the view element it was bound to. Unbinding is deep, meaning that all children of
      * the DOM element will be unbound too.
      *
      * @param domElement The DOM element to unbind.
      */
      unbindDomElement(domElement) {
        const viewElement = this._domToViewMapping.get(domElement);
        if (viewElement) {
          this._domToViewMapping.delete(domElement);
          this._viewToDomMapping.delete(viewElement);
          for (const child of domElement.children) {
            this.unbindDomElement(child);
          }
        }
      }
      /**
      * Binds DOM and view document fragments, so it will be possible to get corresponding document fragments using
      * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and
      * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.
      *
      * @param domFragment The DOM document fragment to bind.
      * @param viewFragment The view document fragment to bind.
      */
      bindDocumentFragments(domFragment, viewFragment) {
        this._domToViewMapping.set(domFragment, viewFragment);
        this._viewToDomMapping.set(viewFragment, domFragment);
      }
      /**
      * Decides whether a given pair of attribute key and value should be passed further down the pipeline.
      *
      * @param elementName Element name in lower case.
      */
      shouldRenderAttribute(attributeKey, attributeValue, elementName) {
        if (this.renderingMode === "data") {
          return true;
        }
        attributeKey = attributeKey.toLowerCase();
        if (attributeKey.startsWith("on")) {
          return false;
        }
        if (attributeKey === "srcdoc" && attributeValue.match(/\bon\S+\s*=|javascript:|<\s*\/*script/i)) {
          return false;
        }
        if (elementName === "img" && (attributeKey === "src" || attributeKey === "srcset")) {
          return true;
        }
        if (elementName === "source" && attributeKey === "srcset") {
          return true;
        }
        if (attributeValue.match(/^\s*(javascript:|data:(image\/svg|text\/x?html))/i)) {
          return false;
        }
        return true;
      }
      /**
      * Set `domElement`'s content using provided `html` argument. Apply necessary filtering for the editing pipeline.
      *
      * @param domElement DOM element that should have `html` set as its content.
      * @param html Textual representation of the HTML that will be set on `domElement`.
      */
      setContentOf(domElement, html2) {
        if (this.renderingMode === "data") {
          domElement.innerHTML = html2;
          return;
        }
        const document2 = new DOMParser().parseFromString(html2, "text/html");
        const fragment = document2.createDocumentFragment();
        const bodyChildNodes = document2.body.childNodes;
        while (bodyChildNodes.length > 0) {
          fragment.appendChild(bodyChildNodes[0]);
        }
        const treeWalker = document2.createTreeWalker(fragment, NodeFilter.SHOW_ELEMENT);
        const nodes = [];
        let currentNode;
        while (currentNode = treeWalker.nextNode()) {
          nodes.push(currentNode);
        }
        for (const currentNode2 of nodes) {
          for (const attributeName of currentNode2.getAttributeNames()) {
            this.setDomElementAttribute(currentNode2, attributeName, currentNode2.getAttribute(attributeName));
          }
          const elementName = currentNode2.tagName.toLowerCase();
          if (this._shouldRenameElement(elementName)) {
            _logUnsafeElement(elementName);
            currentNode2.replaceWith(this._createReplacementDomElement(elementName, currentNode2));
          }
        }
        while (domElement.firstChild) {
          domElement.firstChild.remove();
        }
        domElement.append(fragment);
      }
      /**
      * Converts the view to the DOM. For all text nodes, not bound elements and document fragments new items will
      * be created. For bound elements and document fragments the method will return corresponding items.
      *
      * @param viewNode View node or document fragment to transform.
      * @param options Conversion options.
      * @param options.bind Determines whether new elements will be bound.
      * @param options.withChildren If `false`, node's and document fragment's children will not be converted.
      * @returns Converted node or DocumentFragment.
      */
      viewToDom(viewNode, options = {}) {
        if (viewNode.is("$text")) {
          const textData = this._processDataFromViewText(viewNode);
          return this._domDocument.createTextNode(textData);
        } else {
          const viewElementOrFragment = viewNode;
          if (this.mapViewToDom(viewElementOrFragment)) {
            if (viewElementOrFragment.getCustomProperty("editingPipeline:doNotReuseOnce")) {
              this._elementsWithTemporaryCustomProperties.add(viewElementOrFragment);
            } else {
              return this.mapViewToDom(viewElementOrFragment);
            }
          }
          let domElement;
          if (viewElementOrFragment.is("documentFragment")) {
            domElement = this._domDocument.createDocumentFragment();
            if (options.bind) {
              this.bindDocumentFragments(domElement, viewElementOrFragment);
            }
          } else if (viewElementOrFragment.is("uiElement")) {
            if (viewElementOrFragment.name === "$comment") {
              domElement = this._domDocument.createComment(viewElementOrFragment.getCustomProperty("$rawContent"));
            } else {
              domElement = viewElementOrFragment.render(this._domDocument, this);
            }
            if (options.bind) {
              this.bindElements(domElement, viewElementOrFragment);
            }
            return domElement;
          } else {
            if (this._shouldRenameElement(viewElementOrFragment.name)) {
              _logUnsafeElement(viewElementOrFragment.name);
              domElement = this._createReplacementDomElement(viewElementOrFragment.name);
            } else if (viewElementOrFragment.hasAttribute("xmlns")) {
              domElement = this._domDocument.createElementNS(viewElementOrFragment.getAttribute("xmlns"), viewElementOrFragment.name);
            } else {
              domElement = this._domDocument.createElement(viewElementOrFragment.name);
            }
            if (viewElementOrFragment.is("rawElement")) {
              viewElementOrFragment.render(domElement, this);
            }
            if (options.bind) {
              this.bindElements(domElement, viewElementOrFragment);
            }
            for (const key of viewElementOrFragment.getAttributeKeys()) {
              this.setDomElementAttribute(domElement, key, viewElementOrFragment.getAttribute(key), viewElementOrFragment);
            }
          }
          if (options.withChildren !== false) {
            for (const child of this.viewChildrenToDom(viewElementOrFragment, options)) {
              if (domElement instanceof HTMLTemplateElement) {
                domElement.content.appendChild(child);
              } else {
                domElement.appendChild(child);
              }
            }
          }
          return domElement;
        }
      }
      /**
      * Sets the attribute on a DOM element.
      *
      * **Note**: To remove the attribute, use {@link #removeDomElementAttribute}.
      *
      * @param domElement The DOM element the attribute should be set on.
      * @param key The name of the attribute.
      * @param value The value of the attribute.
      * @param relatedViewElement The view element related to the `domElement` (if there is any).
      * It helps decide whether the attribute set is unsafe. For instance, view elements created via the
      * {@link module:engine/view/downcastwriter~DowncastWriter} methods can allow certain attributes that would normally be filtered out.
      */
      setDomElementAttribute(domElement, key, value, relatedViewElement) {
        const shouldRenderAttribute = this.shouldRenderAttribute(key, value, domElement.tagName.toLowerCase()) || relatedViewElement && relatedViewElement.shouldRenderUnsafeAttribute(key);
        if (!shouldRenderAttribute) {
          logWarning("domconverter-unsafe-attribute-detected", {
            domElement,
            key,
            value
          });
        }
        if (!isValidAttributeName(key)) {
          logWarning("domconverter-invalid-attribute-detected", {
            domElement,
            key,
            value
          });
          return;
        }
        if (domElement.hasAttribute(key) && !shouldRenderAttribute) {
          domElement.removeAttribute(key);
        } else if (domElement.hasAttribute(UNSAFE_ATTRIBUTE_NAME_PREFIX + key) && shouldRenderAttribute) {
          domElement.removeAttribute(UNSAFE_ATTRIBUTE_NAME_PREFIX + key);
        }
        domElement.setAttribute(shouldRenderAttribute ? key : UNSAFE_ATTRIBUTE_NAME_PREFIX + key, value);
      }
      /**
      * Removes an attribute from a DOM element.
      *
      * **Note**: To set the attribute, use {@link #setDomElementAttribute}.
      *
      * @param domElement The DOM element the attribute should be removed from.
      * @param key The name of the attribute.
      */
      removeDomElementAttribute(domElement, key) {
        if (key == UNSAFE_ELEMENT_REPLACEMENT_ATTRIBUTE) {
          return;
        }
        domElement.removeAttribute(key);
        domElement.removeAttribute(UNSAFE_ATTRIBUTE_NAME_PREFIX + key);
      }
      /**
      * Converts children of the view element to DOM using the
      * {@link module:engine/view/domconverter~DomConverter#viewToDom} method.
      * Additionally, this method adds block {@link module:engine/view/filler filler} to the list of children, if needed.
      *
      * @param viewElement Parent view element.
      * @param options See {@link module:engine/view/domconverter~DomConverter#viewToDom} options parameter.
      * @returns DOM nodes.
      */
      *viewChildrenToDom(viewElement, options = {}) {
        const fillerPositionOffset = viewElement.getFillerOffset && viewElement.getFillerOffset();
        let offset2 = 0;
        for (const childView of viewElement.getChildren()) {
          if (fillerPositionOffset === offset2) {
            yield this._getBlockFiller();
          }
          const transparentRendering = childView.is("element") && !!childView.getCustomProperty("dataPipeline:transparentRendering") && !first(childView.getAttributes());
          if (transparentRendering && this.renderingMode == "data") {
            if (childView.is("rawElement")) {
              const tempElement = this._domDocument.createElement(childView.name);
              childView.render(tempElement, this);
              yield* [
                ...tempElement.childNodes
              ];
            } else {
              yield* this.viewChildrenToDom(childView, options);
            }
          } else {
            if (transparentRendering) {
              logWarning("domconverter-transparent-rendering-unsupported-in-editing-pipeline", {
                viewElement: childView
              });
            }
            yield this.viewToDom(childView, options);
          }
          offset2++;
        }
        if (fillerPositionOffset === offset2) {
          yield this._getBlockFiller();
        }
      }
      /**
      * Converts view {@link module:engine/view/range~Range} to DOM range.
      * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.
      *
      * @param viewRange View range.
      * @returns DOM range.
      */
      viewRangeToDom(viewRange) {
        const domStart = this.viewPositionToDom(viewRange.start);
        const domEnd = this.viewPositionToDom(viewRange.end);
        const domRange = this._domDocument.createRange();
        domRange.setStart(domStart.parent, domStart.offset);
        domRange.setEnd(domEnd.parent, domEnd.offset);
        return domRange;
      }
      /**
      * Converts view {@link module:engine/view/position~Position} to DOM parent and offset.
      *
      * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.
      * If the converted position is directly before inline filler it is moved inside the filler.
      *
      * @param viewPosition View position.
      * @returns DOM position or `null` if view position could not be converted to DOM.
      * DOM position has two properties:
      * * `parent` - DOM position parent.
      * * `offset` - DOM position offset.
      */
      viewPositionToDom(viewPosition) {
        const viewParent = viewPosition.parent;
        if (viewParent.is("$text")) {
          const domParent = this.findCorrespondingDomText(viewParent);
          if (!domParent) {
            return null;
          }
          let offset2 = viewPosition.offset;
          if (startsWithFiller(domParent)) {
            offset2 += INLINE_FILLER_LENGTH;
          }
          return {
            parent: domParent,
            offset: offset2
          };
        } else {
          let domParent, domBefore, domAfter;
          if (viewPosition.offset === 0) {
            domParent = this.mapViewToDom(viewParent);
            if (!domParent) {
              return null;
            }
            domAfter = domParent.childNodes[0];
          } else {
            const nodeBefore = viewPosition.nodeBefore;
            domBefore = nodeBefore.is("$text") ? this.findCorrespondingDomText(nodeBefore) : this.mapViewToDom(nodeBefore);
            if (!domBefore) {
              return null;
            }
            domParent = domBefore.parentNode;
            domAfter = domBefore.nextSibling;
          }
          if (isText(domAfter) && startsWithFiller(domAfter)) {
            return {
              parent: domAfter,
              offset: INLINE_FILLER_LENGTH
            };
          }
          const offset2 = domBefore ? indexOf(domBefore) + 1 : 0;
          return {
            parent: domParent,
            offset: offset2
          };
        }
      }
      /**
      * Converts DOM to view. For all text nodes, not bound elements and document fragments new items will
      * be created. For bound elements and document fragments function will return corresponding items. For
      * {@link module:engine/view/filler fillers} `null` will be returned.
      * For all DOM elements rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.
      *
      * @param domNode DOM node or document fragment to transform.
      * @param options Conversion options.
      * @param options.bind Determines whether new elements will be bound. False by default.
      * @param options.withChildren If `true`, node's and document fragment's children will be converted too. True by default.
      * @param options.keepOriginalCase If `false`, node's tag name will be converted to lower case. False by default.
      * @param options.skipComments If `false`, comment nodes will be converted to `$comment`
      * {@link module:engine/view/uielement~UIElement view UI elements}. False by default.
      * @returns Converted node or document fragment or `null` if DOM node is a {@link module:engine/view/filler filler}
      * or the given node is an empty text node.
      */
      domToView(domNode, options = {}) {
        const inlineNodes = [];
        const generator = this._domToView(domNode, options, inlineNodes);
        const node = generator.next().value;
        if (!node) {
          return null;
        }
        generator.next();
        this._processDomInlineNodes(null, inlineNodes, options);
        if (node.is("$text") && node.data.length == 0) {
          return null;
        }
        return node;
      }
      /**
      * Converts children of the DOM element to view nodes using
      * the {@link module:engine/view/domconverter~DomConverter#domToView} method.
      * Additionally this method omits block {@link module:engine/view/filler filler}, if it exists in the DOM parent.
      *
      * @param domElement Parent DOM element.
      * @param options See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.
      * @param inlineNodes An array that will be populated with inline nodes. It's used internally for whitespace processing.
      * @returns View nodes.
      */
      *domChildrenToView(domElement, options = {}, inlineNodes = []) {
        let childNodes = [];
        if (domElement instanceof HTMLTemplateElement) {
          childNodes = [
            ...domElement.content.childNodes
          ];
        } else {
          childNodes = [
            ...domElement.childNodes
          ];
        }
        for (let i2 = 0; i2 < childNodes.length; i2++) {
          const domChild = childNodes[i2];
          const generator = this._domToView(domChild, options, inlineNodes);
          const viewChild = generator.next().value;
          if (viewChild !== null) {
            if (this._isBlockViewElement(viewChild)) {
              this._processDomInlineNodes(domElement, inlineNodes, options);
            }
            yield viewChild;
            generator.next();
          }
        }
        this._processDomInlineNodes(domElement, inlineNodes, options);
      }
      /**
      * Converts DOM selection to view {@link module:engine/view/selection~Selection}.
      * Ranges which cannot be converted will be omitted.
      *
      * @param domSelection DOM selection.
      * @returns View selection.
      */
      domSelectionToView(domSelection) {
        if (isGeckoRestrictedDomSelection(domSelection)) {
          return new Selection$1([]);
        }
        if (domSelection.rangeCount === 1) {
          let container2 = domSelection.getRangeAt(0).startContainer;
          if (isText(container2)) {
            container2 = container2.parentNode;
          }
          const viewSelection = this.fakeSelectionToView(container2);
          if (viewSelection) {
            return viewSelection;
          }
        }
        const isBackward = this.isDomSelectionBackward(domSelection);
        const viewRanges = [];
        for (let i2 = 0; i2 < domSelection.rangeCount; i2++) {
          const domRange = domSelection.getRangeAt(i2);
          const viewRange = this.domRangeToView(domRange);
          if (viewRange) {
            viewRanges.push(viewRange);
          }
        }
        return new Selection$1(viewRanges, {
          backward: isBackward
        });
      }
      /**
      * Converts DOM Range to view {@link module:engine/view/range~Range}.
      * If the start or end position can not be converted `null` is returned.
      *
      * @param domRange DOM range.
      * @returns View range.
      */
      domRangeToView(domRange) {
        const viewStart = this.domPositionToView(domRange.startContainer, domRange.startOffset);
        const viewEnd = this.domPositionToView(domRange.endContainer, domRange.endOffset);
        if (viewStart && viewEnd) {
          return new Range$1(viewStart, viewEnd);
        }
        return null;
      }
      /**
      * Converts DOM parent and offset to view {@link module:engine/view/position~Position}.
      *
      * If the position is inside a {@link module:engine/view/filler filler} which has no corresponding view node,
      * position of the filler will be converted and returned.
      *
      * If the position is inside DOM element rendered by {@link module:engine/view/uielement~UIElement}
      * that position will be converted to view position before that UIElement.
      *
      * If structures are too different and it is not possible to find corresponding position then `null` will be returned.
      *
      * @param domParent DOM position parent.
      * @param domOffset DOM position offset. You can skip it when converting the inline filler node.
      * @returns View position.
      */
      domPositionToView(domParent, domOffset = 0) {
        if (this.isBlockFiller(domParent)) {
          return this.domPositionToView(domParent.parentNode, indexOf(domParent));
        }
        const viewElement = this.mapDomToView(domParent);
        if (viewElement && (viewElement.is("uiElement") || viewElement.is("rawElement"))) {
          return Position$1._createBefore(viewElement);
        }
        if (isText(domParent)) {
          if (isInlineFiller(domParent)) {
            return this.domPositionToView(domParent.parentNode, indexOf(domParent));
          }
          const viewParent = this.findCorrespondingViewText(domParent);
          let offset2 = domOffset;
          if (!viewParent) {
            return null;
          }
          if (startsWithFiller(domParent)) {
            offset2 -= INLINE_FILLER_LENGTH;
            offset2 = offset2 < 0 ? 0 : offset2;
          }
          return new Position$1(viewParent, offset2);
        } else {
          if (domOffset === 0) {
            const viewParent = this.mapDomToView(domParent);
            if (viewParent) {
              return new Position$1(viewParent, 0);
            }
          } else {
            const domBefore = domParent.childNodes[domOffset - 1];
            if (isText(domBefore) && isInlineFiller(domBefore) || domBefore && this.isBlockFiller(domBefore)) {
              return this.domPositionToView(domBefore.parentNode, indexOf(domBefore));
            }
            const viewBefore = isText(domBefore) ? this.findCorrespondingViewText(domBefore) : this.mapDomToView(domBefore);
            if (viewBefore && viewBefore.parent) {
              return new Position$1(viewBefore.parent, viewBefore.index + 1);
            }
          }
          return null;
        }
      }
      /**
      * Returns corresponding view {@link module:engine/view/element~Element Element} or
      * {@link module:engine/view/documentfragment~DocumentFragment} for provided DOM element or
      * document fragment. If there is no view item {@link module:engine/view/domconverter~DomConverter#bindElements bound}
      * to the given DOM - `undefined` is returned.
      *
      * For all DOM elements rendered by a {@link module:engine/view/uielement~UIElement} or
      * a {@link module:engine/view/rawelement~RawElement}, the parent `UIElement` or `RawElement` will be returned.
      *
      * @param domElementOrDocumentFragment DOM element or document fragment.
      * @returns Corresponding view element, document fragment or `undefined` if no element was bound.
      */
      mapDomToView(domElementOrDocumentFragment) {
        const hostElement = this.getHostViewElement(domElementOrDocumentFragment);
        return hostElement || this._domToViewMapping.get(domElementOrDocumentFragment);
      }
      /**
      * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},
      * corresponding text node is returned based on the sibling or parent.
      *
      * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used
      * to find the corresponding text node.
      *
      * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}
      * element, it is used to find the corresponding text node.
      *
      * For all text nodes rendered by a {@link module:engine/view/uielement~UIElement} or
      * a {@link module:engine/view/rawelement~RawElement}, the parent `UIElement` or `RawElement` will be returned.
      *
      * Otherwise `null` is returned.
      *
      * Note that for the block or inline {@link module:engine/view/filler filler} this method returns `null`.
      *
      * @param domText DOM text node.
      * @returns Corresponding view text node or `null`, if it was not possible to find a corresponding node.
      */
      findCorrespondingViewText(domText) {
        if (isInlineFiller(domText)) {
          return null;
        }
        const hostElement = this.getHostViewElement(domText);
        if (hostElement) {
          return hostElement;
        }
        const previousSibling = domText.previousSibling;
        if (previousSibling) {
          if (!this.isElement(previousSibling)) {
            return null;
          }
          const viewElement = this.mapDomToView(previousSibling);
          if (viewElement) {
            const nextSibling = viewElement.nextSibling;
            if (nextSibling instanceof Text$1) {
              return nextSibling;
            } else {
              return null;
            }
          }
        } else {
          const viewElement = this.mapDomToView(domText.parentNode);
          if (viewElement) {
            const firstChild = viewElement.getChild(0);
            if (firstChild instanceof Text$1) {
              return firstChild;
            } else {
              return null;
            }
          }
        }
        return null;
      }
      mapViewToDom(documentFragmentOrElement) {
        return this._viewToDomMapping.get(documentFragmentOrElement);
      }
      /**
      * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},
      * corresponding text node is returned based on the sibling or parent.
      *
      * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used
      * to find the corresponding text node.
      *
      * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}
      * element, it is used to find the corresponding text node.
      *
      * Otherwise `null` is returned.
      *
      * @param viewText View text node.
      * @returns Corresponding DOM text node or `null`, if it was not possible to find a corresponding node.
      */
      findCorrespondingDomText(viewText) {
        const previousSibling = viewText.previousSibling;
        if (previousSibling && this.mapViewToDom(previousSibling)) {
          return this.mapViewToDom(previousSibling).nextSibling;
        }
        if (!previousSibling && viewText.parent && this.mapViewToDom(viewText.parent)) {
          return this.mapViewToDom(viewText.parent).childNodes[0];
        }
        return null;
      }
      /**
      * Focuses DOM editable that is corresponding to provided {@link module:engine/view/editableelement~EditableElement}.
      */
      focus(viewEditable) {
        const domEditable = this.mapViewToDom(viewEditable);
        if (domEditable && domEditable.ownerDocument.activeElement !== domEditable) {
          const { scrollX, scrollY } = global$1.window;
          const scrollPositions = [];
          forEachDomElementAncestor(domEditable, (node) => {
            const { scrollLeft, scrollTop } = node;
            scrollPositions.push([
              scrollLeft,
              scrollTop
            ]);
          });
          domEditable.focus();
          forEachDomElementAncestor(domEditable, (node) => {
            const [scrollLeft, scrollTop] = scrollPositions.shift();
            node.scrollLeft = scrollLeft;
            node.scrollTop = scrollTop;
          });
          global$1.window.scrollTo(scrollX, scrollY);
        }
      }
      /**
      * Remove DOM selection from blurred editable, so it won't interfere with clicking on dropdowns (especially on iOS).
      *
      * @internal
      */
      _clearDomSelection() {
        const domEditable = this.mapViewToDom(this.document.selection.editableElement);
        if (!domEditable) {
          return;
        }
        const domSelection = domEditable.ownerDocument.defaultView.getSelection();
        const newViewSelection = this.domSelectionToView(domSelection);
        const selectionInEditable = newViewSelection && newViewSelection.rangeCount > 0;
        if (selectionInEditable) {
          domSelection.removeAllRanges();
        }
      }
      /**
      * Returns `true` when `node.nodeType` equals `Node.ELEMENT_NODE`.
      *
      * @param node Node to check.
      */
      isElement(node) {
        return node && node.nodeType == Node.ELEMENT_NODE;
      }
      /**
      * Returns `true` when `node.nodeType` equals `Node.DOCUMENT_FRAGMENT_NODE`.
      *
      * @param node Node to check.
      */
      isDocumentFragment(node) {
        return node && node.nodeType == Node.DOCUMENT_FRAGMENT_NODE;
      }
      /**
      * Checks if the node is an instance of the block filler for this DOM converter.
      *
      * ```ts
      * const converter = new DomConverter( viewDocument, { blockFillerMode: 'br' } );
      *
      * converter.isBlockFiller( BR_FILLER( document ) ); // true
      * converter.isBlockFiller( NBSP_FILLER( document ) ); // false
      * ```
      *
      * **Note:**: For the `'nbsp'` mode the method also checks context of a node so it cannot be a detached node.
      *
      * **Note:** A special case in the `'nbsp'` mode exists where the `<br>` in `<p><br></p>` is treated as a block filler.
      *
      * @param domNode DOM node to check.
      * @returns True if a node is considered a block filler for given mode.
      */
      isBlockFiller(domNode) {
        if (this.blockFillerMode == "br") {
          return domNode.isEqualNode(BR_FILLER_REF);
        }
        if (domNode.tagName === "BR" && hasBlockParent(domNode, this.blockElements) && domNode.parentNode.childNodes.length === 1) {
          return true;
        }
        return domNode.isEqualNode(MARKED_NBSP_FILLER_REF) || isNbspBlockFiller(domNode, this.blockElements);
      }
      /**
      * Returns `true` if given selection is a backward selection, that is, if it's `focus` is before `anchor`.
      *
      * @param DOM Selection instance to check.
      */
      isDomSelectionBackward(selection) {
        if (selection.isCollapsed) {
          return false;
        }
        const range2 = this._domDocument.createRange();
        try {
          range2.setStart(selection.anchorNode, selection.anchorOffset);
          range2.setEnd(selection.focusNode, selection.focusOffset);
        } catch (e2) {
          return false;
        }
        const backward = range2.collapsed;
        range2.detach();
        return backward;
      }
      /**
      * Returns a parent {@link module:engine/view/uielement~UIElement} or {@link module:engine/view/rawelement~RawElement}
      * that hosts the provided DOM node. Returns `null` if there is no such parent.
      */
      getHostViewElement(domNode) {
        const ancestors = getAncestors(domNode);
        ancestors.pop();
        while (ancestors.length) {
          const domNode2 = ancestors.pop();
          const viewNode = this._domToViewMapping.get(domNode2);
          if (viewNode && (viewNode.is("uiElement") || viewNode.is("rawElement"))) {
            return viewNode;
          }
        }
        return null;
      }
      /**
      * Checks if the given selection's boundaries are at correct places.
      *
      * The following places are considered as incorrect for selection boundaries:
      *
      * * before or in the middle of an inline filler sequence,
      * * inside a DOM element which represents {@link module:engine/view/uielement~UIElement a view UI element},
      * * inside a DOM element which represents {@link module:engine/view/rawelement~RawElement a view raw element}.
      *
      * @param domSelection The DOM selection object to be checked.
      * @returns `true` if the given selection is at a correct place, `false` otherwise.
      */
      isDomSelectionCorrect(domSelection) {
        return this._isDomSelectionPositionCorrect(domSelection.anchorNode, domSelection.anchorOffset) && this._isDomSelectionPositionCorrect(domSelection.focusNode, domSelection.focusOffset);
      }
      /**
      * Registers a {@link module:engine/view/matcher~MatcherPattern} for view elements whose content should be treated as raw data
      * and not processed during the conversion from DOM nodes to view elements.
      *
      * This is affecting how {@link module:engine/view/domconverter~DomConverter#domToView} and
      * {@link module:engine/view/domconverter~DomConverter#domChildrenToView} process DOM nodes.
      *
      * The raw data can be later accessed by a
      * {@link module:engine/view/element~Element#getCustomProperty custom property of a view element} called `"$rawContent"`.
      *
      * @param pattern Pattern matching a view element whose content should
      * be treated as raw data.
      */
      registerRawContentMatcher(pattern) {
        this._rawContentElementMatcher.add(pattern);
      }
      /**
      * Registers a {@link module:engine/view/matcher~MatcherPattern} for inline object view elements.
      *
      * This is affecting how {@link module:engine/view/domconverter~DomConverter#domToView} and
      * {@link module:engine/view/domconverter~DomConverter#domChildrenToView} process DOM nodes.
      *
      * This is an extension of a simple {@link #inlineObjectElements} array of element names.
      *
      * @param pattern Pattern matching a view element which should be treated as an inline object.
      */
      registerInlineObjectMatcher(pattern) {
        this._inlineObjectElementMatcher.add(pattern);
      }
      /**
      * Clear temporary custom properties.
      *
      * @internal
      */
      _clearTemporaryCustomProperties() {
        for (const element of this._elementsWithTemporaryCustomProperties) {
          element._removeCustomProperty("editingPipeline:doNotReuseOnce");
        }
        this._elementsWithTemporaryCustomProperties.clear();
      }
      /**
      * Returns the block {@link module:engine/view/filler filler} node based on the current {@link #blockFillerMode} setting.
      */
      _getBlockFiller() {
        switch (this.blockFillerMode) {
          case "nbsp":
            return NBSP_FILLER(this._domDocument);
          case "markedNbsp":
            return MARKED_NBSP_FILLER(this._domDocument);
          case "br":
            return BR_FILLER(this._domDocument);
        }
      }
      /**
      * Checks if the given DOM position is a correct place for selection boundary. See {@link #isDomSelectionCorrect}.
      *
      * @param domParent Position parent.
      * @param offset Position offset.
      * @returns `true` if given position is at a correct place for selection boundary, `false` otherwise.
      */
      _isDomSelectionPositionCorrect(domParent, offset2) {
        if (isText(domParent) && startsWithFiller(domParent) && offset2 < INLINE_FILLER_LENGTH) {
          return false;
        }
        if (this.isElement(domParent) && startsWithFiller(domParent.childNodes[offset2])) {
          return false;
        }
        const viewParent = this.mapDomToView(domParent);
        if (viewParent && (viewParent.is("uiElement") || viewParent.is("rawElement"))) {
          return false;
        }
        return true;
      }
      /**
      * Internal generator for {@link #domToView}. Also used by {@link #domChildrenToView}.
      * Separates DOM nodes conversion from whitespaces processing.
      *
      * @param domNode DOM node or document fragment to transform.
      * @param inlineNodes An array of recently encountered inline nodes truncated to the block element boundaries.
      * Used later to process whitespaces.
      */
      *_domToView(domNode, options, inlineNodes) {
        if (this.isBlockFiller(domNode)) {
          return null;
        }
        const hostElement = this.getHostViewElement(domNode);
        if (hostElement) {
          return hostElement;
        }
        if (isComment(domNode) && options.skipComments) {
          return null;
        }
        if (isText(domNode)) {
          if (isInlineFiller(domNode)) {
            return null;
          } else {
            const textData = domNode.data;
            if (textData === "") {
              return null;
            }
            const textNode = new Text$1(this.document, textData);
            inlineNodes.push(textNode);
            return textNode;
          }
        } else {
          let viewElement = this.mapDomToView(domNode);
          if (viewElement) {
            if (this._isInlineObjectElement(viewElement)) {
              inlineNodes.push(viewElement);
            }
            return viewElement;
          }
          if (this.isDocumentFragment(domNode)) {
            viewElement = new DocumentFragment$1(this.document);
            if (options.bind) {
              this.bindDocumentFragments(domNode, viewElement);
            }
          } else {
            viewElement = this._createViewElement(domNode, options);
            if (options.bind) {
              this.bindElements(domNode, viewElement);
            }
            const attrs = domNode.attributes;
            if (attrs) {
              for (let l2 = attrs.length, i2 = 0; i2 < l2; i2++) {
                viewElement._setAttribute(attrs[i2].name, attrs[i2].value);
              }
            }
            if (this._isViewElementWithRawContent(viewElement, options)) {
              viewElement._setCustomProperty("$rawContent", domNode.innerHTML);
              if (!this._isBlockViewElement(viewElement)) {
                inlineNodes.push(viewElement);
              }
              return viewElement;
            }
            if (isComment(domNode)) {
              viewElement._setCustomProperty("$rawContent", domNode.data);
              return viewElement;
            }
          }
          yield viewElement;
          const nestedInlineNodes = [];
          if (options.withChildren !== false) {
            for (const child of this.domChildrenToView(domNode, options, nestedInlineNodes)) {
              viewElement._appendChild(child);
            }
          }
          if (this._isInlineObjectElement(viewElement)) {
            inlineNodes.push(viewElement);
            this._processDomInlineNodes(null, nestedInlineNodes, options);
          } else {
            for (const inlineNode of nestedInlineNodes) {
              inlineNodes.push(inlineNode);
            }
          }
        }
      }
      /**
      * Internal helper that walks the list of inline view nodes already generated from DOM nodes
      * and handles whitespaces and NBSPs.
      *
      * @param domParent The DOM parent of the given inline nodes. This should be a document fragment or
      * a block element to whitespace processing start cleaning.
      * @param inlineNodes An array of recently encountered inline nodes truncated to the block element boundaries.
      */
      _processDomInlineNodes(domParent, inlineNodes, options) {
        if (!inlineNodes.length) {
          return;
        }
        if (domParent && !this.isDocumentFragment(domParent) && !this._isBlockDomElement(domParent)) {
          return;
        }
        let prevNodeEndsWithSpace = false;
        for (let i2 = 0; i2 < inlineNodes.length; i2++) {
          const node = inlineNodes[i2];
          if (!node.is("$text")) {
            prevNodeEndsWithSpace = false;
            continue;
          }
          let data;
          let nodeEndsWithSpace = false;
          if (this._isPreFormatted(node)) {
            data = getDataWithoutFiller(node.data);
          } else {
            data = node.data.replace(/[ \n\t\r]{1,}/g, " ");
            nodeEndsWithSpace = /[^\S\u00A0]/.test(data.charAt(data.length - 1));
            const prevNode = i2 > 0 ? inlineNodes[i2 - 1] : null;
            const nextNode = i2 + 1 < inlineNodes.length ? inlineNodes[i2 + 1] : null;
            const shouldLeftTrim = !prevNode || prevNode.is("element") && prevNode.name == "br" || prevNodeEndsWithSpace;
            const shouldRightTrim = nextNode ? false : !startsWithFiller(node.data);
            if (options.withChildren !== false) {
              if (shouldLeftTrim) {
                data = data.replace(/^ /, "");
              }
              if (shouldRightTrim) {
                data = data.replace(/ $/, "");
              }
            }
            data = getDataWithoutFiller(data);
            data = data.replace(/ \u00A0/g, "  ");
            const isNextNodeInlineObjectElement = nextNode && nextNode.is("element") && nextNode.name != "br";
            const isNextNodeStartingWithSpace = nextNode && nextNode.is("$text") && nextNode.data.charAt(0) == " ";
            if (/[ \u00A0]\u00A0$/.test(data) || !nextNode || isNextNodeInlineObjectElement || isNextNodeStartingWithSpace) {
              data = data.replace(/\u00A0$/, " ");
            }
            if (shouldLeftTrim || prevNode && prevNode.is("element") && prevNode.name != "br") {
              data = data.replace(/^\u00A0/, " ");
            }
          }
          if (data.length == 0 && node.parent) {
            node._remove();
            inlineNodes.splice(i2, 1);
            i2--;
          } else {
            node._data = data;
            prevNodeEndsWithSpace = nodeEndsWithSpace;
          }
        }
        inlineNodes.length = 0;
      }
      /**
      * Takes text data from a given {@link module:engine/view/text~Text#data} and processes it so
      * it is correctly displayed in the DOM.
      *
      * Following changes are done:
      *
      * * a space at the beginning is changed to `&nbsp;` if this is the first text node in its container
      * element or if a previous text node ends with a space character,
      * * space at the end of the text node is changed to `&nbsp;` if there are two spaces at the end of a node or if next node
      * starts with a space or if it is the last text node in its container,
      * * remaining spaces are replaced to a chain of spaces and `&nbsp;` (e.g. `'x   x'` becomes `'x &nbsp; x'`).
      *
      * Content of {@link #preElements} is not processed.
      *
      * @param node View text node to process.
      * @returns Processed text data.
      */
      _processDataFromViewText(node) {
        let data = node.data;
        if (this._isPreFormatted(node)) {
          return data;
        }
        if (data.charAt(0) == " ") {
          const prevNode = this._getTouchingInlineViewNode(node, false);
          const prevEndsWithSpace = prevNode && prevNode.is("$textProxy") && this._nodeEndsWithSpace(prevNode);
          if (prevEndsWithSpace || !prevNode) {
            data = "" + data.substr(1);
          }
        }
        if (data.charAt(data.length - 1) == " ") {
          const nextNode = this._getTouchingInlineViewNode(node, true);
          const nextStartsWithSpace = nextNode && nextNode.is("$textProxy") && nextNode.data.charAt(0) == " ";
          if (data.charAt(data.length - 2) == " " || !nextNode || nextStartsWithSpace) {
            data = data.substr(0, data.length - 1) + "";
          }
        }
        return data.replace(/ {2}/g, " ");
      }
      /**
      * Checks whether given node ends with a space character after changing appropriate space characters to `&nbsp;`s.
      *
      * @param  node Node to check.
      * @returns `true` if given `node` ends with space, `false` otherwise.
      */
      _nodeEndsWithSpace(node) {
        if (this._isPreFormatted(node)) {
          return false;
        }
        const data = this._processDataFromViewText(node);
        return data.charAt(data.length - 1) == " ";
      }
      /**
      * Checks whether given text contains preformatted white space. This is the case if
      * * any of node ancestors has a name which is in `preElements` array, or
      * * the closest ancestor that has the `white-space` CSS property sets it to a value that preserves spaces
      *
      * @param node Node to check
      * @returns `true` if given node contains preformatted white space, `false` otherwise.
      */
      _isPreFormatted(node) {
        if (_hasViewParentOfType(node, this.preElements)) {
          return true;
        }
        for (const ancestor of node.getAncestors({
          parentFirst: true
        })) {
          if (!ancestor.is("element") || !ancestor.hasStyle("white-space") || ancestor.getStyle("white-space") === "inherit") {
            continue;
          }
          return [
            "pre",
            "pre-wrap",
            "break-spaces"
          ].includes(ancestor.getStyle("white-space"));
        }
        return false;
      }
      /**
      * Helper function. For given {@link module:engine/view/text~Text view text node}, it finds previous or next sibling
      * that is contained in the same container element. If there is no such sibling, `null` is returned.
      *
      * @param node Reference node.
      * @returns Touching text node, an inline object
      * or `null` if there is no next or previous touching text node.
      */
      _getTouchingInlineViewNode(node, getNext) {
        const treeWalker = new TreeWalker$1({
          startPosition: getNext ? Position$1._createAfter(node) : Position$1._createBefore(node),
          direction: getNext ? "forward" : "backward"
        });
        for (const { item } of treeWalker) {
          if (item.is("$textProxy")) {
            return item;
          } else if (item.is("element") && item.getCustomProperty("dataPipeline:transparentRendering")) {
            continue;
          } else if (item.is("element", "br")) {
            return null;
          } else if (this._isInlineObjectElement(item)) {
            return item;
          } else if (item.is("containerElement")) {
            return null;
          }
        }
        return null;
      }
      /**
      * Returns `true` if a DOM node belongs to {@link #blockElements}. `false` otherwise.
      */
      _isBlockDomElement(node) {
        return this.isElement(node) && this.blockElements.includes(node.tagName.toLowerCase());
      }
      /**
      * Returns `true` if a view node belongs to {@link #blockElements}. `false` otherwise.
      */
      _isBlockViewElement(node) {
        return node.is("element") && this.blockElements.includes(node.name);
      }
      /**
      * Returns `true` if a DOM node belongs to {@link #inlineObjectElements}. `false` otherwise.
      */
      _isInlineObjectElement(node) {
        if (!node.is("element")) {
          return false;
        }
        return node.name == "br" || this.inlineObjectElements.includes(node.name) || !!this._inlineObjectElementMatcher.match(node);
      }
      /**
      * Creates view element basing on the node type.
      *
      * @param node DOM node to check.
      * @param options Conversion options. See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.
      */
      _createViewElement(node, options) {
        if (isComment(node)) {
          return new UIElement(this.document, "$comment");
        }
        const viewName = options.keepOriginalCase ? node.tagName : node.tagName.toLowerCase();
        return new Element$1(this.document, viewName);
      }
      /**
      * Checks if view element's content should be treated as a raw data.
      *
      * @param viewElement View element to check.
      * @param options Conversion options. See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.
      */
      _isViewElementWithRawContent(viewElement, options) {
        return options.withChildren !== false && viewElement.is("element") && !!this._rawContentElementMatcher.match(viewElement);
      }
      /**
      * Checks whether a given element name should be renamed in a current rendering mode.
      *
      * @param elementName The name of view element.
      */
      _shouldRenameElement(elementName) {
        const name = elementName.toLowerCase();
        return this.renderingMode === "editing" && this.unsafeElements.includes(name);
      }
      /**
      * Return a <span> element with a special attribute holding the name of the original element.
      * Optionally, copy all the attributes of the original element if that element is provided.
      *
      * @param elementName The name of view element.
      * @param originalDomElement The original DOM element to copy attributes and content from.
      */
      _createReplacementDomElement(elementName, originalDomElement) {
        const newDomElement = this._domDocument.createElement("span");
        newDomElement.setAttribute(UNSAFE_ELEMENT_REPLACEMENT_ATTRIBUTE, elementName);
        if (originalDomElement) {
          while (originalDomElement.firstChild) {
            newDomElement.appendChild(originalDomElement.firstChild);
          }
          for (const attributeName of originalDomElement.getAttributeNames()) {
            newDomElement.setAttribute(attributeName, originalDomElement.getAttribute(attributeName));
          }
        }
        return newDomElement;
      }
    }
    function _hasViewParentOfType(node, types) {
      return node.getAncestors().some((parent2) => parent2.is("element") && types.includes(parent2.name));
    }
    function forEachDomElementAncestor(element, callback) {
      let node = element;
      while (node) {
        callback(node);
        node = node.parentElement;
      }
    }
    function isNbspBlockFiller(domNode, blockElements) {
      const isNBSP = domNode.isEqualNode(NBSP_FILLER_REF);
      return isNBSP && hasBlockParent(domNode, blockElements) && domNode.parentNode.childNodes.length === 1;
    }
    function hasBlockParent(domNode, blockElements) {
      const parent2 = domNode.parentNode;
      return !!parent2 && !!parent2.tagName && blockElements.includes(parent2.tagName.toLowerCase());
    }
    function _logUnsafeElement(elementName) {
      if (elementName === "script") {
        logWarning("domconverter-unsafe-script-element-detected");
      }
      if (elementName === "style") {
        logWarning("domconverter-unsafe-style-element-detected");
      }
    }
    function isGeckoRestrictedDomSelection(domSelection) {
      if (!env.isGecko) {
        return false;
      }
      if (!domSelection.rangeCount) {
        return false;
      }
      const container2 = domSelection.getRangeAt(0).startContainer;
      try {
        Object.prototype.toString.call(container2);
      } catch (error) {
        return true;
      }
      return false;
    }
    class Observer extends (/* @__PURE__ */ DomEmitterMixin()) {
      /**
      * Creates an instance of the observer.
      */
      constructor(view) {
        super();
        /**
        * An instance of the view controller.
        */
        __publicField(this, "view");
        /**
        * A reference to the {@link module:engine/view/document~Document} object.
        */
        __publicField(this, "document");
        /**
        * The state of the observer. If it is disabled, no events will be fired.
        */
        __publicField(this, "_isEnabled", false);
        this.view = view;
        this.document = view.document;
      }
      /**
      * The state of the observer. If it is disabled, no events will be fired.
      */
      get isEnabled() {
        return this._isEnabled;
      }
      /**
      * Enables the observer. This method is called when the observer is registered to the
      * {@link module:engine/view/view~View} and after {@link module:engine/view/view~View#forceRender rendering}
      * (all observers are {@link #disable disabled} before rendering).
      *
      * A typical use case for disabling observers is that mutation observers need to be disabled for the rendering.
      * However, a child class may not need to be disabled, so it can implement an empty method.
      *
      * @see module:engine/view/observer/observer~Observer#disable
      */
      enable() {
        this._isEnabled = true;
      }
      /**
      * Disables the observer. This method is called before
      * {@link module:engine/view/view~View#forceRender rendering} to prevent firing events during rendering.
      *
      * @see module:engine/view/observer/observer~Observer#enable
      */
      disable() {
        this._isEnabled = false;
      }
      /**
      * Disables and destroys the observer, among others removes event listeners created by the observer.
      */
      destroy() {
        this.disable();
        this.stopListening();
      }
      /**
      * Checks whether a given DOM event should be ignored (should not be turned into a synthetic view document event).
      *
      * Currently, an event will be ignored only if its target or any of its ancestors has the `data-cke-ignore-events` attribute.
      * This attribute can be used inside the structures generated by
      * {@link module:engine/view/downcastwriter~DowncastWriter#createUIElement `DowncastWriter#createUIElement()`} to ignore events
      * fired within a UI that should be excluded from CKEditor 5's realms.
      *
      * @param domTarget The DOM event target to check (usually an element, sometimes a text node and
      * potentially sometimes a document, too).
      * @returns Whether this event should be ignored by the observer.
      */
      checkShouldIgnoreEventFromTarget(domTarget) {
        if (domTarget && domTarget.nodeType === 3) {
          domTarget = domTarget.parentNode;
        }
        if (!domTarget || domTarget.nodeType !== 1) {
          return false;
        }
        return domTarget.matches("[data-cke-ignore-events], [data-cke-ignore-events] *");
      }
    }
    class DomEventData {
      /**
      * @param view The instance of the view controller.
      * @param domEvent The DOM event.
      * @param additionalData Additional properties that the instance should contain.
      */
      constructor(view, domEvent, additionalData) {
        /**
        * Instance of the view controller.
        */
        __publicField(this, "view");
        /**
        * The instance of the document.
        */
        __publicField(this, "document");
        /**
        * The DOM event.
        */
        __publicField(this, "domEvent");
        /**
        * The DOM target.
        */
        __publicField(this, "domTarget");
        this.view = view;
        this.document = view.document;
        this.domEvent = domEvent;
        this.domTarget = domEvent.target;
        assignIn(this, additionalData);
      }
      /**
      * The tree view element representing the target.
      */
      get target() {
        return this.view.domConverter.mapDomToView(this.domTarget);
      }
      /**
      * Prevents the native's event default action.
      */
      preventDefault() {
        this.domEvent.preventDefault();
      }
      /**
      * Stops native event propagation.
      */
      stopPropagation() {
        this.domEvent.stopPropagation();
      }
    }
    class DomEventObserver extends Observer {
      constructor() {
        super(...arguments);
        /**
        * If set to `true` DOM events will be listened on the capturing phase.
        * Default value is `false`.
        */
        __publicField(this, "useCapture", false);
        /**
        * If set to `true`, indicates that the function specified by listener will never call `preventDefault()`.
        * Default value is `false`.
        */
        __publicField(this, "usePassive", false);
      }
      /**
      * @inheritDoc
      */
      observe(domElement) {
        const types = typeof this.domEventType == "string" ? [
          this.domEventType
        ] : this.domEventType;
        types.forEach((type) => {
          this.listenTo(domElement, type, (eventInfo, domEvent) => {
            if (this.isEnabled && !this.checkShouldIgnoreEventFromTarget(domEvent.target)) {
              this.onDomEvent(domEvent);
            }
          }, {
            useCapture: this.useCapture,
            usePassive: this.usePassive
          });
        });
      }
      /**
      * @inheritDoc
      */
      stopObserving(domElement) {
        this.stopListening(domElement);
      }
      /**
      * Calls `Document#fire()` if observer {@link #isEnabled is enabled}.
      *
      * @see module:utils/emittermixin~Emitter#fire
      * @param eventType The event type (name).
      * @param domEvent The DOM event.
      * @param additionalData The additional data which should extend the
      * {@link module:engine/view/observer/domeventdata~DomEventData event data} object.
      */
      fire(eventType, domEvent, additionalData) {
        if (this.isEnabled) {
          this.document.fire(eventType, new DomEventData(this.view, domEvent, additionalData));
        }
      }
    }
    class KeyObserver extends DomEventObserver {
      constructor() {
        super(...arguments);
        /**
        * @inheritDoc
        */
        __publicField(this, "domEventType", [
          "keydown",
          "keyup"
        ]);
      }
      /**
      * @inheritDoc
      */
      onDomEvent(domEvt) {
        const data = {
          keyCode: domEvt.keyCode,
          altKey: domEvt.altKey,
          ctrlKey: domEvt.ctrlKey,
          shiftKey: domEvt.shiftKey,
          metaKey: domEvt.metaKey,
          get keystroke() {
            return getCode(this);
          }
        };
        this.fire(domEvt.type, domEvt, data);
      }
    }
    class FakeSelectionObserver extends Observer {
      /**
      * Creates new FakeSelectionObserver instance.
      */
      constructor(view) {
        super(view);
        /**
        * Fires debounced event `selectionChangeDone`. It uses `lodash#debounce` method to delay function call.
        */
        __publicField(this, "_fireSelectionChangeDoneDebounced");
        this._fireSelectionChangeDoneDebounced = debounce$1((data) => {
          this.document.fire("selectionChangeDone", data);
        }, 200);
      }
      /**
      * @inheritDoc
      */
      observe() {
        const document2 = this.document;
        document2.on("arrowKey", (eventInfo, data) => {
          const selection = document2.selection;
          if (selection.isFake && this.isEnabled) {
            data.preventDefault();
          }
        }, {
          context: "$capture"
        });
        document2.on("arrowKey", (eventInfo, data) => {
          const selection = document2.selection;
          if (selection.isFake && this.isEnabled) {
            this._handleSelectionMove(data.keyCode);
          }
        }, {
          priority: "lowest"
        });
      }
      /**
      * @inheritDoc
      */
      stopObserving() {
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        this._fireSelectionChangeDoneDebounced.cancel();
      }
      /**
      * Handles collapsing view selection according to given key code. If left or up key is provided - new selection will be
      * collapsed to left. If right or down key is pressed - new selection will be collapsed to right.
      *
      * This method fires {@link module:engine/view/document~Document#event:selectionChange} and
      * {@link module:engine/view/document~Document#event:selectionChangeDone} events imitating behaviour of
      * {@link module:engine/view/observer/selectionobserver~SelectionObserver}.
      */
      _handleSelectionMove(keyCode) {
        const selection = this.document.selection;
        const newSelection = new Selection$1(selection.getRanges(), {
          backward: selection.isBackward,
          fake: false
        });
        if (keyCode == keyCodes.arrowleft || keyCode == keyCodes.arrowup) {
          newSelection.setTo(newSelection.getFirstPosition());
        }
        if (keyCode == keyCodes.arrowright || keyCode == keyCodes.arrowdown) {
          newSelection.setTo(newSelection.getLastPosition());
        }
        const data = {
          oldSelection: selection,
          newSelection,
          domSelection: null
        };
        this.document.fire("selectionChange", data);
        this._fireSelectionChangeDoneDebounced(data);
      }
    }
    let MutationObserver$1 = class MutationObserver extends Observer {
      /**
      * @inheritDoc
      */
      constructor(view) {
        super(view);
        /**
        * Reference to the {@link module:engine/view/view~View#domConverter}.
        */
        __publicField(this, "domConverter");
        /**
        * Native mutation observer config.
        */
        __publicField(this, "_config");
        /**
        * Observed DOM elements.
        */
        __publicField(this, "_domElements");
        /**
        * Native mutation observer.
        */
        __publicField(this, "_mutationObserver");
        this._config = {
          childList: true,
          characterData: true,
          subtree: true
        };
        this.domConverter = view.domConverter;
        this._domElements = /* @__PURE__ */ new Set();
        this._mutationObserver = new window.MutationObserver(this._onMutations.bind(this));
      }
      /**
      * Synchronously handles mutations and empties the queue.
      */
      flush() {
        this._onMutations(this._mutationObserver.takeRecords());
      }
      /**
      * @inheritDoc
      */
      observe(domElement) {
        this._domElements.add(domElement);
        if (this.isEnabled) {
          this._mutationObserver.observe(domElement, this._config);
        }
      }
      /**
      * @inheritDoc
      */
      stopObserving(domElement) {
        this._domElements.delete(domElement);
        if (this.isEnabled) {
          this._mutationObserver.disconnect();
          for (const domElement2 of this._domElements) {
            this._mutationObserver.observe(domElement2, this._config);
          }
        }
      }
      /**
      * @inheritDoc
      */
      enable() {
        super.enable();
        for (const domElement of this._domElements) {
          this._mutationObserver.observe(domElement, this._config);
        }
      }
      /**
      * @inheritDoc
      */
      disable() {
        super.disable();
        this._mutationObserver.disconnect();
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        this._mutationObserver.disconnect();
      }
      /**
      * Handles mutations. Mark view elements to sync and call render.
      *
      * @param domMutations Array of native mutations.
      */
      _onMutations(domMutations) {
        if (domMutations.length === 0) {
          return;
        }
        const domConverter = this.domConverter;
        const mutatedTextNodes = /* @__PURE__ */ new Set();
        const elementsWithMutatedChildren = /* @__PURE__ */ new Set();
        for (const mutation of domMutations) {
          const element = domConverter.mapDomToView(mutation.target);
          if (!element) {
            continue;
          }
          if (element.is("uiElement") || element.is("rawElement")) {
            continue;
          }
          if (mutation.type === "childList" && !this._isBogusBrMutation(mutation)) {
            elementsWithMutatedChildren.add(element);
          }
        }
        for (const mutation of domMutations) {
          const element = domConverter.mapDomToView(mutation.target);
          if (element && (element.is("uiElement") || element.is("rawElement"))) {
            continue;
          }
          if (mutation.type === "characterData") {
            const text2 = domConverter.findCorrespondingViewText(mutation.target);
            if (text2 && !elementsWithMutatedChildren.has(text2.parent)) {
              mutatedTextNodes.add(text2);
            } else if (!text2 && startsWithFiller(mutation.target)) {
              elementsWithMutatedChildren.add(domConverter.mapDomToView(mutation.target.parentNode));
            }
          }
        }
        const mutations = [];
        for (const textNode of mutatedTextNodes) {
          mutations.push({
            type: "text",
            node: textNode
          });
        }
        for (const viewElement of elementsWithMutatedChildren) {
          const domElement = domConverter.mapViewToDom(viewElement);
          const viewChildren = Array.from(viewElement.getChildren());
          const newViewChildren = Array.from(domConverter.domChildrenToView(domElement, {
            withChildren: false
          }));
          if (!isEqualWith(viewChildren, newViewChildren, sameNodes)) {
            mutations.push({
              type: "children",
              node: viewElement
            });
          }
        }
        if (mutations.length) {
          this.document.fire("mutations", {
            mutations
          });
        }
      }
      /**
      * Checks if mutation was generated by the browser inserting bogus br on the end of the block element.
      * Such mutations are generated while pressing space or performing native spellchecker correction
      * on the end of the block element in Firefox browser.
      *
      * @param mutation Native mutation object.
      */
      _isBogusBrMutation(mutation) {
        let addedNode = null;
        if (mutation.nextSibling === null && mutation.removedNodes.length === 0 && mutation.addedNodes.length == 1) {
          addedNode = this.domConverter.domToView(mutation.addedNodes[0], {
            withChildren: false
          });
        }
        return addedNode && addedNode.is("element", "br");
      }
    };
    function sameNodes(child1, child2) {
      if (Array.isArray(child1)) {
        return;
      }
      if (child1 === child2) {
        return true;
      } else if (child1.is("$text") && child2.is("$text")) {
        return child1.data === child2.data;
      }
      return false;
    }
    class FocusObserver extends DomEventObserver {
      /**
      * @inheritDoc
      */
      constructor(view) {
        super(view);
        /**
        * Identifier of the timeout currently used by focus listener to delay rendering execution.
        */
        __publicField(this, "_renderTimeoutId", null);
        /**
        * Set to `true` if the document is in the process of setting the focus.
        *
        * The flag is used to indicate that setting the focus is in progress.
        */
        __publicField(this, "_isFocusChanging", false);
        /**
        * @inheritDoc
        */
        __publicField(this, "domEventType", [
          "focus",
          "blur"
        ]);
        this.useCapture = true;
        const document2 = this.document;
        document2.on("focus", () => this._handleFocus());
        document2.on("blur", (evt, data) => this._handleBlur(data));
        document2.on("beforeinput", () => {
          if (!document2.isFocused) {
            this._handleFocus();
          }
        }, {
          priority: "highest"
        });
      }
      /**
      * Finishes setting the document focus state.
      */
      flush() {
        if (this._isFocusChanging) {
          this._isFocusChanging = false;
          this.document.isFocused = true;
        }
      }
      /**
      * @inheritDoc
      */
      onDomEvent(domEvent) {
        this.fire(domEvent.type, domEvent);
      }
      /**
      * @inheritDoc
      */
      destroy() {
        this._clearTimeout();
        super.destroy();
      }
      /**
      * The `focus` event handler.
      */
      _handleFocus() {
        this._clearTimeout();
        this._isFocusChanging = true;
        this._renderTimeoutId = setTimeout(() => {
          this._renderTimeoutId = null;
          this.flush();
          this.view.change(() => {
          });
        }, 50);
      }
      /**
      * The `blur` event handler.
      */
      _handleBlur(data) {
        const selectedEditable = this.document.selection.editableElement;
        if (selectedEditable === null || selectedEditable === data.target) {
          this.document.isFocused = false;
          this._isFocusChanging = false;
          this.view.change(() => {
          });
        }
      }
      /**
      * Clears timeout.
      */
      _clearTimeout() {
        if (this._renderTimeoutId) {
          clearTimeout(this._renderTimeoutId);
          this._renderTimeoutId = null;
        }
      }
    }
    class SelectionObserver extends Observer {
      constructor(view) {
        super(view);
        /**
        * Instance of the mutation observer. Selection observer calls
        * {@link module:engine/view/observer/mutationobserver~MutationObserver#flush} to ensure that the mutations will be handled
        * before the {@link module:engine/view/document~Document#event:selectionChange} event is fired.
        */
        __publicField(this, "mutationObserver");
        /**
        * Instance of the focus observer. Focus observer calls
        * {@link module:engine/view/observer/focusobserver~FocusObserver#flush} to mark the latest focus change as complete.
        */
        __publicField(this, "focusObserver");
        /**
        * Reference to the view {@link module:engine/view/documentselection~DocumentSelection} object used to compare
        * new selection with it.
        */
        __publicField(this, "selection");
        /**
        * Reference to the {@link module:engine/view/view~View#domConverter}.
        */
        __publicField(this, "domConverter");
        /**
        * A set of documents which have added `selectionchange` listener to avoid adding a listener twice to the same
        * document.
        */
        __publicField(this, "_documents");
        /**
        * Fires debounced event `selectionChangeDone`. It uses `lodash#debounce` method to delay function call.
        */
        __publicField(this, "_fireSelectionChangeDoneDebounced");
        /**
        * When called, starts clearing the {@link #_loopbackCounter} counter in time intervals. When the number of selection
        * changes exceeds a certain limit within the interval of time, the observer will not fire `selectionChange` but warn about
        * possible infinite selection loop.
        */
        __publicField(this, "_clearInfiniteLoopInterval");
        /**
        * Unlocks the `isSelecting` state of the view document in case the selection observer did not record this fact
        * correctly (for whatever reason). It is a safeguard (paranoid check), that returns document to the normal state
        * after a certain period of time (debounced, postponed by each selectionchange event).
        */
        __publicField(this, "_documentIsSelectingInactivityTimeoutDebounced");
        /**
        * Private property to check if the code does not enter infinite loop.
        */
        __publicField(this, "_loopbackCounter");
        this.mutationObserver = view.getObserver(MutationObserver$1);
        this.focusObserver = view.getObserver(FocusObserver);
        this.selection = this.document.selection;
        this.domConverter = view.domConverter;
        this._documents = /* @__PURE__ */ new WeakSet();
        this._fireSelectionChangeDoneDebounced = debounce$1((data) => {
          this.document.fire("selectionChangeDone", data);
        }, 200);
        this._clearInfiniteLoopInterval = setInterval(() => this._clearInfiniteLoop(), 1e3);
        this._documentIsSelectingInactivityTimeoutDebounced = debounce$1(() => this.document.isSelecting = false, 5e3);
        this._loopbackCounter = 0;
      }
      /**
      * @inheritDoc
      */
      observe(domElement) {
        const domDocument = domElement.ownerDocument;
        const startDocumentIsSelecting = () => {
          this.document.isSelecting = true;
          this._documentIsSelectingInactivityTimeoutDebounced();
        };
        const endDocumentIsSelecting = () => {
          if (!this.document.isSelecting) {
            return;
          }
          this._handleSelectionChange(domDocument);
          this.document.isSelecting = false;
          this._documentIsSelectingInactivityTimeoutDebounced.cancel();
        };
        this.listenTo(domElement, "selectstart", startDocumentIsSelecting, {
          priority: "highest"
        });
        this.listenTo(domElement, "keydown", endDocumentIsSelecting, {
          priority: "highest",
          useCapture: true
        });
        this.listenTo(domElement, "keyup", endDocumentIsSelecting, {
          priority: "highest",
          useCapture: true
        });
        if (this._documents.has(domDocument)) {
          return;
        }
        this.listenTo(domDocument, "mouseup", endDocumentIsSelecting, {
          priority: "highest",
          useCapture: true
        });
        this.listenTo(domDocument, "selectionchange", () => {
          if (this.document.isComposing && !env.isAndroid) {
            return;
          }
          this._handleSelectionChange(domDocument);
          this._documentIsSelectingInactivityTimeoutDebounced();
        });
        this.listenTo(this.view.document, "compositionstart", () => {
          this._handleSelectionChange(domDocument);
        }, {
          priority: "lowest"
        });
        this._documents.add(domDocument);
      }
      /**
      * @inheritDoc
      */
      stopObserving(domElement) {
        this.stopListening(domElement);
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        clearInterval(this._clearInfiniteLoopInterval);
        this._fireSelectionChangeDoneDebounced.cancel();
        this._documentIsSelectingInactivityTimeoutDebounced.cancel();
      }
      /* istanbul ignore next -- @preserve */
      _reportInfiniteLoop() {
      }
      /**
      * Selection change listener. {@link module:engine/view/observer/mutationobserver~MutationObserver#flush Flush} mutations, check if
      * a selection changes and fires {@link module:engine/view/document~Document#event:selectionChange} event on every change
      * and {@link module:engine/view/document~Document#event:selectionChangeDone} when a selection stop changing.
      *
      * @param domDocument DOM document.
      */
      _handleSelectionChange(domDocument) {
        if (!this.isEnabled) {
          return;
        }
        const domSelection = domDocument.defaultView.getSelection();
        if (this.checkShouldIgnoreEventFromTarget(domSelection.anchorNode)) {
          return;
        }
        this.mutationObserver.flush();
        const newViewSelection = this.domConverter.domSelectionToView(domSelection);
        if (newViewSelection.rangeCount == 0) {
          this.view.hasDomSelection = false;
          return;
        }
        this.view.hasDomSelection = true;
        this.focusObserver.flush();
        if (this.selection.isEqual(newViewSelection) && this.domConverter.isDomSelectionCorrect(domSelection)) {
          return;
        }
        if (++this._loopbackCounter > 60) {
          this._reportInfiniteLoop();
          return;
        }
        if (this.selection.isSimilar(newViewSelection)) {
          this.view.forceRender();
        } else {
          const data = {
            oldSelection: this.selection,
            newSelection: newViewSelection,
            domSelection
          };
          this.document.fire("selectionChange", data);
          this._fireSelectionChangeDoneDebounced(data);
        }
      }
      /**
      * Clears `SelectionObserver` internal properties connected with preventing infinite loop.
      */
      _clearInfiniteLoop() {
        this._loopbackCounter = 0;
      }
    }
    class CompositionObserver extends DomEventObserver {
      /**
      * @inheritDoc
      */
      constructor(view) {
        super(view);
        /**
        * @inheritDoc
        */
        __publicField(this, "domEventType", [
          "compositionstart",
          "compositionupdate",
          "compositionend"
        ]);
        const document2 = this.document;
        document2.on("compositionstart", () => {
          document2.isComposing = true;
        }, {
          priority: "low"
        });
        document2.on("compositionend", () => {
          document2.isComposing = false;
        }, {
          priority: "low"
        });
      }
      /**
      * @inheritDoc
      */
      onDomEvent(domEvent) {
        this.fire(domEvent.type, domEvent, {
          data: domEvent.data
        });
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class DataTransfer {
      /**
      * @param nativeDataTransfer The native [`DataTransfer`](https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer) object.
      * @param options.cacheFiles Whether `files` list should be initialized in the constructor.
      */
      constructor(nativeDataTransfer, options = {}) {
        /**
        * The array of files created from the native `DataTransfer#files` or `DataTransfer#items`.
        */
        __publicField(this, "_files");
        /**
        * The native DataTransfer object.
        */
        __publicField(this, "_native");
        this._files = options.cacheFiles ? getFiles(nativeDataTransfer) : null;
        this._native = nativeDataTransfer;
      }
      /**
      * The array of files created from the native `DataTransfer#files` or `DataTransfer#items`.
      */
      get files() {
        if (!this._files) {
          this._files = getFiles(this._native);
        }
        return this._files;
      }
      /**
      * Returns an array of available native content types.
      */
      get types() {
        return this._native.types;
      }
      /**
      * Gets the data from the data transfer by its MIME type.
      *
      * ```ts
      * dataTransfer.getData( 'text/plain' );
      * ```
      *
      * @param type The MIME type. E.g. `text/html` or `text/plain`.
      */
      getData(type) {
        return this._native.getData(type);
      }
      /**
      * Sets the data in the data transfer.
      *
      * @param type The MIME type. E.g. `text/html` or `text/plain`.
      */
      setData(type, data) {
        this._native.setData(type, data);
      }
      /**
      * The effect that is allowed for a drag operation.
      */
      set effectAllowed(value) {
        this._native.effectAllowed = value;
      }
      get effectAllowed() {
        return this._native.effectAllowed;
      }
      /**
      * The actual drop effect.
      */
      set dropEffect(value) {
        this._native.dropEffect = value;
      }
      get dropEffect() {
        return this._native.dropEffect;
      }
      /**
      * Set a preview image of the dragged content.
      */
      setDragImage(image2, x2, y2) {
        this._native.setDragImage(image2, x2, y2);
      }
      /**
      * Whether the dragging operation was canceled.
      */
      get isCanceled() {
        return this._native.dropEffect == "none" || !!this._native.mozUserCancelled;
      }
    }
    function getFiles(nativeDataTransfer) {
      const files = Array.from(nativeDataTransfer.files || []);
      const items = Array.from(nativeDataTransfer.items || []);
      if (files.length) {
        return files;
      }
      return items.filter((item) => item.kind === "file").map((item) => item.getAsFile());
    }
    class InputObserver extends DomEventObserver {
      constructor() {
        super(...arguments);
        /**
        * @inheritDoc
        */
        __publicField(this, "domEventType", "beforeinput");
      }
      /**
      * @inheritDoc
      */
      onDomEvent(domEvent) {
        const domTargetRanges = domEvent.getTargetRanges();
        const view = this.view;
        const viewDocument = view.document;
        let dataTransfer = null;
        let data = null;
        let targetRanges = [];
        if (domEvent.dataTransfer) {
          dataTransfer = new DataTransfer(domEvent.dataTransfer);
        }
        if (domEvent.data !== null) {
          data = domEvent.data;
        } else if (dataTransfer) {
          data = dataTransfer.getData("text/plain");
        }
        if (viewDocument.selection.isFake) {
          targetRanges = Array.from(viewDocument.selection.getRanges());
        } else if (domTargetRanges.length) {
          targetRanges = domTargetRanges.map((domRange) => {
            const viewStart = view.domConverter.domPositionToView(domRange.startContainer, domRange.startOffset);
            const viewEnd = view.domConverter.domPositionToView(domRange.endContainer, domRange.endOffset);
            if (viewStart) {
              return view.createRange(viewStart, viewEnd);
            } else if (viewEnd) {
              return view.createRange(viewEnd);
            }
          }).filter((range2) => !!range2);
        } else if (env.isAndroid) {
          const domSelection = domEvent.target.ownerDocument.defaultView.getSelection();
          targetRanges = Array.from(view.domConverter.domSelectionToView(domSelection).getRanges());
        }
        if (env.isAndroid && domEvent.inputType == "insertCompositionText" && data && data.endsWith("\n")) {
          this.fire(domEvent.type, domEvent, {
            inputType: "insertParagraph",
            targetRanges: [
              view.createRange(targetRanges[0].end)
            ]
          });
          return;
        }
        if (domEvent.inputType == "insertText" && data && data.includes("\n")) {
          const parts = data.split(/\n{1,2}/g);
          let partTargetRanges = targetRanges;
          for (let i2 = 0; i2 < parts.length; i2++) {
            const dataPart = parts[i2];
            if (dataPart != "") {
              this.fire(domEvent.type, domEvent, {
                data: dataPart,
                dataTransfer,
                targetRanges: partTargetRanges,
                inputType: domEvent.inputType,
                isComposing: domEvent.isComposing
              });
              partTargetRanges = [
                viewDocument.selection.getFirstRange()
              ];
            }
            if (i2 + 1 < parts.length) {
              this.fire(domEvent.type, domEvent, {
                inputType: "insertParagraph",
                targetRanges: partTargetRanges
              });
              partTargetRanges = [
                viewDocument.selection.getFirstRange()
              ];
            }
          }
          return;
        }
        this.fire(domEvent.type, domEvent, {
          data,
          dataTransfer,
          targetRanges,
          inputType: domEvent.inputType,
          isComposing: domEvent.isComposing
        });
      }
    }
    class ArrowKeysObserver extends Observer {
      /**
      * @inheritDoc
      */
      constructor(view) {
        super(view);
        this.document.on("keydown", (event, data) => {
          if (this.isEnabled && isArrowKeyCode(data.keyCode)) {
            const eventInfo = new BubblingEventInfo(this.document, "arrowKey", this.document.selection.getFirstRange());
            this.document.fire(eventInfo, data);
            if (eventInfo.stop.called) {
              event.stop();
            }
          }
        });
      }
      /**
      * @inheritDoc
      */
      observe() {
      }
      /**
      * @inheritDoc
      */
      stopObserving() {
      }
    }
    class TabObserver extends Observer {
      /**
      * @inheritDoc
      */
      constructor(view) {
        super(view);
        const doc = this.document;
        doc.on("keydown", (evt, data) => {
          if (!this.isEnabled || data.keyCode != keyCodes.tab || data.ctrlKey) {
            return;
          }
          const event = new BubblingEventInfo(doc, "tab", doc.selection.getFirstRange());
          doc.fire(event, data);
          if (event.stop.called) {
            evt.stop();
          }
        });
      }
      /**
      * @inheritDoc
      */
      observe() {
      }
      /**
      * @inheritDoc
      */
      stopObserving() {
      }
    }
    let View$1 = class View extends (/* @__PURE__ */ ObservableMixin()) {
      /**
      * @param stylesProcessor The styles processor instance.
      */
      constructor(stylesProcessor) {
        super();
        /**
        * Instance of the {@link module:engine/view/document~Document} associated with this view controller.
        */
        __publicField(this, "document");
        /**
        * Instance of the {@link module:engine/view/domconverter~DomConverter domConverter} used by
        * {@link module:engine/view/view~View#_renderer renderer}
        * and {@link module:engine/view/observer/observer~Observer observers}.
        */
        __publicField(this, "domConverter");
        /**
        * Roots of the DOM tree. Map on the `HTMLElement`s with roots names as keys.
        */
        __publicField(this, "domRoots", /* @__PURE__ */ new Map());
        /**
        * Instance of the {@link module:engine/view/renderer~Renderer renderer}.
        */
        __publicField(this, "_renderer");
        /**
        * A DOM root attributes cache. It saves the initial values of DOM root attributes before the DOM element
        * is {@link module:engine/view/view~View#attachDomRoot attached} to the view so later on, when
        * the view is destroyed ({@link module:engine/view/view~View#detachDomRoot}), they can be easily restored.
        * This way, the DOM element can go back to the (clean) state as if the editing view never used it.
        */
        __publicField(this, "_initialDomRootAttributes", /* @__PURE__ */ new WeakMap());
        /**
        * Map of registered {@link module:engine/view/observer/observer~Observer observers}.
        */
        __publicField(this, "_observers", /* @__PURE__ */ new Map());
        /**
        * DowncastWriter instance used in {@link #change change method} callbacks.
        */
        __publicField(this, "_writer");
        /**
        * Is set to `true` when {@link #change view changes} are currently in progress.
        */
        __publicField(this, "_ongoingChange", false);
        /**
        * Used to prevent calling {@link #forceRender} and {@link #change} during rendering view to the DOM.
        */
        __publicField(this, "_postFixersInProgress", false);
        /**
        * Internal flag to temporary disable rendering. See the usage in the {@link #_disableRendering}.
        */
        __publicField(this, "_renderingDisabled", false);
        /**
        * Internal flag that disables rendering when there are no changes since the last rendering.
        * It stores information about changed selection and changed elements from attached document roots.
        */
        __publicField(this, "_hasChangedSinceTheLastRendering", false);
        this.document = new Document$1(stylesProcessor);
        this.domConverter = new DomConverter(this.document);
        this.set("isRenderingInProgress", false);
        this.set("hasDomSelection", false);
        this._renderer = new Renderer$1(this.domConverter, this.document.selection);
        this._renderer.bind("isFocused", "isSelecting", "isComposing").to(this.document, "isFocused", "isSelecting", "isComposing");
        this._writer = new DowncastWriter(this.document);
        this.addObserver(MutationObserver$1);
        this.addObserver(FocusObserver);
        this.addObserver(SelectionObserver);
        this.addObserver(KeyObserver);
        this.addObserver(FakeSelectionObserver);
        this.addObserver(CompositionObserver);
        this.addObserver(ArrowKeysObserver);
        this.addObserver(InputObserver);
        this.addObserver(TabObserver);
        injectQuirksHandling(this);
        injectUiElementHandling(this);
        this.on("render", () => {
          this._render();
          this.document.fire("layoutChanged");
          this._hasChangedSinceTheLastRendering = false;
        });
        this.listenTo(this.document.selection, "change", () => {
          this._hasChangedSinceTheLastRendering = true;
        });
        this.listenTo(this.document, "change:isFocused", () => {
          this._hasChangedSinceTheLastRendering = true;
        });
        if (env.isiOS) {
          this.listenTo(this.document, "blur", (evt, data) => {
            const relatedViewElement = this.domConverter.mapDomToView(data.domEvent.relatedTarget);
            if (!relatedViewElement) {
              this.domConverter._clearDomSelection();
            }
          });
        }
        this.listenTo(this.document, "mutations", (evt, { mutations }) => {
          mutations.forEach((mutation) => this._renderer.markToSync(mutation.type, mutation.node));
        }, {
          priority: "low"
        });
        this.listenTo(this.document, "mutations", () => {
          this.forceRender();
        }, {
          priority: "lowest"
        });
      }
      /**
      * Attaches a DOM root element to the view element and enable all observers on that element.
      * Also {@link module:engine/view/renderer~Renderer#markToSync mark element} to be synchronized
      * with the view what means that all child nodes will be removed and replaced with content of the view root.
      *
      * This method also will change view element name as the same as tag name of given dom root.
      * Name is always transformed to lower case.
      *
      * **Note:** Use {@link #detachDomRoot `detachDomRoot()`} to revert this action.
      *
      * @param domRoot DOM root element.
      * @param name Name of the root.
      */
      attachDomRoot(domRoot, name = "main") {
        const viewRoot = this.document.getRoot(name);
        viewRoot._name = domRoot.tagName.toLowerCase();
        const initialDomRootAttributes = {};
        for (const { name: name2, value } of Array.from(domRoot.attributes)) {
          initialDomRootAttributes[name2] = value;
          if (name2 === "class") {
            this._writer.addClass(value.split(" "), viewRoot);
          } else {
            if (!viewRoot.hasAttribute(name2)) {
              this._writer.setAttribute(name2, value, viewRoot);
            }
          }
        }
        this._initialDomRootAttributes.set(domRoot, initialDomRootAttributes);
        const updateContenteditableAttribute = () => {
          this._writer.setAttribute("contenteditable", (!viewRoot.isReadOnly).toString(), viewRoot);
          if (viewRoot.isReadOnly) {
            this._writer.addClass("ck-read-only", viewRoot);
          } else {
            this._writer.removeClass("ck-read-only", viewRoot);
          }
        };
        updateContenteditableAttribute();
        this.domRoots.set(name, domRoot);
        this.domConverter.bindElements(domRoot, viewRoot);
        this._renderer.markToSync("children", viewRoot);
        this._renderer.markToSync("attributes", viewRoot);
        this._renderer.domDocuments.add(domRoot.ownerDocument);
        viewRoot.on("change:children", (evt, node) => this._renderer.markToSync("children", node));
        viewRoot.on("change:attributes", (evt, node) => this._renderer.markToSync("attributes", node));
        viewRoot.on("change:text", (evt, node) => this._renderer.markToSync("text", node));
        viewRoot.on("change:isReadOnly", () => this.change(updateContenteditableAttribute));
        viewRoot.on("change", () => {
          this._hasChangedSinceTheLastRendering = true;
        });
        for (const observer of this._observers.values()) {
          observer.observe(domRoot, name);
        }
      }
      /**
      * Detaches a DOM root element from the view element and restores its attributes to the state before
      * {@link #attachDomRoot `attachDomRoot()`}.
      *
      * @param name Name of the root to detach.
      */
      detachDomRoot(name) {
        const domRoot = this.domRoots.get(name);
        Array.from(domRoot.attributes).forEach(({ name: name2 }) => domRoot.removeAttribute(name2));
        const initialDomRootAttributes = this._initialDomRootAttributes.get(domRoot);
        for (const attribute in initialDomRootAttributes) {
          domRoot.setAttribute(attribute, initialDomRootAttributes[attribute]);
        }
        this.domRoots.delete(name);
        this.domConverter.unbindDomElement(domRoot);
        for (const observer of this._observers.values()) {
          observer.stopObserving(domRoot);
        }
      }
      /**
      * Gets DOM root element.
      *
      * @param name  Name of the root.
      * @returns DOM root element instance.
      */
      getDomRoot(name = "main") {
        return this.domRoots.get(name);
      }
      /**
      * Creates observer of the given type if not yet created, {@link module:engine/view/observer/observer~Observer#enable enables} it
      * and {@link module:engine/view/observer/observer~Observer#observe attaches} to all existing and future
      * {@link #domRoots DOM roots}.
      *
      * Note: Observers are recognized by their constructor (classes). A single observer will be instantiated and used only
      * when registered for the first time. This means that features and other components can register a single observer
      * multiple times without caring whether it has been already added or not.
      *
      * @param ObserverConstructor The constructor of an observer to add.
      * Should create an instance inheriting from {@link module:engine/view/observer/observer~Observer}.
      * @returns Added observer instance.
      */
      addObserver(ObserverConstructor) {
        let observer = this._observers.get(ObserverConstructor);
        if (observer) {
          return observer;
        }
        observer = new ObserverConstructor(this);
        this._observers.set(ObserverConstructor, observer);
        for (const [name, domElement] of this.domRoots) {
          observer.observe(domElement, name);
        }
        observer.enable();
        return observer;
      }
      /**
      * Returns observer of the given type or `undefined` if such observer has not been added yet.
      *
      * @param ObserverConstructor The constructor of an observer to get.
      * @returns Observer instance or undefined.
      */
      getObserver(ObserverConstructor) {
        return this._observers.get(ObserverConstructor);
      }
      /**
      * Disables all added observers.
      */
      disableObservers() {
        for (const observer of this._observers.values()) {
          observer.disable();
        }
      }
      /**
      * Enables all added observers.
      */
      enableObservers() {
        for (const observer of this._observers.values()) {
          observer.enable();
        }
      }
      /**
      * Scrolls the page viewport and {@link #domRoots} with their ancestors to reveal the
      * caret, **if not already visible to the user**.
      *
      * **Note**: Calling this method fires the {@link module:engine/view/view~ViewScrollToTheSelectionEvent} event that
      * allows custom behaviors.
      *
      * @param options Additional configuration of the scrolling behavior.
      * @param options.viewportOffset A distance between the DOM selection and the viewport boundary to be maintained
      * while scrolling to the selection (default is 20px). Setting this value to `0` will reveal the selection precisely at
      * the viewport boundary.
      * @param options.ancestorOffset A distance between the DOM selection and scrollable DOM root ancestor(s) to be maintained
      * while scrolling to the selection (default is 20px). Setting this value to `0` will reveal the selection precisely at
      * the scrollable ancestor(s) boundary.
      * @param options.alignToTop When set `true`, the DOM selection will be aligned to the top of the viewport if not already visible
      * (see `forceScroll` to learn more).
      * @param options.forceScroll When set `true`, the DOM selection will be aligned to the top of the viewport and scrollable ancestors
      * whether it is already visible or not. This option will only work when `alignToTop` is `true`.
      */
      scrollToTheSelection({ alignToTop, forceScroll, viewportOffset = 20, ancestorOffset = 20 } = {}) {
        const range2 = this.document.selection.getFirstRange();
        if (!range2) {
          return;
        }
        const originalArgs = cloneDeep({
          alignToTop,
          forceScroll,
          viewportOffset,
          ancestorOffset
        });
        if (typeof viewportOffset === "number") {
          viewportOffset = {
            top: viewportOffset,
            bottom: viewportOffset,
            left: viewportOffset,
            right: viewportOffset
          };
        }
        const options = {
          target: this.domConverter.viewRangeToDom(range2),
          viewportOffset,
          ancestorOffset,
          alignToTop,
          forceScroll
        };
        this.fire("scrollToTheSelection", options, originalArgs);
        scrollViewportToShowTarget(options);
      }
      /**
      * It will focus DOM element representing {@link module:engine/view/editableelement~EditableElement EditableElement}
      * that is currently having selection inside.
      */
      focus() {
        if (!this.document.isFocused) {
          const editable = this.document.selection.editableElement;
          if (editable) {
            this.domConverter.focus(editable);
            this.forceRender();
          }
        }
      }
      /**
      * The `change()` method is the primary way of changing the view. You should use it to modify any node in the view tree.
      * It makes sure that after all changes are made the view is rendered to the DOM (assuming that the view will be changed
      * inside the callback). It prevents situations when the DOM is updated when the view state is not yet correct. It allows
      * to nest calls one inside another and still performs a single rendering after all those changes are made.
      * It also returns the return value of its callback.
      *
      * ```ts
      * const text = view.change( writer => {
      * 	const newText = writer.createText( 'foo' );
      * 	writer.insert( position1, newText );
      *
      * 	view.change( writer => {
      * 		writer.insert( position2, writer.createText( 'bar' ) );
      * 	} );
      *
      * 	writer.remove( range );
      *
      * 	return newText;
      * } );
      * ```
      *
      * When the outermost change block is done and rendering to the DOM is over the
      * {@link module:engine/view/view~View#event:render `View#render`} event is fired.
      *
      * This method throws a `applying-view-changes-on-rendering` error when
      * the change block is used after rendering to the DOM has started.
      *
      * @param callback Callback function which may modify the view.
      * @returns Value returned by the callback.
      */
      change(callback) {
        if (this.isRenderingInProgress || this._postFixersInProgress) {
          throw new CKEditorError("cannot-change-view-tree", this);
        }
        try {
          if (this._ongoingChange) {
            return callback(this._writer);
          }
          this._ongoingChange = true;
          const callbackResult = callback(this._writer);
          this._ongoingChange = false;
          if (!this._renderingDisabled && this._hasChangedSinceTheLastRendering) {
            this._postFixersInProgress = true;
            this.document._callPostFixers(this._writer);
            this._postFixersInProgress = false;
            this.fire("render");
          }
          return callbackResult;
        } catch (err) {
          /* istanbul ignore next -- @preserve */
          CKEditorError.rethrowUnexpectedError(err, this);
        }
      }
      /**
      * Forces rendering {@link module:engine/view/document~Document view document} to DOM. If any view changes are
      * currently in progress, rendering will start after all {@link #change change blocks} are processed.
      *
      * Note that this method is dedicated for special cases. All view changes should be wrapped in the {@link #change}
      * block and the view will automatically check whether it needs to render DOM or not.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `applying-view-changes-on-rendering` when
      * trying to re-render when rendering to DOM has already started.
      */
      forceRender() {
        this._hasChangedSinceTheLastRendering = true;
        this.getObserver(FocusObserver).flush();
        this.change(() => {
        });
      }
      /**
      * Destroys this instance. Makes sure that all observers are destroyed and listeners removed.
      */
      destroy() {
        for (const observer of this._observers.values()) {
          observer.destroy();
        }
        this.document.destroy();
        this.stopListening();
      }
      /**
      * Creates position at the given location. The location can be specified as:
      *
      * * a {@link module:engine/view/position~Position position},
      * * parent element and offset (offset defaults to `0`),
      * * parent element and `'end'` (sets position at the end of that element),
      * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).
      *
      * This method is a shortcut to other constructors such as:
      *
      * * {@link #createPositionBefore},
      * * {@link #createPositionAfter},
      *
      * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/view/item~Item view item}.
      */
      createPositionAt(itemOrPosition, offset2) {
        return Position$1._createAt(itemOrPosition, offset2);
      }
      /**
      * Creates a new position after given view item.
      *
      * @param item View item after which the position should be located.
      */
      createPositionAfter(item) {
        return Position$1._createAfter(item);
      }
      /**
      * Creates a new position before given view item.
      *
      * @param item View item before which the position should be located.
      */
      createPositionBefore(item) {
        return Position$1._createBefore(item);
      }
      /**
      * Creates a range spanning from `start` position to `end` position.
      *
      * **Note:** This factory method creates it's own {@link module:engine/view/position~Position} instances basing on passed values.
      *
      * @param start Start position.
      * @param end End position. If not set, range will be collapsed at `start` position.
      */
      createRange(start2, end2) {
        return new Range$1(start2, end2);
      }
      /**
      * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.
      */
      createRangeOn(item) {
        return Range$1._createOn(item);
      }
      /**
      * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
      * that element and ends after the last child of that element.
      *
      * @param element Element which is a parent for the range.
      */
      createRangeIn(element) {
        return Range$1._createIn(element);
      }
      createSelection(...args) {
        return new Selection$1(...args);
      }
      /**
      * Disables or enables rendering. If the flag is set to `true` then the rendering will be disabled.
      * If the flag is set to `false` and if there was some change in the meantime, then the rendering action will be performed.
      *
      * @internal
      * @param flag A flag indicates whether the rendering should be disabled.
      */
      _disableRendering(flag2) {
        this._renderingDisabled = flag2;
        if (flag2 == false) {
          this.change(() => {
          });
        }
      }
      /**
      * Renders all changes. In order to avoid triggering the observers (e.g. selection) all observers are disabled
      * before rendering and re-enabled after that.
      */
      _render() {
        this.isRenderingInProgress = true;
        this.disableObservers();
        this._renderer.render();
        this.enableObservers();
        this.isRenderingInProgress = false;
      }
    };
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class TypeCheckable {
      /* istanbul ignore next -- @preserve */
      is() {
        throw new Error("is() method is abstract");
      }
    }
    let Node$1 = class Node extends TypeCheckable {
      /**
      * Creates a model node.
      *
      * This is an abstract class, so this constructor should not be used directly.
      *
      * @param attrs Node's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.
      */
      constructor(attrs) {
        super();
        /**
        * Parent of this node. It could be {@link module:engine/model/element~Element}
        * or {@link module:engine/model/documentfragment~DocumentFragment}.
        * Equals to `null` if the node has no parent.
        */
        __publicField(this, "parent", null);
        /**
        * Attributes set on this node.
        */
        __publicField(this, "_attrs");
        /**
        * Index of this node in its parent or `null` if the node has no parent.
        *
        * @internal
        */
        __publicField(this, "_index", null);
        /**
        * Offset at which this node starts in its parent or `null` if the node has no parent.
        *
        * @internal
        */
        __publicField(this, "_startOffset", null);
        this._attrs = toMap(attrs);
      }
      /**
      * {@link module:engine/model/document~Document Document} that owns this root element.
      */
      get document() {
        return null;
      }
      /**
      * Index of this node in its parent or `null` if the node has no parent.
      */
      get index() {
        return this._index;
      }
      /**
      * Offset at which this node starts in its parent. It is equal to the sum of {@link #offsetSize offsetSize}
      * of all its previous siblings. Equals to `null` if node has no parent.
      */
      get startOffset() {
        return this._startOffset;
      }
      /**
      * Offset size of this node.
      *
      * Represents how much "offset space" is occupied by the node in its parent. It is important for
      * {@link module:engine/model/position~Position position}. When node has `offsetSize` greater than `1`, position can be placed between
      * that node start and end. `offsetSize` greater than `1` is for nodes that represents more than one entity, i.e.
      * a {@link module:engine/model/text~Text text node}.
      */
      get offsetSize() {
        return 1;
      }
      /**
      * Offset at which this node ends in its parent. It is equal to the sum of this node's
      * {@link module:engine/model/node~Node#startOffset start offset} and {@link #offsetSize offset size}.
      * Equals to `null` if the node has no parent.
      */
      get endOffset() {
        if (this.startOffset === null) {
          return null;
        }
        return this.startOffset + this.offsetSize;
      }
      /**
      * Node's next sibling or `null` if the node is a last child of it's parent or if the node has no parent.
      */
      get nextSibling() {
        const index = this.index;
        return index !== null && this.parent.getChild(index + 1) || null;
      }
      /**
      * Node's previous sibling or `null` if the node is a first child of it's parent or if the node has no parent.
      */
      get previousSibling() {
        const index = this.index;
        return index !== null && this.parent.getChild(index - 1) || null;
      }
      /**
      * The top-most ancestor of the node. If node has no parent it is the root itself. If the node is a part
      * of {@link module:engine/model/documentfragment~DocumentFragment}, it's `root` is equal to that `DocumentFragment`.
      */
      get root() {
        let root2 = this;
        while (root2.parent) {
          root2 = root2.parent;
        }
        return root2;
      }
      /**
      * Returns `true` if the node is inside a document root that is attached to the document.
      */
      isAttached() {
        return this.parent === null ? false : this.root.isAttached();
      }
      /**
      * Gets path to the node. The path is an array containing starting offsets of consecutive ancestors of this node,
      * beginning from {@link module:engine/model/node~Node#root root}, down to this node's starting offset. The path can be used to
      * create {@link module:engine/model/position~Position Position} instance.
      *
      * ```ts
      * const abc = new Text( 'abc' );
      * const foo = new Text( 'foo' );
      * const h1 = new Element( 'h1', null, new Text( 'header' ) );
      * const p = new Element( 'p', null, [ abc, foo ] );
      * const div = new Element( 'div', null, [ h1, p ] );
      * foo.getPath(); // Returns [ 1, 3 ]. `foo` is in `p` which is in `div`. `p` starts at offset 1, while `foo` at 3.
      * h1.getPath(); // Returns [ 0 ].
      * div.getPath(); // Returns [].
      * ```
      */
      getPath() {
        const path = [];
        let node = this;
        while (node.parent) {
          path.unshift(node.startOffset);
          node = node.parent;
        }
        return path;
      }
      /**
      * Returns ancestors array of this node.
      *
      * @param options Options object.
      * @param options.includeSelf When set to `true` this node will be also included in parent's array.
      * @param options.parentFirst When set to `true`, array will be sorted from node's parent to root element,
      * otherwise root element will be the first item in the array.
      * @returns Array with ancestors.
      */
      getAncestors(options = {}) {
        const ancestors = [];
        let parent2 = options.includeSelf ? this : this.parent;
        while (parent2) {
          ancestors[options.parentFirst ? "push" : "unshift"](parent2);
          parent2 = parent2.parent;
        }
        return ancestors;
      }
      /**
      * Returns a {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}
      * which is a common ancestor of both nodes.
      *
      * @param node The second node.
      * @param options Options object.
      * @param options.includeSelf When set to `true` both nodes will be considered "ancestors" too.
      * Which means that if e.g. node A is inside B, then their common ancestor will be B.
      */
      getCommonAncestor(node, options = {}) {
        const ancestorsA = this.getAncestors(options);
        const ancestorsB = node.getAncestors(options);
        let i2 = 0;
        while (ancestorsA[i2] == ancestorsB[i2] && ancestorsA[i2]) {
          i2++;
        }
        return i2 === 0 ? null : ancestorsA[i2 - 1];
      }
      /**
      * Returns whether this node is before given node. `false` is returned if nodes are in different trees (for example,
      * in different {@link module:engine/model/documentfragment~DocumentFragment}s).
      *
      * @param node Node to compare with.
      */
      isBefore(node) {
        if (this == node) {
          return false;
        }
        if (this.root !== node.root) {
          return false;
        }
        const thisPath = this.getPath();
        const nodePath = node.getPath();
        const result2 = compareArrays(thisPath, nodePath);
        switch (result2) {
          case "prefix":
            return true;
          case "extension":
            return false;
          default:
            return thisPath[result2] < nodePath[result2];
        }
      }
      /**
      * Returns whether this node is after given node. `false` is returned if nodes are in different trees (for example,
      * in different {@link module:engine/model/documentfragment~DocumentFragment}s).
      *
      * @param node Node to compare with.
      */
      isAfter(node) {
        if (this == node) {
          return false;
        }
        if (this.root !== node.root) {
          return false;
        }
        return !this.isBefore(node);
      }
      /**
      * Checks if the node has an attribute with given key.
      *
      * @param key Key of attribute to check.
      * @returns `true` if attribute with given key is set on node, `false` otherwise.
      */
      hasAttribute(key) {
        return this._attrs.has(key);
      }
      /**
      * Gets an attribute value for given key or `undefined` if that attribute is not set on node.
      *
      * @param key Key of attribute to look for.
      * @returns Attribute value or `undefined`.
      */
      getAttribute(key) {
        return this._attrs.get(key);
      }
      /**
      * Returns iterator that iterates over this node's attributes.
      *
      * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.
      * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
      */
      getAttributes() {
        return this._attrs.entries();
      }
      /**
      * Returns iterator that iterates over this node's attribute keys.
      */
      getAttributeKeys() {
        return this._attrs.keys();
      }
      /**
      * Converts `Node` to plain object and returns it.
      *
      * @returns `Node` converted to plain object.
      */
      toJSON() {
        const json = {};
        if (this._attrs.size) {
          json.attributes = Array.from(this._attrs).reduce((result2, attr) => {
            result2[attr[0]] = attr[1];
            return result2;
          }, {});
        }
        return json;
      }
      /**
      * Creates a copy of this node, that is a node with exactly same attributes, and returns it.
      *
      * @internal
      * @returns Node with same attributes as this node.
      */
      _clone(_deep) {
        return new this.constructor(this._attrs);
      }
      /**
      * Removes this node from its parent.
      *
      * @internal
      * @see module:engine/model/writer~Writer#remove
      */
      _remove() {
        this.parent._removeChildren(this.index);
      }
      /**
      * Sets attribute on the node. If attribute with the same key already is set, it's value is overwritten.
      *
      * @see module:engine/model/writer~Writer#setAttribute
      * @internal
      * @param key Key of attribute to set.
      * @param value Attribute value.
      */
      _setAttribute(key, value) {
        this._attrs.set(key, value);
      }
      /**
      * Removes all attributes from the node and sets given attributes.
      *
      * @see module:engine/model/writer~Writer#setAttributes
      * @internal
      * @param attrs Attributes to set. See {@link module:utils/tomap~toMap} for a list of accepted values.
      */
      _setAttributesTo(attrs) {
        this._attrs = toMap(attrs);
      }
      /**
      * Removes an attribute with given key from the node.
      *
      * @see module:engine/model/writer~Writer#removeAttribute
      * @internal
      * @param key Key of attribute to remove.
      * @returns `true` if the attribute was set on the element, `false` otherwise.
      */
      _removeAttribute(key) {
        return this._attrs.delete(key);
      }
      /**
      * Removes all attributes from the node.
      *
      * @see module:engine/model/writer~Writer#clearAttributes
      * @internal
      */
      _clearAttributes() {
        this._attrs.clear();
      }
    };
    Node$1.prototype.is = function(type) {
      return type === "node" || type === "model:node";
    };
    class NodeList {
      /**
      * Creates a node list.
      *
      * @internal
      * @param nodes Nodes contained in this node list.
      */
      constructor(nodes) {
        /**
        * Nodes contained in this node list.
        */
        __publicField(this, "_nodes", []);
        /**
        * This array maps numbers (offsets) to node that is placed at that offset.
        *
        * This array is similar to `_nodes` with the difference that one node may occupy multiple consecutive items in the array.
        *
        * This array is needed to quickly retrieve a node that is placed at given offset.
        */
        __publicField(this, "_offsetToNode", []);
        if (nodes) {
          this._insertNodes(0, nodes);
        }
      }
      /**
      * Iterable interface.
      *
      * Iterates over all nodes contained inside this node list.
      */
      [Symbol.iterator]() {
        return this._nodes[Symbol.iterator]();
      }
      /**
      * Number of nodes contained inside this node list.
      */
      get length() {
        return this._nodes.length;
      }
      /**
      * Sum of {@link module:engine/model/node~Node#offsetSize offset sizes} of all nodes contained inside this node list.
      */
      get maxOffset() {
        return this._offsetToNode.length;
      }
      /**
      * Gets the node at the given index. Returns `null` if incorrect index was passed.
      */
      getNode(index) {
        return this._nodes[index] || null;
      }
      /**
      * Gets the node at the given offset. Returns `null` if incorrect offset was passed.
      */
      getNodeAtOffset(offset2) {
        return this._offsetToNode[offset2] || null;
      }
      /**
      * Returns an index of the given node or `null` if given node does not have a parent.
      *
      * This is an alias to {@link module:engine/model/node~Node#index}.
      */
      getNodeIndex(node) {
        return node.index;
      }
      /**
      * Returns the offset at which given node is placed in its parent or `null` if given node does not have a parent.
      *
      * This is an alias to {@link module:engine/model/node~Node#startOffset}.
      */
      getNodeStartOffset(node) {
        return node.startOffset;
      }
      /**
      * Converts index to offset in node list.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `model-nodelist-index-out-of-bounds` if given index is less
      * than `0` or more than {@link #length}.
      */
      indexToOffset(index) {
        if (index == this._nodes.length) {
          return this.maxOffset;
        }
        const node = this._nodes[index];
        if (!node) {
          throw new CKEditorError("model-nodelist-index-out-of-bounds", this);
        }
        return this.getNodeStartOffset(node);
      }
      /**
      * Converts offset in node list to index.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `model-nodelist-offset-out-of-bounds` if given offset is less
      * than `0` or more than {@link #maxOffset}.
      */
      offsetToIndex(offset2) {
        if (offset2 == this._offsetToNode.length) {
          return this._nodes.length;
        }
        const node = this._offsetToNode[offset2];
        if (!node) {
          throw new CKEditorError("model-nodelist-offset-out-of-bounds", this, {
            offset: offset2,
            nodeList: this
          });
        }
        return this.getNodeIndex(node);
      }
      /**
      * Inserts given nodes at given index.
      *
      * @internal
      * @param index Index at which nodes should be inserted.
      * @param nodes Nodes to be inserted.
      */
      _insertNodes(index, nodes) {
        for (const node of nodes) {
          if (!(node instanceof Node$1)) {
            throw new CKEditorError("model-nodelist-insertnodes-not-node", this);
          }
        }
        const nodesArray = Array.from(nodes);
        const offsetsArray = makeOffsetsArray(nodesArray);
        let offset2 = this.indexToOffset(index);
        this._nodes = spliceArray(this._nodes, nodesArray, index, 0);
        this._offsetToNode = spliceArray(this._offsetToNode, offsetsArray, offset2, 0);
        for (let i2 = index; i2 < this._nodes.length; i2++) {
          this._nodes[i2]._index = i2;
          this._nodes[i2]._startOffset = offset2;
          offset2 += this._nodes[i2].offsetSize;
        }
      }
      /**
      * Removes one or more nodes starting at the given index.
      *
      * @internal
      * @param indexStart Index of the first node to remove.
      * @param howMany Number of nodes to remove.
      * @returns Array containing removed nodes.
      */
      _removeNodes(indexStart, howMany = 1) {
        if (howMany == 0) {
          return [];
        }
        let offset2 = this.indexToOffset(indexStart);
        const nodes = this._nodes.splice(indexStart, howMany);
        const lastNode = nodes[nodes.length - 1];
        const removedOffsetSum = lastNode.startOffset + lastNode.offsetSize - offset2;
        this._offsetToNode.splice(offset2, removedOffsetSum);
        for (const node of nodes) {
          node._index = null;
          node._startOffset = null;
        }
        for (let i2 = indexStart; i2 < this._nodes.length; i2++) {
          this._nodes[i2]._index = i2;
          this._nodes[i2]._startOffset = offset2;
          offset2 += this._nodes[i2].offsetSize;
        }
        return nodes;
      }
      /**
      * Converts `NodeList` instance to an array containing nodes that were inserted in the node list. Nodes
      * are also converted to their plain object representation.
      *
      * @returns `NodeList` instance converted to `Array`.
      */
      toJSON() {
        return this._nodes.map((node) => node.toJSON());
      }
    }
    function makeOffsetsArray(nodes) {
      const offsets = [];
      for (const node of nodes) {
        const start2 = offsets.length;
        offsets.length += node.offsetSize;
        offsets.fill(node, start2);
      }
      return offsets;
    }
    class Text extends Node$1 {
      /**
      * Creates a text node.
      *
      * **Note:** Constructor of this class shouldn't be used directly in the code.
      * Use the {@link module:engine/model/writer~Writer#createText} method instead.
      *
      * @internal
      * @param data Node's text.
      * @param attrs Node's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.
      */
      constructor(data, attrs) {
        super(attrs);
        /**
        * Text data contained in this text node.
        *
        * @internal
        */
        __publicField(this, "_data");
        this._data = data || "";
      }
      /**
      * @inheritDoc
      */
      get offsetSize() {
        return this.data.length;
      }
      /**
      * Returns a text data contained in the node.
      */
      get data() {
        return this._data;
      }
      /**
      * Converts `Text` instance to plain object and returns it.
      *
      * @returns`Text` instance converted to plain object.
      */
      toJSON() {
        const json = super.toJSON();
        json.data = this.data;
        return json;
      }
      /**
      * Creates a copy of this text node and returns it. Created text node has same text data and attributes as original text node.
      *
      * @internal
      * @returns `Text` instance created using given plain object.
      */
      _clone() {
        return new Text(this.data, this.getAttributes());
      }
      /**
      * Creates a `Text` instance from given plain object (i.e. parsed JSON string).
      *
      * @param json Plain object to be converted to `Text`.
      * @returns `Text` instance created using given plain object.
      */
      static fromJSON(json) {
        return new Text(json.data, json.attributes);
      }
    }
    Text.prototype.is = function(type) {
      return type === "$text" || type === "model:$text" || // This are legacy values kept for backward compatibility.
      type === "text" || type === "model:text" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
      type === "node" || type === "model:node";
    };
    class TextProxy extends TypeCheckable {
      /**
      * Creates a text proxy.
      *
      * @internal
      * @param textNode Text node which part is represented by this text proxy.
      * @param offsetInText Offset in {@link module:engine/model/textproxy~TextProxy#textNode text node} from which the text proxy
      * starts.
      * @param length Text proxy length, that is how many text node's characters, starting from `offsetInText` it represents.
      */
      constructor(textNode, offsetInText, length) {
        super();
        /**
        * Text node which part is represented by this text proxy.
        */
        __publicField(this, "textNode");
        /**
        * Text data represented by this text proxy.
        */
        __publicField(this, "data");
        /**
        * Offset in {@link module:engine/model/textproxy~TextProxy#textNode text node} from which the text proxy starts.
        */
        __publicField(this, "offsetInText");
        this.textNode = textNode;
        if (offsetInText < 0 || offsetInText > textNode.offsetSize) {
          throw new CKEditorError("model-textproxy-wrong-offsetintext", this);
        }
        if (length < 0 || offsetInText + length > textNode.offsetSize) {
          throw new CKEditorError("model-textproxy-wrong-length", this);
        }
        this.data = textNode.data.substring(offsetInText, offsetInText + length);
        this.offsetInText = offsetInText;
      }
      /**
      * Offset at which this text proxy starts in it's parent.
      *
      * @see module:engine/model/node~Node#startOffset
      */
      get startOffset() {
        return this.textNode.startOffset !== null ? this.textNode.startOffset + this.offsetInText : null;
      }
      /**
      * Offset size of this text proxy. Equal to the number of characters represented by the text proxy.
      *
      * @see module:engine/model/node~Node#offsetSize
      */
      get offsetSize() {
        return this.data.length;
      }
      /**
      * Offset at which this text proxy ends in it's parent.
      *
      * @see module:engine/model/node~Node#endOffset
      */
      get endOffset() {
        return this.startOffset !== null ? this.startOffset + this.offsetSize : null;
      }
      /**
      * Flag indicating whether `TextProxy` instance covers only part of the original {@link module:engine/model/text~Text text node}
      * (`true`) or the whole text node (`false`).
      *
      * This is `false` when text proxy starts at the very beginning of {@link module:engine/model/textproxy~TextProxy#textNode textNode}
      * ({@link module:engine/model/textproxy~TextProxy#offsetInText offsetInText} equals `0`) and text proxy sizes is equal to
      * text node size.
      */
      get isPartial() {
        return this.offsetSize !== this.textNode.offsetSize;
      }
      /**
      * Parent of this text proxy, which is same as parent of text node represented by this text proxy.
      */
      get parent() {
        return this.textNode.parent;
      }
      /**
      * Root of this text proxy, which is same as root of text node represented by this text proxy.
      */
      get root() {
        return this.textNode.root;
      }
      /**
      * Gets path to this text proxy.
      *
      * @see module:engine/model/node~Node#getPath
      */
      getPath() {
        const path = this.textNode.getPath();
        if (path.length > 0) {
          path[path.length - 1] += this.offsetInText;
        }
        return path;
      }
      /**
      * Returns ancestors array of this text proxy.
      *
      * @param options Options object.
      * @param options.includeSelf When set to `true` this text proxy will be also included in parent's array.
      * @param options.parentFirst When set to `true`, array will be sorted from text proxy parent to root element,
      * otherwise root element will be the first item in the array.
      * @returns Array with ancestors.
      */
      getAncestors(options = {}) {
        const ancestors = [];
        let parent2 = options.includeSelf ? this : this.parent;
        while (parent2) {
          ancestors[options.parentFirst ? "push" : "unshift"](parent2);
          parent2 = parent2.parent;
        }
        return ancestors;
      }
      /**
      * Checks if this text proxy has an attribute for given key.
      *
      * @param key Key of attribute to check.
      * @returns `true` if attribute with given key is set on text proxy, `false` otherwise.
      */
      hasAttribute(key) {
        return this.textNode.hasAttribute(key);
      }
      /**
      * Gets an attribute value for given key or `undefined` if that attribute is not set on text proxy.
      *
      * @param key Key of attribute to look for.
      * @returns Attribute value or `undefined`.
      */
      getAttribute(key) {
        return this.textNode.getAttribute(key);
      }
      /**
      * Returns iterator that iterates over this node's attributes. Attributes are returned as arrays containing two
      * items. First one is attribute key and second is attribute value.
      *
      * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
      */
      getAttributes() {
        return this.textNode.getAttributes();
      }
      /**
      * Returns iterator that iterates over this node's attribute keys.
      */
      getAttributeKeys() {
        return this.textNode.getAttributeKeys();
      }
    }
    TextProxy.prototype.is = function(type) {
      return type === "$textProxy" || type === "model:$textProxy" || // This are legacy values kept for backward compatibility.
      type === "textProxy" || type === "model:textProxy";
    };
    let Element$2 = class Element2 extends Node$1 {
      /**
      * Creates a model element.
      *
      * **Note:** Constructor of this class shouldn't be used directly in the code.
      * Use the {@link module:engine/model/writer~Writer#createElement} method instead.
      *
      * @internal
      * @param name Element's name.
      * @param attrs Element's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.
      * @param children One or more nodes to be inserted as children of created element.
      */
      constructor(name, attrs, children) {
        super(attrs);
        /**
        * Element name.
        */
        __publicField(this, "name");
        /**
        * List of children nodes.
        */
        __publicField(this, "_children", new NodeList());
        this.name = name;
        if (children) {
          this._insertChild(0, children);
        }
      }
      /**
      * Number of this element's children.
      */
      get childCount() {
        return this._children.length;
      }
      /**
      * Sum of {@link module:engine/model/node~Node#offsetSize offset sizes} of all of this element's children.
      */
      get maxOffset() {
        return this._children.maxOffset;
      }
      /**
      * Is `true` if there are no nodes inside this element, `false` otherwise.
      */
      get isEmpty() {
        return this.childCount === 0;
      }
      /**
      * Gets the child at the given index. Returns `null` if incorrect index was passed.
      *
      * @param index Index in this element.
      * @returns Child node.
      */
      getChild(index) {
        return this._children.getNode(index);
      }
      /**
      * Gets the child at the given offset. Returns `null` if incorrect index was passed.
      *
      * @param offset Offset in this element.
      * @returns Child node.
      */
      getChildAtOffset(offset2) {
        return this._children.getNodeAtOffset(offset2);
      }
      /**
      * Returns an iterator that iterates over all of this element's children.
      */
      getChildren() {
        return this._children[Symbol.iterator]();
      }
      /**
      * Returns an index of the given child node. Returns `null` if given node is not a child of this element.
      *
      * @param node Child node to look for.
      * @returns Child node's index in this element.
      */
      getChildIndex(node) {
        return this._children.getNodeIndex(node);
      }
      /**
      * Returns the starting offset of given child. Starting offset is equal to the sum of
      * {@link module:engine/model/node~Node#offsetSize offset sizes} of all node's siblings that are before it. Returns `null` if
      * given node is not a child of this element.
      *
      * @param node Child node to look for.
      * @returns Child node's starting offset.
      */
      getChildStartOffset(node) {
        return this._children.getNodeStartOffset(node);
      }
      /**
      * Returns index of a node that occupies given offset. If given offset is too low, returns `0`. If given offset is
      * too high, returns {@link module:engine/model/element~Element#getChildIndex index after last child}.
      *
      * ```ts
      * const textNode = new Text( 'foo' );
      * const pElement = new Element( 'p' );
      * const divElement = new Element( [ textNode, pElement ] );
      * divElement.offsetToIndex( -1 ); // Returns 0, because offset is too low.
      * divElement.offsetToIndex( 0 ); // Returns 0, because offset 0 is taken by `textNode` which is at index 0.
      * divElement.offsetToIndex( 1 ); // Returns 0, because `textNode` has `offsetSize` equal to 3, so it occupies offset 1 too.
      * divElement.offsetToIndex( 2 ); // Returns 0.
      * divElement.offsetToIndex( 3 ); // Returns 1.
      * divElement.offsetToIndex( 4 ); // Returns 2. There are no nodes at offset 4, so last available index is returned.
      * ```
      */
      offsetToIndex(offset2) {
        return this._children.offsetToIndex(offset2);
      }
      /**
      * Returns a descendant node by its path relative to this element.
      *
      * ```ts
      * // <this>a<b>c</b></this>
      * this.getNodeByPath( [ 0 ] );     // -> "a"
      * this.getNodeByPath( [ 1 ] );     // -> <b>
      * this.getNodeByPath( [ 1, 0 ] );  // -> "c"
      * ```
      *
      * @param relativePath Path of the node to find, relative to this element.
      */
      getNodeByPath(relativePath) {
        let node = this;
        for (const offset2 of relativePath) {
          node = node.getChildAtOffset(offset2);
        }
        return node;
      }
      /**
      * Returns the parent element of the given name. Returns null if the element is not inside the desired parent.
      *
      * @param parentName The name of the parent element to find.
      * @param options Options object.
      * @param options.includeSelf When set to `true` this node will be also included while searching.
      */
      findAncestor(parentName, options = {}) {
        let parent2 = options.includeSelf ? this : this.parent;
        while (parent2) {
          if (parent2.name === parentName) {
            return parent2;
          }
          parent2 = parent2.parent;
        }
        return null;
      }
      /**
      * Converts `Element` instance to plain object and returns it. Takes care of converting all of this element's children.
      *
      * @returns `Element` instance converted to plain object.
      */
      toJSON() {
        const json = super.toJSON();
        json.name = this.name;
        if (this._children.length > 0) {
          json.children = [];
          for (const node of this._children) {
            json.children.push(node.toJSON());
          }
        }
        return json;
      }
      /**
      * Creates a copy of this element and returns it. Created element has the same name and attributes as the original element.
      * If clone is deep, the original element's children are also cloned. If not, then empty element is returned.
      *
      * @internal
      * @param deep If set to `true` clones element and all its children recursively. When set to `false`,
      * element will be cloned without any child.
      */
      _clone(deep = false) {
        const children = deep ? Array.from(this._children).map((node) => node._clone(true)) : void 0;
        return new Element2(this.name, this.getAttributes(), children);
      }
      /**
      * {@link module:engine/model/element~Element#_insertChild Inserts} one or more nodes at the end of this element.
      *
      * @see module:engine/model/writer~Writer#append
      * @internal
      * @param nodes Nodes to be inserted.
      */
      _appendChild(nodes) {
        this._insertChild(this.childCount, nodes);
      }
      /**
      * Inserts one or more nodes at the given index and sets {@link module:engine/model/node~Node#parent parent} of these nodes
      * to this element.
      *
      * @see module:engine/model/writer~Writer#insert
      * @internal
      * @param index Index at which nodes should be inserted.
      * @param items Items to be inserted.
      */
      _insertChild(index, items) {
        const nodes = normalize$1(items);
        for (const node of nodes) {
          if (node.parent !== null) {
            node._remove();
          }
          node.parent = this;
        }
        this._children._insertNodes(index, nodes);
      }
      /**
      * Removes one or more nodes starting at the given index and sets
      * {@link module:engine/model/node~Node#parent parent} of these nodes to `null`.
      *
      * @see module:engine/model/writer~Writer#remove
      * @internal
      * @param index Index of the first node to remove.
      * @param howMany Number of nodes to remove.
      * @returns Array containing removed nodes.
      */
      _removeChildren(index, howMany = 1) {
        const nodes = this._children._removeNodes(index, howMany);
        for (const node of nodes) {
          node.parent = null;
        }
        return nodes;
      }
      /**
      * Creates an `Element` instance from given plain object (i.e. parsed JSON string).
      * Converts `Element` children to proper nodes.
      *
      * @param json Plain object to be converted to `Element`.
      * @returns `Element` instance created using given plain object.
      */
      static fromJSON(json) {
        let children;
        if (json.children) {
          children = [];
          for (const child of json.children) {
            if (child.name) {
              children.push(Element2.fromJSON(child));
            } else {
              children.push(Text.fromJSON(child));
            }
          }
        }
        return new Element2(json.name, json.attributes, children);
      }
    };
    Element$2.prototype.is = function(type, name) {
      if (!name) {
        return type === "element" || type === "model:element" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === "node" || type === "model:node";
      }
      return name === this.name && (type === "element" || type === "model:element");
    };
    function normalize$1(nodes) {
      if (typeof nodes == "string") {
        return [
          new Text(nodes)
        ];
      }
      if (!isIterable(nodes)) {
        nodes = [
          nodes
        ];
      }
      return Array.from(nodes).map((node) => {
        if (typeof node == "string") {
          return new Text(node);
        }
        if (node instanceof TextProxy) {
          return new Text(node.data, node.getAttributes());
        }
        return node;
      });
    }
    class TreeWalker {
      /**
      * Creates a range iterator. All parameters are optional, but you have to specify either `boundaries` or `startPosition`.
      *
      * @param options Object with configuration.
      */
      constructor(options) {
        /**
        * Walking direction. Defaults `'forward'`.
        */
        __publicField(this, "direction");
        /**
        * Iterator boundaries.
        *
        * When the iterator is walking `'forward'` on the end of boundary or is walking `'backward'`
        * on the start of boundary, then `{ done: true }` is returned.
        *
        * If boundaries are not defined they are set before first and after last child of the root node.
        */
        __publicField(this, "boundaries");
        /**
        * Flag indicating whether all consecutive characters with the same attributes should be
        * returned as one {@link module:engine/model/textproxy~TextProxy} (`true`) or one by one (`false`).
        */
        __publicField(this, "singleCharacters");
        /**
        * Flag indicating whether iterator should enter elements or not. If the iterator is shallow child nodes of any
        * iterated node will not be returned along with `elementEnd` tag.
        */
        __publicField(this, "shallow");
        /**
        * Flag indicating whether iterator should ignore `elementEnd` tags. If the option is true walker will not
        * return a parent node of the start position. If this option is `true` each {@link module:engine/model/element~Element} will
        * be returned once, while if the option is `false` they might be returned twice:
        * for `'elementStart'` and `'elementEnd'`.
        */
        __publicField(this, "ignoreElementEnd");
        /**
        * Iterator position. This is always static position, even if the initial position was a
        * {@link module:engine/model/liveposition~LivePosition live position}. If start position is not defined then position depends
        * on {@link #direction}. If direction is `'forward'` position starts form the beginning, when direction
        * is `'backward'` position starts from the end.
        */
        __publicField(this, "_position");
        /**
        * Start boundary cached for optimization purposes.
        */
        __publicField(this, "_boundaryStartParent");
        /**
        * End boundary cached for optimization purposes.
        */
        __publicField(this, "_boundaryEndParent");
        /**
        * Parent of the most recently visited node. Cached for optimization purposes.
        */
        __publicField(this, "_visitedParent");
        if (!options || !options.boundaries && !options.startPosition) {
          throw new CKEditorError("model-tree-walker-no-start-position", null);
        }
        const direction = options.direction || "forward";
        if (direction != "forward" && direction != "backward") {
          throw new CKEditorError("model-tree-walker-unknown-direction", options, {
            direction
          });
        }
        this.direction = direction;
        this.boundaries = options.boundaries || null;
        if (options.startPosition) {
          this._position = options.startPosition.clone();
        } else {
          this._position = Position._createAt(this.boundaries[this.direction == "backward" ? "end" : "start"]);
        }
        this.position.stickiness = "toNone";
        this.singleCharacters = !!options.singleCharacters;
        this.shallow = !!options.shallow;
        this.ignoreElementEnd = !!options.ignoreElementEnd;
        this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;
        this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;
        this._visitedParent = this.position.parent;
      }
      /**
      * Iterable interface.
      *
      * @returns {Iterable.<module:engine/model/treewalker~TreeWalkerValue>}
      */
      [Symbol.iterator]() {
        return this;
      }
      /**
      * Iterator position. This is always static position, even if the initial position was a
      * {@link module:engine/model/liveposition~LivePosition live position}. If start position is not defined then position depends
      * on {@link #direction}. If direction is `'forward'` position starts form the beginning, when direction
      * is `'backward'` position starts from the end.
      */
      get position() {
        return this._position;
      }
      /**
      * Moves {@link #position} in the {@link #direction} skipping values as long as the callback function returns `true`.
      *
      * For example:
      *
      * ```ts
      * walker.skip( value => value.type == 'text' ); // <paragraph>[]foo</paragraph> -> <paragraph>foo[]</paragraph>
      * walker.skip( () => true ); // Move the position to the end: <paragraph>[]foo</paragraph> -> <paragraph>foo</paragraph>[]
      * walker.skip( () => false ); // Do not move the position.
      * ```
      *
      * @param skip Callback function. Gets {@link module:engine/model/treewalker~TreeWalkerValue} and should
      * return `true` if the value should be skipped or `false` if not.
      */
      skip(skip) {
        let done, value, prevPosition, prevVisitedParent;
        do {
          prevPosition = this.position;
          prevVisitedParent = this._visitedParent;
          ({ done, value } = this.next());
        } while (!done && skip(value));
        if (!done) {
          this._position = prevPosition;
          this._visitedParent = prevVisitedParent;
        }
      }
      /**
      * Gets the next tree walker's value.
      */
      next() {
        if (this.direction == "forward") {
          return this._next();
        } else {
          return this._previous();
        }
      }
      /**
      * Makes a step forward in model. Moves the {@link #position} to the next position and returns the encountered value.
      */
      _next() {
        const previousPosition = this.position;
        const position = this.position.clone();
        const parent2 = this._visitedParent;
        if (parent2.parent === null && position.offset === parent2.maxOffset) {
          return {
            done: true,
            value: void 0
          };
        }
        if (parent2 === this._boundaryEndParent && position.offset == this.boundaries.end.offset) {
          return {
            done: true,
            value: void 0
          };
        }
        const textNodeAtPosition = getTextNodeAtPosition(position, parent2);
        const node = textNodeAtPosition || getNodeAfterPosition(position, parent2, textNodeAtPosition);
        if (node instanceof Element$2) {
          if (!this.shallow) {
            position.path.push(0);
            this._visitedParent = node;
          } else {
            if (this.boundaries && this.boundaries.end.isBefore(position)) {
              return {
                done: true,
                value: void 0
              };
            }
            position.offset++;
          }
          this._position = position;
          return formatReturnValue("elementStart", node, previousPosition, position, 1);
        }
        if (node instanceof Text) {
          let charactersCount;
          if (this.singleCharacters) {
            charactersCount = 1;
          } else {
            let offset2 = node.endOffset;
            if (this._boundaryEndParent == parent2 && this.boundaries.end.offset < offset2) {
              offset2 = this.boundaries.end.offset;
            }
            charactersCount = offset2 - position.offset;
          }
          const offsetInTextNode = position.offset - node.startOffset;
          const item = new TextProxy(node, offsetInTextNode, charactersCount);
          position.offset += charactersCount;
          this._position = position;
          return formatReturnValue("text", item, previousPosition, position, charactersCount);
        }
        position.path.pop();
        position.offset++;
        this._position = position;
        this._visitedParent = parent2.parent;
        if (this.ignoreElementEnd) {
          return this._next();
        }
        return formatReturnValue("elementEnd", parent2, previousPosition, position);
      }
      /**
      * Makes a step backward in model. Moves the {@link #position} to the previous position and returns the encountered value.
      */
      _previous() {
        const previousPosition = this.position;
        const position = this.position.clone();
        const parent2 = this._visitedParent;
        if (parent2.parent === null && position.offset === 0) {
          return {
            done: true,
            value: void 0
          };
        }
        if (parent2 == this._boundaryStartParent && position.offset == this.boundaries.start.offset) {
          return {
            done: true,
            value: void 0
          };
        }
        const positionParent = position.parent;
        const textNodeAtPosition = getTextNodeAtPosition(position, positionParent);
        const node = textNodeAtPosition || getNodeBeforePosition(position, positionParent, textNodeAtPosition);
        if (node instanceof Element$2) {
          position.offset--;
          if (this.shallow) {
            this._position = position;
            return formatReturnValue("elementStart", node, previousPosition, position, 1);
          }
          position.path.push(node.maxOffset);
          this._position = position;
          this._visitedParent = node;
          if (this.ignoreElementEnd) {
            return this._previous();
          }
          return formatReturnValue("elementEnd", node, previousPosition, position);
        }
        if (node instanceof Text) {
          let charactersCount;
          if (this.singleCharacters) {
            charactersCount = 1;
          } else {
            let offset2 = node.startOffset;
            if (this._boundaryStartParent == parent2 && this.boundaries.start.offset > offset2) {
              offset2 = this.boundaries.start.offset;
            }
            charactersCount = position.offset - offset2;
          }
          const offsetInTextNode = position.offset - node.startOffset;
          const item = new TextProxy(node, offsetInTextNode - charactersCount, charactersCount);
          position.offset -= charactersCount;
          this._position = position;
          return formatReturnValue("text", item, previousPosition, position, charactersCount);
        }
        position.path.pop();
        this._position = position;
        this._visitedParent = parent2.parent;
        return formatReturnValue("elementStart", parent2, previousPosition, position, 1);
      }
    }
    function formatReturnValue(type, item, previousPosition, nextPosition, length) {
      return {
        done: false,
        value: {
          type,
          item,
          previousPosition,
          nextPosition,
          length
        }
      };
    }
    class Position extends TypeCheckable {
      /**
      * Creates a position.
      *
      * @param root Root of the position.
      * @param path Position path. See {@link module:engine/model/position~Position#path}.
      * @param stickiness Position stickiness. See {@link module:engine/model/position~PositionStickiness}.
      */
      constructor(root2, path, stickiness = "toNone") {
        super();
        /**
        * Root of the position path.
        */
        __publicField(this, "root");
        /**
        * Position of the node in the tree. **Path contains offsets, not indexes.**
        *
        * Position can be placed before, after or in a {@link module:engine/model/node~Node node} if that node has
        * {@link module:engine/model/node~Node#offsetSize} greater than `1`. Items in position path are
        * {@link module:engine/model/node~Node#startOffset starting offsets} of position ancestors, starting from direct root children,
        * down to the position offset in it's parent.
        *
        * ```
        * ROOT
        *  |- P            before: [ 0 ]         after: [ 1 ]
        *  |- UL           before: [ 1 ]         after: [ 2 ]
        *     |- LI        before: [ 1, 0 ]      after: [ 1, 1 ]
        *     |  |- foo    before: [ 1, 0, 0 ]   after: [ 1, 0, 3 ]
        *     |- LI        before: [ 1, 1 ]      after: [ 1, 2 ]
        *        |- bar    before: [ 1, 1, 0 ]   after: [ 1, 1, 3 ]
        * ```
        *
        * `foo` and `bar` are representing {@link module:engine/model/text~Text text nodes}. Since text nodes has offset size
        * greater than `1` you can place position offset between their start and end:
        *
        * ```
        * ROOT
        *  |- P
        *  |- UL
        *     |- LI
        *     |  |- f^o|o  ^ has path: [ 1, 0, 1 ]   | has path: [ 1, 0, 2 ]
        *     |- LI
        *        |- b^a|r  ^ has path: [ 1, 1, 1 ]   | has path: [ 1, 1, 2 ]
        * ```
        */
        __publicField(this, "path");
        /**
        * Position stickiness. See {@link module:engine/model/position~PositionStickiness}.
        */
        __publicField(this, "stickiness");
        if (!root2.is("element") && !root2.is("documentFragment")) {
          throw new CKEditorError("model-position-root-invalid", root2);
        }
        if (!(path instanceof Array) || path.length === 0) {
          throw new CKEditorError("model-position-path-incorrect-format", root2, {
            path
          });
        }
        if (root2.is("rootElement")) {
          path = path.slice();
        } else {
          path = [
            ...root2.getPath(),
            ...path
          ];
          root2 = root2.root;
        }
        this.root = root2;
        this.path = path;
        this.stickiness = stickiness;
      }
      /**
      * Offset at which this position is located in its {@link module:engine/model/position~Position#parent parent}. It is equal
      * to the last item in position {@link module:engine/model/position~Position#path path}.
      *
      * @type {Number}
      */
      get offset() {
        return this.path[this.path.length - 1];
      }
      set offset(newOffset) {
        this.path[this.path.length - 1] = newOffset;
      }
      /**
      * Parent element of this position.
      *
      * Keep in mind that `parent` value is calculated when the property is accessed.
      * If {@link module:engine/model/position~Position#path position path}
      * leads to a non-existing element, `parent` property will throw error.
      *
      * Also it is a good idea to cache `parent` property if it is used frequently in an algorithm (i.e. in a long loop).
      */
      get parent() {
        let parent2 = this.root;
        for (let i2 = 0; i2 < this.path.length - 1; i2++) {
          parent2 = parent2.getChildAtOffset(this.path[i2]);
          if (!parent2) {
            throw new CKEditorError("model-position-path-incorrect", this, {
              position: this
            });
          }
        }
        if (parent2.is("$text")) {
          throw new CKEditorError("model-position-path-incorrect", this, {
            position: this
          });
        }
        return parent2;
      }
      /**
      * Position {@link module:engine/model/position~Position#offset offset} converted to an index in position's parent node. It is
      * equal to the {@link module:engine/model/node~Node#index index} of a node after this position. If position is placed
      * in text node, position index is equal to the index of that text node.
      */
      get index() {
        return this.parent.offsetToIndex(this.offset);
      }
      /**
      * Returns {@link module:engine/model/text~Text text node} instance in which this position is placed or `null` if this
      * position is not in a text node.
      */
      get textNode() {
        return getTextNodeAtPosition(this, this.parent);
      }
      /**
      * Node directly after this position. Returns `null` if this position is at the end of its parent, or if it is in a text node.
      */
      get nodeAfter() {
        const parent2 = this.parent;
        return getNodeAfterPosition(this, parent2, getTextNodeAtPosition(this, parent2));
      }
      /**
      * Node directly before this position. Returns `null` if this position is at the start of its parent, or if it is in a text node.
      */
      get nodeBefore() {
        const parent2 = this.parent;
        return getNodeBeforePosition(this, parent2, getTextNodeAtPosition(this, parent2));
      }
      /**
      * Is `true` if position is at the beginning of its {@link module:engine/model/position~Position#parent parent}, `false` otherwise.
      */
      get isAtStart() {
        return this.offset === 0;
      }
      /**
      * Is `true` if position is at the end of its {@link module:engine/model/position~Position#parent parent}, `false` otherwise.
      */
      get isAtEnd() {
        return this.offset == this.parent.maxOffset;
      }
      /**
      * Checks whether the position is valid in current model tree, that is whether it points to an existing place in the model.
      */
      isValid() {
        if (this.offset < 0) {
          return false;
        }
        let parent2 = this.root;
        for (let i2 = 0; i2 < this.path.length - 1; i2++) {
          parent2 = parent2.getChildAtOffset(this.path[i2]);
          if (!parent2) {
            return false;
          }
        }
        return this.offset <= parent2.maxOffset;
      }
      /**
      * Checks whether this position is before or after given position.
      *
      * This method is safe to use it on non-existing positions (for example during operational transformation).
      */
      compareWith(otherPosition) {
        if (this.root != otherPosition.root) {
          return "different";
        }
        const result2 = compareArrays(this.path, otherPosition.path);
        switch (result2) {
          case "same":
            return "same";
          case "prefix":
            return "before";
          case "extension":
            return "after";
          default:
            return this.path[result2] < otherPosition.path[result2] ? "before" : "after";
        }
      }
      /**
      * Gets the farthest position which matches the callback using
      * {@link module:engine/model/treewalker~TreeWalker TreeWalker}.
      *
      * For example:
      *
      * ```ts
      * getLastMatchingPosition( value => value.type == 'text' );
      * // <paragraph>[]foo</paragraph> -> <paragraph>foo[]</paragraph>
      *
      * getLastMatchingPosition( value => value.type == 'text', { direction: 'backward' } );
      * // <paragraph>foo[]</paragraph> -> <paragraph>[]foo</paragraph>
      *
      * getLastMatchingPosition( value => false );
      * // Do not move the position.
      * ```
      *
      * @param skip Callback function. Gets {@link module:engine/model/treewalker~TreeWalkerValue} and should
      * return `true` if the value should be skipped or `false` if not.
      * @param options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.
      *
      * @returns The position after the last item which matches the `skip` callback test.
      */
      getLastMatchingPosition(skip, options = {}) {
        options.startPosition = this;
        const treeWalker = new TreeWalker(options);
        treeWalker.skip(skip);
        return treeWalker.position;
      }
      /**
      * Returns a path to this position's parent. Parent path is equal to position {@link module:engine/model/position~Position#path path}
      * but without the last item.
      *
      * This method is safe to use it on non-existing positions (for example during operational transformation).
      *
      * @returns Path to the parent.
      */
      getParentPath() {
        return this.path.slice(0, -1);
      }
      /**
      * Returns ancestors array of this position, that is this position's parent and its ancestors.
      *
      * @returns Array with ancestors.
      */
      getAncestors() {
        const parent2 = this.parent;
        if (parent2.is("documentFragment")) {
          return [
            parent2
          ];
        } else {
          return parent2.getAncestors({
            includeSelf: true
          });
        }
      }
      /**
      * Returns the parent element of the given name. Returns null if the position is not inside the desired parent.
      *
      * @param parentName The name of the parent element to find.
      */
      findAncestor(parentName) {
        const parent2 = this.parent;
        if (parent2.is("element")) {
          return parent2.findAncestor(parentName, {
            includeSelf: true
          });
        }
        return null;
      }
      /**
      * Returns the slice of two position {@link #path paths} which is identical. The {@link #root roots}
      * of these two paths must be identical.
      *
      * This method is safe to use it on non-existing positions (for example during operational transformation).
      *
      * @param position The second position.
      * @returns The common path.
      */
      getCommonPath(position) {
        if (this.root != position.root) {
          return [];
        }
        const cmp = compareArrays(this.path, position.path);
        const diffAt = typeof cmp == "string" ? Math.min(this.path.length, position.path.length) : cmp;
        return this.path.slice(0, diffAt);
      }
      /**
      * Returns an {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}
      * which is a common ancestor of both positions. The {@link #root roots} of these two positions must be identical.
      *
      * @param position The second position.
      */
      getCommonAncestor(position) {
        const ancestorsA = this.getAncestors();
        const ancestorsB = position.getAncestors();
        let i2 = 0;
        while (ancestorsA[i2] == ancestorsB[i2] && ancestorsA[i2]) {
          i2++;
        }
        return i2 === 0 ? null : ancestorsA[i2 - 1];
      }
      /**
      * Returns a new instance of `Position`, that has same {@link #parent parent} but it's offset
      * is shifted by `shift` value (can be a negative value).
      *
      * This method is safe to use it on non-existing positions (for example during operational transformation).
      *
      * @param shift Offset shift. Can be a negative value.
      * @returns Shifted position.
      */
      getShiftedBy(shift2) {
        const shifted = this.clone();
        const offset2 = shifted.offset + shift2;
        shifted.offset = offset2 < 0 ? 0 : offset2;
        return shifted;
      }
      /**
      * Checks whether this position is after given position.
      *
      * This method is safe to use it on non-existing positions (for example during operational transformation).
      *
      * @see module:engine/model/position~Position#isBefore
      * @param  otherPosition Position to compare with.
      * @returns True if this position is after given position.
      */
      isAfter(otherPosition) {
        return this.compareWith(otherPosition) == "after";
      }
      /**
      * Checks whether this position is before given position.
      *
      * **Note:** watch out when using negation of the value returned by this method, because the negation will also
      * be `true` if positions are in different roots and you might not expect this. You should probably use
      * `a.isAfter( b ) || a.isEqual( b )` or `!a.isBefore( p ) && a.root == b.root` in most scenarios. If your
      * condition uses multiple `isAfter` and `isBefore` checks, build them so they do not use negated values, i.e.:
      *
      * ```ts
      * if ( a.isBefore( b ) && c.isAfter( d ) ) {
      * 	// do A.
      * } else {
      * 	// do B.
      * }
      * ```
      *
      * or, if you have only one if-branch:
      *
      * ```ts
      * if ( !( a.isBefore( b ) && c.isAfter( d ) ) {
      * 	// do B.
      * }
      * ```
      *
      * rather than:
      *
      * ```ts
      * if ( !a.isBefore( b ) || && !c.isAfter( d ) ) {
      * 	// do B.
      * } else {
      * 	// do A.
      * }
      * ```
      *
      * This method is safe to use it on non-existing positions (for example during operational transformation).
      *
      * @param otherPosition Position to compare with.
      * @returns True if this position is before given position.
      */
      isBefore(otherPosition) {
        return this.compareWith(otherPosition) == "before";
      }
      /**
      * Checks whether this position is equal to given position.
      *
      * This method is safe to use it on non-existing positions (for example during operational transformation).
      *
      * @param otherPosition Position to compare with.
      * @returns True if positions are same.
      */
      isEqual(otherPosition) {
        return this.compareWith(otherPosition) == "same";
      }
      /**
      * Checks whether this position is touching given position. Positions touch when there are no text nodes
      * or empty nodes in a range between them. Technically, those positions are not equal but in many cases
      * they are very similar or even indistinguishable.
      *
      * @param otherPosition Position to compare with.
      * @returns True if positions touch.
      */
      isTouching(otherPosition) {
        if (this.root !== otherPosition.root) {
          return false;
        }
        const commonLevel = Math.min(this.path.length, otherPosition.path.length);
        for (let level = 0; level < commonLevel; level++) {
          const diff2 = this.path[level] - otherPosition.path[level];
          if (diff2 < -1 || diff2 > 1) {
            return false;
          } else if (diff2 === 1) {
            return checkTouchingBranch(otherPosition, this, level);
          } else if (diff2 === -1) {
            return checkTouchingBranch(this, otherPosition, level);
          }
        }
        if (this.path.length === otherPosition.path.length) {
          return true;
        } else if (this.path.length > otherPosition.path.length) {
          return checkOnlyZeroes(this.path, commonLevel);
        } else {
          return checkOnlyZeroes(otherPosition.path, commonLevel);
        }
      }
      /**
      * Checks if two positions are in the same parent.
      *
      * This method is safe to use it on non-existing positions (for example during operational transformation).
      *
      * @param position Position to compare with.
      * @returns `true` if positions have the same parent, `false` otherwise.
      */
      hasSameParentAs(position) {
        if (this.root !== position.root) {
          return false;
        }
        const thisParentPath = this.getParentPath();
        const posParentPath = position.getParentPath();
        return compareArrays(thisParentPath, posParentPath) == "same";
      }
      /**
      * Returns a copy of this position that is transformed by given `operation`.
      *
      * The new position's parameters are updated accordingly to the effect of the `operation`.
      *
      * For example, if `n` nodes are inserted before the position, the returned position {@link ~Position#offset} will be
      * increased by `n`. If the position was in a merged element, it will be accordingly moved to the new element, etc.
      *
      * This method is safe to use it on non-existing positions (for example during operational transformation).
      *
      * @param operation Operation to transform by.
      * @returns Transformed position.
      */
      getTransformedByOperation(operation) {
        let result2;
        switch (operation.type) {
          case "insert":
            result2 = this._getTransformedByInsertOperation(operation);
            break;
          case "move":
          case "remove":
          case "reinsert":
            result2 = this._getTransformedByMoveOperation(operation);
            break;
          case "split":
            result2 = this._getTransformedBySplitOperation(operation);
            break;
          case "merge":
            result2 = this._getTransformedByMergeOperation(operation);
            break;
          default:
            result2 = Position._createAt(this);
            break;
        }
        return result2;
      }
      /**
      * Returns a copy of this position transformed by an insert operation.
      *
      * @internal
      */
      _getTransformedByInsertOperation(operation) {
        return this._getTransformedByInsertion(operation.position, operation.howMany);
      }
      /**
      * Returns a copy of this position transformed by a move operation.
      *
      * @internal
      */
      _getTransformedByMoveOperation(operation) {
        return this._getTransformedByMove(operation.sourcePosition, operation.targetPosition, operation.howMany);
      }
      /**
      * Returns a copy of this position transformed by a split operation.
      *
      * @internal
      */
      _getTransformedBySplitOperation(operation) {
        const movedRange = operation.movedRange;
        const isContained = movedRange.containsPosition(this) || movedRange.start.isEqual(this) && this.stickiness == "toNext";
        if (isContained) {
          return this._getCombined(operation.splitPosition, operation.moveTargetPosition);
        } else {
          if (operation.graveyardPosition) {
            return this._getTransformedByMove(operation.graveyardPosition, operation.insertionPosition, 1);
          } else {
            return this._getTransformedByInsertion(operation.insertionPosition, 1);
          }
        }
      }
      /**
      * Returns a copy of this position transformed by merge operation.
      *
      * @internal
      */
      _getTransformedByMergeOperation(operation) {
        const movedRange = operation.movedRange;
        const isContained = movedRange.containsPosition(this) || movedRange.start.isEqual(this);
        let pos;
        if (isContained) {
          pos = this._getCombined(operation.sourcePosition, operation.targetPosition);
          if (operation.sourcePosition.isBefore(operation.targetPosition)) {
            pos = pos._getTransformedByDeletion(operation.deletionPosition, 1);
          }
        } else if (this.isEqual(operation.deletionPosition)) {
          pos = Position._createAt(operation.deletionPosition);
        } else {
          pos = this._getTransformedByMove(operation.deletionPosition, operation.graveyardPosition, 1);
        }
        return pos;
      }
      /**
      * Returns a copy of this position that is updated by removing `howMany` nodes starting from `deletePosition`.
      * It may happen that this position is in a removed node. If that is the case, `null` is returned instead.
      *
      * @internal
      * @param deletePosition Position before the first removed node.
      * @param howMany How many nodes are removed.
      * @returns Transformed position or `null`.
      */
      _getTransformedByDeletion(deletePosition, howMany) {
        const transformed = Position._createAt(this);
        if (this.root != deletePosition.root) {
          return transformed;
        }
        if (compareArrays(deletePosition.getParentPath(), this.getParentPath()) == "same") {
          if (deletePosition.offset < this.offset) {
            if (deletePosition.offset + howMany > this.offset) {
              return null;
            } else {
              transformed.offset -= howMany;
            }
          }
        } else if (compareArrays(deletePosition.getParentPath(), this.getParentPath()) == "prefix") {
          const i2 = deletePosition.path.length - 1;
          if (deletePosition.offset <= this.path[i2]) {
            if (deletePosition.offset + howMany > this.path[i2]) {
              return null;
            } else {
              transformed.path[i2] -= howMany;
            }
          }
        }
        return transformed;
      }
      /**
      * Returns a copy of this position that is updated by inserting `howMany` nodes at `insertPosition`.
      *
      * @internal
      * @param insertPosition Position where nodes are inserted.
      * @param howMany How many nodes are inserted.
      * @returns Transformed position.
      */
      _getTransformedByInsertion(insertPosition, howMany) {
        const transformed = Position._createAt(this);
        if (this.root != insertPosition.root) {
          return transformed;
        }
        if (compareArrays(insertPosition.getParentPath(), this.getParentPath()) == "same") {
          if (insertPosition.offset < this.offset || insertPosition.offset == this.offset && this.stickiness != "toPrevious") {
            transformed.offset += howMany;
          }
        } else if (compareArrays(insertPosition.getParentPath(), this.getParentPath()) == "prefix") {
          const i2 = insertPosition.path.length - 1;
          if (insertPosition.offset <= this.path[i2]) {
            transformed.path[i2] += howMany;
          }
        }
        return transformed;
      }
      /**
      * Returns a copy of this position that is updated by moving `howMany` nodes from `sourcePosition` to `targetPosition`.
      *
      * @internal
      * @param sourcePosition Position before the first element to move.
      * @param targetPosition Position where moved elements will be inserted.
      * @param howMany How many consecutive nodes to move, starting from `sourcePosition`.
      * @returns Transformed position.
      */
      _getTransformedByMove(sourcePosition, targetPosition, howMany) {
        targetPosition = targetPosition._getTransformedByDeletion(sourcePosition, howMany);
        if (sourcePosition.isEqual(targetPosition)) {
          return Position._createAt(this);
        }
        const transformed = this._getTransformedByDeletion(sourcePosition, howMany);
        const isMoved = transformed === null || sourcePosition.isEqual(this) && this.stickiness == "toNext" || sourcePosition.getShiftedBy(howMany).isEqual(this) && this.stickiness == "toPrevious";
        if (isMoved) {
          return this._getCombined(sourcePosition, targetPosition);
        } else {
          return transformed._getTransformedByInsertion(targetPosition, howMany);
        }
      }
      /**
      * Returns a new position that is a combination of this position and given positions.
      *
      * The combined position is a copy of this position transformed by moving a range starting at `source` position
      * to the `target` position. It is expected that this position is inside the moved range.
      *
      * Example:
      *
      * ```ts
      * let original = model.createPositionFromPath( root, [ 2, 3, 1 ] );
      * let source = model.createPositionFromPath( root, [ 2, 2 ] );
      * let target = model.createPositionFromPath( otherRoot, [ 1, 1, 3 ] );
      * original._getCombined( source, target ); // path is [ 1, 1, 4, 1 ], root is `otherRoot`
      * ```
      *
      * Explanation:
      *
      * We have a position `[ 2, 3, 1 ]` and move some nodes from `[ 2, 2 ]` to `[ 1, 1, 3 ]`. The original position
      * was inside moved nodes and now should point to the new place. The moved nodes will be after
      * positions `[ 1, 1, 3 ]`, `[ 1, 1, 4 ]`, `[ 1, 1, 5 ]`. Since our position was in the second moved node,
      * the transformed position will be in a sub-tree of a node at `[ 1, 1, 4 ]`. Looking at original path, we
      * took care of `[ 2, 3 ]` part of it. Now we have to add the rest of the original path to the transformed path.
      * Finally, the transformed position will point to `[ 1, 1, 4, 1 ]`.
      *
      * @internal
      * @param source Beginning of the moved range.
      * @param target Position where the range is moved.
      * @returns Combined position.
      */
      _getCombined(source, target) {
        const i2 = source.path.length - 1;
        const combined = Position._createAt(target);
        combined.stickiness = this.stickiness;
        combined.offset = combined.offset + this.path[i2] - source.offset;
        combined.path = [
          ...combined.path,
          ...this.path.slice(i2 + 1)
        ];
        return combined;
      }
      /**
      * @inheritDoc
      */
      toJSON() {
        return {
          root: this.root.toJSON(),
          path: Array.from(this.path),
          stickiness: this.stickiness
        };
      }
      /**
      * Returns a new position that is equal to current position.
      */
      clone() {
        return new this.constructor(this.root, this.path, this.stickiness);
      }
      /**
      * Creates position at the given location. The location can be specified as:
      *
      * * a {@link module:engine/model/position~Position position},
      * * parent element and offset (offset defaults to `0`),
      * * parent element and `'end'` (sets position at the end of that element),
      * * {@link module:engine/model/item~Item model item} and `'before'` or `'after'` (sets position before or after given model item).
      *
      * This method is a shortcut to other factory methods such as:
      *
      * * {@link module:engine/model/position~Position._createBefore},
      * * {@link module:engine/model/position~Position._createAfter}.
      *
      * @internal
      * @param offset Offset or one of the flags. Used only when the first parameter is a {@link module:engine/model/item~Item model item}.
      * @param stickiness Position stickiness. Used only when the first parameter is a {@link module:engine/model/item~Item model item}.
      */
      static _createAt(itemOrPosition, offset2, stickiness = "toNone") {
        if (itemOrPosition instanceof Position) {
          return new Position(itemOrPosition.root, itemOrPosition.path, itemOrPosition.stickiness);
        } else {
          const node = itemOrPosition;
          if (offset2 == "end") {
            offset2 = node.maxOffset;
          } else if (offset2 == "before") {
            return this._createBefore(node, stickiness);
          } else if (offset2 == "after") {
            return this._createAfter(node, stickiness);
          } else if (offset2 !== 0 && !offset2) {
            throw new CKEditorError("model-createpositionat-offset-required", [
              this,
              itemOrPosition
            ]);
          }
          if (!node.is("element") && !node.is("documentFragment")) {
            throw new CKEditorError("model-position-parent-incorrect", [
              this,
              itemOrPosition
            ]);
          }
          const path = node.getPath();
          path.push(offset2);
          return new this(node.root, path, stickiness);
        }
      }
      /**
      * Creates a new position, after given {@link module:engine/model/item~Item model item}.
      *
      * @internal
      * @param item Item after which the position should be placed.
      * @param stickiness Position stickiness.
      */
      static _createAfter(item, stickiness) {
        if (!item.parent) {
          throw new CKEditorError("model-position-after-root", [
            this,
            item
          ], {
            root: item
          });
        }
        return this._createAt(item.parent, item.endOffset, stickiness);
      }
      /**
      * Creates a new position, before the given {@link module:engine/model/item~Item model item}.
      *
      * @internal
      * @param item Item before which the position should be placed.
      * @param stickiness Position stickiness.
      */
      static _createBefore(item, stickiness) {
        if (!item.parent) {
          throw new CKEditorError("model-position-before-root", item, {
            root: item
          });
        }
        return this._createAt(item.parent, item.startOffset, stickiness);
      }
      /**
      * Creates a `Position` instance from given plain object (i.e. parsed JSON string).
      *
      * @param json Plain object to be converted to `Position`.
      * @param doc Document object that will be position owner.
      * @returns `Position` instance created using given plain object.
      */
      static fromJSON(json, doc) {
        if (json.root === "$graveyard") {
          const pos = new Position(doc.graveyard, json.path);
          pos.stickiness = json.stickiness;
          return pos;
        }
        if (!doc.getRoot(json.root)) {
          throw new CKEditorError("model-position-fromjson-no-root", doc, {
            rootName: json.root
          });
        }
        return new Position(doc.getRoot(json.root), json.path, json.stickiness);
      }
    }
    Position.prototype.is = function(type) {
      return type === "position" || type === "model:position";
    };
    function getTextNodeAtPosition(position, positionParent) {
      const node = positionParent.getChildAtOffset(position.offset);
      if (node && node.is("$text") && node.startOffset < position.offset) {
        return node;
      }
      return null;
    }
    function getNodeAfterPosition(position, positionParent, textNode) {
      if (textNode !== null) {
        return null;
      }
      return positionParent.getChildAtOffset(position.offset);
    }
    function getNodeBeforePosition(position, positionParent, textNode) {
      if (textNode !== null) {
        return null;
      }
      return positionParent.getChild(positionParent.offsetToIndex(position.offset) - 1);
    }
    function checkTouchingBranch(left2, right2, level) {
      if (level + 1 === left2.path.length) {
        return false;
      }
      if (!checkOnlyZeroes(right2.path, level + 1)) {
        return false;
      }
      if (!checkOnlyMaxOffset(left2, level + 1)) {
        return false;
      }
      return true;
    }
    function checkOnlyZeroes(arr, idx) {
      while (idx < arr.length) {
        if (arr[idx] !== 0) {
          return false;
        }
        idx++;
      }
      return true;
    }
    function checkOnlyMaxOffset(pos, level) {
      let parent2 = pos.parent;
      let idx = pos.path.length - 1;
      let add2 = 0;
      while (idx >= level) {
        if (pos.path[idx] + add2 !== parent2.maxOffset) {
          return false;
        }
        add2 = 1;
        idx--;
        parent2 = parent2.parent;
      }
      return true;
    }
    class Range extends TypeCheckable {
      /**
      * Creates a range spanning from `start` position to `end` position.
      *
      * @param start The start position.
      * @param end The end position. If not set, the range will be collapsed at the `start` position.
      */
      constructor(start2, end2) {
        super();
        /**
        * Start position.
        */
        __publicField(this, "start");
        /**
        * End position.
        */
        __publicField(this, "end");
        this.start = Position._createAt(start2);
        this.end = end2 ? Position._createAt(end2) : Position._createAt(start2);
        this.start.stickiness = this.isCollapsed ? "toNone" : "toNext";
        this.end.stickiness = this.isCollapsed ? "toNone" : "toPrevious";
      }
      /**
      * Iterable interface.
      *
      * Iterates over all {@link module:engine/model/item~Item items} that are in this range and returns
      * them together with additional information like length or {@link module:engine/model/position~Position positions},
      * grouped as {@link module:engine/model/treewalker~TreeWalkerValue}.
      * It iterates over all {@link module:engine/model/textproxy~TextProxy text contents} that are inside the range
      * and all the {@link module:engine/model/element~Element}s that are entered into when iterating over this range.
      *
      * This iterator uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range
      * and `ignoreElementEnd` option set to `true`.
      */
      *[Symbol.iterator]() {
        yield* new TreeWalker({
          boundaries: this,
          ignoreElementEnd: true
        });
      }
      /**
      * Describes whether the range is collapsed, that is if {@link #start} and
      * {@link #end} positions are equal.
      */
      get isCollapsed() {
        return this.start.isEqual(this.end);
      }
      /**
      * Describes whether this range is flat, that is if {@link #start} position and
      * {@link #end} position are in the same {@link module:engine/model/position~Position#parent}.
      */
      get isFlat() {
        const startParentPath = this.start.getParentPath();
        const endParentPath = this.end.getParentPath();
        return compareArrays(startParentPath, endParentPath) == "same";
      }
      /**
      * Range root element.
      */
      get root() {
        return this.start.root;
      }
      /**
      * Checks whether this range contains given {@link module:engine/model/position~Position position}.
      *
      * @param position Position to check.
      * @returns `true` if given {@link module:engine/model/position~Position position} is contained
      * in this range,`false` otherwise.
      */
      containsPosition(position) {
        return position.isAfter(this.start) && position.isBefore(this.end);
      }
      /**
      * Checks whether this range contains given {@link ~Range range}.
      *
      * @param otherRange Range to check.
      * @param loose Whether the check is loose or strict. If the check is strict (`false`), compared range cannot
      * start or end at the same position as this range boundaries. If the check is loose (`true`), compared range can start, end or
      * even be equal to this range. Note that collapsed ranges are always compared in strict mode.
      * @returns {Boolean} `true` if given {@link ~Range range} boundaries are contained by this range, `false` otherwise.
      */
      containsRange(otherRange, loose = false) {
        if (otherRange.isCollapsed) {
          loose = false;
        }
        const containsStart = this.containsPosition(otherRange.start) || loose && this.start.isEqual(otherRange.start);
        const containsEnd = this.containsPosition(otherRange.end) || loose && this.end.isEqual(otherRange.end);
        return containsStart && containsEnd;
      }
      /**
      * Checks whether given {@link module:engine/model/item~Item} is inside this range.
      */
      containsItem(item) {
        const pos = Position._createBefore(item);
        return this.containsPosition(pos) || this.start.isEqual(pos);
      }
      /**
      * Two ranges are equal if their {@link #start} and {@link #end} positions are equal.
      *
      * @param otherRange Range to compare with.
      * @returns `true` if ranges are equal, `false` otherwise.
      */
      isEqual(otherRange) {
        return this.start.isEqual(otherRange.start) && this.end.isEqual(otherRange.end);
      }
      /**
      * Checks and returns whether this range intersects with given range.
      *
      * @param otherRange Range to compare with.
      * @returns `true` if ranges intersect, `false` otherwise.
      */
      isIntersecting(otherRange) {
        return this.start.isBefore(otherRange.end) && this.end.isAfter(otherRange.start);
      }
      /**
      * Computes which part(s) of this {@link ~Range range} is not a part of given {@link ~Range range}.
      * Returned array contains zero, one or two {@link ~Range ranges}.
      *
      * Examples:
      *
      * ```ts
      * let range = model.createRange(
      * 	model.createPositionFromPath( root, [ 2, 7 ] ),
      * 	model.createPositionFromPath( root, [ 4, 0, 1 ] )
      * );
      * let otherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 5 ] ) );
      * let transformed = range.getDifference( otherRange );
      * // transformed array has no ranges because `otherRange` contains `range`
      *
      * otherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 3 ] ) );
      * transformed = range.getDifference( otherRange );
      * // transformed array has one range: from [ 3 ] to [ 4, 0, 1 ]
      *
      * otherRange = model.createRange( model.createPositionFromPath( root, [ 3 ] ), model.createPositionFromPath( root, [ 4 ] ) );
      * transformed = range.getDifference( otherRange );
      * // transformed array has two ranges: from [ 2, 7 ] to [ 3 ] and from [ 4 ] to [ 4, 0, 1 ]
      * ```
      *
      * @param otherRange Range to differentiate against.
      * @returns The difference between ranges.
      */
      getDifference(otherRange) {
        const ranges = [];
        if (this.isIntersecting(otherRange)) {
          if (this.containsPosition(otherRange.start)) {
            ranges.push(new Range(this.start, otherRange.start));
          }
          if (this.containsPosition(otherRange.end)) {
            ranges.push(new Range(otherRange.end, this.end));
          }
        } else {
          ranges.push(new Range(this.start, this.end));
        }
        return ranges;
      }
      /**
      * Returns an intersection of this {@link ~Range range} and given {@link ~Range range}.
      * Intersection is a common part of both of those ranges. If ranges has no common part, returns `null`.
      *
      * Examples:
      *
      * ```ts
      * let range = model.createRange(
      * 	model.createPositionFromPath( root, [ 2, 7 ] ),
      * 	model.createPositionFromPath( root, [ 4, 0, 1 ] )
      * );
      * let otherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 2 ] ) );
      * let transformed = range.getIntersection( otherRange ); // null - ranges have no common part
      *
      * otherRange = model.createRange( model.createPositionFromPath( root, [ 3 ] ), model.createPositionFromPath( root, [ 5 ] ) );
      * transformed = range.getIntersection( otherRange ); // range from [ 3 ] to [ 4, 0, 1 ]
      * ```
      *
      * @param otherRange Range to check for intersection.
      * @returns A common part of given ranges or `null` if ranges have no common part.
      */
      getIntersection(otherRange) {
        if (this.isIntersecting(otherRange)) {
          let commonRangeStart = this.start;
          let commonRangeEnd = this.end;
          if (this.containsPosition(otherRange.start)) {
            commonRangeStart = otherRange.start;
          }
          if (this.containsPosition(otherRange.end)) {
            commonRangeEnd = otherRange.end;
          }
          return new Range(commonRangeStart, commonRangeEnd);
        }
        return null;
      }
      /**
      * Returns a range created by joining this {@link ~Range range} with the given {@link ~Range range}.
      * If ranges have no common part, returns `null`.
      *
      * Examples:
      *
      * ```ts
      * let range = model.createRange(
      * 	model.createPositionFromPath( root, [ 2, 7 ] ),
      * 	model.createPositionFromPath( root, [ 4, 0, 1 ] )
      * );
      * let otherRange = model.createRange(
      * 	model.createPositionFromPath( root, [ 1 ] ),
      * 	model.createPositionFromPath( root, [ 2 ] )
       * );
      * let transformed = range.getJoined( otherRange ); // null - ranges have no common part
      *
      * otherRange = model.createRange(
      * 	model.createPositionFromPath( root, [ 3 ] ),
      * 	model.createPositionFromPath( root, [ 5 ] )
      * );
      * transformed = range.getJoined( otherRange ); // range from [ 2, 7 ] to [ 5 ]
      * ```
      *
      * @param otherRange Range to be joined.
      * @param loose Whether the intersection check is loose or strict. If the check is strict (`false`),
      * ranges are tested for intersection or whether start/end positions are equal. If the check is loose (`true`),
      * compared range is also checked if it's {@link module:engine/model/position~Position#isTouching touching} current range.
      * @returns A sum of given ranges or `null` if ranges have no common part.
      */
      getJoined(otherRange, loose = false) {
        let shouldJoin = this.isIntersecting(otherRange);
        if (!shouldJoin) {
          if (this.start.isBefore(otherRange.start)) {
            shouldJoin = loose ? this.end.isTouching(otherRange.start) : this.end.isEqual(otherRange.start);
          } else {
            shouldJoin = loose ? otherRange.end.isTouching(this.start) : otherRange.end.isEqual(this.start);
          }
        }
        if (!shouldJoin) {
          return null;
        }
        let startPosition = this.start;
        let endPosition = this.end;
        if (otherRange.start.isBefore(startPosition)) {
          startPosition = otherRange.start;
        }
        if (otherRange.end.isAfter(endPosition)) {
          endPosition = otherRange.end;
        }
        return new Range(startPosition, endPosition);
      }
      /**
      * Computes and returns the smallest set of {@link #isFlat flat} ranges, that covers this range in whole.
      *
      * See an example of a model structure (`[` and `]` are range boundaries):
      *
      * ```
      * root                                                            root
      *  |- element DIV                         DIV             P2              P3             DIV
      *  |   |- element H                   H        P1        f o o           b a r       H         P4
      *  |   |   |- "fir[st"             fir[st     lorem                               se]cond     ipsum
      *  |   |- element P1
      *  |   |   |- "lorem"                                              ||
      *  |- element P2                                                   ||
      *  |   |- "foo"                                                    VV
      *  |- element P3
      *  |   |- "bar"                                                   root
      *  |- element DIV                         DIV             [P2             P3]             DIV
      *  |   |- element H                   H       [P1]       f o o           b a r        H         P4
      *  |   |   |- "se]cond"            fir[st]    lorem                               [se]cond     ipsum
      *  |   |- element P4
      *  |   |   |- "ipsum"
      * ```
      *
      * As it can be seen, letters contained in the range are: `stloremfoobarse`, spread across different parents.
      * We are looking for minimal set of flat ranges that contains the same nodes.
      *
      * Minimal flat ranges for above range `( [ 0, 0, 3 ], [ 3, 0, 2 ] )` will be:
      *
      * ```
      * ( [ 0, 0, 3 ], [ 0, 0, 5 ] ) = "st"
      * ( [ 0, 1 ], [ 0, 2 ] ) = element P1 ("lorem")
      * ( [ 1 ], [ 3 ] ) = element P2, element P3 ("foobar")
      * ( [ 3, 0, 0 ], [ 3, 0, 2 ] ) = "se"
      * ```
      *
      * **Note:** if an {@link module:engine/model/element~Element element} is not wholly contained in this range, it won't be returned
      * in any of the returned flat ranges. See in the example how `H` elements at the beginning and at the end of the range
      * were omitted. Only their parts that were wholly in the range were returned.
      *
      * **Note:** this method is not returning flat ranges that contain no nodes.
      *
      * @returns Array of flat ranges covering this range.
      */
      getMinimalFlatRanges() {
        const ranges = [];
        const diffAt = this.start.getCommonPath(this.end).length;
        const pos = Position._createAt(this.start);
        let posParent = pos.parent;
        while (pos.path.length > diffAt + 1) {
          const howMany = posParent.maxOffset - pos.offset;
          if (howMany !== 0) {
            ranges.push(new Range(pos, pos.getShiftedBy(howMany)));
          }
          pos.path = pos.path.slice(0, -1);
          pos.offset++;
          posParent = posParent.parent;
        }
        while (pos.path.length <= this.end.path.length) {
          const offset2 = this.end.path[pos.path.length - 1];
          const howMany = offset2 - pos.offset;
          if (howMany !== 0) {
            ranges.push(new Range(pos, pos.getShiftedBy(howMany)));
          }
          pos.offset = offset2;
          pos.path.push(0);
        }
        return ranges;
      }
      /**
      * Creates a {@link module:engine/model/treewalker~TreeWalker TreeWalker} instance with this range as a boundary.
      *
      * For example, to iterate over all items in the entire document root:
      *
      * ```ts
      * // Create a range spanning over the entire root content:
      * const range = editor.model.createRangeIn( editor.model.document.getRoot() );
      *
      * // Iterate over all items in this range:
      * for ( const value of range.getWalker() ) {
      * 	console.log( value.item );
      * }
      * ```
      *
      * @param options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.
      */
      getWalker(options = {}) {
        options.boundaries = this;
        return new TreeWalker(options);
      }
      /**
      * Returns an iterator that iterates over all {@link module:engine/model/item~Item items} that are in this range and returns
      * them.
      *
      * This method uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range and `ignoreElementEnd` option
      * set to `true`. However it returns only {@link module:engine/model/item~Item model items},
      * not {@link module:engine/model/treewalker~TreeWalkerValue}.
      *
      * You may specify additional options for the tree walker. See {@link module:engine/model/treewalker~TreeWalker} for
      * a full list of available options.
      *
      * @param options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.
      */
      *getItems(options = {}) {
        options.boundaries = this;
        options.ignoreElementEnd = true;
        const treeWalker = new TreeWalker(options);
        for (const value of treeWalker) {
          yield value.item;
        }
      }
      /**
      * Returns an iterator that iterates over all {@link module:engine/model/position~Position positions} that are boundaries or
      * contained in this range.
      *
      * This method uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range. However it returns only
      * {@link module:engine/model/position~Position positions}, not {@link module:engine/model/treewalker~TreeWalkerValue}.
      *
      * You may specify additional options for the tree walker. See {@link module:engine/model/treewalker~TreeWalker} for
      * a full list of available options.
      *
      * @param options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.
      */
      *getPositions(options = {}) {
        options.boundaries = this;
        const treeWalker = new TreeWalker(options);
        yield treeWalker.position;
        for (const value of treeWalker) {
          yield value.nextPosition;
        }
      }
      /**
      * Returns a range that is a result of transforming this range by given `operation`.
      *
      * **Note:** transformation may break one range into multiple ranges (for example, when a part of the range is
      * moved to a different part of document tree). For this reason, an array is returned by this method and it
      * may contain one or more `Range` instances.
      *
      * @param operation Operation to transform range by.
      * @returns Range which is the result of transformation.
      */
      getTransformedByOperation(operation) {
        switch (operation.type) {
          case "insert":
            return this._getTransformedByInsertOperation(operation);
          case "move":
          case "remove":
          case "reinsert":
            return this._getTransformedByMoveOperation(operation);
          case "split":
            return [
              this._getTransformedBySplitOperation(operation)
            ];
          case "merge":
            return [
              this._getTransformedByMergeOperation(operation)
            ];
        }
        return [
          new Range(this.start, this.end)
        ];
      }
      /**
      * Returns a range that is a result of transforming this range by multiple `operations`.
      *
      * @see ~Range#getTransformedByOperation
      * @param operations Operations to transform the range by.
      * @returns Range which is the result of transformation.
      */
      getTransformedByOperations(operations2) {
        const ranges = [
          new Range(this.start, this.end)
        ];
        for (const operation of operations2) {
          for (let i2 = 0; i2 < ranges.length; i2++) {
            const result2 = ranges[i2].getTransformedByOperation(operation);
            ranges.splice(i2, 1, ...result2);
            i2 += result2.length - 1;
          }
        }
        for (let i2 = 0; i2 < ranges.length; i2++) {
          const range2 = ranges[i2];
          for (let j2 = i2 + 1; j2 < ranges.length; j2++) {
            const next = ranges[j2];
            if (range2.containsRange(next) || next.containsRange(range2) || range2.isEqual(next)) {
              ranges.splice(j2, 1);
            }
          }
        }
        return ranges;
      }
      /**
      * Returns an {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}
      * which is a common ancestor of the range's both ends (in which the entire range is contained).
      */
      getCommonAncestor() {
        return this.start.getCommonAncestor(this.end);
      }
      /**
      * Returns an {@link module:engine/model/element~Element Element} contained by the range.
      * The element will be returned when it is the **only** node within the range and **fullycontained**
      * at the same time.
      */
      getContainedElement() {
        if (this.isCollapsed) {
          return null;
        }
        const nodeAfterStart = this.start.nodeAfter;
        const nodeBeforeEnd = this.end.nodeBefore;
        if (nodeAfterStart && nodeAfterStart.is("element") && nodeAfterStart === nodeBeforeEnd) {
          return nodeAfterStart;
        }
        return null;
      }
      /**
      * Converts `Range` to plain object and returns it.
      *
      * @returns `Node` converted to plain object.
      */
      toJSON() {
        return {
          start: this.start.toJSON(),
          end: this.end.toJSON()
        };
      }
      /**
      * Returns a new range that is equal to current range.
      */
      clone() {
        return new this.constructor(this.start, this.end);
      }
      /**
      * Returns a result of transforming a copy of this range by insert operation.
      *
      * One or more ranges may be returned as a result of this transformation.
      *
      * @internal
      */
      _getTransformedByInsertOperation(operation, spread2 = false) {
        return this._getTransformedByInsertion(operation.position, operation.howMany, spread2);
      }
      /**
      * Returns a result of transforming a copy of this range by move operation.
      *
      * One or more ranges may be returned as a result of this transformation.
      *
      * @internal
      */
      _getTransformedByMoveOperation(operation, spread2 = false) {
        const sourcePosition = operation.sourcePosition;
        const howMany = operation.howMany;
        const targetPosition = operation.targetPosition;
        return this._getTransformedByMove(sourcePosition, targetPosition, howMany, spread2);
      }
      /**
      * Returns a result of transforming a copy of this range by split operation.
      *
      * Always one range is returned. The transformation is done in a way to not break the range.
      *
      * @internal
      */
      _getTransformedBySplitOperation(operation) {
        const start2 = this.start._getTransformedBySplitOperation(operation);
        let end2 = this.end._getTransformedBySplitOperation(operation);
        if (this.end.isEqual(operation.insertionPosition)) {
          end2 = this.end.getShiftedBy(1);
        }
        if (start2.root != end2.root) {
          end2 = this.end.getShiftedBy(-1);
        }
        return new Range(start2, end2);
      }
      /**
      * Returns a result of transforming a copy of this range by merge operation.
      *
      * Always one range is returned. The transformation is done in a way to not break the range.
      *
      * @internal
      */
      _getTransformedByMergeOperation(operation) {
        if (this.start.isEqual(operation.targetPosition) && this.end.isEqual(operation.deletionPosition)) {
          return new Range(this.start);
        }
        let start2 = this.start._getTransformedByMergeOperation(operation);
        let end2 = this.end._getTransformedByMergeOperation(operation);
        if (start2.root != end2.root) {
          end2 = this.end.getShiftedBy(-1);
        }
        if (start2.isAfter(end2)) {
          if (operation.sourcePosition.isBefore(operation.targetPosition)) {
            start2 = Position._createAt(end2);
            start2.offset = 0;
          } else {
            if (!operation.deletionPosition.isEqual(start2)) {
              end2 = operation.deletionPosition;
            }
            start2 = operation.targetPosition;
          }
          return new Range(start2, end2);
        }
        return new Range(start2, end2);
      }
      /**
      * Returns an array containing one or two {@link ~Range ranges} that are a result of transforming this
      * {@link ~Range range} by inserting `howMany` nodes at `insertPosition`. Two {@link ~Range ranges} are
      * returned if the insertion was inside this {@link ~Range range} and `spread` is set to `true`.
      *
      * Examples:
      *
      * ```ts
      * let range = model.createRange(
      * 	model.createPositionFromPath( root, [ 2, 7 ] ),
      * 	model.createPositionFromPath( root, [ 4, 0, 1 ] )
      * );
      * let transformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 1 ] ), 2 );
      * // transformed array has one range from [ 4, 7 ] to [ 6, 0, 1 ]
      *
      * transformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 4, 0, 0 ] ), 4 );
      * // transformed array has one range from [ 2, 7 ] to [ 4, 0, 5 ]
      *
      * transformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 3, 2 ] ), 4 );
      * // transformed array has one range, which is equal to original range
      *
      * transformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 3, 2 ] ), 4, true );
      * // transformed array has two ranges: from [ 2, 7 ] to [ 3, 2 ] and from [ 3, 6 ] to [ 4, 0, 1 ]
      * ```
      *
      * @internal
      * @param insertPosition Position where nodes are inserted.
      * @param howMany How many nodes are inserted.
      * @param spread Flag indicating whether this range should be spread if insertion
      * was inside the range. Defaults to `false`.
      * @returns Result of the transformation.
      */
      _getTransformedByInsertion(insertPosition, howMany, spread2 = false) {
        if (spread2 && this.containsPosition(insertPosition)) {
          return [
            new Range(this.start, insertPosition),
            new Range(insertPosition.getShiftedBy(howMany), this.end._getTransformedByInsertion(insertPosition, howMany))
          ];
        } else {
          const range2 = new Range(this.start, this.end);
          range2.start = range2.start._getTransformedByInsertion(insertPosition, howMany);
          range2.end = range2.end._getTransformedByInsertion(insertPosition, howMany);
          return [
            range2
          ];
        }
      }
      /**
      * Returns an array containing {@link ~Range ranges} that are a result of transforming this
      * {@link ~Range range} by moving `howMany` nodes from `sourcePosition` to `targetPosition`.
      *
      * @internal
      * @param sourcePosition Position from which nodes are moved.
      * @param targetPosition Position to where nodes are moved.
      * @param howMany How many nodes are moved.
      * @param spread Whether the range should be spread if the move points inside the range.
      * @returns  Result of the transformation.
      */
      _getTransformedByMove(sourcePosition, targetPosition, howMany, spread2 = false) {
        if (this.isCollapsed) {
          const newPos = this.start._getTransformedByMove(sourcePosition, targetPosition, howMany);
          return [
            new Range(newPos)
          ];
        }
        const moveRange = Range._createFromPositionAndShift(sourcePosition, howMany);
        const insertPosition = targetPosition._getTransformedByDeletion(sourcePosition, howMany);
        if (this.containsPosition(targetPosition) && !spread2) {
          if (moveRange.containsPosition(this.start) || moveRange.containsPosition(this.end)) {
            const start2 = this.start._getTransformedByMove(sourcePosition, targetPosition, howMany);
            const end2 = this.end._getTransformedByMove(sourcePosition, targetPosition, howMany);
            return [
              new Range(start2, end2)
            ];
          }
        }
        let result2;
        const differenceSet = this.getDifference(moveRange);
        let difference2 = null;
        const common2 = this.getIntersection(moveRange);
        if (differenceSet.length == 1) {
          difference2 = new Range(differenceSet[0].start._getTransformedByDeletion(sourcePosition, howMany), differenceSet[0].end._getTransformedByDeletion(sourcePosition, howMany));
        } else if (differenceSet.length == 2) {
          difference2 = new Range(this.start, this.end._getTransformedByDeletion(sourcePosition, howMany));
        }
        if (difference2) {
          result2 = difference2._getTransformedByInsertion(insertPosition, howMany, common2 !== null || spread2);
        } else {
          result2 = [];
        }
        if (common2) {
          const transformedCommon = new Range(common2.start._getCombined(moveRange.start, insertPosition), common2.end._getCombined(moveRange.start, insertPosition));
          if (result2.length == 2) {
            result2.splice(1, 0, transformedCommon);
          } else {
            result2.push(transformedCommon);
          }
        }
        return result2;
      }
      /**
      * Returns a copy of this range that is transformed by deletion of `howMany` nodes from `deletePosition`.
      *
      * If the deleted range is intersecting with the transformed range, the transformed range will be shrank.
      *
      * If the deleted range contains transformed range, `null` will be returned.
      *
      * @internal
      * @param deletionPosition Position from which nodes are removed.
      * @param howMany How many nodes are removed.
      * @returns Result of the transformation.
      */
      _getTransformedByDeletion(deletePosition, howMany) {
        let newStart = this.start._getTransformedByDeletion(deletePosition, howMany);
        let newEnd = this.end._getTransformedByDeletion(deletePosition, howMany);
        if (newStart == null && newEnd == null) {
          return null;
        }
        if (newStart == null) {
          newStart = deletePosition;
        }
        if (newEnd == null) {
          newEnd = deletePosition;
        }
        return new Range(newStart, newEnd);
      }
      /**
      * Creates a new range, spreading from specified {@link module:engine/model/position~Position position} to a position moved by
      * given `shift`. If `shift` is a negative value, shifted position is treated as the beginning of the range.
      *
      * @internal
      * @param position Beginning of the range.
      * @param shift How long the range should be.
      */
      static _createFromPositionAndShift(position, shift2) {
        const start2 = position;
        const end2 = position.getShiftedBy(shift2);
        return shift2 > 0 ? new this(start2, end2) : new this(end2, start2);
      }
      /**
      * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of
      * that element and ends after the last child of that element.
      *
      * @internal
      * @param element Element which is a parent for the range.
      */
      static _createIn(element) {
        return new this(Position._createAt(element, 0), Position._createAt(element, element.maxOffset));
      }
      /**
      * Creates a range that starts before given {@link module:engine/model/item~Item model item} and ends after it.
      *
      * @internal
      */
      static _createOn(item) {
        return this._createFromPositionAndShift(Position._createBefore(item), item.offsetSize);
      }
      /**
      * Combines all ranges from the passed array into a one range. At least one range has to be passed.
      * Passed ranges must not have common parts.
      *
      * The first range from the array is a reference range. If other ranges start or end on the exactly same position where
      * the reference range, they get combined into one range.
      *
      * ```
      * [  ][]  [    ][ ][             ][ ][]  [  ]  // Passed ranges, shown sorted
      * [    ]                                       // The result of the function if the first range was a reference range.
      *         [                           ]        // The result of the function if the third-to-seventh range was a reference range.
      *                                        [  ]  // The result of the function if the last range was a reference range.
      * ```
      *
      * @internal
      * @param ranges Ranges to combine.
      * @returns Combined range.
      */
      static _createFromRanges(ranges) {
        if (ranges.length === 0) {
          throw new CKEditorError("range-create-from-ranges-empty-array", null);
        } else if (ranges.length == 1) {
          return ranges[0].clone();
        }
        const ref2 = ranges[0];
        ranges.sort((a2, b2) => {
          return a2.start.isAfter(b2.start) ? 1 : -1;
        });
        const refIndex = ranges.indexOf(ref2);
        const result2 = new this(ref2.start, ref2.end);
        for (let i2 = refIndex - 1; i2 >= 0; i2--) {
          if (ranges[i2].end.isEqual(result2.start)) {
            result2.start = Position._createAt(ranges[i2].start);
          } else {
            break;
          }
        }
        for (let i2 = refIndex + 1; i2 < ranges.length; i2++) {
          if (ranges[i2].start.isEqual(result2.end)) {
            result2.end = Position._createAt(ranges[i2].end);
          } else {
            break;
          }
        }
        return result2;
      }
      /**
      * Creates a `Range` instance from given plain object (i.e. parsed JSON string).
      *
      * @param json Plain object to be converted to `Range`.
      * @param doc Document object that will be range owner.
      * @returns `Range` instance created using given plain object.
      */
      static fromJSON(json, doc) {
        return new this(Position.fromJSON(json.start, doc), Position.fromJSON(json.end, doc));
      }
    }
    Range.prototype.is = function(type) {
      return type === "range" || type === "model:range";
    };
    class Mapper extends (/* @__PURE__ */ EmitterMixin()) {
      /**
      * Creates an instance of the mapper.
      */
      constructor() {
        super();
        /**
        * Model element to view element mapping.
        */
        __publicField(this, "_modelToViewMapping", /* @__PURE__ */ new WeakMap());
        /**
        * View element to model element mapping.
        */
        __publicField(this, "_viewToModelMapping", /* @__PURE__ */ new WeakMap());
        /**
        * A map containing callbacks between view element names and functions evaluating length of view elements
        * in model.
        */
        __publicField(this, "_viewToModelLengthCallbacks", /* @__PURE__ */ new Map());
        /**
        * Model marker name to view elements mapping.
        *
        * Keys are `String`s while values are `Set`s with {@link module:engine/view/element~Element view elements}.
        * One marker (name) can be mapped to multiple elements.
        */
        __publicField(this, "_markerNameToElements", /* @__PURE__ */ new Map());
        /**
        * View element to model marker names mapping.
        *
        * This is reverse to {@link ~Mapper#_markerNameToElements} map.
        */
        __publicField(this, "_elementToMarkerNames", /* @__PURE__ */ new Map());
        /**
        * The map of removed view elements with their current root (used for deferred unbinding).
        */
        __publicField(this, "_deferredBindingRemovals", /* @__PURE__ */ new Map());
        /**
        * Stores marker names of markers which have changed due to unbinding a view element (so it is assumed that the view element
        * has been removed, moved or renamed).
        */
        __publicField(this, "_unboundMarkerNames", /* @__PURE__ */ new Set());
        this.on("modelToViewPosition", (evt, data) => {
          if (data.viewPosition) {
            return;
          }
          const viewContainer = this._modelToViewMapping.get(data.modelPosition.parent);
          if (!viewContainer) {
            throw new CKEditorError("mapping-model-position-view-parent-not-found", this, {
              modelPosition: data.modelPosition
            });
          }
          data.viewPosition = this.findPositionIn(viewContainer, data.modelPosition.offset);
        }, {
          priority: "low"
        });
        this.on("viewToModelPosition", (evt, data) => {
          if (data.modelPosition) {
            return;
          }
          const viewBlock = this.findMappedViewAncestor(data.viewPosition);
          const modelParent = this._viewToModelMapping.get(viewBlock);
          const modelOffset = this._toModelOffset(data.viewPosition.parent, data.viewPosition.offset, viewBlock);
          data.modelPosition = Position._createAt(modelParent, modelOffset);
        }, {
          priority: "low"
        });
      }
      /**
      * Marks model and view elements as corresponding. Corresponding elements can be retrieved by using
      * the {@link module:engine/conversion/mapper~Mapper#toModelElement toModelElement} and
      * {@link module:engine/conversion/mapper~Mapper#toViewElement toViewElement} methods.
      * The information that elements are bound is also used to translate positions.
      *
      * @param modelElement Model element.
      * @param viewElement View element.
      */
      bindElements(modelElement, viewElement) {
        this._modelToViewMapping.set(modelElement, viewElement);
        this._viewToModelMapping.set(viewElement, modelElement);
      }
      /**
      * Unbinds the given {@link module:engine/view/element~Element view element} from the map.
      *
      * **Note:** view-to-model binding will be removed, if it existed. However, corresponding model-to-view binding
      * will be removed only if model element is still bound to the passed `viewElement`.
      *
      * This behavior allows for re-binding model element to another view element without fear of losing the new binding
      * when the previously bound view element is unbound.
      *
      * @param viewElement View element to unbind.
      * @param options The options object.
      * @param options.defer Controls whether the binding should be removed immediately or deferred until a
      * {@link #flushDeferredBindings `flushDeferredBindings()`} call.
      */
      unbindViewElement(viewElement, options = {}) {
        const modelElement = this.toModelElement(viewElement);
        if (this._elementToMarkerNames.has(viewElement)) {
          for (const markerName of this._elementToMarkerNames.get(viewElement)) {
            this._unboundMarkerNames.add(markerName);
          }
        }
        if (options.defer) {
          this._deferredBindingRemovals.set(viewElement, viewElement.root);
        } else {
          this._viewToModelMapping.delete(viewElement);
          if (this._modelToViewMapping.get(modelElement) == viewElement) {
            this._modelToViewMapping.delete(modelElement);
          }
        }
      }
      /**
      * Unbinds the given {@link module:engine/model/element~Element model element} from the map.
      *
      * **Note:** the model-to-view binding will be removed, if it existed. However, the corresponding view-to-model binding
      * will be removed only if the view element is still bound to the passed `modelElement`.
      *
      * This behavior lets for re-binding view element to another model element without fear of losing the new binding
      * when the previously bound model element is unbound.
      *
      * @param modelElement Model element to unbind.
      */
      unbindModelElement(modelElement) {
        const viewElement = this.toViewElement(modelElement);
        this._modelToViewMapping.delete(modelElement);
        if (this._viewToModelMapping.get(viewElement) == modelElement) {
          this._viewToModelMapping.delete(viewElement);
        }
      }
      /**
      * Binds the given marker name with the given {@link module:engine/view/element~Element view element}. The element
      * will be added to the current set of elements bound with the given marker name.
      *
      * @param element Element to bind.
      * @param name Marker name.
      */
      bindElementToMarker(element, name) {
        const elements2 = this._markerNameToElements.get(name) || /* @__PURE__ */ new Set();
        elements2.add(element);
        const names2 = this._elementToMarkerNames.get(element) || /* @__PURE__ */ new Set();
        names2.add(name);
        this._markerNameToElements.set(name, elements2);
        this._elementToMarkerNames.set(element, names2);
      }
      /**
      * Unbinds an element from given marker name.
      *
      * @param element Element to unbind.
      * @param name Marker name.
      */
      unbindElementFromMarkerName(element, name) {
        const nameToElements = this._markerNameToElements.get(name);
        if (nameToElements) {
          nameToElements.delete(element);
          if (nameToElements.size == 0) {
            this._markerNameToElements.delete(name);
          }
        }
        const elementToNames = this._elementToMarkerNames.get(element);
        if (elementToNames) {
          elementToNames.delete(name);
          if (elementToNames.size == 0) {
            this._elementToMarkerNames.delete(element);
          }
        }
      }
      /**
      * Returns all marker names of markers which have changed due to unbinding a view element (so it is assumed that the view element
      * has been removed, moved or renamed) since the last flush. After returning, the marker names list is cleared.
      */
      flushUnboundMarkerNames() {
        const markerNames = Array.from(this._unboundMarkerNames);
        this._unboundMarkerNames.clear();
        return markerNames;
      }
      /**
      * Unbinds all deferred binding removals of view elements that in the meantime were not re-attached to some root or document fragment.
      *
      * See: {@link #unbindViewElement `unbindViewElement()`}.
      */
      flushDeferredBindings() {
        for (const [viewElement, root2] of this._deferredBindingRemovals) {
          if (viewElement.root == root2) {
            this.unbindViewElement(viewElement);
          }
        }
        this._deferredBindingRemovals = /* @__PURE__ */ new Map();
      }
      /**
      * Removes all model to view and view to model bindings.
      */
      clearBindings() {
        this._modelToViewMapping = /* @__PURE__ */ new WeakMap();
        this._viewToModelMapping = /* @__PURE__ */ new WeakMap();
        this._markerNameToElements = /* @__PURE__ */ new Map();
        this._elementToMarkerNames = /* @__PURE__ */ new Map();
        this._unboundMarkerNames = /* @__PURE__ */ new Set();
        this._deferredBindingRemovals = /* @__PURE__ */ new Map();
      }
      toModelElement(viewElement) {
        return this._viewToModelMapping.get(viewElement);
      }
      toViewElement(modelElement) {
        return this._modelToViewMapping.get(modelElement);
      }
      /**
      * Gets the corresponding model range.
      *
      * @param viewRange View range.
      * @returns Corresponding model range.
      */
      toModelRange(viewRange) {
        return new Range(this.toModelPosition(viewRange.start), this.toModelPosition(viewRange.end));
      }
      /**
      * Gets the corresponding view range.
      *
      * @param modelRange Model range.
      * @returns Corresponding view range.
      */
      toViewRange(modelRange) {
        return new Range$1(this.toViewPosition(modelRange.start), this.toViewPosition(modelRange.end));
      }
      /**
      * Gets the corresponding model position.
      *
      * @fires viewToModelPosition
      * @param viewPosition View position.
      * @returns Corresponding model position.
      */
      toModelPosition(viewPosition) {
        const data = {
          viewPosition,
          mapper: this
        };
        this.fire("viewToModelPosition", data);
        return data.modelPosition;
      }
      /**
      * Gets the corresponding view position.
      *
      * @fires modelToViewPosition
      * @param modelPosition Model position.
      * @param options Additional options for position mapping process.
      * @param options.isPhantom Should be set to `true` if the model position to map is pointing to a place
      * in model tree which no longer exists. For example, it could be an end of a removed model range.
      * @returns Corresponding view position.
      */
      toViewPosition(modelPosition, options = {}) {
        const data = {
          modelPosition,
          mapper: this,
          isPhantom: options.isPhantom
        };
        this.fire("modelToViewPosition", data);
        return data.viewPosition;
      }
      /**
      * Gets all view elements bound to the given marker name.
      *
      * @param name Marker name.
      * @returns View elements bound with the given marker name or `null`
      * if no elements are bound to the given marker name.
      */
      markerNameToElements(name) {
        const boundElements = this._markerNameToElements.get(name);
        if (!boundElements) {
          return null;
        }
        const elements2 = /* @__PURE__ */ new Set();
        for (const element of boundElements) {
          if (element.is("attributeElement")) {
            for (const clone2 of element.getElementsWithSameId()) {
              elements2.add(clone2);
            }
          } else {
            elements2.add(element);
          }
        }
        return elements2;
      }
      /**
      * Registers a callback that evaluates the length in the model of a view element with the given name.
      *
      * The callback is fired with one argument, which is a view element instance. The callback is expected to return
      * a number representing the length of the view element in the model.
      *
      * ```ts
      * // List item in view may contain nested list, which have other list items. In model though,
      * // the lists are represented by flat structure. Because of those differences, length of list view element
      * // may be greater than one. In the callback it's checked how many nested list items are in evaluated list item.
      *
      * function getViewListItemLength( element ) {
      * 	let length = 1;
      *
      * 	for ( let child of element.getChildren() ) {
      * 		if ( child.name == 'ul' || child.name == 'ol' ) {
      * 			for ( let item of child.getChildren() ) {
      * 				length += getViewListItemLength( item );
      * 			}
      * 		}
      * 	}
      *
      * 	return length;
      * }
      *
      * mapper.registerViewToModelLength( 'li', getViewListItemLength );
      * ```
      *
      * @param viewElementName Name of view element for which callback is registered.
      * @param lengthCallback Function return a length of view element instance in model.
      */
      registerViewToModelLength(viewElementName, lengthCallback) {
        this._viewToModelLengthCallbacks.set(viewElementName, lengthCallback);
      }
      /**
      * For the given `viewPosition`, finds and returns the closest ancestor of this position that has a mapping to
      * the model.
      *
      * @param viewPosition Position for which a mapped ancestor should be found.
      */
      findMappedViewAncestor(viewPosition) {
        let parent2 = viewPosition.parent;
        while (!this._viewToModelMapping.has(parent2)) {
          parent2 = parent2.parent;
        }
        return parent2;
      }
      /**
      * Calculates model offset based on the view position and the block element.
      *
      * Example:
      *
      * ```html
      * <p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, p ) -> 5
      * ```
      *
      * Is a sum of:
      *
      * ```html
      * <p>foo|<b>bar</b></p> // _toModelOffset( p, 3, p ) -> 3
      * <p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, b ) -> 2
      * ```
      *
      * @param viewParent Position parent.
      * @param viewOffset Position offset.
      * @param viewBlock Block used as a base to calculate offset.
      * @returns Offset in the model.
      */
      _toModelOffset(viewParent, viewOffset, viewBlock) {
        if (viewBlock != viewParent) {
          const offsetToParentStart = this._toModelOffset(viewParent.parent, viewParent.index, viewBlock);
          const offsetInParent = this._toModelOffset(viewParent, viewOffset, viewParent);
          return offsetToParentStart + offsetInParent;
        }
        if (viewParent.is("$text")) {
          return viewOffset;
        }
        let modelOffset = 0;
        for (let i2 = 0; i2 < viewOffset; i2++) {
          modelOffset += this.getModelLength(viewParent.getChild(i2));
        }
        return modelOffset;
      }
      /**
      * Gets the length of the view element in the model.
      *
      * The length is calculated as follows:
      * * if a {@link #registerViewToModelLength length mapping callback} is provided for the given `viewNode`, it is used to
      * evaluate the model length (`viewNode` is used as first and only parameter passed to the callback),
      * * length of a {@link module:engine/view/text~Text text node} is equal to the length of its
      * {@link module:engine/view/text~Text#data data},
      * * length of a {@link module:engine/view/uielement~UIElement ui element} is equal to 0,
      * * length of a mapped {@link module:engine/view/element~Element element} is equal to 1,
      * * length of a non-mapped {@link module:engine/view/element~Element element} is equal to the length of its children.
      *
      * Examples:
      *
      * ```
      * foo                          -> 3 // Text length is equal to its data length.
      * <p>foo</p>                   -> 1 // Length of an element which is mapped is by default equal to 1.
      * <b>foo</b>                   -> 3 // Length of an element which is not mapped is a length of its children.
      * <div><p>x</p><p>y</p></div>  -> 2 // Assuming that <div> is not mapped and <p> are mapped.
      * ```
      *
      * @param viewNode View node.
      * @returns Length of the node in the tree model.
      */
      getModelLength(viewNode) {
        if (this._viewToModelLengthCallbacks.get(viewNode.name)) {
          const callback = this._viewToModelLengthCallbacks.get(viewNode.name);
          return callback(viewNode);
        } else if (this._viewToModelMapping.has(viewNode)) {
          return 1;
        } else if (viewNode.is("$text")) {
          return viewNode.data.length;
        } else if (viewNode.is("uiElement")) {
          return 0;
        } else {
          let len = 0;
          for (const child of viewNode.getChildren()) {
            len += this.getModelLength(child);
          }
          return len;
        }
      }
      /**
      * Finds the position in the view node (or in its children) with the expected model offset.
      *
      * Example:
      *
      * ```
      * <p>fo<b>bar</b>bom</p> -> expected offset: 4
      *
      * findPositionIn( p, 4 ):
      * <p>|fo<b>bar</b>bom</p> -> expected offset: 4, actual offset: 0
      * <p>fo|<b>bar</b>bom</p> -> expected offset: 4, actual offset: 2
      * <p>fo<b>bar</b>|bom</p> -> expected offset: 4, actual offset: 5 -> we are too far
      *
      * findPositionIn( b, 4 - ( 5 - 3 ) ):
      * <p>fo<b>|bar</b>bom</p> -> expected offset: 2, actual offset: 0
      * <p>fo<b>bar|</b>bom</p> -> expected offset: 2, actual offset: 3 -> we are too far
      *
      * findPositionIn( bar, 2 - ( 3 - 3 ) ):
      * We are in the text node so we can simple find the offset.
      * <p>fo<b>ba|r</b>bom</p> -> expected offset: 2, actual offset: 2 -> position found
      * ```
      *
      * @param viewParent Tree view element in which we are looking for the position.
      * @param expectedOffset Expected offset.
      * @returns Found position.
      */
      findPositionIn(viewParent, expectedOffset) {
        let viewNode;
        let lastLength = 0;
        let modelOffset = 0;
        let viewOffset = 0;
        if (viewParent.is("$text")) {
          return new Position$1(viewParent, expectedOffset);
        }
        while (modelOffset < expectedOffset) {
          viewNode = viewParent.getChild(viewOffset);
          lastLength = this.getModelLength(viewNode);
          modelOffset += lastLength;
          viewOffset++;
        }
        if (modelOffset == expectedOffset) {
          return this._moveViewPositionToTextNode(new Position$1(viewParent, viewOffset));
        } else {
          return this.findPositionIn(viewNode, expectedOffset - (modelOffset - lastLength));
        }
      }
      /**
      * Because we prefer positions in the text nodes over positions next to text nodes, if the view position was next to a text node,
      * it moves it into the text node instead.
      *
      * ```
      * <p>[]<b>foo</b></p> -> <p>[]<b>foo</b></p> // do not touch if position is not directly next to text
      * <p>foo[]<b>foo</b></p> -> <p>foo{}<b>foo</b></p> // move to text node
      * <p><b>[]foo</b></p> -> <p><b>{}foo</b></p> // move to text node
      * ```
      *
      * @param viewPosition Position potentially next to the text node.
      * @returns Position in the text node if possible.
      */
      _moveViewPositionToTextNode(viewPosition) {
        const nodeBefore = viewPosition.nodeBefore;
        const nodeAfter = viewPosition.nodeAfter;
        if (nodeBefore instanceof Text$1) {
          return new Position$1(nodeBefore, nodeBefore.data.length);
        } else if (nodeAfter instanceof Text$1) {
          return new Position$1(nodeAfter, 0);
        }
        return viewPosition;
      }
    }
    class ModelConsumable {
      constructor() {
        /**
        * Contains list of consumable values.
        */
        __publicField(this, "_consumable", /* @__PURE__ */ new Map());
        /**
        * For each {@link module:engine/model/textproxy~TextProxy} added to `ModelConsumable`, this registry holds a parent
        * of that `TextProxy` and the start and end indices of that `TextProxy`. This allows identification of the `TextProxy`
        * instances that point to the same part of the model but are different instances. Each distinct `TextProxy`
        * is given a unique `Symbol` which is then registered as consumable. This process is transparent for the `ModelConsumable`
        * API user because whenever `TextProxy` is added, tested, consumed or reverted, the internal mechanisms of
        * `ModelConsumable` translate `TextProxy` to that unique `Symbol`.
        */
        __publicField(this, "_textProxyRegistry", /* @__PURE__ */ new Map());
      }
      /**
      * Adds a consumable value to the consumables list and links it with a given model item.
      *
      * ```ts
      * modelConsumable.add( modelElement, 'insert' ); // Add `modelElement` insertion change to consumable values.
      * modelConsumable.add( modelElement, 'addAttribute:bold' ); // Add `bold` attribute insertion on `modelElement` change.
      * modelConsumable.add( modelElement, 'removeAttribute:bold' ); // Add `bold` attribute removal on `modelElement` change.
      * modelConsumable.add( modelSelection, 'selection' ); // Add `modelSelection` to consumable values.
      * modelConsumable.add( modelRange, 'range' ); // Add `modelRange` to consumable values.
      * ```
      *
      * @param item Model item, range or selection that has the consumable.
      * @param type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.
      * Second colon and everything after will be cut. Passing event name is a safe and good practice.
      */
      add(item, type) {
        type = _normalizeConsumableType(type);
        if (item instanceof TextProxy) {
          item = this._getSymbolForTextProxy(item);
        }
        if (!this._consumable.has(item)) {
          this._consumable.set(item, /* @__PURE__ */ new Map());
        }
        this._consumable.get(item).set(type, true);
      }
      /**
      * Removes a given consumable value from a given model item.
      *
      * ```ts
      * modelConsumable.consume( modelElement, 'insert' ); // Remove `modelElement` insertion change from consumable values.
      * modelConsumable.consume( modelElement, 'addAttribute:bold' ); // Remove `bold` attribute insertion on `modelElement` change.
      * modelConsumable.consume( modelElement, 'removeAttribute:bold' ); // Remove `bold` attribute removal on `modelElement` change.
      * modelConsumable.consume( modelSelection, 'selection' ); // Remove `modelSelection` from consumable values.
      * modelConsumable.consume( modelRange, 'range' ); // Remove 'modelRange' from consumable values.
      * ```
      *
      * @param item Model item, range or selection from which consumable will be consumed.
      * @param type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.
      * Second colon and everything after will be cut. Passing event name is a safe and good practice.
      * @returns `true` if consumable value was available and was consumed, `false` otherwise.
      */
      consume(item, type) {
        type = _normalizeConsumableType(type);
        if (item instanceof TextProxy) {
          item = this._getSymbolForTextProxy(item);
        }
        if (this.test(item, type)) {
          this._consumable.get(item).set(type, false);
          return true;
        } else {
          return false;
        }
      }
      /**
      * Tests whether there is a consumable value of a given type connected with a given model item.
      *
      * ```ts
      * modelConsumable.test( modelElement, 'insert' ); // Check for `modelElement` insertion change.
      * modelConsumable.test( modelElement, 'addAttribute:bold' ); // Check for `bold` attribute insertion on `modelElement` change.
      * modelConsumable.test( modelElement, 'removeAttribute:bold' ); // Check for `bold` attribute removal on `modelElement` change.
      * modelConsumable.test( modelSelection, 'selection' ); // Check if `modelSelection` is consumable.
      * modelConsumable.test( modelRange, 'range' ); // Check if `modelRange` is consumable.
      * ```
      *
      * @param item Model item, range or selection to be tested.
      * @param type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.
      * Second colon and everything after will be cut. Passing event name is a safe and good practice.
      * @returns `null` if such consumable was never added, `false` if the consumable values was
      * already consumed or `true` if it was added and not consumed yet.
      */
      test(item, type) {
        type = _normalizeConsumableType(type);
        if (item instanceof TextProxy) {
          item = this._getSymbolForTextProxy(item);
        }
        const itemConsumables = this._consumable.get(item);
        if (itemConsumables === void 0) {
          return null;
        }
        const value = itemConsumables.get(type);
        if (value === void 0) {
          return null;
        }
        return value;
      }
      /**
      * Reverts consuming of a consumable value.
      *
      * ```ts
      * modelConsumable.revert( modelElement, 'insert' ); // Revert consuming `modelElement` insertion change.
      * modelConsumable.revert( modelElement, 'addAttribute:bold' ); // Revert consuming `bold` attribute insert from `modelElement`.
      * modelConsumable.revert( modelElement, 'removeAttribute:bold' ); // Revert consuming `bold` attribute remove from `modelElement`.
      * modelConsumable.revert( modelSelection, 'selection' ); // Revert consuming `modelSelection`.
      * modelConsumable.revert( modelRange, 'range' ); // Revert consuming `modelRange`.
      * ```
      *
      * @param item Model item, range or selection to be reverted.
      * @param type Consumable type.
      * @returns `true` if consumable has been reversed, `false` otherwise. `null` if the consumable has
      * never been added.
      */
      revert(item, type) {
        type = _normalizeConsumableType(type);
        if (item instanceof TextProxy) {
          item = this._getSymbolForTextProxy(item);
        }
        const test = this.test(item, type);
        if (test === false) {
          this._consumable.get(item).set(type, true);
          return true;
        } else if (test === true) {
          return false;
        }
        return null;
      }
      /**
      * Verifies if all events from the specified group were consumed.
      *
      * @param eventGroup The events group to verify.
      */
      verifyAllConsumed(eventGroup) {
        const items = [];
        for (const [item, consumables] of this._consumable) {
          for (const [event, canConsume] of consumables) {
            const eventPrefix = event.split(":")[0];
            if (canConsume && eventGroup == eventPrefix) {
              items.push({
                event,
                item: item.name || item.description
              });
            }
          }
        }
        if (items.length) {
          throw new CKEditorError("conversion-model-consumable-not-consumed", null, {
            items
          });
        }
      }
      /**
      * Gets a unique symbol for the passed {@link module:engine/model/textproxy~TextProxy} instance. All `TextProxy` instances that
      * have same parent, same start index and same end index will get the same symbol.
      *
      * Used internally to correctly consume `TextProxy` instances.
      *
      * @internal
      * @param textProxy `TextProxy` instance to get a symbol for.
      * @returns Symbol representing all equal instances of `TextProxy`.
      */
      _getSymbolForTextProxy(textProxy) {
        let symbol = null;
        const startMap = this._textProxyRegistry.get(textProxy.startOffset);
        if (startMap) {
          const endMap = startMap.get(textProxy.endOffset);
          if (endMap) {
            symbol = endMap.get(textProxy.parent);
          }
        }
        if (!symbol) {
          symbol = this._addSymbolForTextProxy(textProxy);
        }
        return symbol;
      }
      /**
      * Adds a symbol for the given {@link module:engine/model/textproxy~TextProxy} instance.
      *
      * Used internally to correctly consume `TextProxy` instances.
      *
      * @param textProxy Text proxy instance.
      * @returns Symbol generated for given `TextProxy`.
      */
      _addSymbolForTextProxy(textProxy) {
        const start2 = textProxy.startOffset;
        const end2 = textProxy.endOffset;
        const parent2 = textProxy.parent;
        const symbol = Symbol("$textProxy:" + textProxy.data);
        let startMap;
        let endMap;
        startMap = this._textProxyRegistry.get(start2);
        if (!startMap) {
          startMap = /* @__PURE__ */ new Map();
          this._textProxyRegistry.set(start2, startMap);
        }
        endMap = startMap.get(end2);
        if (!endMap) {
          endMap = /* @__PURE__ */ new Map();
          startMap.set(end2, endMap);
        }
        endMap.set(parent2, symbol);
        return symbol;
      }
    }
    function _normalizeConsumableType(type) {
      const parts = type.split(":");
      if (parts[0] == "insert") {
        return parts[0];
      }
      if (parts[0] == "addMarker" || parts[0] == "removeMarker") {
        return type;
      }
      return parts.length > 1 ? parts[0] + ":" + parts[1] : parts[0];
    }
    class DowncastDispatcher extends (/* @__PURE__ */ EmitterMixin()) {
      /**
      * Creates a downcast dispatcher instance.
      *
      * @see module:engine/conversion/downcastdispatcher~DowncastConversionApi
      *
      * @param conversionApi Additional properties for an interface that will be passed to events fired
      * by the downcast dispatcher.
      */
      constructor(conversionApi) {
        super();
        /**
        * A template for an interface passed by the dispatcher to the event callbacks.
        *
        * @internal
        */
        __publicField(this, "_conversionApi");
        /**
        * A map of already fired events for a given `ModelConsumable`.
        */
        __publicField(this, "_firedEventsMap");
        this._conversionApi = {
          dispatcher: this,
          ...conversionApi
        };
        this._firedEventsMap = /* @__PURE__ */ new WeakMap();
      }
      /**
      * Converts changes buffered in the given {@link module:engine/model/differ~Differ model differ}
      * and fires conversion events based on it.
      *
      * @fires insert
      * @fires remove
      * @fires attribute
      * @fires addMarker
      * @fires removeMarker
      * @fires reduceChanges
      * @param differ The differ object with buffered changes.
      * @param markers Markers related to the model fragment to convert.
      * @param writer The view writer that should be used to modify the view document.
      */
      convertChanges(differ, markers, writer) {
        const conversionApi = this._createConversionApi(writer, differ.getRefreshedItems());
        for (const change of differ.getMarkersToRemove()) {
          this._convertMarkerRemove(change.name, change.range, conversionApi);
        }
        const changes = this._reduceChanges(differ.getChanges());
        for (const entry of changes) {
          if (entry.type === "insert") {
            this._convertInsert(Range._createFromPositionAndShift(entry.position, entry.length), conversionApi);
          } else if (entry.type === "reinsert") {
            this._convertReinsert(Range._createFromPositionAndShift(entry.position, entry.length), conversionApi);
          } else if (entry.type === "remove") {
            this._convertRemove(entry.position, entry.length, entry.name, conversionApi);
          } else {
            this._convertAttribute(entry.range, entry.attributeKey, entry.attributeOldValue, entry.attributeNewValue, conversionApi);
          }
        }
        conversionApi.mapper.flushDeferredBindings();
        for (const markerName of conversionApi.mapper.flushUnboundMarkerNames()) {
          const markerRange = markers.get(markerName).getRange();
          this._convertMarkerRemove(markerName, markerRange, conversionApi);
          this._convertMarkerAdd(markerName, markerRange, conversionApi);
        }
        for (const change of differ.getMarkersToAdd()) {
          this._convertMarkerAdd(change.name, change.range, conversionApi);
        }
        conversionApi.consumable.verifyAllConsumed("insert");
      }
      /**
      * Starts a conversion of a model range and the provided markers.
      *
      * @fires insert
      * @fires attribute
      * @fires addMarker
      * @param range The inserted range.
      * @param markers The map of markers that should be down-casted.
      * @param writer The view writer that should be used to modify the view document.
      * @param options Optional options object passed to `convertionApi.options`.
      */
      convert(range2, markers, writer, options = {}) {
        const conversionApi = this._createConversionApi(writer, void 0, options);
        this._convertInsert(range2, conversionApi);
        for (const [name, range3] of markers) {
          this._convertMarkerAdd(name, range3, conversionApi);
        }
        conversionApi.consumable.verifyAllConsumed("insert");
      }
      /**
      * Starts the model selection conversion.
      *
      * Fires events for a given {@link module:engine/model/selection~Selection selection} to start the selection conversion.
      *
      * @fires selection
      * @fires addMarker
      * @fires attribute
      * @param selection The selection to convert.
      * @param markers Markers connected with the converted model.
      * @param writer View writer that should be used to modify the view document.
      */
      convertSelection(selection, markers, writer) {
        const conversionApi = this._createConversionApi(writer);
        this.fire("cleanSelection", {
          selection
        }, conversionApi);
        const modelRoot = selection.getFirstPosition().root;
        if (!conversionApi.mapper.toViewElement(modelRoot)) {
          return;
        }
        const markersAtSelection = Array.from(markers.getMarkersAtPosition(selection.getFirstPosition()));
        this._addConsumablesForSelection(conversionApi.consumable, selection, markersAtSelection);
        this.fire("selection", {
          selection
        }, conversionApi);
        if (!selection.isCollapsed) {
          return;
        }
        for (const marker of markersAtSelection) {
          if (conversionApi.consumable.test(selection, "addMarker:" + marker.name)) {
            const markerRange = marker.getRange();
            if (!shouldMarkerChangeBeConverted(selection.getFirstPosition(), marker, conversionApi.mapper)) {
              continue;
            }
            const data = {
              item: selection,
              markerName: marker.name,
              markerRange
            };
            this.fire(`addMarker:${marker.name}`, data, conversionApi);
          }
        }
        for (const key of selection.getAttributeKeys()) {
          if (conversionApi.consumable.test(selection, "attribute:" + key)) {
            const data = {
              item: selection,
              range: selection.getFirstRange(),
              attributeKey: key,
              attributeOldValue: null,
              attributeNewValue: selection.getAttribute(key)
            };
            this.fire(`attribute:${key}:$text`, data, conversionApi);
          }
        }
      }
      /**
      * Fires insertion conversion of a range of nodes.
      *
      * For each node in the range, {@link #event:insert `insert` event is fired}. For each attribute on each node,
      * {@link #event:attribute `attribute` event is fired}.
      *
      * @fires insert
      * @fires attribute
      * @param range The inserted range.
      * @param conversionApi The conversion API object.
      * @param options.doNotAddConsumables Whether the ModelConsumable should not get populated
      * for items in the provided range.
      */
      _convertInsert(range2, conversionApi, options = {}) {
        if (!options.doNotAddConsumables) {
          this._addConsumablesForInsert(conversionApi.consumable, range2);
        }
        for (const data of Array.from(range2.getWalker({
          shallow: true
        })).map(walkerValueToEventData)) {
          this._testAndFire("insert", data, conversionApi);
        }
      }
      /**
      * Fires conversion of a single node removal. Fires {@link #event:remove remove event} with provided data.
      *
      * @param position Position from which node was removed.
      * @param length Offset size of removed node.
      * @param name Name of removed node.
      * @param conversionApi The conversion API object.
      */
      _convertRemove(position, length, name, conversionApi) {
        this.fire(`remove:${name}`, {
          position,
          length
        }, conversionApi);
      }
      /**
      * Starts a conversion of an attribute change on a given `range`.
      *
      * For each node in the given `range`, {@link #event:attribute attribute event} is fired with the passed data.
      *
      * @fires attribute
      * @param range Changed range.
      * @param key Key of the attribute that has changed.
      * @param oldValue Attribute value before the change or `null` if the attribute has not been set before.
      * @param newValue New attribute value or `null` if the attribute has been removed.
      * @param conversionApi The conversion API object.
      */
      _convertAttribute(range2, key, oldValue, newValue, conversionApi) {
        this._addConsumablesForRange(conversionApi.consumable, range2, `attribute:${key}`);
        for (const value of range2) {
          const data = {
            item: value.item,
            range: Range._createFromPositionAndShift(value.previousPosition, value.length),
            attributeKey: key,
            attributeOldValue: oldValue,
            attributeNewValue: newValue
          };
          this._testAndFire(`attribute:${key}`, data, conversionApi);
        }
      }
      /**
      * Fires re-insertion conversion (with a `reconversion` flag passed to `insert` events)
      * of a range of elements (only elements on the range depth, without children).
      *
      * For each node in the range on its depth (without children), {@link #event:insert `insert` event} is fired.
      * For each attribute on each node, {@link #event:attribute `attribute` event} is fired.
      *
      * @fires insert
      * @fires attribute
      * @param range The range to reinsert.
      * @param conversionApi The conversion API object.
      */
      _convertReinsert(range2, conversionApi) {
        const walkerValues = Array.from(range2.getWalker({
          shallow: true
        }));
        this._addConsumablesForInsert(conversionApi.consumable, walkerValues);
        for (const data of walkerValues.map(walkerValueToEventData)) {
          this._testAndFire("insert", {
            ...data,
            reconversion: true
          }, conversionApi);
        }
      }
      /**
      * Converts the added marker. Fires the {@link #event:addMarker `addMarker`} event for each item
      * in the marker's range. If the range is collapsed, a single event is dispatched. See the event description for more details.
      *
      * @fires addMarker
      * @param markerName Marker name.
      * @param markerRange The marker range.
      * @param conversionApi The conversion API object.
      */
      _convertMarkerAdd(markerName, markerRange, conversionApi) {
        if (markerRange.root.rootName == "$graveyard") {
          return;
        }
        const eventName = `addMarker:${markerName}`;
        conversionApi.consumable.add(markerRange, eventName);
        this.fire(eventName, {
          markerName,
          markerRange
        }, conversionApi);
        if (!conversionApi.consumable.consume(markerRange, eventName)) {
          return;
        }
        this._addConsumablesForRange(conversionApi.consumable, markerRange, eventName);
        for (const item of markerRange.getItems()) {
          if (!conversionApi.consumable.test(item, eventName)) {
            continue;
          }
          const data = {
            item,
            range: Range._createOn(item),
            markerName,
            markerRange
          };
          this.fire(eventName, data, conversionApi);
        }
      }
      /**
      * Fires the conversion of the marker removal. Fires the {@link #event:removeMarker `removeMarker`} event with the provided data.
      *
      * @fires removeMarker
      * @param markerName Marker name.
      * @param markerRange The marker range.
      * @param conversionApi The conversion API object.
      */
      _convertMarkerRemove(markerName, markerRange, conversionApi) {
        if (markerRange.root.rootName == "$graveyard") {
          return;
        }
        this.fire(`removeMarker:${markerName}`, {
          markerName,
          markerRange
        }, conversionApi);
      }
      /**
      * Fires the reduction of changes buffered in the {@link module:engine/model/differ~Differ `Differ`}.
      *
      * Features can replace selected {@link module:engine/model/differ~DiffItem `DiffItem`}s with `reinsert` entries to trigger
      * reconversion. The {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure
      * `DowncastHelpers.elementToStructure()`} is using this event to trigger reconversion.
      *
      * @fires reduceChanges
      */
      _reduceChanges(changes) {
        const data = {
          changes
        };
        this.fire("reduceChanges", data);
        return data.changes;
      }
      /**
      * Populates provided {@link module:engine/conversion/modelconsumable~ModelConsumable} with values to consume from a given range,
      * assuming that the range has just been inserted to the model.
      *
      * @param consumable The consumable.
      * @param walkerValues The walker values for the inserted range.
      * @returns The values to consume.
      */
      _addConsumablesForInsert(consumable, walkerValues) {
        for (const value of walkerValues) {
          const item = value.item;
          if (consumable.test(item, "insert") === null) {
            consumable.add(item, "insert");
            for (const key of item.getAttributeKeys()) {
              consumable.add(item, "attribute:" + key);
            }
          }
        }
        return consumable;
      }
      /**
      * Populates provided {@link module:engine/conversion/modelconsumable~ModelConsumable} with values to consume for a given range.
      *
      * @param consumable The consumable.
      * @param range The affected range.
      * @param type Consumable type.
      * @returns The values to consume.
      */
      _addConsumablesForRange(consumable, range2, type) {
        for (const item of range2.getItems()) {
          consumable.add(item, type);
        }
        return consumable;
      }
      /**
      * Populates provided {@link module:engine/conversion/modelconsumable~ModelConsumable} with selection consumable values.
      *
      * @param consumable The consumable.
      * @param selection The selection to create the consumable from.
      * @param markers Markers that contain the selection.
      * @returns The values to consume.
      */
      _addConsumablesForSelection(consumable, selection, markers) {
        consumable.add(selection, "selection");
        for (const marker of markers) {
          consumable.add(selection, "addMarker:" + marker.name);
        }
        for (const key of selection.getAttributeKeys()) {
          consumable.add(selection, "attribute:" + key);
        }
        return consumable;
      }
      /**
      * Tests whether given event wasn't already fired and if so, fires it.
      *
      * @fires insert
      * @fires attribute
      * @param type Event type.
      * @param data Event data.
      * @param conversionApi The conversion API object.
      */
      _testAndFire(type, data, conversionApi) {
        const eventName = getEventName(type, data);
        const itemKey = data.item.is("$textProxy") ? conversionApi.consumable._getSymbolForTextProxy(data.item) : data.item;
        const eventsFiredForConversion = this._firedEventsMap.get(conversionApi);
        const eventsFiredForItem = eventsFiredForConversion.get(itemKey);
        if (!eventsFiredForItem) {
          eventsFiredForConversion.set(itemKey, /* @__PURE__ */ new Set([
            eventName
          ]));
        } else if (!eventsFiredForItem.has(eventName)) {
          eventsFiredForItem.add(eventName);
        } else {
          return;
        }
        this.fire(eventName, data, conversionApi);
      }
      /**
      * Fires not already fired events for setting attributes on just inserted item.
      *
      * @param item The model item to convert attributes for.
      * @param conversionApi The conversion API object.
      */
      _testAndFireAddAttributes(item, conversionApi) {
        const data = {
          item,
          range: Range._createOn(item)
        };
        for (const key of data.item.getAttributeKeys()) {
          data.attributeKey = key;
          data.attributeOldValue = null;
          data.attributeNewValue = data.item.getAttribute(key);
          this._testAndFire(`attribute:${key}`, data, conversionApi);
        }
      }
      /**
      * Builds an instance of the {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi} from a template and a given
      * {@link module:engine/view/downcastwriter~DowncastWriter `DowncastWriter`} and options object.
      *
      * @param writer View writer that should be used to modify the view document.
      * @param refreshedItems A set of model elements that should not reuse their
      * previous view representations.
      * @param options Optional options passed to `convertionApi.options`.
      * @return The conversion API object.
      */
      _createConversionApi(writer, refreshedItems = /* @__PURE__ */ new Set(), options = {}) {
        const conversionApi = {
          ...this._conversionApi,
          consumable: new ModelConsumable(),
          writer,
          options,
          convertItem: (item) => this._convertInsert(Range._createOn(item), conversionApi),
          convertChildren: (element) => this._convertInsert(Range._createIn(element), conversionApi, {
            doNotAddConsumables: true
          }),
          convertAttributes: (item) => this._testAndFireAddAttributes(item, conversionApi),
          canReuseView: (viewElement) => !refreshedItems.has(conversionApi.mapper.toModelElement(viewElement))
        };
        this._firedEventsMap.set(conversionApi, /* @__PURE__ */ new Map());
        return conversionApi;
      }
    }
    function shouldMarkerChangeBeConverted(modelPosition, marker, mapper) {
      const range2 = marker.getRange();
      const ancestors = Array.from(modelPosition.getAncestors());
      ancestors.shift();
      ancestors.reverse();
      const hasCustomHandling = ancestors.some((element) => {
        if (range2.containsItem(element)) {
          const viewElement = mapper.toViewElement(element);
          return !!viewElement.getCustomProperty("addHighlight");
        }
      });
      return !hasCustomHandling;
    }
    function getEventName(type, data) {
      const name = data.item.is("element") ? data.item.name : "$text";
      return `${type}:${name}`;
    }
    function walkerValueToEventData(value) {
      const item = value.item;
      const itemRange = Range._createFromPositionAndShift(value.previousPosition, value.length);
      return {
        item,
        range: itemRange
      };
    }
    class Selection extends (/* @__PURE__ */ EmitterMixin(TypeCheckable)) {
      /**
      * Creates a new selection instance based on the given {@link module:engine/model/selection~Selectable selectable}
      * or creates an empty selection if no arguments were passed.
      *
      * ```ts
      * // Creates empty selection without ranges.
      * const selection = writer.createSelection();
      *
      * // Creates selection at the given range.
      * const range = writer.createRange( start, end );
      * const selection = writer.createSelection( range );
      *
      * // Creates selection at the given ranges
      * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];
      * const selection = writer.createSelection( ranges );
      *
      * // Creates selection from the other selection.
      * // Note: It doesn't copy selection attributes.
      * const otherSelection = writer.createSelection();
      * const selection = writer.createSelection( otherSelection );
      *
      * // Creates selection from the given document selection.
      * // Note: It doesn't copy selection attributes.
      * const documentSelection = model.document.selection;
      * const selection = writer.createSelection( documentSelection );
      *
      * // Creates selection at the given position.
      * const position = writer.createPositionFromPath( root, path );
      * const selection = writer.createSelection( position );
      *
      * // Creates selection at the given offset in the given element.
      * const paragraph = writer.createElement( 'paragraph' );
      * const selection = writer.createSelection( paragraph, offset );
      *
      * // Creates a range inside an {@link module:engine/model/element~Element element} which starts before the
      * // first child of that element and ends after the last child of that element.
      * const selection = writer.createSelection( paragraph, 'in' );
      *
      * // Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends
      * // just after the item.
      * const selection = writer.createSelection( paragraph, 'on' );
      * ```
      *
      * Selection's constructor allow passing additional options (`'backward'`) as the last argument.
      *
      * ```ts
      * // Creates backward selection.
      * const selection = writer.createSelection( range, { backward: true } );
      * ```
      *
      * @internal
      */
      constructor(...args) {
        super();
        /**
        * Specifies whether the last added range was added as a backward or forward range.
        */
        __publicField(this, "_lastRangeBackward", false);
        /**
        * List of attributes set on current selection.
        */
        __publicField(this, "_attrs", /* @__PURE__ */ new Map());
        /** @internal */
        __publicField(this, "_ranges", []);
        if (args.length) {
          this.setTo(...args);
        }
      }
      /**
      * Selection anchor. Anchor is the position from which the selection was started. If a user is making a selection
      * by dragging the mouse, the anchor is where the user pressed the mouse button (the beginning of the selection).
      *
      * Anchor and {@link #focus} define the direction of the selection, which is important
      * when expanding/shrinking selection. The focus moves, while the anchor should remain in the same place.
      *
      * Anchor is always set to the {@link module:engine/model/range~Range#start start} or
      * {@link module:engine/model/range~Range#end end} position of the last of selection's ranges. Whether it is
      * the `start` or `end` depends on the specified `options.backward`. See the {@link #setTo `setTo()`} method.
      *
      * May be set to `null` if there are no ranges in the selection.
      *
      * @see #focus
      */
      get anchor() {
        if (this._ranges.length > 0) {
          const range2 = this._ranges[this._ranges.length - 1];
          return this._lastRangeBackward ? range2.end : range2.start;
        }
        return null;
      }
      /**
      * Selection focus. Focus is the position where the selection ends. If a user is making a selection
      * by dragging the mouse, the focus is where the mouse cursor is.
      *
      * May be set to `null` if there are no ranges in the selection.
      *
      * @see #anchor
      */
      get focus() {
        if (this._ranges.length > 0) {
          const range2 = this._ranges[this._ranges.length - 1];
          return this._lastRangeBackward ? range2.start : range2.end;
        }
        return null;
      }
      /**
      * Whether the selection is collapsed. Selection is collapsed when there is exactly one range in it
      * and it is collapsed.
      */
      get isCollapsed() {
        const length = this._ranges.length;
        if (length === 1) {
          return this._ranges[0].isCollapsed;
        } else {
          return false;
        }
      }
      /**
      * Returns the number of ranges in the selection.
      */
      get rangeCount() {
        return this._ranges.length;
      }
      /**
      * Specifies whether the selection's {@link #focus} precedes the selection's {@link #anchor}.
      */
      get isBackward() {
        return !this.isCollapsed && this._lastRangeBackward;
      }
      /**
      * Checks whether this selection is equal to the given selection. Selections are equal if they have the same directions,
      * the same number of ranges and all ranges from one selection equal to ranges from the another selection.
      *
      * @param otherSelection Selection to compare with.
      * @returns `true` if selections are equal, `false` otherwise.
      */
      isEqual(otherSelection) {
        if (this.rangeCount != otherSelection.rangeCount) {
          return false;
        } else if (this.rangeCount === 0) {
          return true;
        }
        if (!this.anchor.isEqual(otherSelection.anchor) || !this.focus.isEqual(otherSelection.focus)) {
          return false;
        }
        for (const thisRange of this._ranges) {
          let found = false;
          for (const otherRange of otherSelection._ranges) {
            if (thisRange.isEqual(otherRange)) {
              found = true;
              break;
            }
          }
          if (!found) {
            return false;
          }
        }
        return true;
      }
      /**
      * Returns an iterable object that iterates over copies of selection ranges.
      */
      *getRanges() {
        for (const range2 of this._ranges) {
          yield new Range(range2.start, range2.end);
        }
      }
      /**
      * Returns a copy of the first range in the selection.
      * First range is the one which {@link module:engine/model/range~Range#start start} position
      * {@link module:engine/model/position~Position#isBefore is before} start position of all other ranges
      * (not to confuse with the first range added to the selection).
      *
      * Returns `null` if there are no ranges in selection.
      */
      getFirstRange() {
        let first2 = null;
        for (const range2 of this._ranges) {
          if (!first2 || range2.start.isBefore(first2.start)) {
            first2 = range2;
          }
        }
        return first2 ? new Range(first2.start, first2.end) : null;
      }
      /**
      * Returns a copy of the last range in the selection.
      * Last range is the one which {@link module:engine/model/range~Range#end end} position
      * {@link module:engine/model/position~Position#isAfter is after} end position of all other ranges (not to confuse with the range most
      * recently added to the selection).
      *
      * Returns `null` if there are no ranges in selection.
      */
      getLastRange() {
        let last2 = null;
        for (const range2 of this._ranges) {
          if (!last2 || range2.end.isAfter(last2.end)) {
            last2 = range2;
          }
        }
        return last2 ? new Range(last2.start, last2.end) : null;
      }
      /**
      * Returns the first position in the selection.
      * First position is the position that {@link module:engine/model/position~Position#isBefore is before}
      * any other position in the selection.
      *
      * Returns `null` if there are no ranges in selection.
      */
      getFirstPosition() {
        const first2 = this.getFirstRange();
        return first2 ? first2.start.clone() : null;
      }
      /**
      * Returns the last position in the selection.
      * Last position is the position that {@link module:engine/model/position~Position#isAfter is after}
      * any other position in the selection.
      *
      * Returns `null` if there are no ranges in selection.
      */
      getLastPosition() {
        const lastRange = this.getLastRange();
        return lastRange ? lastRange.end.clone() : null;
      }
      /**
      * Sets this selection's ranges and direction to the specified location based on the given
      * {@link module:engine/model/selection~Selectable selectable}.
      *
      * ```ts
      * // Removes all selection's ranges.
      * selection.setTo( null );
      *
      * // Sets selection to the given range.
      * const range = writer.createRange( start, end );
      * selection.setTo( range );
      *
      * // Sets selection to given ranges.
      * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];
      * selection.setTo( ranges );
      *
      * // Sets selection to other selection.
      * // Note: It doesn't copy selection attributes.
      * const otherSelection = writer.createSelection();
      * selection.setTo( otherSelection );
      *
      * // Sets selection to the given document selection.
      * // Note: It doesn't copy selection attributes.
      * const documentSelection = new DocumentSelection( doc );
      * selection.setTo( documentSelection );
      *
      * // Sets collapsed selection at the given position.
      * const position = writer.createPositionFromPath( root, path );
      * selection.setTo( position );
      *
      * // Sets collapsed selection at the position of the given node and an offset.
      * selection.setTo( paragraph, offset );
      * ```
      *
      * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of
       * that element and ends after the last child of that element.
      *
      * ```ts
      * selection.setTo( paragraph, 'in' );
      * ```
      *
      * Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends just after the item.
      *
      * ```ts
      * selection.setTo( paragraph, 'on' );
      * ```
      *
      * `Selection#setTo()`' method allow passing additional options (`backward`) as the last argument.
      *
      * ```ts
      * // Sets backward selection.
      * const selection = writer.createSelection( range, { backward: true } );
      * ```
      */
      setTo(...args) {
        let [selectable, placeOrOffset, options] = args;
        if (typeof placeOrOffset == "object") {
          options = placeOrOffset;
          placeOrOffset = void 0;
        }
        if (selectable === null) {
          this._setRanges([]);
        } else if (selectable instanceof Selection) {
          this._setRanges(selectable.getRanges(), selectable.isBackward);
        } else if (selectable && typeof selectable.getRanges == "function") {
          this._setRanges(selectable.getRanges(), selectable.isBackward);
        } else if (selectable instanceof Range) {
          this._setRanges([
            selectable
          ], !!options && !!options.backward);
        } else if (selectable instanceof Position) {
          this._setRanges([
            new Range(selectable)
          ]);
        } else if (selectable instanceof Node$1) {
          const backward = !!options && !!options.backward;
          let range2;
          if (placeOrOffset == "in") {
            range2 = Range._createIn(selectable);
          } else if (placeOrOffset == "on") {
            range2 = Range._createOn(selectable);
          } else if (placeOrOffset !== void 0) {
            range2 = new Range(Position._createAt(selectable, placeOrOffset));
          } else {
            throw new CKEditorError("model-selection-setto-required-second-parameter", [
              this,
              selectable
            ]);
          }
          this._setRanges([
            range2
          ], backward);
        } else if (isIterable(selectable)) {
          this._setRanges(selectable, options && !!options.backward);
        } else {
          throw new CKEditorError("model-selection-setto-not-selectable", [
            this,
            selectable
          ]);
        }
      }
      /**
      * Replaces all ranges that were added to the selection with given array of ranges. Last range of the array
      * is treated like the last added range and is used to set {@link module:engine/model/selection~Selection#anchor} and
      * {@link module:engine/model/selection~Selection#focus}. Accepts a flag describing in which direction the selection is made.
      *
      * @fires change:range
      * @param newRanges Ranges to set.
      * @param isLastBackward Flag describing if last added range was selected forward - from start to end (`false`)
      * or backward - from end to start (`true`).
      */
      _setRanges(newRanges, isLastBackward = false) {
        const ranges = Array.from(newRanges);
        const anyNewRange = ranges.some((newRange) => {
          if (!(newRange instanceof Range)) {
            throw new CKEditorError("model-selection-set-ranges-not-range", [
              this,
              newRanges
            ]);
          }
          return this._ranges.every((oldRange) => {
            return !oldRange.isEqual(newRange);
          });
        });
        if (ranges.length === this._ranges.length && !anyNewRange) {
          return;
        }
        this._replaceAllRanges(ranges);
        this._lastRangeBackward = !!isLastBackward;
        this.fire("change:range", {
          directChange: true
        });
      }
      /**
      * Moves {@link module:engine/model/selection~Selection#focus} to the specified location.
      *
      * The location can be specified in the same form as
      * {@link module:engine/model/writer~Writer#createPositionAt writer.createPositionAt()} parameters.
      *
      * @fires change:range
      * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/model/item~Item model item}.
      */
      setFocus(itemOrPosition, offset2) {
        if (this.anchor === null) {
          throw new CKEditorError("model-selection-setfocus-no-ranges", [
            this,
            itemOrPosition
          ]);
        }
        const newFocus = Position._createAt(itemOrPosition, offset2);
        if (newFocus.compareWith(this.focus) == "same") {
          return;
        }
        const anchor = this.anchor;
        if (this._ranges.length) {
          this._popRange();
        }
        if (newFocus.compareWith(anchor) == "before") {
          this._pushRange(new Range(newFocus, anchor));
          this._lastRangeBackward = true;
        } else {
          this._pushRange(new Range(anchor, newFocus));
          this._lastRangeBackward = false;
        }
        this.fire("change:range", {
          directChange: true
        });
      }
      /**
      * Gets an attribute value for given key or `undefined` if that attribute is not set on the selection.
      *
      * @param key Key of attribute to look for.
      * @returns Attribute value or `undefined`.
      */
      getAttribute(key) {
        return this._attrs.get(key);
      }
      /**
      * Returns iterable that iterates over this selection's attributes.
      *
      * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.
      * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
      */
      getAttributes() {
        return this._attrs.entries();
      }
      /**
      * Returns iterable that iterates over this selection's attribute keys.
      */
      getAttributeKeys() {
        return this._attrs.keys();
      }
      /**
      * Checks if the selection has an attribute for given key.
      *
      * @param key Key of attribute to check.
      * @returns `true` if attribute with given key is set on selection, `false` otherwise.
      */
      hasAttribute(key) {
        return this._attrs.has(key);
      }
      /**
      * Removes an attribute with given key from the selection.
      *
      * If given attribute was set on the selection, fires the {@link #event:change:range} event with
      * removed attribute key.
      *
      * @fires change:attribute
      * @param key Key of attribute to remove.
      */
      removeAttribute(key) {
        if (this.hasAttribute(key)) {
          this._attrs.delete(key);
          this.fire("change:attribute", {
            attributeKeys: [
              key
            ],
            directChange: true
          });
        }
      }
      /**
      * Sets attribute on the selection. If attribute with the same key already is set, it's value is overwritten.
      *
      * If the attribute value has changed, fires the {@link #event:change:range} event with
      * the attribute key.
      *
      * @fires change:attribute
      * @param key Key of attribute to set.
      * @param value Attribute value.
      */
      setAttribute(key, value) {
        if (this.getAttribute(key) !== value) {
          this._attrs.set(key, value);
          this.fire("change:attribute", {
            attributeKeys: [
              key
            ],
            directChange: true
          });
        }
      }
      /**
      * Returns the selected element. {@link module:engine/model/element~Element Element} is considered as selected if there is only
      * one range in the selection, and that range contains exactly one element.
      * Returns `null` if there is no selected element.
      */
      getSelectedElement() {
        if (this.rangeCount !== 1) {
          return null;
        }
        return this.getFirstRange().getContainedElement();
      }
      /**
      * Gets elements of type {@link module:engine/model/schema~Schema#isBlock "block"} touched by the selection.
      *
      * This method's result can be used for example to apply block styling to all blocks covered by this selection.
      *
      * **Note:** `getSelectedBlocks()` returns blocks that are nested in other non-block elements
      * but will not return blocks nested in other blocks.
      *
      * In this case the function will return exactly all 3 paragraphs (note: `<blockQuote>` is not a block itself):
      *
      * ```xml
      * <paragraph>[a</paragraph>
      * <blockQuote>
      * 	<paragraph>b</paragraph>
      * </blockQuote>
      * <paragraph>c]d</paragraph>
      * ```
      *
      * In this case the paragraph will also be returned, despite the collapsed selection:
      *
      * ```xml
      * <paragraph>[]a</paragraph>
      * ```
      *
      * In such a scenario, however, only blocks A, B & E will be returned as blocks C & D are nested in block B:
      *
      * ```xml
      * [<blockA></blockA>
      * <blockB>
      * 	<blockC></blockC>
      * 	<blockD></blockD>
      * </blockB>
      * <blockE></blockE>]
      * ```
      *
      * If the selection is inside a block all the inner blocks (A & B) are returned:
      *
      * ```xml
      * <block>
      * 	<blockA>[a</blockA>
      * 	<blockB>b]</blockB>
      * </block>
      * ```
      *
      * **Special case**: Selection ignores first and/or last blocks if nothing (from user perspective) is selected in them.
      *
      * ```xml
      * // Selection ends and the beginning of the last block.
      * <paragraph>[a</paragraph>
      * <paragraph>b</paragraph>
      * <paragraph>]c</paragraph> // This block will not be returned
      *
      * // Selection begins at the end of the first block.
      * <paragraph>a[</paragraph> // This block will not be returned
      * <paragraph>b</paragraph>
      * <paragraph>c]</paragraph>
      *
      * // Selection begings at the end of the first block and ends at the beginning of the last block.
      * <paragraph>a[</paragraph> // This block will not be returned
      * <paragraph>b</paragraph>
      * <paragraph>]c</paragraph> // This block will not be returned
      * ```
      */
      *getSelectedBlocks() {
        const visited = /* @__PURE__ */ new WeakSet();
        for (const range2 of this.getRanges()) {
          const startBlock = getParentBlock$1(range2.start, visited);
          if (isStartBlockSelected(startBlock, range2)) {
            yield startBlock;
          }
          for (const value of range2.getWalker()) {
            const block2 = value.item;
            if (value.type == "elementEnd" && isUnvisitedTopBlock(block2, visited, range2)) {
              yield block2;
            }
          }
          const endBlock = getParentBlock$1(range2.end, visited);
          if (isEndBlockSelected(endBlock, range2)) {
            yield endBlock;
          }
        }
      }
      /**
      * Checks whether the selection contains the entire content of the given element. This means that selection must start
      * at a position {@link module:engine/model/position~Position#isTouching touching} the element's start and ends at position
      * touching the element's end.
      *
      * By default, this method will check whether the entire content of the selection's current root is selected.
      * Useful to check if e.g. the user has just pressed <kbd>Ctrl</kbd> + <kbd>A</kbd>.
      */
      containsEntireContent(element = this.anchor.root) {
        const limitStartPosition = Position._createAt(element, 0);
        const limitEndPosition = Position._createAt(element, "end");
        return limitStartPosition.isTouching(this.getFirstPosition()) && limitEndPosition.isTouching(this.getLastPosition());
      }
      /**
      * Adds given range to internal {@link #_ranges ranges array}. Throws an error
      * if given range is intersecting with any range that is already stored in this selection.
      */
      _pushRange(range2) {
        this._checkRange(range2);
        this._ranges.push(new Range(range2.start, range2.end));
      }
      /**
      * Checks if given range intersects with ranges that are already in the selection. Throws an error if it does.
      */
      _checkRange(range2) {
        for (let i2 = 0; i2 < this._ranges.length; i2++) {
          if (range2.isIntersecting(this._ranges[i2])) {
            throw new CKEditorError("model-selection-range-intersects", [
              this,
              range2
            ], {
              addedRange: range2,
              intersectingRange: this._ranges[i2]
            });
          }
        }
      }
      /**
      * Replaces all the ranges by the given ones.
      * Uses {@link #_popRange _popRange} and {@link #_pushRange _pushRange} to ensure proper ranges removal and addition.
      */
      _replaceAllRanges(ranges) {
        this._removeAllRanges();
        for (const range2 of ranges) {
          this._pushRange(range2);
        }
      }
      /**
      * Deletes ranges from internal range array. Uses {@link #_popRange _popRange} to
      * ensure proper ranges removal.
      */
      _removeAllRanges() {
        while (this._ranges.length > 0) {
          this._popRange();
        }
      }
      /**
      * Removes most recently added range from the selection.
      */
      _popRange() {
        this._ranges.pop();
      }
    }
    Selection.prototype.is = function(type) {
      return type === "selection" || type === "model:selection";
    };
    function isUnvisitedBlock(element, visited) {
      if (visited.has(element)) {
        return false;
      }
      visited.add(element);
      return element.root.document.model.schema.isBlock(element) && !!element.parent;
    }
    function isUnvisitedTopBlock(element, visited, range2) {
      return isUnvisitedBlock(element, visited) && isTopBlockInRange(element, range2);
    }
    function getParentBlock$1(position, visited) {
      const element = position.parent;
      const schema = element.root.document.model.schema;
      const ancestors = position.parent.getAncestors({
        parentFirst: true,
        includeSelf: true
      });
      let hasParentLimit = false;
      const block2 = ancestors.find((element2) => {
        if (hasParentLimit) {
          return false;
        }
        hasParentLimit = schema.isLimit(element2);
        return !hasParentLimit && isUnvisitedBlock(element2, visited);
      });
      ancestors.forEach((element2) => visited.add(element2));
      return block2;
    }
    function isTopBlockInRange(block2, range2) {
      const parentBlock = findAncestorBlock(block2);
      if (!parentBlock) {
        return true;
      }
      const isParentInRange = range2.containsRange(Range._createOn(parentBlock), true);
      return !isParentInRange;
    }
    function isStartBlockSelected(startBlock, range2) {
      if (!startBlock) {
        return false;
      }
      if (range2.isCollapsed || startBlock.isEmpty) {
        return true;
      }
      if (range2.start.isTouching(Position._createAt(startBlock, startBlock.maxOffset))) {
        return false;
      }
      return isTopBlockInRange(startBlock, range2);
    }
    function isEndBlockSelected(endBlock, range2) {
      if (!endBlock) {
        return false;
      }
      if (range2.isCollapsed || endBlock.isEmpty) {
        return true;
      }
      if (range2.end.isTouching(Position._createAt(endBlock, 0))) {
        return false;
      }
      return isTopBlockInRange(endBlock, range2);
    }
    function findAncestorBlock(node) {
      const schema = node.root.document.model.schema;
      let parent2 = node.parent;
      while (parent2) {
        if (schema.isBlock(parent2)) {
          return parent2;
        }
        parent2 = parent2.parent;
      }
    }
    class LiveRange extends (/* @__PURE__ */ EmitterMixin(Range)) {
      /**
      * Creates a live range.
      *
      * @see module:engine/model/range~Range
      */
      constructor(start2, end2) {
        super(start2, end2);
        bindWithDocument$1.call(this);
      }
      /**
      * Unbinds all events previously bound by `LiveRange`. Use it whenever you don't need `LiveRange` instance
      * anymore (i.e. when leaving scope in which it was declared or before re-assigning variable that was
      * referring to it).
      */
      detach() {
        this.stopListening();
      }
      /**
      * Creates a {@link module:engine/model/range~Range range instance} that is equal to this live range.
      */
      toRange() {
        return new Range(this.start, this.end);
      }
      /**
      * Creates a `LiveRange` instance that is equal to the given range.
      */
      static fromRange(range2) {
        return new LiveRange(range2.start, range2.end);
      }
    }
    LiveRange.prototype.is = function(type) {
      return type === "liveRange" || type === "model:liveRange" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
      type == "range" || type === "model:range";
    };
    function bindWithDocument$1() {
      this.listenTo(this.root.document.model, "applyOperation", (event, args) => {
        const operation = args[0];
        if (!operation.isDocumentOperation) {
          return;
        }
        transform$2.call(this, operation);
      }, {
        priority: "low"
      });
    }
    function transform$2(operation) {
      const ranges = this.getTransformedByOperation(operation);
      const result2 = Range._createFromRanges(ranges);
      const boundariesChanged = !result2.isEqual(this);
      const contentChanged = doesOperationChangeRangeContent(this, operation);
      let deletionPosition = null;
      if (boundariesChanged) {
        if (result2.root.rootName == "$graveyard") {
          if (operation.type == "remove") {
            deletionPosition = operation.sourcePosition;
          } else {
            deletionPosition = operation.deletionPosition;
          }
        }
        const oldRange = this.toRange();
        this.start = result2.start;
        this.end = result2.end;
        this.fire("change:range", oldRange, {
          deletionPosition
        });
      } else if (contentChanged) {
        this.fire("change:content", this.toRange(), {
          deletionPosition
        });
      }
    }
    function doesOperationChangeRangeContent(range2, operation) {
      switch (operation.type) {
        case "insert":
          return range2.containsPosition(operation.position);
        case "move":
        case "remove":
        case "reinsert":
        case "merge":
          return range2.containsPosition(operation.sourcePosition) || range2.start.isEqual(operation.sourcePosition) || range2.containsPosition(operation.targetPosition);
        case "split":
          return range2.containsPosition(operation.splitPosition) || range2.containsPosition(operation.insertionPosition);
      }
      return false;
    }
    const storePrefix = "selection:";
    class DocumentSelection extends (/* @__PURE__ */ EmitterMixin(TypeCheckable)) {
      /**
      * Creates an empty live selection for given {@link module:engine/model/document~Document}.
      *
      * @param doc Document which owns this selection.
      */
      constructor(doc) {
        super();
        /**
        * Selection used internally by that class (`DocumentSelection` is a proxy to that selection).
        */
        __publicField(this, "_selection");
        this._selection = new LiveSelection(doc);
        this._selection.delegate("change:range").to(this);
        this._selection.delegate("change:attribute").to(this);
        this._selection.delegate("change:marker").to(this);
      }
      /**
      * Describes whether the selection is collapsed. Selection is collapsed when there is exactly one range which is
      * collapsed.
      */
      get isCollapsed() {
        return this._selection.isCollapsed;
      }
      /**
      * Selection anchor. Anchor may be described as a position where the most recent part of the selection starts.
      * Together with {@link #focus} they define the direction of selection, which is important
      * when expanding/shrinking selection. Anchor is always {@link module:engine/model/range~Range#start start} or
      * {@link module:engine/model/range~Range#end end} position of the most recently added range.
      *
      * Is set to `null` if there are no ranges in selection.
      *
      * @see #focus
      */
      get anchor() {
        return this._selection.anchor;
      }
      /**
      * Selection focus. Focus is a position where the selection ends.
      *
      * Is set to `null` if there are no ranges in selection.
      *
      * @see #anchor
      */
      get focus() {
        return this._selection.focus;
      }
      /**
      * Number of ranges in selection.
      */
      get rangeCount() {
        return this._selection.rangeCount;
      }
      /**
      * Describes whether `Documentselection` has own range(s) set, or if it is defaulted to
      * {@link module:engine/model/document~Document#_getDefaultRange document's default range}.
      */
      get hasOwnRange() {
        return this._selection.hasOwnRange;
      }
      /**
      * Specifies whether the {@link #focus}
      * precedes {@link #anchor}.
      *
      * @readonly
      * @type {Boolean}
      */
      get isBackward() {
        return this._selection.isBackward;
      }
      /**
      * Describes whether the gravity is overridden (using {@link module:engine/model/writer~Writer#overrideSelectionGravity}) or not.
      *
      * Note that the gravity remains overridden as long as will not be restored the same number of times as it was overridden.
      */
      get isGravityOverridden() {
        return this._selection.isGravityOverridden;
      }
      /**
      * A collection of selection {@link module:engine/model/markercollection~Marker markers}.
      * Marker is a selection marker when selection range is inside the marker range.
      *
      * **Note**: Only markers from {@link ~DocumentSelection#observeMarkers observed markers groups} are collected.
      */
      get markers() {
        return this._selection.markers;
      }
      /**
      * Used for the compatibility with the {@link module:engine/model/selection~Selection#isEqual} method.
      *
      * @internal
      */
      get _ranges() {
        return this._selection._ranges;
      }
      /**
      * Returns an iterable that iterates over copies of selection ranges.
      */
      getRanges() {
        return this._selection.getRanges();
      }
      /**
      * Returns the first position in the selection.
      * First position is the position that {@link module:engine/model/position~Position#isBefore is before}
      * any other position in the selection.
      *
      * Returns `null` if there are no ranges in selection.
      */
      getFirstPosition() {
        return this._selection.getFirstPosition();
      }
      /**
      * Returns the last position in the selection.
      * Last position is the position that {@link module:engine/model/position~Position#isAfter is after}
      * any other position in the selection.
      *
      * Returns `null` if there are no ranges in selection.
      */
      getLastPosition() {
        return this._selection.getLastPosition();
      }
      /**
      * Returns a copy of the first range in the selection.
      * First range is the one which {@link module:engine/model/range~Range#start start} position
      * {@link module:engine/model/position~Position#isBefore is before} start position of all other ranges
      * (not to confuse with the first range added to the selection).
      *
      * Returns `null` if there are no ranges in selection.
      */
      getFirstRange() {
        return this._selection.getFirstRange();
      }
      /**
      * Returns a copy of the last range in the selection.
      * Last range is the one which {@link module:engine/model/range~Range#end end} position
      * {@link module:engine/model/position~Position#isAfter is after} end position of all other ranges (not to confuse with the range most
      * recently added to the selection).
      *
      * Returns `null` if there are no ranges in selection.
      */
      getLastRange() {
        return this._selection.getLastRange();
      }
      /**
      * Gets elements of type {@link module:engine/model/schema~Schema#isBlock "block"} touched by the selection.
      *
      * This method's result can be used for example to apply block styling to all blocks covered by this selection.
      *
      * **Note:** `getSelectedBlocks()` returns blocks that are nested in other non-block elements
      * but will not return blocks nested in other blocks.
      *
      * In this case the function will return exactly all 3 paragraphs (note: `<blockQuote>` is not a block itself):
      *
      * ```
      * <paragraph>[a</paragraph>
      * <blockQuote>
      * 	<paragraph>b</paragraph>
      * </blockQuote>
      * <paragraph>c]d</paragraph>
      * ```
      *
      * In this case the paragraph will also be returned, despite the collapsed selection:
      *
      * ```
      * <paragraph>[]a</paragraph>
      * ```
      *
      * In such a scenario, however, only blocks A, B & E will be returned as blocks C & D are nested in block B:
      *
      * ```
      * [<blockA></blockA>
      * <blockB>
      * 	<blockC></blockC>
      * 	<blockD></blockD>
      * </blockB>
      * <blockE></blockE>]
      * ```
      *
      * If the selection is inside a block all the inner blocks (A & B) are returned:
      *
      * ```
      * <block>
      * 	<blockA>[a</blockA>
      * 	<blockB>b]</blockB>
      * </block>
      * ```
      *
      * **Special case**: If a selection ends at the beginning of a block, that block is not returned as from user perspective
      * this block wasn't selected. See [#984](https://github.com/ckeditor/ckeditor5-engine/issues/984) for more details.
      *
      * ```
      * <paragraph>[a</paragraph>
      * <paragraph>b</paragraph>
      * <paragraph>]c</paragraph> // this block will not be returned
      * ```
      */
      getSelectedBlocks() {
        return this._selection.getSelectedBlocks();
      }
      /**
      * Returns the selected element. {@link module:engine/model/element~Element Element} is considered as selected if there is only
      * one range in the selection, and that range contains exactly one element.
      * Returns `null` if there is no selected element.
      */
      getSelectedElement() {
        return this._selection.getSelectedElement();
      }
      /**
      * Checks whether the selection contains the entire content of the given element. This means that selection must start
      * at a position {@link module:engine/model/position~Position#isTouching touching} the element's start and ends at position
      * touching the element's end.
      *
      * By default, this method will check whether the entire content of the selection's current root is selected.
      * Useful to check if e.g. the user has just pressed <kbd>Ctrl</kbd> + <kbd>A</kbd>.
      */
      containsEntireContent(element) {
        return this._selection.containsEntireContent(element);
      }
      /**
      * Unbinds all events previously bound by document selection.
      */
      destroy() {
        this._selection.destroy();
      }
      /**
      * Returns iterable that iterates over this selection's attribute keys.
      */
      getAttributeKeys() {
        return this._selection.getAttributeKeys();
      }
      /**
      * Returns iterable that iterates over this selection's attributes.
      *
      * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.
      * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
      */
      getAttributes() {
        return this._selection.getAttributes();
      }
      /**
      * Gets an attribute value for given key or `undefined` if that attribute is not set on the selection.
      *
      * @param key Key of attribute to look for.
      * @returns Attribute value or `undefined`.
      */
      getAttribute(key) {
        return this._selection.getAttribute(key);
      }
      /**
      * Checks if the selection has an attribute for given key.
      *
      * @param key Key of attribute to check.
      * @returns `true` if attribute with given key is set on selection, `false` otherwise.
      */
      hasAttribute(key) {
        return this._selection.hasAttribute(key);
      }
      /**
      * Refreshes selection attributes and markers according to the current position in the model.
      */
      refresh() {
        this._selection.updateMarkers();
        this._selection._updateAttributes(false);
      }
      /**
      * Registers a marker group prefix or a marker name to be collected in the
      * {@link ~DocumentSelection#markers selection markers collection}.
      *
      * See also {@link module:engine/model/markercollection~MarkerCollection#getMarkersGroup `MarkerCollection#getMarkersGroup()`}.
      *
      * @param prefixOrName The marker group prefix or marker name.
      */
      observeMarkers(prefixOrName) {
        this._selection.observeMarkers(prefixOrName);
      }
      /**
      * Moves {@link module:engine/model/documentselection~DocumentSelection#focus} to the specified location.
      * Should be used only within the {@link module:engine/model/writer~Writer#setSelectionFocus} method.
      *
      * The location can be specified in the same form as
      * {@link module:engine/model/writer~Writer#createPositionAt writer.createPositionAt()} parameters.
      *
      * @see module:engine/model/writer~Writer#setSelectionFocus
      * @internal
      * @param offset Offset or one of the flags. Used only when
      * first parameter is a {@link module:engine/model/item~Item model item}.
      */
      _setFocus(itemOrPosition, offset2) {
        this._selection.setFocus(itemOrPosition, offset2);
      }
      /**
      * Sets this selection's ranges and direction to the specified location based on the given
      * {@link module:engine/model/selection~Selectable selectable}.
      * Should be used only within the {@link module:engine/model/writer~Writer#setSelection} method.
      *
      * @see module:engine/model/writer~Writer#setSelection
      * @internal
      */
      _setTo(...args) {
        this._selection.setTo(...args);
      }
      /**
      * Sets attribute on the selection. If attribute with the same key already is set, it's value is overwritten.
      * Should be used only within the {@link module:engine/model/writer~Writer#setSelectionAttribute} method.
      *
      * @see module:engine/model/writer~Writer#setSelectionAttribute
      * @internal
      * @param key Key of the attribute to set.
      * @param value Attribute value.
      */
      _setAttribute(key, value) {
        this._selection.setAttribute(key, value);
      }
      /**
      * Removes an attribute with given key from the selection.
      * If the given attribute was set on the selection, fires the {@link module:engine/model/selection~Selection#event:change:range}
      * event with removed attribute key.
      * Should be used only within the {@link module:engine/model/writer~Writer#removeSelectionAttribute} method.
      *
      * @see module:engine/model/writer~Writer#removeSelectionAttribute
      * @internal
      * @param key Key of the attribute to remove.
      */
      _removeAttribute(key) {
        this._selection.removeAttribute(key);
      }
      /**
      * Returns an iterable that iterates through all selection attributes stored in current selection's parent.
      *
      * @internal
      */
      _getStoredAttributes() {
        return this._selection.getStoredAttributes();
      }
      /**
      * Temporarily changes the gravity of the selection from the left to the right.
      *
      * The gravity defines from which direction the selection inherits its attributes. If it's the default left
      * gravity, the selection (after being moved by the the user) inherits attributes from its left hand side.
      * This method allows to temporarily override this behavior by forcing the gravity to the right.
      *
      * It returns an unique identifier which is required to restore the gravity. It guarantees the symmetry
      * of the process.
      *
      * @see module:engine/model/writer~Writer#overrideSelectionGravity
      * @internal
      * @returns The unique id which allows restoring the gravity.
      */
      _overrideGravity() {
        return this._selection.overrideGravity();
      }
      /**
      * Restores the {@link ~DocumentSelection#_overrideGravity overridden gravity}.
      *
      * Restoring the gravity is only possible using the unique identifier returned by
      * {@link ~DocumentSelection#_overrideGravity}. Note that the gravity remains overridden as long as won't be restored
      * the same number of times it was overridden.
      *
      * @see module:engine/model/writer~Writer#restoreSelectionGravity
      * @internal
      * @param uid The unique id returned by {@link #_overrideGravity}.
      */
      _restoreGravity(uid2) {
        this._selection.restoreGravity(uid2);
      }
      /**
      * Generates and returns an attribute key for selection attributes store, basing on original attribute key.
      *
      * @internal
      * @param key Attribute key to convert.
      * @returns Converted attribute key, applicable for selection store.
      */
      static _getStoreAttributeKey(key) {
        return storePrefix + key;
      }
      /**
      * Checks whether the given attribute key is an attribute stored on an element.
      *
      * @internal
      */
      static _isStoreAttributeKey(key) {
        return key.startsWith(storePrefix);
      }
    }
    DocumentSelection.prototype.is = function(type) {
      return type === "selection" || type == "model:selection" || type == "documentSelection" || type == "model:documentSelection";
    };
    class LiveSelection extends Selection {
      /**
      * Creates an empty live selection for given {@link module:engine/model/document~Document}.
      *
      * @param doc Document which owns this selection.
      */
      constructor(doc) {
        super();
        /**
        * List of selection markers.
        * Marker is a selection marker when selection range is inside the marker range.
        */
        __publicField(this, "markers", new Collection({
          idProperty: "name"
        }));
        /**
        * Document which owns this selection.
        */
        __publicField(this, "_model");
        /**
        * Document which owns this selection.
        */
        __publicField(this, "_document");
        /**
        * Keeps mapping of attribute name to priority with which the attribute got modified (added/changed/removed)
        * last time. Possible values of priority are: `'low'` and `'normal'`.
        *
        * Priorities are used by internal `LiveSelection` mechanisms. All attributes set using `LiveSelection`
        * attributes API are set with `'normal'` priority.
        */
        __publicField(this, "_attributePriority", /* @__PURE__ */ new Map());
        /**
        * Position to which the selection should be set if the last selection range was moved to the graveyard.
        */
        __publicField(this, "_selectionRestorePosition", null);
        /**
        * Flag that informs whether the selection ranges have changed. It is changed on true when `LiveRange#change:range` event is fired.
        */
        __publicField(this, "_hasChangedRange", false);
        /**
        * Each overriding gravity adds an UID to the set and each removal removes it.
        * Gravity is overridden when there's at least one UID in the set.
        * Gravity is restored when the set is empty.
        * This is to prevent conflicts when gravity is overridden by more than one feature at the same time.
        */
        __publicField(this, "_overriddenGravityRegister", /* @__PURE__ */ new Set());
        /**
        * Prefixes of marker names that should affect `LiveSelection#markers` collection.
        */
        __publicField(this, "_observedMarkers", /* @__PURE__ */ new Set());
        this._model = doc.model;
        this._document = doc;
        this.listenTo(this._model, "applyOperation", (evt, args) => {
          const operation = args[0];
          if (!operation.isDocumentOperation || operation.type == "marker" || operation.type == "rename" || operation.type == "noop") {
            return;
          }
          if (this._ranges.length == 0 && this._selectionRestorePosition) {
            this._fixGraveyardSelection(this._selectionRestorePosition);
          }
          this._selectionRestorePosition = null;
          if (this._hasChangedRange) {
            this._hasChangedRange = false;
            this.fire("change:range", {
              directChange: false
            });
          }
        }, {
          priority: "lowest"
        });
        this.on("change:range", () => {
          this._validateSelectionRanges(this.getRanges());
        });
        this.listenTo(this._model.markers, "update", (evt, marker, oldRange, newRange) => {
          this._updateMarker(marker, newRange);
        });
        this.listenTo(this._document, "change", (evt, batch) => {
          clearAttributesStoredInElement(this._model, batch);
        });
      }
      get isCollapsed() {
        const length = this._ranges.length;
        return length === 0 ? this._document._getDefaultRange().isCollapsed : super.isCollapsed;
      }
      get anchor() {
        return super.anchor || this._document._getDefaultRange().start;
      }
      get focus() {
        return super.focus || this._document._getDefaultRange().end;
      }
      get rangeCount() {
        return this._ranges.length ? this._ranges.length : 1;
      }
      /**
      * Describes whether `LiveSelection` has own range(s) set, or if it is defaulted to
      * {@link module:engine/model/document~Document#_getDefaultRange document's default range}.
      */
      get hasOwnRange() {
        return this._ranges.length > 0;
      }
      /**
      * When set to `true` then selection attributes on node before the caret won't be taken
      * into consideration while updating selection attributes.
      */
      get isGravityOverridden() {
        return !!this._overriddenGravityRegister.size;
      }
      /**
      * Unbinds all events previously bound by live selection.
      */
      destroy() {
        for (let i2 = 0; i2 < this._ranges.length; i2++) {
          this._ranges[i2].detach();
        }
        this.stopListening();
      }
      *getRanges() {
        if (this._ranges.length) {
          yield* super.getRanges();
        } else {
          yield this._document._getDefaultRange();
        }
      }
      getFirstRange() {
        return super.getFirstRange() || this._document._getDefaultRange();
      }
      getLastRange() {
        return super.getLastRange() || this._document._getDefaultRange();
      }
      setTo(...args) {
        super.setTo(...args);
        this._updateAttributes(true);
        this.updateMarkers();
      }
      setFocus(itemOrPosition, offset2) {
        super.setFocus(itemOrPosition, offset2);
        this._updateAttributes(true);
        this.updateMarkers();
      }
      setAttribute(key, value) {
        if (this._setAttribute(key, value)) {
          const attributeKeys = [
            key
          ];
          this.fire("change:attribute", {
            attributeKeys,
            directChange: true
          });
        }
      }
      removeAttribute(key) {
        if (this._removeAttribute(key)) {
          const attributeKeys = [
            key
          ];
          this.fire("change:attribute", {
            attributeKeys,
            directChange: true
          });
        }
      }
      overrideGravity() {
        const overrideUid = uid();
        this._overriddenGravityRegister.add(overrideUid);
        if (this._overriddenGravityRegister.size === 1) {
          this._updateAttributes(true);
        }
        return overrideUid;
      }
      restoreGravity(uid2) {
        if (!this._overriddenGravityRegister.has(uid2)) {
          throw new CKEditorError("document-selection-gravity-wrong-restore", this, {
            uid: uid2
          });
        }
        this._overriddenGravityRegister.delete(uid2);
        if (!this.isGravityOverridden) {
          this._updateAttributes(true);
        }
      }
      observeMarkers(prefixOrName) {
        this._observedMarkers.add(prefixOrName);
        this.updateMarkers();
      }
      _replaceAllRanges(ranges) {
        this._validateSelectionRanges(ranges);
        super._replaceAllRanges(ranges);
      }
      _popRange() {
        this._ranges.pop().detach();
      }
      _pushRange(range2) {
        const liveRange = this._prepareRange(range2);
        if (liveRange) {
          this._ranges.push(liveRange);
        }
      }
      _validateSelectionRanges(ranges) {
        for (const range2 of ranges) {
          if (!this._document._validateSelectionRange(range2)) {
            throw new CKEditorError("document-selection-wrong-position", this, {
              range: range2
            });
          }
        }
      }
      /**
      * Prepares given range to be added to selection. Checks if it is correct,
      * converts it to {@link module:engine/model/liverange~LiveRange LiveRange}
      * and sets listeners listening to the range's change event.
      */
      _prepareRange(range2) {
        this._checkRange(range2);
        if (range2.root == this._document.graveyard) {
          return;
        }
        const liveRange = LiveRange.fromRange(range2);
        liveRange.on("change:range", (evt, oldRange, data) => {
          this._hasChangedRange = true;
          if (liveRange.root == this._document.graveyard) {
            this._selectionRestorePosition = data.deletionPosition;
            const index = this._ranges.indexOf(liveRange);
            this._ranges.splice(index, 1);
            liveRange.detach();
          }
        });
        return liveRange;
      }
      updateMarkers() {
        if (!this._observedMarkers.size) {
          return;
        }
        const markers = [];
        let changed = false;
        for (const marker of this._model.markers) {
          const markerGroup = marker.name.split(":", 1)[0];
          if (!this._observedMarkers.has(markerGroup)) {
            continue;
          }
          const markerRange = marker.getRange();
          for (const selectionRange of this.getRanges()) {
            if (markerRange.containsRange(selectionRange, !selectionRange.isCollapsed)) {
              markers.push(marker);
            }
          }
        }
        const oldMarkers = Array.from(this.markers);
        for (const marker of markers) {
          if (!this.markers.has(marker)) {
            this.markers.add(marker);
            changed = true;
          }
        }
        for (const marker of Array.from(this.markers)) {
          if (!markers.includes(marker)) {
            this.markers.remove(marker);
            changed = true;
          }
        }
        if (changed) {
          this.fire("change:marker", {
            oldMarkers,
            directChange: false
          });
        }
      }
      _updateMarker(marker, markerRange) {
        const markerGroup = marker.name.split(":", 1)[0];
        if (!this._observedMarkers.has(markerGroup)) {
          return;
        }
        let changed = false;
        const oldMarkers = Array.from(this.markers);
        const hasMarker = this.markers.has(marker);
        if (!markerRange) {
          if (hasMarker) {
            this.markers.remove(marker);
            changed = true;
          }
        } else {
          let contained = false;
          for (const selectionRange of this.getRanges()) {
            if (markerRange.containsRange(selectionRange, !selectionRange.isCollapsed)) {
              contained = true;
              break;
            }
          }
          if (contained && !hasMarker) {
            this.markers.add(marker);
            changed = true;
          } else if (!contained && hasMarker) {
            this.markers.remove(marker);
            changed = true;
          }
        }
        if (changed) {
          this.fire("change:marker", {
            oldMarkers,
            directChange: false
          });
        }
      }
      /**
      * Updates this selection attributes according to its ranges and the {@link module:engine/model/document~Document model document}.
      */
      _updateAttributes(clearAll) {
        const newAttributes = toMap(this._getSurroundingAttributes());
        const oldAttributes = toMap(this.getAttributes());
        if (clearAll) {
          this._attributePriority = /* @__PURE__ */ new Map();
          this._attrs = /* @__PURE__ */ new Map();
        } else {
          for (const [key, priority] of this._attributePriority) {
            if (priority == "low") {
              this._attrs.delete(key);
              this._attributePriority.delete(key);
            }
          }
        }
        this._setAttributesTo(newAttributes);
        const changed = [];
        for (const [newKey, newValue] of this.getAttributes()) {
          if (!oldAttributes.has(newKey) || oldAttributes.get(newKey) !== newValue) {
            changed.push(newKey);
          }
        }
        for (const [oldKey] of oldAttributes) {
          if (!this.hasAttribute(oldKey)) {
            changed.push(oldKey);
          }
        }
        if (changed.length > 0) {
          this.fire("change:attribute", {
            attributeKeys: changed,
            directChange: false
          });
        }
      }
      /**
      * Internal method for setting `LiveSelection` attribute. Supports attribute priorities (through `directChange`
      * parameter).
      */
      _setAttribute(key, value, directChange = true) {
        const priority = directChange ? "normal" : "low";
        if (priority == "low" && this._attributePriority.get(key) == "normal") {
          return false;
        }
        const oldValue = super.getAttribute(key);
        if (oldValue === value) {
          return false;
        }
        this._attrs.set(key, value);
        this._attributePriority.set(key, priority);
        return true;
      }
      /**
      * Internal method for removing `LiveSelection` attribute. Supports attribute priorities (through `directChange`
      * parameter).
      *
      * NOTE: Even if attribute is not present in the selection but is provided to this method, it's priority will
      * be changed according to `directChange` parameter.
      */
      _removeAttribute(key, directChange = true) {
        const priority = directChange ? "normal" : "low";
        if (priority == "low" && this._attributePriority.get(key) == "normal") {
          return false;
        }
        this._attributePriority.set(key, priority);
        if (!super.hasAttribute(key)) {
          return false;
        }
        this._attrs.delete(key);
        return true;
      }
      /**
      * Internal method for setting multiple `LiveSelection` attributes. Supports attribute priorities (through
      * `directChange` parameter).
      */
      _setAttributesTo(attrs) {
        const changed = /* @__PURE__ */ new Set();
        for (const [oldKey, oldValue] of this.getAttributes()) {
          if (attrs.get(oldKey) === oldValue) {
            continue;
          }
          this._removeAttribute(oldKey, false);
        }
        for (const [key, value] of attrs) {
          const gotAdded = this._setAttribute(key, value, false);
          if (gotAdded) {
            changed.add(key);
          }
        }
        return changed;
      }
      /**
      * Returns an iterable that iterates through all selection attributes stored in current selection's parent.
      */
      *getStoredAttributes() {
        const selectionParent = this.getFirstPosition().parent;
        if (this.isCollapsed && selectionParent.isEmpty) {
          for (const key of selectionParent.getAttributeKeys()) {
            if (key.startsWith(storePrefix)) {
              const realKey = key.substr(storePrefix.length);
              yield [
                realKey,
                selectionParent.getAttribute(key)
              ];
            }
          }
        }
      }
      /**
      * Checks model text nodes that are closest to the selection's first position and returns attributes of first
      * found element. If there are no text nodes in selection's first position parent, it returns selection
      * attributes stored in that parent.
      */
      _getSurroundingAttributes() {
        const position = this.getFirstPosition();
        const schema = this._model.schema;
        if (position.root.rootName == "$graveyard") {
          return null;
        }
        let attrs = null;
        if (!this.isCollapsed) {
          const range2 = this.getFirstRange();
          for (const value of range2) {
            if (value.item.is("element") && schema.isObject(value.item)) {
              attrs = getTextAttributes(value.item, schema);
              break;
            }
            if (value.type == "text") {
              attrs = value.item.getAttributes();
              break;
            }
          }
        } else {
          const nodeBefore = position.textNode ? position.textNode : position.nodeBefore;
          const nodeAfter = position.textNode ? position.textNode : position.nodeAfter;
          if (!this.isGravityOverridden) {
            attrs = getTextAttributes(nodeBefore, schema);
          }
          if (!attrs) {
            attrs = getTextAttributes(nodeAfter, schema);
          }
          if (!this.isGravityOverridden && !attrs) {
            let node = nodeBefore;
            while (node && !attrs) {
              node = node.previousSibling;
              attrs = getTextAttributes(node, schema);
            }
          }
          if (!attrs) {
            let node = nodeAfter;
            while (node && !attrs) {
              node = node.nextSibling;
              attrs = getTextAttributes(node, schema);
            }
          }
          if (!attrs) {
            attrs = this.getStoredAttributes();
          }
        }
        return attrs;
      }
      /**
      * Fixes the selection after all its ranges got removed.
      * @param deletionPosition Position where the deletion happened.
      */
      _fixGraveyardSelection(deletionPosition) {
        const selectionRange = this._model.schema.getNearestSelectionRange(deletionPosition);
        if (selectionRange) {
          this._pushRange(selectionRange);
        }
      }
    }
    function getTextAttributes(node, schema) {
      if (!node) {
        return null;
      }
      if (node instanceof TextProxy || node instanceof Text) {
        return node.getAttributes();
      }
      if (!schema.isInline(node)) {
        return null;
      }
      if (!schema.isObject(node)) {
        return [];
      }
      const attributes = [];
      for (const [key, value] of node.getAttributes()) {
        if (schema.checkAttribute("$text", key) && schema.getAttributeProperties(key).copyFromObject !== false) {
          attributes.push([
            key,
            value
          ]);
        }
      }
      return attributes;
    }
    function clearAttributesStoredInElement(model, batch) {
      const differ = model.document.differ;
      for (const entry of differ.getChanges()) {
        if (entry.type != "insert") {
          continue;
        }
        const changeParent = entry.position.parent;
        const isNoLongerEmpty = entry.length === changeParent.maxOffset;
        if (isNoLongerEmpty) {
          model.enqueueChange(batch, (writer) => {
            const storedAttributes = Array.from(changeParent.getAttributeKeys()).filter((key) => key.startsWith(storePrefix));
            for (const key of storedAttributes) {
              writer.removeAttribute(key, changeParent);
            }
          });
        }
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class ConversionHelpers {
      /**
      * Creates a conversion helpers instance.
      */
      constructor(dispatchers) {
        __publicField(this, "_dispatchers");
        this._dispatchers = dispatchers;
      }
      /**
      * Registers a conversion helper.
      *
      * **Note**: See full usage example in the `{@link module:engine/conversion/conversion~Conversion#for conversion.for()}`
      * method description.
      *
      * @param conversionHelper The function to be called on event.
      */
      add(conversionHelper) {
        for (const dispatcher of this._dispatchers) {
          conversionHelper(dispatcher);
        }
        return this;
      }
    }
    class DowncastHelpers extends ConversionHelpers {
      /**
      * Model element to view element conversion helper.
      *
      * This conversion results in creating a view element. For example, model `<paragraph>Foo</paragraph>` becomes `<p>Foo</p>` in the view.
      *
      * ```ts
      * editor.conversion.for( 'downcast' ).elementToElement( {
      * 	model: 'paragraph',
      * 	view: 'p'
      * } );
      *
      * editor.conversion.for( 'downcast' ).elementToElement( {
      * 	model: 'paragraph',
      * 	view: 'div',
      * 	converterPriority: 'high'
      * } );
      *
      * editor.conversion.for( 'downcast' ).elementToElement( {
      * 	model: 'fancyParagraph',
      * 	view: {
      * 		name: 'p',
      * 		classes: 'fancy'
      * 	}
      * } );
      *
      * editor.conversion.for( 'downcast' ).elementToElement( {
      * 	model: 'heading',
      * 	view: ( modelElement, conversionApi ) => {
      * 		const { writer } = conversionApi;
      *
      * 		return writer.createContainerElement( 'h' + modelElement.getAttribute( 'level' ) );
      * 	}
      * } );
      * ```
      *
      * The element-to-element conversion supports the reconversion mechanism. It can be enabled by using either the `attributes` or
      * the `children` props on a model description. You will find a couple examples below.
      *
      * In order to reconvert an element if any of its direct children have been added or removed, use the `children` property on a `model`
      * description. For example, this model:
      *
      * ```xml
      * <box>
      * 	<paragraph>Some text.</paragraph>
      * </box>
      * ```
      *
      * will be converted into this structure in the view:
      *
      * ```html
      * <div class="box" data-type="single">
      * 	<p>Some text.</p>
      * </div>
      * ```
      *
      * But if more items were inserted in the model:
      *
      * ```xml
      * <box>
      * 	<paragraph>Some text.</paragraph>
      * 	<paragraph>Other item.</paragraph>
      * </box>
      * ```
      *
      * it will be converted into this structure in the view (note the element `data-type` change):
      *
      * ```html
      * <div class="box" data-type="multiple">
      * 	<p>Some text.</p>
      * 	<p>Other item.</p>
      * </div>
      * ```
      *
      * Such a converter would look like this (note that the `paragraph` elements are converted separately):
      *
      * ```ts
      * editor.conversion.for( 'downcast' ).elementToElement( {
      * 	model: {
      * 		name: 'box',
      * 		children: true
      * 	},
      * 	view: ( modelElement, conversionApi ) => {
      * 		const { writer } = conversionApi;
      *
      * 		return writer.createContainerElement( 'div', {
      * 			class: 'box',
      * 			'data-type': modelElement.childCount == 1 ? 'single' : 'multiple'
      * 		} );
      * 	}
      * } );
      * ```
      *
      * In order to reconvert element if any of its attributes have been updated, use the `attributes` property on a `model`
      * description. For example, this model:
      *
      * ```xml
      * <heading level="2">Some text.</heading>
      * ```
      *
      * will be converted into this structure in the view:
      *
      * ```html
      * <h2>Some text.</h2>
      * ```
      *
      * But if the `heading` element's `level` attribute has been updated to `3` for example, then
      * it will be converted into this structure in the view:
      *
      * ```html
      * <h3>Some text.</h3>
      * ```
      *
      * Such a converter would look as follows:
      *
      * ```ts
      * editor.conversion.for( 'downcast' ).elementToElement( {
      * 	model: {
      * 		name: 'heading',
      * 		attributes: 'level'
      * 	},
      * 	view: ( modelElement, conversionApi ) => {
      * 		const { writer } = conversionApi;
      *
      * 		return writer.createContainerElement( 'h' + modelElement.getAttribute( 'level' ) );
      * 	}
      * } );
      * ```
      *
      * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
      * to the conversion process.
      *
      * You can read more about the element-to-element conversion in the
      * {@glink framework/deep-dive/conversion/downcast downcast conversion} guide.
      *
      * @param config Conversion configuration.
      * @param config.model The description or a name of the model element to convert.
      * @param config.model.attributes The list of attribute names that should be consumed while creating
      * the view element. Note that the view will be reconverted if any of the listed attributes changes.
       * @param config.model.children Specifies whether the view element requires reconversion if the list
      * of the model child nodes changed.
      * @param config.view A view element definition or a function that takes the model element and
      * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}
      * as parameters and returns a view container element.
      */
      elementToElement(config2) {
        return this.add(downcastElementToElement(config2));
      }
      /**
      * The model element to view structure (several elements) conversion helper.
      *
      * This conversion results in creating a view structure with one or more slots defined for the child nodes.
      * For example, a model `<table>` may become this structure in the view:
      *
      * ```html
      * <figure class="table">
      * 	<table>
      * 		<tbody>${ slot for table rows }</tbody>
      * 	</table>
      * </figure>
      * ```
      *
      * The children of the model's `<table>` element will be inserted into the `<tbody>` element.
      * If the `elementToElement()` helper was used, the children would be inserted into the `<figure>`.
      *
      * Imagine a table feature where for this model structure:
      *
      * ```xml
      * <table headingRows="1">
      * 	<tableRow> ... table cells 1 ... </tableRow>
      * 	<tableRow> ... table cells 2 ... </tableRow>
      * 	<tableRow> ... table cells 3 ... </tableRow>
      * 	<caption>Caption text</caption>
      * </table>
      * ```
      *
      * we want to generate this view structure:
      *
      * ```html
      * <figure class="table">
      * 	<table>
      * 		<thead>
      * 			<tr> ... table cells 1 ... </tr>
      * 		</thead>
      * 		<tbody>
      * 			<tr> ... table cells 2 ... </tr>
      * 			<tr> ... table cells 3 ... </tr>
      * 		</tbody>
      * 	</table>
      * 	<figcaption>Caption text</figcaption>
      * </figure>
      * ```
      *
      * The converter has to take the `headingRows` attribute into consideration when allocating the `<tableRow>` elements
      * into the `<tbody>` and `<thead>` elements. Hence, we need two slots and need to define proper filter callbacks for them.
      *
      * Additionally, all elements other than `<tableRow>` should be placed outside the `<table>` tag.
      * In the example above, this will handle the table caption.
      *
      * Such a converter would look like this:
      *
      * ```ts
      * editor.conversion.for( 'downcast' ).elementToStructure( {
      * 	model: {
      * 		name: 'table',
      * 		attributes: [ 'headingRows' ]
      * 	},
      * 	view: ( modelElement, conversionApi ) => {
      * 		const { writer } = conversionApi;
      *
      * 		const figureElement = writer.createContainerElement( 'figure', { class: 'table' } );
      * 		const tableElement = writer.createContainerElement( 'table' );
      *
      * 		writer.insert( writer.createPositionAt( figureElement, 0 ), tableElement );
      *
      * 		const headingRows = modelElement.getAttribute( 'headingRows' ) || 0;
      *
      * 		if ( headingRows > 0 ) {
      * 			const tableHead = writer.createContainerElement( 'thead' );
      *
      * 			const headSlot = writer.createSlot( node => node.is( 'element', 'tableRow' ) && node.index < headingRows );
      *
      * 			writer.insert( writer.createPositionAt( tableElement, 'end' ), tableHead );
      * 			writer.insert( writer.createPositionAt( tableHead, 0 ), headSlot );
      * 		}
      *
      * 		if ( headingRows < tableUtils.getRows( table ) ) {
      * 			const tableBody = writer.createContainerElement( 'tbody' );
      *
      * 			const bodySlot = writer.createSlot( node => node.is( 'element', 'tableRow' ) && node.index >= headingRows );
      *
      * 			writer.insert( writer.createPositionAt( tableElement, 'end' ), tableBody );
      * 			writer.insert( writer.createPositionAt( tableBody, 0 ), bodySlot );
      * 		}
      *
      * 		const restSlot = writer.createSlot( node => !node.is( 'element', 'tableRow' ) );
      *
      * 		writer.insert( writer.createPositionAt( figureElement, 'end' ), restSlot );
      *
      * 		return figureElement;
      * 	}
      * } );
      * ```
      *
      * Note: The children of a model element that's being converted must be allocated in the same order in the view
      * in which they are placed in the model.
      *
      * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
      * to the conversion process.
      *
      * @param config Conversion configuration.
       * @param config.model The description or a name of the model element to convert.
      * @param config.model.name The name of the model element to convert.
       * @param config.model.attributes The list of attribute names that should be consumed while creating
      * the view structure. Note that the view will be reconverted if any of the listed attributes will change.
      * @param config.view A function that takes the model element and
      * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as parameters
      * and returns a view container element with slots for model child nodes to be converted into.
      */
      elementToStructure(config2) {
        return this.add(downcastElementToStructure(config2));
      }
      /**
      * Model attribute to view element conversion helper.
      *
      * This conversion results in wrapping view nodes with a view attribute element. For example, a model text node with
      * `"Foo"` as data and the `bold` attribute becomes `<strong>Foo</strong>` in the view.
      *
      * ```ts
      * editor.conversion.for( 'downcast' ).attributeToElement( {
      * 	model: 'bold',
      * 	view: 'strong'
      * } );
      *
      * editor.conversion.for( 'downcast' ).attributeToElement( {
      * 	model: 'bold',
      * 	view: 'b',
      * 	converterPriority: 'high'
      * } );
      *
      * editor.conversion.for( 'downcast' ).attributeToElement( {
      * 	model: 'invert',
      * 	view: {
      * 		name: 'span',
      * 		classes: [ 'font-light', 'bg-dark' ]
      * 	}
      * } );
      *
      * editor.conversion.for( 'downcast' ).attributeToElement( {
      * 	model: {
      * 		key: 'fontSize',
      * 		values: [ 'big', 'small' ]
      * 	},
      * 	view: {
      * 		big: {
      * 			name: 'span',
      * 			styles: {
      * 				'font-size': '1.2em'
      * 			}
      * 		},
      * 		small: {
      * 			name: 'span',
      * 			styles: {
      * 				'font-size': '0.8em'
      * 			}
      * 		}
      * 	}
      * } );
      *
      * editor.conversion.for( 'downcast' ).attributeToElement( {
      * 	model: 'bold',
      * 	view: ( modelAttributeValue, conversionApi ) => {
      * 		const { writer } = conversionApi;
      *
      * 		return writer.createAttributeElement( 'span', {
      * 			style: 'font-weight:' + modelAttributeValue
      * 		} );
      * 	}
      * } );
      *
      * editor.conversion.for( 'downcast' ).attributeToElement( {
      * 	model: {
      * 		key: 'color',
      * 		name: '$text'
      * 	},
      * 	view: ( modelAttributeValue, conversionApi ) => {
      * 		const { writer } = conversionApi;
      *
      * 		return writer.createAttributeElement( 'span', {
      * 			style: 'color:' + modelAttributeValue
      * 		} );
      * 	}
      * } );
      * ```
      *
      * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
      * to the conversion process.
      *
      * @param config Conversion configuration.
      * @param config.model The key of the attribute to convert from or a `{ key, values }` object. `values` is an array
      * of `String`s with possible values if the model attribute is an enumerable.
      * @param config.view A view element definition or a function
      * that takes the model attribute value and
      * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as parameters and returns a view
      * attribute element. If `config.model.values` is given, `config.view` should be an object assigning values from `config.model.values`
      * to view element definitions or functions.
      * @param config.converterPriority Converter priority.
      */
      attributeToElement(config2) {
        return this.add(downcastAttributeToElement(config2));
      }
      /**
      * Model attribute to view attribute conversion helper.
      *
      * This conversion results in adding an attribute to a view node, basing on an attribute from a model node. For example,
      * `<imageInline src='foo.jpg'></imageInline>` is converted to `<img src='foo.jpg'></img>`.
      *
      * ```ts
      * editor.conversion.for( 'downcast' ).attributeToAttribute( {
      * 	model: 'source',
      * 	view: 'src'
      * } );
      *
      * editor.conversion.for( 'downcast' ).attributeToAttribute( {
      * 	model: 'source',
      * 	view: 'href',
      * 	converterPriority: 'high'
      * } );
      *
      * editor.conversion.for( 'downcast' ).attributeToAttribute( {
      * 	model: {
      * 		name: 'imageInline',
      * 		key: 'source'
      * 	},
      * 	view: 'src'
      * } );
      *
      * editor.conversion.for( 'downcast' ).attributeToAttribute( {
      * 	model: {
      * 		name: 'styled',
      * 		values: [ 'dark', 'light' ]
      * 	},
      * 	view: {
      * 		dark: {
      * 			key: 'class',
      * 			value: [ 'styled', 'styled-dark' ]
      * 		},
      * 		light: {
      * 			key: 'class',
      * 			value: [ 'styled', 'styled-light' ]
      * 		}
      * 	}
      * } );
      *
      * editor.conversion.for( 'downcast' ).attributeToAttribute( {
      * 	model: 'styled',
      * 	view: modelAttributeValue => ( {
      * 		key: 'class',
      * 		value: 'styled-' + modelAttributeValue
      * 	} )
      * } );
      * ```
      *
      * **Note**: Downcasting to a style property requires providing `value` as an object:
      *
      * ```ts
      * editor.conversion.for( 'downcast' ).attributeToAttribute( {
      * 	model: 'lineHeight',
      * 	view: modelAttributeValue => ( {
      * 		key: 'style',
      * 		value: {
      * 			'line-height': modelAttributeValue,
      * 			'border-bottom': '1px dotted #ba2'
      * 		}
      * 	} )
      * } );
      * ```
      *
      * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
      * to the conversion process.
      *
      * @param config Conversion configuration.
      * @param config.model The key of the attribute to convert from or a `{ key, values, [ name ] }` object describing
      * the attribute key, possible values and, optionally, an element name to convert from.
      * @param config.view A view attribute key, or a `{ key, value }` object or a function that takes the model attribute value and
      * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}
      * as parameters and returns a `{ key, value }` object. If the `key` is `'class'`, the `value` can be a `String` or an
      * array of `String`s. If the `key` is `'style'`, the `value` is an object with key-value pairs. In other cases, `value` is a `String`.
      * If `config.model.values` is set, `config.view` should be an object assigning values from `config.model.values` to
      * `{ key, value }` objects or a functions.
      * @param config.converterPriority Converter priority.
      */
      attributeToAttribute(config2) {
        return this.add(downcastAttributeToAttribute(config2));
      }
      /**
      * Model marker to view element conversion helper.
      *
      * **Note**: This method should be used mainly for editing the downcast and it is recommended
      * to use the {@link #markerToData `#markerToData()`} helper instead.
      *
      * This helper may produce invalid HTML code (e.g. a span between table cells).
      * It should only be used when you are sure that the produced HTML will be semantically correct.
      *
      * This conversion results in creating a view element on the boundaries of the converted marker. If the converted marker
      * is collapsed, only one element is created. For example, a model marker set like this: `<paragraph>F[oo b]ar</paragraph>`
      * becomes `<p>F<span data-marker="search"></span>oo b<span data-marker="search"></span>ar</p>` in the view.
      *
      * ```ts
      * editor.conversion.for( 'editingDowncast' ).markerToElement( {
      * 	model: 'search',
      * 	view: 'marker-search'
      * } );
      *
      * editor.conversion.for( 'editingDowncast' ).markerToElement( {
      * 	model: 'search',
      * 	view: 'search-result',
      * 	converterPriority: 'high'
      * } );
      *
      * editor.conversion.for( 'editingDowncast' ).markerToElement( {
      * 	model: 'search',
      * 	view: {
      * 		name: 'span',
      * 		attributes: {
      * 			'data-marker': 'search'
      * 		}
      * 	}
      * } );
      *
      * editor.conversion.for( 'editingDowncast' ).markerToElement( {
      * 	model: 'search',
      * 	view: ( markerData, conversionApi ) => {
      * 		const { writer } = conversionApi;
      *
      * 		return writer.createUIElement( 'span', {
      * 			'data-marker': 'search',
      * 			'data-start': markerData.isOpening
      * 		} );
      * 	}
      * } );
      * ```
      *
      * If a function is passed as the `config.view` parameter, it will be used to generate both boundary elements. The function
      * receives the `data` object and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}
      * as a parameters and should return an instance of the
      * {@link module:engine/view/uielement~UIElement view UI element}. The `data` object and
      * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi `conversionApi`} are passed from
      * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}. Additionally,
      * the `data.isOpening` parameter is passed, which is set to `true` for the marker start boundary element, and `false` for
      * the marker end boundary element.
      *
      * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
      * to the conversion process.
      *
      * @param config Conversion configuration.
      * @param config.model The name of the model marker (or model marker group) to convert.
      * @param config.view A view element definition or a function that takes the model marker data and
      * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as a parameters
      * and returns a view UI element.
      * @param config.converterPriority Converter priority.
      */
      markerToElement(config2) {
        return this.add(downcastMarkerToElement(config2));
      }
      /**
      * Model marker to highlight conversion helper.
      *
      * This conversion results in creating a highlight on view nodes. For this kind of conversion,
      * the {@link module:engine/conversion/downcasthelpers~HighlightDescriptor} should be provided.
      *
      * For text nodes, a `<span>` {@link module:engine/view/attributeelement~AttributeElement} is created and it wraps all text nodes
      * in the converted marker range. For example, a model marker set like this: `<paragraph>F[oo b]ar</paragraph>` becomes
      * `<p>F<span class="comment">oo b</span>ar</p>` in the view.
      *
      * {@link module:engine/view/containerelement~ContainerElement} may provide a custom way of handling highlight. Most often,
      * the element itself is given classes and attributes described in the highlight descriptor (instead of being wrapped in `<span>`).
      * For example, a model marker set like this:
      * `[<imageInline src="foo.jpg"></imageInline>]` becomes `<img src="foo.jpg" class="comment"></img>` in the view.
      *
      * For container elements, the conversion is two-step. While the converter processes the highlight descriptor and passes it
      * to a container element, it is the container element instance itself that applies values from the highlight descriptor.
      * So, in a sense, the converter takes care of stating what should be applied on what, while the element decides how to apply that.
      *
      * ```ts
      * editor.conversion.for( 'downcast' ).markerToHighlight( { model: 'comment', view: { classes: 'comment' } } );
      *
      * editor.conversion.for( 'downcast' ).markerToHighlight( {
      * 	model: 'comment',
      * 	view: { classes: 'comment' },
      * 	converterPriority: 'high'
      * } );
      *
      * editor.conversion.for( 'downcast' ).markerToHighlight( {
      * 	model: 'comment',
      * 	view: ( data, conversionApi ) => {
      * 		// Assuming that the marker name is in a form of comment:commentType:commentId.
      * 		const [ , commentType, commentId ] = data.markerName.split( ':' );
      *
      * 		return {
      * 			classes: [ 'comment', 'comment-' + commentType ],
      * 			attributes: { 'data-comment-id': commentId }
      * 		};
      * 	}
      * } );
      * ```
      *
      * If a function is passed as the `config.view` parameter, it will be used to generate the highlight descriptor. The function
      * receives the `data` object and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}
      * as the parameters and should return a
      * {@link module:engine/conversion/downcasthelpers~HighlightDescriptor highlight descriptor}.
      * The `data` object properties are passed from {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}.
      *
      * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
      * to the conversion process.
      *
      * @param config Conversion configuration.
      * @param config.model The name of the model marker (or model marker group) to convert.
      * @param config.view A highlight descriptor that will be used for highlighting or a function that takes the model marker data and
      * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as a parameters
      * and returns a highlight descriptor.
      * @param config.converterPriority Converter priority.
      */
      markerToHighlight(config2) {
        return this.add(downcastMarkerToHighlight(config2));
      }
      /**
      * Model marker converter for data downcast.
      *
      * This conversion creates a representation for model marker boundaries in the view:
      *
      * * If the marker boundary is before or after a model element, a view attribute is set on a corresponding view element.
      * * In other cases, a view element with the specified tag name is inserted at the corresponding view position.
      *
      * Typically, the marker names use the `group:uniqueId:otherData` convention. For example: `comment:e34zfk9k2n459df53sjl34:zx32c`.
      * The default configuration for this conversion is that the first part is the `group` part and the rest of
      * the marker name becomes the `name` part.
      *
      * Tag and attribute names and values are generated from the marker name:
      *
      * * The templates for attributes are `data-[group]-start-before="[name]"`, `data-[group]-start-after="[name]"`,
      * `data-[group]-end-before="[name]"` and `data-[group]-end-after="[name]"`.
      * * The templates for view elements are `<[group]-start name="[name]">` and `<[group]-end name="[name]">`.
      *
      * Attributes mark whether the given marker's start or end boundary is before or after the given element.
      * The `data-[group]-start-before` and `data-[group]-end-after` attributes are favored.
      * The other two are used when the former two cannot be used.
      *
      * The conversion configuration can take a function that will generate different group and name parts.
      * If such a function is set as the `config.view` parameter, it is passed a marker name and it is expected to return an object with two
      * properties: `group` and `name`. If the function returns a falsy value, the conversion will not take place.
      *
      * Basic usage:
      *
      * ```ts
      * // Using the default conversion.
      * // In this case, all markers with names starting with 'comment:' will be converted.
      * // The `group` parameter will be set to `comment`.
      * // The `name` parameter will be the rest of the marker name (without the `:`).
      * editor.conversion.for( 'dataDowncast' ).markerToData( {
      * 	model: 'comment'
      * } );
      * ```
      *
      * An example of a view that may be generated by this conversion (assuming a marker with the name `comment:commentId:uid` marked
      * by `[]`):
      *
      * ```
      * // Model:
      * <paragraph>Foo[bar</paragraph>
      * <imageBlock src="abc.jpg"></imageBlock>]
      *
      * // View:
      * <p>Foo<comment-start name="commentId:uid"></comment-start>bar</p>
      * <figure data-comment-end-after="commentId:uid" class="image"><img src="abc.jpg" /></figure>
      * ```
      *
      * In the example above, the comment starts before "bar" and ends after the image.
      *
      * If the `name` part is empty, the following view may be generated:
      *
      * ```html
      * <p>Foo <myMarker-start></myMarker-start>bar</p>
      * <figure data-myMarker-end-after="" class="image"><img src="abc.jpg" /></figure>
      * ```
      *
      * **Note:** A situation where some markers have the `name` part and some do not, is incorrect and should be avoided.
      *
      * Examples where `data-group-start-after` and `data-group-end-before` are used:
      *
      * ```
      * // Model:
      * <blockQuote>[]<paragraph>Foo</paragraph></blockQuote>
      *
      * // View:
      * <blockquote><p data-group-end-before="name" data-group-start-before="name">Foo</p></blockquote>
      * ```
      *
      * Similarly, when a marker is collapsed after the last element:
      *
      * ```
      * // Model:
      * <blockQuote><paragraph>Foo</paragraph>[]</blockQuote>
      *
      * // View:
      * <blockquote><p data-group-end-after="name" data-group-start-after="name">Foo</p></blockquote>
      * ```
      *
      * When there are multiple markers from the same group stored in the same attribute of the same element, their
      * name parts are put together in the attribute value, for example: `data-group-start-before="name1,name2,name3"`.
      *
      * Other examples of usage:
      *
      * ```ts
      * // Using a custom function which is the same as the default conversion:
      * editor.conversion.for( 'dataDowncast' ).markerToData( {
      * 	model: 'comment',
      * 	view: markerName => ( {
      * 		group: 'comment',
      * 		name: markerName.substr( 8 ) // Removes 'comment:' part.
      * 	} )
      * } );
      *
      * // Using the converter priority:
      * editor.conversion.for( 'dataDowncast' ).markerToData( {
      * 	model: 'comment',
      * 	view: markerName => ( {
      * 		group: 'comment',
      * 		name: markerName.substr( 8 ) // Removes 'comment:' part.
      * 	} ),
      * 	converterPriority: 'high'
      * } );
      * ```
      *
      * This kind of conversion is useful for saving data into the database, so it should be used in the data conversion pipeline.
      *
      * See the {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} API guide to learn how to
      * add a converter to the conversion process.
      *
      * @param config Conversion configuration.
      * @param config.model The name of the model marker (or the model marker group) to convert.
      * @param config.view A function that takes the model marker name and
      * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as the parameters
      * and returns an object with the `group` and `name` properties.
      * @param config.converterPriority Converter priority.
      */
      markerToData(config2) {
        return this.add(downcastMarkerToData(config2));
      }
    }
    function insertText() {
      return (evt, data, conversionApi) => {
        if (!conversionApi.consumable.consume(data.item, evt.name)) {
          return;
        }
        const viewWriter = conversionApi.writer;
        const viewPosition = conversionApi.mapper.toViewPosition(data.range.start);
        const viewText = viewWriter.createText(data.item.data);
        viewWriter.insert(viewPosition, viewText);
      };
    }
    function insertAttributesAndChildren() {
      return (evt, data, conversionApi) => {
        conversionApi.convertAttributes(data.item);
        if (!data.reconversion && data.item.is("element") && !data.item.isEmpty) {
          conversionApi.convertChildren(data.item);
        }
      };
    }
    function remove() {
      return (evt, data, conversionApi) => {
        const viewStart = conversionApi.mapper.toViewPosition(data.position);
        const modelEnd = data.position.getShiftedBy(data.length);
        const viewEnd = conversionApi.mapper.toViewPosition(modelEnd, {
          isPhantom: true
        });
        const viewRange = conversionApi.writer.createRange(viewStart, viewEnd);
        const removed = conversionApi.writer.remove(viewRange.getTrimmed());
        for (const child of conversionApi.writer.createRangeIn(removed).getItems()) {
          conversionApi.mapper.unbindViewElement(child, {
            defer: true
          });
        }
      };
    }
    function createViewElementFromHighlightDescriptor(writer, descriptor) {
      const viewElement = writer.createAttributeElement("span", descriptor.attributes);
      if (descriptor.classes) {
        viewElement._addClass(descriptor.classes);
      }
      if (typeof descriptor.priority === "number") {
        viewElement._priority = descriptor.priority;
      }
      viewElement._id = descriptor.id;
      return viewElement;
    }
    function convertRangeSelection() {
      return (evt, data, conversionApi) => {
        const selection = data.selection;
        if (selection.isCollapsed) {
          return;
        }
        if (!conversionApi.consumable.consume(selection, "selection")) {
          return;
        }
        const viewRanges = [];
        for (const range2 of selection.getRanges()) {
          viewRanges.push(conversionApi.mapper.toViewRange(range2));
        }
        conversionApi.writer.setSelection(viewRanges, {
          backward: selection.isBackward
        });
      };
    }
    function convertCollapsedSelection() {
      return (evt, data, conversionApi) => {
        const selection = data.selection;
        if (!selection.isCollapsed) {
          return;
        }
        if (!conversionApi.consumable.consume(selection, "selection")) {
          return;
        }
        const viewWriter = conversionApi.writer;
        const modelPosition = selection.getFirstPosition();
        const viewPosition = conversionApi.mapper.toViewPosition(modelPosition);
        const brokenPosition = viewWriter.breakAttributes(viewPosition);
        viewWriter.setSelection(brokenPosition);
      };
    }
    function cleanSelection() {
      return (evt, data, conversionApi) => {
        const viewWriter = conversionApi.writer;
        const viewSelection = viewWriter.document.selection;
        for (const range2 of viewSelection.getRanges()) {
          if (range2.isCollapsed) {
            if (range2.end.parent.isAttached()) {
              conversionApi.writer.mergeAttributes(range2.start);
            }
          }
        }
        viewWriter.setSelection(null);
      };
    }
    function wrap(elementCreator) {
      return (evt, data, conversionApi) => {
        if (!conversionApi.consumable.test(data.item, evt.name)) {
          return;
        }
        const oldViewElement = elementCreator(data.attributeOldValue, conversionApi, data);
        const newViewElement = elementCreator(data.attributeNewValue, conversionApi, data);
        if (!oldViewElement && !newViewElement) {
          return;
        }
        conversionApi.consumable.consume(data.item, evt.name);
        const viewWriter = conversionApi.writer;
        const viewSelection = viewWriter.document.selection;
        if (data.item instanceof Selection || data.item instanceof DocumentSelection) {
          viewWriter.wrap(viewSelection.getFirstRange(), newViewElement);
        } else {
          let viewRange = conversionApi.mapper.toViewRange(data.range);
          if (data.attributeOldValue !== null && oldViewElement) {
            viewRange = viewWriter.unwrap(viewRange, oldViewElement);
          }
          if (data.attributeNewValue !== null && newViewElement) {
            viewWriter.wrap(viewRange, newViewElement);
          }
        }
      };
    }
    function insertElement(elementCreator, consumer = defaultConsumer) {
      return (evt, data, conversionApi) => {
        if (!consumer(data.item, conversionApi.consumable, {
          preflight: true
        })) {
          return;
        }
        const viewElement = elementCreator(data.item, conversionApi, data);
        if (!viewElement) {
          return;
        }
        consumer(data.item, conversionApi.consumable);
        const viewPosition = conversionApi.mapper.toViewPosition(data.range.start);
        conversionApi.mapper.bindElements(data.item, viewElement);
        conversionApi.writer.insert(viewPosition, viewElement);
        conversionApi.convertAttributes(data.item);
        reinsertOrConvertNodes(viewElement, data.item.getChildren(), conversionApi, {
          reconversion: data.reconversion
        });
      };
    }
    function insertStructure(elementCreator, consumer) {
      return (evt, data, conversionApi) => {
        if (!consumer(data.item, conversionApi.consumable, {
          preflight: true
        })) {
          return;
        }
        const slotsMap = /* @__PURE__ */ new Map();
        conversionApi.writer._registerSlotFactory(createSlotFactory(data.item, slotsMap, conversionApi));
        const viewElement = elementCreator(data.item, conversionApi, data);
        conversionApi.writer._clearSlotFactory();
        if (!viewElement) {
          return;
        }
        validateSlotsChildren(data.item, slotsMap, conversionApi);
        consumer(data.item, conversionApi.consumable);
        const viewPosition = conversionApi.mapper.toViewPosition(data.range.start);
        conversionApi.mapper.bindElements(data.item, viewElement);
        conversionApi.writer.insert(viewPosition, viewElement);
        conversionApi.convertAttributes(data.item);
        fillSlots(viewElement, slotsMap, conversionApi, {
          reconversion: data.reconversion
        });
      };
    }
    function insertUIElement(elementCreator) {
      return (evt, data, conversionApi) => {
        data.isOpening = true;
        const viewStartElement = elementCreator(data, conversionApi);
        data.isOpening = false;
        const viewEndElement = elementCreator(data, conversionApi);
        if (!viewStartElement || !viewEndElement) {
          return;
        }
        const markerRange = data.markerRange;
        if (markerRange.isCollapsed && !conversionApi.consumable.consume(markerRange, evt.name)) {
          return;
        }
        for (const value of markerRange) {
          if (!conversionApi.consumable.consume(value.item, evt.name)) {
            return;
          }
        }
        const mapper = conversionApi.mapper;
        const viewWriter = conversionApi.writer;
        viewWriter.insert(mapper.toViewPosition(markerRange.start), viewStartElement);
        conversionApi.mapper.bindElementToMarker(viewStartElement, data.markerName);
        if (!markerRange.isCollapsed) {
          viewWriter.insert(mapper.toViewPosition(markerRange.end), viewEndElement);
          conversionApi.mapper.bindElementToMarker(viewEndElement, data.markerName);
        }
        evt.stop();
      };
    }
    function removeUIElement() {
      return (evt, data, conversionApi) => {
        const elements2 = conversionApi.mapper.markerNameToElements(data.markerName);
        if (!elements2) {
          return;
        }
        for (const element of elements2) {
          conversionApi.mapper.unbindElementFromMarkerName(element, data.markerName);
          conversionApi.writer.clear(conversionApi.writer.createRangeOn(element), element);
        }
        conversionApi.writer.clearClonedElementsGroup(data.markerName);
        evt.stop();
      };
    }
    function insertMarkerData(viewCreator) {
      return (evt, data, conversionApi) => {
        const viewMarkerData = viewCreator(data.markerName, conversionApi);
        if (!viewMarkerData) {
          return;
        }
        const markerRange = data.markerRange;
        if (!conversionApi.consumable.consume(markerRange, evt.name)) {
          return;
        }
        handleMarkerBoundary(markerRange, false, conversionApi, data, viewMarkerData);
        handleMarkerBoundary(markerRange, true, conversionApi, data, viewMarkerData);
        evt.stop();
      };
    }
    function handleMarkerBoundary(range2, isStart, conversionApi, data, viewMarkerData) {
      const modelPosition = isStart ? range2.start : range2.end;
      const elementAfter = modelPosition.nodeAfter && modelPosition.nodeAfter.is("element") ? modelPosition.nodeAfter : null;
      const elementBefore = modelPosition.nodeBefore && modelPosition.nodeBefore.is("element") ? modelPosition.nodeBefore : null;
      if (elementAfter || elementBefore) {
        let modelElement;
        let isBefore;
        if (isStart && elementAfter || !isStart && !elementBefore) {
          modelElement = elementAfter;
          isBefore = true;
        } else {
          modelElement = elementBefore;
          isBefore = false;
        }
        const viewElement = conversionApi.mapper.toViewElement(modelElement);
        if (viewElement) {
          insertMarkerAsAttribute(viewElement, isStart, isBefore, conversionApi, data, viewMarkerData);
          return;
        }
      }
      const viewPosition = conversionApi.mapper.toViewPosition(modelPosition);
      insertMarkerAsElement(viewPosition, isStart, conversionApi, data, viewMarkerData);
    }
    function insertMarkerAsAttribute(viewElement, isStart, isBefore, conversionApi, data, viewMarkerData) {
      const attributeName = `data-${viewMarkerData.group}-${isStart ? "start" : "end"}-${isBefore ? "before" : "after"}`;
      const markerNames = viewElement.hasAttribute(attributeName) ? viewElement.getAttribute(attributeName).split(",") : [];
      markerNames.unshift(viewMarkerData.name);
      conversionApi.writer.setAttribute(attributeName, markerNames.join(","), viewElement);
      conversionApi.mapper.bindElementToMarker(viewElement, data.markerName);
    }
    function insertMarkerAsElement(position, isStart, conversionApi, data, viewMarkerData) {
      const viewElementName = `${viewMarkerData.group}-${isStart ? "start" : "end"}`;
      const attrs = viewMarkerData.name ? {
        "name": viewMarkerData.name
      } : null;
      const viewElement = conversionApi.writer.createUIElement(viewElementName, attrs);
      conversionApi.writer.insert(position, viewElement);
      conversionApi.mapper.bindElementToMarker(viewElement, data.markerName);
    }
    function removeMarkerData(viewCreator) {
      return (evt, data, conversionApi) => {
        const viewData = viewCreator(data.markerName, conversionApi);
        if (!viewData) {
          return;
        }
        const elements2 = conversionApi.mapper.markerNameToElements(data.markerName);
        if (!elements2) {
          return;
        }
        for (const element of elements2) {
          conversionApi.mapper.unbindElementFromMarkerName(element, data.markerName);
          if (element.is("containerElement")) {
            removeMarkerFromAttribute(`data-${viewData.group}-start-before`, element);
            removeMarkerFromAttribute(`data-${viewData.group}-start-after`, element);
            removeMarkerFromAttribute(`data-${viewData.group}-end-before`, element);
            removeMarkerFromAttribute(`data-${viewData.group}-end-after`, element);
          } else {
            conversionApi.writer.clear(conversionApi.writer.createRangeOn(element), element);
          }
        }
        conversionApi.writer.clearClonedElementsGroup(data.markerName);
        evt.stop();
        function removeMarkerFromAttribute(attributeName, element) {
          if (element.hasAttribute(attributeName)) {
            const markerNames = new Set(element.getAttribute(attributeName).split(","));
            markerNames.delete(viewData.name);
            if (markerNames.size == 0) {
              conversionApi.writer.removeAttribute(attributeName, element);
            } else {
              conversionApi.writer.setAttribute(attributeName, Array.from(markerNames).join(","), element);
            }
          }
        }
      };
    }
    function changeAttribute(attributeCreator) {
      return (evt, data, conversionApi) => {
        if (!conversionApi.consumable.test(data.item, evt.name)) {
          return;
        }
        const oldAttribute = attributeCreator(data.attributeOldValue, conversionApi, data);
        const newAttribute = attributeCreator(data.attributeNewValue, conversionApi, data);
        if (!oldAttribute && !newAttribute) {
          return;
        }
        conversionApi.consumable.consume(data.item, evt.name);
        const viewElement = conversionApi.mapper.toViewElement(data.item);
        const viewWriter = conversionApi.writer;
        if (!viewElement) {
          throw new CKEditorError("conversion-attribute-to-attribute-on-text", conversionApi.dispatcher, data);
        }
        if (data.attributeOldValue !== null && oldAttribute) {
          if (oldAttribute.key == "class") {
            const classes = typeof oldAttribute.value == "string" ? oldAttribute.value.split(/\s+/) : oldAttribute.value;
            for (const className of classes) {
              viewWriter.removeClass(className, viewElement);
            }
          } else if (oldAttribute.key == "style") {
            if (typeof oldAttribute.value == "string") {
              const styles = new StylesMap(viewWriter.document.stylesProcessor);
              styles.setTo(oldAttribute.value);
              for (const [key] of styles.getStylesEntries()) {
                viewWriter.removeStyle(key, viewElement);
              }
            } else {
              const keys2 = Object.keys(oldAttribute.value);
              for (const key of keys2) {
                viewWriter.removeStyle(key, viewElement);
              }
            }
          } else {
            viewWriter.removeAttribute(oldAttribute.key, viewElement);
          }
        }
        if (data.attributeNewValue !== null && newAttribute) {
          if (newAttribute.key == "class") {
            const classes = typeof newAttribute.value == "string" ? newAttribute.value.split(/\s+/) : newAttribute.value;
            for (const className of classes) {
              viewWriter.addClass(className, viewElement);
            }
          } else if (newAttribute.key == "style") {
            if (typeof newAttribute.value == "string") {
              const styles = new StylesMap(viewWriter.document.stylesProcessor);
              styles.setTo(newAttribute.value);
              for (const [key, value] of styles.getStylesEntries()) {
                viewWriter.setStyle(key, value, viewElement);
              }
            } else {
              const keys2 = Object.keys(newAttribute.value);
              for (const key of keys2) {
                viewWriter.setStyle(key, newAttribute.value[key], viewElement);
              }
            }
          } else {
            viewWriter.setAttribute(newAttribute.key, newAttribute.value, viewElement);
          }
        }
      };
    }
    function highlightText(highlightDescriptor) {
      return (evt, data, conversionApi) => {
        if (!data.item) {
          return;
        }
        if (!(data.item instanceof Selection || data.item instanceof DocumentSelection) && !data.item.is("$textProxy")) {
          return;
        }
        const descriptor = prepareDescriptor(highlightDescriptor, data, conversionApi);
        if (!descriptor) {
          return;
        }
        if (!conversionApi.consumable.consume(data.item, evt.name)) {
          return;
        }
        const viewWriter = conversionApi.writer;
        const viewElement = createViewElementFromHighlightDescriptor(viewWriter, descriptor);
        const viewSelection = viewWriter.document.selection;
        if (data.item instanceof Selection || data.item instanceof DocumentSelection) {
          viewWriter.wrap(viewSelection.getFirstRange(), viewElement);
        } else {
          const viewRange = conversionApi.mapper.toViewRange(data.range);
          const rangeAfterWrap = viewWriter.wrap(viewRange, viewElement);
          for (const element of rangeAfterWrap.getItems()) {
            if (element.is("attributeElement") && element.isSimilar(viewElement)) {
              conversionApi.mapper.bindElementToMarker(element, data.markerName);
              break;
            }
          }
        }
      };
    }
    function highlightElement(highlightDescriptor) {
      return (evt, data, conversionApi) => {
        if (!data.item) {
          return;
        }
        if (!(data.item instanceof Element$2)) {
          return;
        }
        const descriptor = prepareDescriptor(highlightDescriptor, data, conversionApi);
        if (!descriptor) {
          return;
        }
        if (!conversionApi.consumable.test(data.item, evt.name)) {
          return;
        }
        const viewElement = conversionApi.mapper.toViewElement(data.item);
        if (viewElement && viewElement.getCustomProperty("addHighlight")) {
          conversionApi.consumable.consume(data.item, evt.name);
          for (const value of Range._createIn(data.item)) {
            conversionApi.consumable.consume(value.item, evt.name);
          }
          const addHighlightCallback = viewElement.getCustomProperty("addHighlight");
          addHighlightCallback(viewElement, descriptor, conversionApi.writer);
          conversionApi.mapper.bindElementToMarker(viewElement, data.markerName);
        }
      };
    }
    function removeHighlight(highlightDescriptor) {
      return (evt, data, conversionApi) => {
        if (data.markerRange.isCollapsed) {
          return;
        }
        const descriptor = prepareDescriptor(highlightDescriptor, data, conversionApi);
        if (!descriptor) {
          return;
        }
        const viewHighlightElement = createViewElementFromHighlightDescriptor(conversionApi.writer, descriptor);
        const elements2 = conversionApi.mapper.markerNameToElements(data.markerName);
        if (!elements2) {
          return;
        }
        for (const element of elements2) {
          conversionApi.mapper.unbindElementFromMarkerName(element, data.markerName);
          if (element.is("attributeElement")) {
            conversionApi.writer.unwrap(conversionApi.writer.createRangeOn(element), viewHighlightElement);
          } else {
            const removeHighlightCallback = element.getCustomProperty("removeHighlight");
            removeHighlightCallback(element, descriptor.id, conversionApi.writer);
          }
        }
        conversionApi.writer.clearClonedElementsGroup(data.markerName);
        evt.stop();
      };
    }
    function downcastElementToElement(config2) {
      const model = normalizeModelElementConfig(config2.model);
      const view = normalizeToElementConfig(config2.view, "container");
      if (model.attributes.length) {
        model.children = true;
      }
      return (dispatcher) => {
        dispatcher.on(`insert:${model.name}`, insertElement(view, createConsumer(model)), {
          priority: config2.converterPriority || "normal"
        });
        if (model.children || model.attributes.length) {
          dispatcher.on("reduceChanges", createChangeReducer(model), {
            priority: "low"
          });
        }
      };
    }
    function downcastElementToStructure(config2) {
      const model = normalizeModelElementConfig(config2.model);
      const view = normalizeToElementConfig(config2.view, "container");
      model.children = true;
      return (dispatcher) => {
        if (dispatcher._conversionApi.schema.checkChild(model.name, "$text")) {
          throw new CKEditorError("conversion-element-to-structure-disallowed-text", dispatcher, {
            elementName: model.name
          });
        }
        dispatcher.on(`insert:${model.name}`, insertStructure(view, createConsumer(model)), {
          priority: config2.converterPriority || "normal"
        });
        dispatcher.on("reduceChanges", createChangeReducer(model), {
          priority: "low"
        });
      };
    }
    function downcastAttributeToElement(config2) {
      config2 = cloneDeep(config2);
      let model = config2.model;
      if (typeof model == "string") {
        model = {
          key: model
        };
      }
      let eventName = `attribute:${model.key}`;
      if (model.name) {
        eventName += ":" + model.name;
      }
      if (model.values) {
        for (const modelValue of model.values) {
          config2.view[modelValue] = normalizeToElementConfig(config2.view[modelValue], "attribute");
        }
      } else {
        config2.view = normalizeToElementConfig(config2.view, "attribute");
      }
      const elementCreator = getFromAttributeCreator(config2);
      return (dispatcher) => {
        dispatcher.on(eventName, wrap(elementCreator), {
          priority: config2.converterPriority || "normal"
        });
      };
    }
    function downcastAttributeToAttribute(config2) {
      config2 = cloneDeep(config2);
      let model = config2.model;
      if (typeof model == "string") {
        model = {
          key: model
        };
      }
      let eventName = `attribute:${model.key}`;
      if (model.name) {
        eventName += ":" + model.name;
      }
      if (model.values) {
        for (const modelValue of model.values) {
          config2.view[modelValue] = normalizeToAttributeConfig(config2.view[modelValue]);
        }
      } else {
        config2.view = normalizeToAttributeConfig(config2.view);
      }
      const elementCreator = getFromAttributeCreator(config2);
      return (dispatcher) => {
        dispatcher.on(eventName, changeAttribute(elementCreator), {
          priority: config2.converterPriority || "normal"
        });
      };
    }
    function downcastMarkerToElement(config2) {
      const view = normalizeToElementConfig(config2.view, "ui");
      return (dispatcher) => {
        dispatcher.on(`addMarker:${config2.model}`, insertUIElement(view), {
          priority: config2.converterPriority || "normal"
        });
        dispatcher.on(`removeMarker:${config2.model}`, removeUIElement(), {
          priority: config2.converterPriority || "normal"
        });
      };
    }
    function downcastMarkerToData(config2) {
      config2 = cloneDeep(config2);
      const group = config2.model;
      let view = config2.view;
      if (!view) {
        view = (markerName) => ({
          group,
          name: markerName.substr(config2.model.length + 1)
        });
      }
      return (dispatcher) => {
        dispatcher.on(`addMarker:${group}`, insertMarkerData(view), {
          priority: config2.converterPriority || "normal"
        });
        dispatcher.on(`removeMarker:${group}`, removeMarkerData(view), {
          priority: config2.converterPriority || "normal"
        });
      };
    }
    function downcastMarkerToHighlight(config2) {
      return (dispatcher) => {
        dispatcher.on(`addMarker:${config2.model}`, highlightText(config2.view), {
          priority: config2.converterPriority || "normal"
        });
        dispatcher.on(`addMarker:${config2.model}`, highlightElement(config2.view), {
          priority: config2.converterPriority || "normal"
        });
        dispatcher.on(`removeMarker:${config2.model}`, removeHighlight(config2.view), {
          priority: config2.converterPriority || "normal"
        });
      };
    }
    function normalizeModelElementConfig(model) {
      if (typeof model == "string") {
        model = {
          name: model
        };
      }
      return {
        name: model.name,
        attributes: model.attributes ? toArray$2(model.attributes) : [],
        children: !!model.children
      };
    }
    function normalizeToElementConfig(view, viewElementType) {
      if (typeof view == "function") {
        return view;
      }
      return (modelData, conversionApi) => createViewElementFromDefinition(view, conversionApi, viewElementType);
    }
    function createViewElementFromDefinition(viewElementDefinition, conversionApi, viewElementType) {
      if (typeof viewElementDefinition == "string") {
        viewElementDefinition = {
          name: viewElementDefinition
        };
      }
      let element;
      const viewWriter = conversionApi.writer;
      const attributes = Object.assign({}, viewElementDefinition.attributes);
      if (viewElementType == "container") {
        element = viewWriter.createContainerElement(viewElementDefinition.name, attributes);
      } else if (viewElementType == "attribute") {
        const options = {
          priority: viewElementDefinition.priority || AttributeElement.DEFAULT_PRIORITY
        };
        element = viewWriter.createAttributeElement(viewElementDefinition.name, attributes, options);
      } else {
        element = viewWriter.createUIElement(viewElementDefinition.name, attributes);
      }
      if (viewElementDefinition.styles) {
        const keys2 = Object.keys(viewElementDefinition.styles);
        for (const key of keys2) {
          viewWriter.setStyle(key, viewElementDefinition.styles[key], element);
        }
      }
      if (viewElementDefinition.classes) {
        const classes = viewElementDefinition.classes;
        if (typeof classes == "string") {
          viewWriter.addClass(classes, element);
        } else {
          for (const className of classes) {
            viewWriter.addClass(className, element);
          }
        }
      }
      return element;
    }
    function getFromAttributeCreator(config2) {
      if (config2.model.values) {
        return (modelAttributeValue, conversionApi, data) => {
          const view = config2.view[modelAttributeValue];
          if (view) {
            return view(modelAttributeValue, conversionApi, data);
          }
          return null;
        };
      } else {
        return config2.view;
      }
    }
    function normalizeToAttributeConfig(view) {
      if (typeof view == "string") {
        return (modelAttributeValue) => ({
          key: view,
          value: modelAttributeValue
        });
      } else if (typeof view == "object") {
        if (view.value) {
          return () => view;
        } else {
          return (modelAttributeValue) => ({
            key: view.key,
            value: modelAttributeValue
          });
        }
      } else {
        return view;
      }
    }
    function prepareDescriptor(highlightDescriptor, data, conversionApi) {
      const descriptor = typeof highlightDescriptor == "function" ? highlightDescriptor(data, conversionApi) : highlightDescriptor;
      if (!descriptor) {
        return null;
      }
      if (!descriptor.priority) {
        descriptor.priority = 10;
      }
      if (!descriptor.id) {
        descriptor.id = data.markerName;
      }
      return descriptor;
    }
    function createChangeReducerCallback(model) {
      return (node, change) => {
        if (!node.is("element", model.name)) {
          return false;
        }
        if (change.type == "attribute") {
          if (model.attributes.includes(change.attributeKey)) {
            return true;
          }
        } else {
          /* istanbul ignore else: This is always true because otherwise it would not register a reducer callback. -- @preserve */
          if (model.children) {
            return true;
          }
        }
        return false;
      };
    }
    function createChangeReducer(model) {
      const shouldReplace = createChangeReducerCallback(model);
      return (evt, data) => {
        const reducedChanges = [];
        if (!data.reconvertedElements) {
          data.reconvertedElements = /* @__PURE__ */ new Set();
        }
        for (const change of data.changes) {
          const node = change.type == "attribute" ? change.range.start.nodeAfter : change.position.parent;
          if (!node || !shouldReplace(node, change)) {
            reducedChanges.push(change);
            continue;
          }
          if (!data.reconvertedElements.has(node)) {
            data.reconvertedElements.add(node);
            const position = Position._createBefore(node);
            let changeIndex = reducedChanges.length;
            for (let i2 = reducedChanges.length - 1; i2 >= 0; i2--) {
              const change2 = reducedChanges[i2];
              const changePosition = change2.type == "attribute" ? change2.range.start : change2.position;
              const positionRelation = changePosition.compareWith(position);
              if (positionRelation == "before" || change2.type == "remove" && positionRelation == "same") {
                break;
              }
              changeIndex = i2;
            }
            reducedChanges.splice(changeIndex, 0, {
              type: "remove",
              name: node.name,
              position,
              length: 1
            }, {
              type: "reinsert",
              name: node.name,
              position,
              length: 1
            });
          }
        }
        data.changes = reducedChanges;
      };
    }
    function createConsumer(model) {
      return (node, consumable, options = {}) => {
        const events = [
          "insert"
        ];
        for (const attributeName of model.attributes) {
          if (node.hasAttribute(attributeName)) {
            events.push(`attribute:${attributeName}`);
          }
        }
        if (!events.every((event) => consumable.test(node, event))) {
          return false;
        }
        if (!options.preflight) {
          events.forEach((event) => consumable.consume(node, event));
        }
        return true;
      };
    }
    function createSlotFactory(element, slotsMap, conversionApi) {
      return (writer, modeOrFilter) => {
        const slot = writer.createContainerElement("$slot");
        let children = null;
        if (modeOrFilter === "children") {
          children = Array.from(element.getChildren());
        } else if (typeof modeOrFilter == "function") {
          children = Array.from(element.getChildren()).filter((element2) => modeOrFilter(element2));
        } else {
          throw new CKEditorError("conversion-slot-mode-unknown", conversionApi.dispatcher, {
            modeOrFilter
          });
        }
        slotsMap.set(slot, children);
        return slot;
      };
    }
    function validateSlotsChildren(element, slotsMap, conversionApi) {
      const childrenInSlots = Array.from(slotsMap.values()).flat();
      const uniqueChildrenInSlots = new Set(childrenInSlots);
      if (uniqueChildrenInSlots.size != childrenInSlots.length) {
        throw new CKEditorError("conversion-slot-filter-overlap", conversionApi.dispatcher, {
          element
        });
      }
      if (uniqueChildrenInSlots.size != element.childCount) {
        throw new CKEditorError("conversion-slot-filter-incomplete", conversionApi.dispatcher, {
          element
        });
      }
    }
    function fillSlots(viewElement, slotsMap, conversionApi, options) {
      conversionApi.mapper.on("modelToViewPosition", toViewPositionMapping, {
        priority: "highest"
      });
      let currentSlot = null;
      let currentSlotNodes = null;
      for ([currentSlot, currentSlotNodes] of slotsMap) {
        reinsertOrConvertNodes(viewElement, currentSlotNodes, conversionApi, options);
        conversionApi.writer.move(conversionApi.writer.createRangeIn(currentSlot), conversionApi.writer.createPositionBefore(currentSlot));
        conversionApi.writer.remove(currentSlot);
      }
      conversionApi.mapper.off("modelToViewPosition", toViewPositionMapping);
      function toViewPositionMapping(evt, data) {
        const element = data.modelPosition.nodeAfter;
        const index = currentSlotNodes.indexOf(element);
        if (index < 0) {
          return;
        }
        data.viewPosition = data.mapper.findPositionIn(currentSlot, index);
      }
    }
    function reinsertOrConvertNodes(viewElement, modelNodes, conversionApi, options) {
      for (const modelChildNode of modelNodes) {
        if (!reinsertNode(viewElement.root, modelChildNode, conversionApi, options)) {
          conversionApi.convertItem(modelChildNode);
        }
      }
    }
    function reinsertNode(viewRoot, modelNode, conversionApi, options) {
      const { writer, mapper } = conversionApi;
      if (!options.reconversion) {
        return false;
      }
      const viewChildNode = mapper.toViewElement(modelNode);
      if (!viewChildNode || viewChildNode.root == viewRoot) {
        return false;
      }
      if (!conversionApi.canReuseView(viewChildNode)) {
        return false;
      }
      writer.move(writer.createRangeOn(viewChildNode), mapper.toViewPosition(Position._createBefore(modelNode)));
      return true;
    }
    function defaultConsumer(item, consumable, { preflight } = {}) {
      if (preflight) {
        return consumable.test(item, "insert");
      } else {
        return consumable.consume(item, "insert");
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function autoParagraphEmptyRoots(writer) {
      const { schema, document: document2 } = writer.model;
      for (const root2 of document2.getRoots()) {
        if (root2.isEmpty && !schema.checkChild(root2, "$text")) {
          if (schema.checkChild(root2, "paragraph")) {
            writer.insertElement("paragraph", root2);
            return true;
          }
        }
      }
      return false;
    }
    function isParagraphable(position, nodeOrType, schema) {
      const context = schema.createContext(position);
      if (!schema.checkChild(context, "paragraph")) {
        return false;
      }
      if (!schema.checkChild(context.push("paragraph"), nodeOrType)) {
        return false;
      }
      return true;
    }
    function wrapInParagraph(position, writer) {
      const paragraph2 = writer.createElement("paragraph");
      writer.insert(paragraph2, position);
      return writer.createPositionAt(paragraph2, 0);
    }
    class UpcastHelpers extends ConversionHelpers {
      /**
      * View element to model element conversion helper.
      *
      * This conversion results in creating a model element. For example,
      * view `<p>Foo</p>` becomes `<paragraph>Foo</paragraph>` in the model.
      *
      * Keep in mind that the element will be inserted only if it is allowed
      * by {@link module:engine/model/schema~Schema schema} configuration.
      *
      * ```ts
      * editor.conversion.for( 'upcast' ).elementToElement( {
      * 	view: 'p',
      * 	model: 'paragraph'
      * } );
      *
      * editor.conversion.for( 'upcast' ).elementToElement( {
      * 	view: 'p',
      * 	model: 'paragraph',
      * 	converterPriority: 'high'
      * } );
      *
      * editor.conversion.for( 'upcast' ).elementToElement( {
      * 	view: {
      * 		name: 'p',
      * 		classes: 'fancy'
      * 	},
      * 	model: 'fancyParagraph'
      * } );
      *
      * editor.conversion.for( 'upcast' ).elementToElement( {
      * 	view: {
      * 		name: 'p',
      * 		classes: 'heading'
      * 	},
      * 	model: ( viewElement, conversionApi ) => {
      * 		const modelWriter = conversionApi.writer;
      *
      * 		return modelWriter.createElement( 'heading', { level: viewElement.getAttribute( 'data-level' ) } );
      * 	}
      * } );
      * ```
      *
      * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
      * to the conversion process.
      *
      * @param config Conversion configuration.
      * @param config.view Pattern matching all view elements which should be converted. If not set, the converter
      * will fire for every view element.
      * @param config.model Name of the model element, a model element instance or a function that takes a view element
      * and {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API}
      * and returns a model element. The model element will be inserted in the model.
      * @param config.converterPriority Converter priority.
      */
      elementToElement(config2) {
        return this.add(upcastElementToElement(config2));
      }
      /**
      * View element to model attribute conversion helper.
      *
      * This conversion results in setting an attribute on a model node. For example, view `<strong>Foo</strong>` becomes
      * `Foo` {@link module:engine/model/text~Text model text node} with `bold` attribute set to `true`.
      *
      * This helper is meant to set a model attribute on all the elements that are inside the converted element:
      *
      * ```
      * <strong>Foo</strong>   -->   <strong><p>Foo</p></strong>   -->   <paragraph><$text bold="true">Foo</$text></paragraph>
      * ```
      *
      * Above is a sample of HTML code, that goes through autoparagraphing (first step) and then is converted (second step).
      * Even though `<strong>` is over `<p>` element, `bold="true"` was added to the text. See
      * {@link module:engine/conversion/upcasthelpers~UpcastHelpers#attributeToAttribute} for comparison.
      *
      * Keep in mind that the attribute will be set only if it is allowed by {@link module:engine/model/schema~Schema schema} configuration.
      *
      * ```ts
      * editor.conversion.for( 'upcast' ).elementToAttribute( {
      * 	view: 'strong',
      * 	model: 'bold'
      * } );
      *
      * editor.conversion.for( 'upcast' ).elementToAttribute( {
      * 	view: 'strong',
      * 	model: 'bold',
      * 	converterPriority: 'high'
      * } );
      *
      * editor.conversion.for( 'upcast' ).elementToAttribute( {
      * 	view: {
      * 		name: 'span',
      * 		classes: 'bold'
      * 	},
      * 	model: 'bold'
      * } );
      *
      * editor.conversion.for( 'upcast' ).elementToAttribute( {
      * 	view: {
      * 		name: 'span',
      * 		classes: [ 'styled', 'styled-dark' ]
      * 	},
      * 	model: {
      * 		key: 'styled',
      * 		value: 'dark'
      * 	}
      * } );
      *
      * editor.conversion.for( 'upcast' ).elementToAttribute( {
      * 	view: {
      * 		name: 'span',
      * 		styles: {
      * 			'font-size': /[\s\S]+/
      * 		}
      * 	},
      * 	model: {
      * 		key: 'fontSize',
      * 		value: ( viewElement, conversionApi ) => {
      * 			const fontSize = viewElement.getStyle( 'font-size' );
      * 			const value = fontSize.substr( 0, fontSize.length - 2 );
      *
      * 			if ( value <= 10 ) {
      * 				return 'small';
      * 			} else if ( value > 12 ) {
      * 				return 'big';
      * 			}
      *
      * 			return null;
      * 		}
      * 	}
      * } );
      * ```
      *
      * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
      * to the conversion process.
      *
      * @param config Conversion configuration.
      * @param config.view Pattern matching all view elements which should be converted.
      * @param config.model Model attribute key or an object with `key` and `value` properties, describing
      * the model attribute. `value` property may be set as a function that takes a view element and
      * {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API} and returns the value.
      * If `String` is given, the model attribute value will be set to `true`.
      * @param config.converterPriority Converter priority. Defaults to `low`.
      */
      elementToAttribute(config2) {
        return this.add(upcastElementToAttribute(config2));
      }
      /**
      * View attribute to model attribute conversion helper.
      *
      * This conversion results in setting an attribute on a model node. For example, view `<img src="foo.jpg"></img>` becomes
      * `<imageBlock source="foo.jpg"></imageBlock>` in the model.
      *
      * This helper is meant to convert view attributes from view elements which got converted to the model, so the view attribute
      * is set only on the corresponding model node:
      *
      * ```
      * <div class="dark"><div>foo</div></div>    -->    <div dark="true"><div>foo</div></div>
      * ```
      *
      * Above, `class="dark"` attribute is added only to the `<div>` elements that has it. This is in contrast to
      * {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToAttribute} which sets attributes for
      * all the children in the model:
      *
      * ```
      * <strong>Foo</strong>   -->   <strong><p>Foo</p></strong>   -->   <paragraph><$text bold="true">Foo</$text></paragraph>
      * ```
      *
      * Above is a sample of HTML code, that goes through autoparagraphing (first step) and then is converted (second step).
      * Even though `<strong>` is over `<p>` element, `bold="true"` was added to the text.
      *
      * Keep in mind that the attribute will be set only if it is allowed by {@link module:engine/model/schema~Schema schema} configuration.
      *
      * ```ts
      * editor.conversion.for( 'upcast' ).attributeToAttribute( {
      * 	view: 'src',
      * 	model: 'source'
      * } );
      *
      * editor.conversion.for( 'upcast' ).attributeToAttribute( {
      * 	view: { key: 'src' },
      * 	model: 'source'
      * } );
      *
      * editor.conversion.for( 'upcast' ).attributeToAttribute( {
      * 	view: { key: 'src' },
      * 	model: 'source',
      * 	converterPriority: 'normal'
      * } );
      *
      * editor.conversion.for( 'upcast' ).attributeToAttribute( {
      * 	view: {
      * 		key: 'data-style',
      * 		value: /[\s\S]+/
      * 	},
      * 	model: 'styled'
      * } );
      *
      * editor.conversion.for( 'upcast' ).attributeToAttribute( {
      * 	view: {
      * 		name: 'img',
      * 		key: 'class',
      * 		value: 'styled-dark'
      * 	},
      * 	model: {
      * 		key: 'styled',
      * 		value: 'dark'
      * 	}
      * } );
      *
      * editor.conversion.for( 'upcast' ).attributeToAttribute( {
      * 	view: {
      * 		key: 'class',
      * 		value: /styled-[\S]+/
      * 	},
      * 	model: {
      * 		key: 'styled'
      * 		value: ( viewElement, conversionApi ) => {
      * 			const regexp = /styled-([\S]+)/;
      * 			const match = viewElement.getAttribute( 'class' ).match( regexp );
      *
      * 			return match[ 1 ];
      * 		}
      * 	}
      * } );
      * ```
      *
      * Converting styles works a bit differently as it requires `view.styles` to be an object and by default
      * a model attribute will be set to `true` by such a converter. You can set the model attribute to any value by providing the `value`
      * callback that returns the desired value.
      *
      * ```ts
      * // Default conversion of font-weight style will result in setting bold attribute to true.
      * editor.conversion.for( 'upcast' ).attributeToAttribute( {
      * 	view: {
      * 		styles: {
      * 			'font-weight': 'bold'
      * 		}
      * 	},
      * 	model: 'bold'
      * } );
      *
      * // This converter will pass any style value to the `lineHeight` model attribute.
      * editor.conversion.for( 'upcast' ).attributeToAttribute( {
      * 	view: {
      * 		styles: {
      * 			'line-height': /[\s\S]+/
      * 		}
      * 	},
      * 	model: {
      * 		key: 'lineHeight',
      * 		value: ( viewElement, conversionApi ) => viewElement.getStyle( 'line-height' )
      * 	}
      * } );
      * ```
      *
      * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
      * to the conversion process.
      *
      * @param config Conversion configuration.
      * @param config.view Specifies which view attribute will be converted. If a `String` is passed,
      * attributes with given key will be converted. If an `Object` is passed, it must have a required `key` property,
      * specifying view attribute key, and may have an optional `value` property, specifying view attribute value and optional `name`
      * property specifying a view element name from/on which the attribute should be converted. `value` can be given as a `String`,
      * a `RegExp` or a function callback, that takes view attribute value as the only parameter and returns `Boolean`.
      * @param config.model Model attribute key or an object with `key` and `value` properties, describing
      * the model attribute. `value` property may be set as a function that takes a view element and
      * {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API} and returns the value.
      * If `String` is given, the model attribute value will be same as view attribute value.
      * @param config.converterPriority Converter priority. Defaults to `low`.
      */
      attributeToAttribute(config2) {
        return this.add(upcastAttributeToAttribute(config2));
      }
      /**
      * View element to model marker conversion helper.
      *
      * This conversion results in creating a model marker. For example, if the marker was stored in a view as an element:
      * `<p>Fo<span data-marker="comment" data-comment-id="7"></span>o</p><p>B<span data-marker="comment" data-comment-id="7"></span>ar</p>`,
      * after the conversion is done, the marker will be available in
      * {@link module:engine/model/model~Model#markers model document markers}.
      *
      * **Note**: When this helper is used in the data upcast in combination with
      * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToData `#markerToData()`} in the data downcast,
      * then invalid HTML code (e.g. a span between table cells) may be produced by the latter converter.
      *
      * In most of the cases, the {@link #dataToMarker} should be used instead.
      *
      * ```ts
      * editor.conversion.for( 'upcast' ).elementToMarker( {
      * 	view: 'marker-search',
      * 	model: 'search'
      * } );
      *
      * editor.conversion.for( 'upcast' ).elementToMarker( {
      * 	view: 'marker-search',
      * 	model: 'search',
      * 	converterPriority: 'high'
      * } );
      *
      * editor.conversion.for( 'upcast' ).elementToMarker( {
      * 	view: 'marker-search',
      * 	model: ( viewElement, conversionApi ) => 'comment:' + viewElement.getAttribute( 'data-comment-id' )
      * } );
      *
      * editor.conversion.for( 'upcast' ).elementToMarker( {
      * 	view: {
      * 		name: 'span',
      * 		attributes: {
      * 			'data-marker': 'search'
      * 		}
      * 	},
      * 	model: 'search'
      * } );
      * ```
      *
      * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
      * to the conversion process.
      *
      * @param config Conversion configuration.
      * @param config.view Pattern matching all view elements which should be converted.
      * @param config.model Name of the model marker, or a function that takes a view element and returns
      * a model marker name.
      * @param config.converterPriority Converter priority.
      */
      elementToMarker(config2) {
        return this.add(upcastElementToMarker(config2));
      }
      /**
      * View-to-model marker conversion helper.
      *
      * Converts view data created by {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToData `#markerToData()`}
      * back to a model marker.
      *
      * This converter looks for specific view elements and view attributes that mark marker boundaries. See
      * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToData `#markerToData()`} to learn what view data
      * is expected by this converter.
      *
      * The `config.view` property is equal to the marker group name to convert.
      *
      * By default, this converter creates markers with the `group:name` name convention (to match the default `markerToData` conversion).
      *
      * The conversion configuration can take a function that will generate a marker name.
      * If such function is set as the `config.model` parameter, it is passed the `name` part from the view element or attribute and it is
      * expected to return a string with the marker name.
      *
      * Basic usage:
      *
      * ```ts
      * // Using the default conversion.
      * // In this case, all markers from the `comment` group will be converted.
      * // The conversion will look for `<comment-start>` and `<comment-end>` tags and
      * // `data-comment-start-before`, `data-comment-start-after`,
      * // `data-comment-end-before` and `data-comment-end-after` attributes.
      * editor.conversion.for( 'upcast' ).dataToMarker( {
      * 	view: 'comment'
      * } );
      * ```
      *
      * An example of a model that may be generated by this conversion:
      *
      * ```
      * // View:
      * <p>Foo<comment-start name="commentId:uid"></comment-start>bar</p>
      * <figure data-comment-end-after="commentId:uid" class="image"><img src="abc.jpg" /></figure>
      *
      * // Model:
      * <paragraph>Foo[bar</paragraph>
      * <imageBlock src="abc.jpg"></imageBlock>]
      * ```
      *
      * Where `[]` are boundaries of a marker that will receive the `comment:commentId:uid` name.
      *
      * Other examples of usage:
      *
      * ```ts
      * // Using a custom function which is the same as the default conversion:
      * editor.conversion.for( 'upcast' ).dataToMarker( {
      * 	view: 'comment',
      * 	model: ( name, conversionApi ) => 'comment:' + name,
      * } );
      *
      * // Using the converter priority:
      * editor.conversion.for( 'upcast' ).dataToMarker( {
      * 	view: 'comment',
      * 	model: ( name, conversionApi ) => 'comment:' + name,
      * 	converterPriority: 'high'
      * } );
      * ```
      *
      * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
      * to the conversion process.
      *
      * @param config Conversion configuration.
      * @param config.view The marker group name to convert.
      * @param config.model A function that takes the `name` part from the view element or attribute and
      * {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API} and returns the marker name.
      * @param config.converterPriority Converter priority.
      */
      dataToMarker(config2) {
        return this.add(upcastDataToMarker(config2));
      }
    }
    function convertToModelFragment$1() {
      return (evt, data, conversionApi) => {
        if (!data.modelRange && conversionApi.consumable.consume(data.viewItem, {
          name: true
        })) {
          const { modelRange, modelCursor } = conversionApi.convertChildren(data.viewItem, data.modelCursor);
          data.modelRange = modelRange;
          data.modelCursor = modelCursor;
        }
      };
    }
    function convertText() {
      return (evt, data, { schema, consumable, writer }) => {
        let position = data.modelCursor;
        if (!consumable.test(data.viewItem)) {
          return;
        }
        if (!schema.checkChild(position, "$text")) {
          if (!isParagraphable(position, "$text", schema)) {
            return;
          }
          if (data.viewItem.data.trim().length == 0) {
            return;
          }
          position = wrapInParagraph(position, writer);
        }
        consumable.consume(data.viewItem);
        const text2 = writer.createText(data.viewItem.data);
        writer.insert(text2, position);
        data.modelRange = writer.createRange(position, position.getShiftedBy(text2.offsetSize));
        data.modelCursor = data.modelRange.end;
      };
    }
    function convertSelectionChange(model, mapper) {
      return (evt, data) => {
        const viewSelection = data.newSelection;
        const ranges = [];
        for (const viewRange of viewSelection.getRanges()) {
          ranges.push(mapper.toModelRange(viewRange));
        }
        const modelSelection = model.createSelection(ranges, {
          backward: viewSelection.isBackward
        });
        if (!modelSelection.isEqual(model.document.selection)) {
          model.change((writer) => {
            writer.setSelection(modelSelection);
          });
        }
      };
    }
    function upcastElementToElement(config2) {
      config2 = cloneDeep(config2);
      const converter = prepareToElementConverter(config2);
      const elementName = getViewElementNameFromConfig(config2.view);
      const eventName = elementName ? `element:${elementName}` : "element";
      return (dispatcher) => {
        dispatcher.on(eventName, converter, {
          priority: config2.converterPriority || "normal"
        });
      };
    }
    function upcastElementToAttribute(config2) {
      config2 = cloneDeep(config2);
      normalizeModelAttributeConfig(config2);
      const converter = prepareToAttributeConverter(config2, false);
      const elementName = getViewElementNameFromConfig(config2.view);
      const eventName = elementName ? `element:${elementName}` : "element";
      return (dispatcher) => {
        dispatcher.on(eventName, converter, {
          priority: config2.converterPriority || "low"
        });
      };
    }
    function upcastAttributeToAttribute(config2) {
      config2 = cloneDeep(config2);
      let viewKey = null;
      if (typeof config2.view == "string" || config2.view.key) {
        viewKey = normalizeViewAttributeKeyValueConfig(config2);
      }
      normalizeModelAttributeConfig(config2, viewKey);
      const converter = prepareToAttributeConverter(config2, true);
      return (dispatcher) => {
        dispatcher.on("element", converter, {
          priority: config2.converterPriority || "low"
        });
      };
    }
    function upcastElementToMarker(config2) {
      const model = normalizeElementToMarkerModelConfig(config2.model);
      return upcastElementToElement({
        ...config2,
        model
      });
    }
    function upcastDataToMarker(config2) {
      config2 = cloneDeep(config2);
      if (!config2.model) {
        config2.model = (name) => {
          return name ? config2.view + ":" + name : config2.view;
        };
      }
      const normalizedConfig = {
        view: config2.view,
        model: config2.model
      };
      const converterStart = prepareToElementConverter(normalizeDataToMarkerConfig(normalizedConfig, "start"));
      const converterEnd = prepareToElementConverter(normalizeDataToMarkerConfig(normalizedConfig, "end"));
      return (dispatcher) => {
        dispatcher.on(`element:${config2.view}-start`, converterStart, {
          priority: config2.converterPriority || "normal"
        });
        dispatcher.on(`element:${config2.view}-end`, converterEnd, {
          priority: config2.converterPriority || "normal"
        });
        const basePriority = priorities.low;
        const maxPriority = priorities.highest;
        const priorityFactor = priorities.get(config2.converterPriority) / maxPriority;
        dispatcher.on("element", upcastAttributeToMarker(normalizedConfig), {
          priority: basePriority + priorityFactor
        });
      };
    }
    function upcastAttributeToMarker(config2) {
      return (evt, data, conversionApi) => {
        const attrName = `data-${config2.view}`;
        if (!conversionApi.consumable.test(data.viewItem, {
          attributes: attrName + "-end-after"
        }) && !conversionApi.consumable.test(data.viewItem, {
          attributes: attrName + "-start-after"
        }) && !conversionApi.consumable.test(data.viewItem, {
          attributes: attrName + "-end-before"
        }) && !conversionApi.consumable.test(data.viewItem, {
          attributes: attrName + "-start-before"
        })) {
          return;
        }
        if (!data.modelRange) {
          Object.assign(data, conversionApi.convertChildren(data.viewItem, data.modelCursor));
        }
        if (conversionApi.consumable.consume(data.viewItem, {
          attributes: attrName + "-end-after"
        })) {
          addMarkerElements(data.modelRange.end, data.viewItem.getAttribute(attrName + "-end-after").split(","));
        }
        if (conversionApi.consumable.consume(data.viewItem, {
          attributes: attrName + "-start-after"
        })) {
          addMarkerElements(data.modelRange.end, data.viewItem.getAttribute(attrName + "-start-after").split(","));
        }
        if (conversionApi.consumable.consume(data.viewItem, {
          attributes: attrName + "-end-before"
        })) {
          addMarkerElements(data.modelRange.start, data.viewItem.getAttribute(attrName + "-end-before").split(","));
        }
        if (conversionApi.consumable.consume(data.viewItem, {
          attributes: attrName + "-start-before"
        })) {
          addMarkerElements(data.modelRange.start, data.viewItem.getAttribute(attrName + "-start-before").split(","));
        }
        function addMarkerElements(position, markerViewNames) {
          for (const markerViewName of markerViewNames) {
            const markerName = config2.model(markerViewName, conversionApi);
            const element = conversionApi.writer.createElement("$marker", {
              "data-name": markerName
            });
            conversionApi.writer.insert(element, position);
            if (data.modelCursor.isEqual(position)) {
              data.modelCursor = data.modelCursor.getShiftedBy(1);
            } else {
              data.modelCursor = data.modelCursor._getTransformedByInsertion(position, 1);
            }
            data.modelRange = data.modelRange._getTransformedByInsertion(position, 1)[0];
          }
        }
      };
    }
    function getViewElementNameFromConfig(viewConfig) {
      if (typeof viewConfig == "string") {
        return viewConfig;
      }
      if (typeof viewConfig == "object" && typeof viewConfig.name == "string") {
        return viewConfig.name;
      }
      return null;
    }
    function prepareToElementConverter(config2) {
      const matcher = new Matcher(config2.view);
      return (evt, data, conversionApi) => {
        const matcherResult = matcher.match(data.viewItem);
        if (!matcherResult) {
          return;
        }
        const match = matcherResult.match;
        match.name = true;
        if (!conversionApi.consumable.test(data.viewItem, match)) {
          return;
        }
        const modelElement = getModelElement(config2.model, data.viewItem, conversionApi);
        if (!modelElement) {
          return;
        }
        if (!conversionApi.safeInsert(modelElement, data.modelCursor)) {
          return;
        }
        conversionApi.consumable.consume(data.viewItem, match);
        conversionApi.convertChildren(data.viewItem, modelElement);
        conversionApi.updateConversionResult(modelElement, data);
      };
    }
    function getModelElement(model, input, conversionApi) {
      if (model instanceof Function) {
        return model(input, conversionApi);
      } else {
        return conversionApi.writer.createElement(model);
      }
    }
    function normalizeViewAttributeKeyValueConfig(config2) {
      if (typeof config2.view == "string") {
        config2.view = {
          key: config2.view
        };
      }
      const key = config2.view.key;
      const value = typeof config2.view.value == "undefined" ? /[\s\S]*/ : config2.view.value;
      let normalized;
      if (key == "class" || key == "style") {
        const keyName = key == "class" ? "classes" : "styles";
        normalized = {
          [keyName]: value
        };
      } else {
        normalized = {
          attributes: {
            [key]: value
          }
        };
      }
      if (config2.view.name) {
        normalized.name = config2.view.name;
      }
      config2.view = normalized;
      return key;
    }
    function normalizeModelAttributeConfig(config2, viewAttributeKeyToCopy = null) {
      const defaultModelValue = viewAttributeKeyToCopy === null ? true : (viewElement) => viewElement.getAttribute(viewAttributeKeyToCopy);
      const key = typeof config2.model != "object" ? config2.model : config2.model.key;
      const value = typeof config2.model != "object" || typeof config2.model.value == "undefined" ? defaultModelValue : config2.model.value;
      config2.model = {
        key,
        value
      };
    }
    function prepareToAttributeConverter(config2, shallow) {
      const matcher = new Matcher(config2.view);
      return (evt, data, conversionApi) => {
        if (!data.modelRange && shallow) {
          return;
        }
        const match = matcher.match(data.viewItem);
        if (!match) {
          return;
        }
        if (onlyViewNameIsDefined(config2.view, data.viewItem)) {
          match.match.name = true;
        } else {
          delete match.match.name;
        }
        if (!conversionApi.consumable.test(data.viewItem, match.match)) {
          return;
        }
        const modelKey = config2.model.key;
        const modelValue = typeof config2.model.value == "function" ? config2.model.value(data.viewItem, conversionApi) : config2.model.value;
        if (modelValue === null) {
          return;
        }
        if (!data.modelRange) {
          Object.assign(data, conversionApi.convertChildren(data.viewItem, data.modelCursor));
        }
        const attributeWasSet = setAttributeOn(data.modelRange, {
          key: modelKey,
          value: modelValue
        }, shallow, conversionApi);
        if (attributeWasSet) {
          if (conversionApi.consumable.test(data.viewItem, {
            name: true
          })) {
            match.match.name = true;
          }
          conversionApi.consumable.consume(data.viewItem, match.match);
        }
      };
    }
    function onlyViewNameIsDefined(viewConfig, viewItem) {
      const configToTest = typeof viewConfig == "function" ? viewConfig(viewItem) : viewConfig;
      if (typeof configToTest == "object" && !getViewElementNameFromConfig(configToTest)) {
        return false;
      }
      return !configToTest.classes && !configToTest.attributes && !configToTest.styles;
    }
    function setAttributeOn(modelRange, modelAttribute, shallow, conversionApi) {
      let result2 = false;
      for (const node of Array.from(modelRange.getItems({
        shallow
      }))) {
        if (!conversionApi.schema.checkAttribute(node, modelAttribute.key)) {
          continue;
        }
        result2 = true;
        if (node.hasAttribute(modelAttribute.key)) {
          continue;
        }
        conversionApi.writer.setAttribute(modelAttribute.key, modelAttribute.value, node);
      }
      return result2;
    }
    function normalizeElementToMarkerModelConfig(model) {
      return (viewElement, conversionApi) => {
        const markerName = typeof model == "string" ? model : model(viewElement, conversionApi);
        return conversionApi.writer.createElement("$marker", {
          "data-name": markerName
        });
      };
    }
    function normalizeDataToMarkerConfig(config2, type) {
      const elementCreatorFunction = (viewElement, conversionApi) => {
        const viewName = viewElement.getAttribute("name");
        const markerName = config2.model(viewName, conversionApi);
        return conversionApi.writer.createElement("$marker", {
          "data-name": markerName
        });
      };
      return {
        // Upcast <markerGroup-start> and <markerGroup-end> elements.
        view: `${config2.view}-${type}`,
        model: elementCreatorFunction
      };
    }
    function injectSelectionPostFixer(model) {
      model.document.registerPostFixer((writer) => selectionPostFixer(writer, model));
    }
    function selectionPostFixer(writer, model) {
      const selection = model.document.selection;
      const schema = model.schema;
      const ranges = [];
      let wasFixed = false;
      for (const modelRange of selection.getRanges()) {
        const correctedRange = tryFixingRange(modelRange, schema);
        if (correctedRange && !correctedRange.isEqual(modelRange)) {
          ranges.push(correctedRange);
          wasFixed = true;
        } else {
          ranges.push(modelRange);
        }
      }
      if (wasFixed) {
        writer.setSelection(mergeIntersectingRanges(ranges), {
          backward: selection.isBackward
        });
      }
      return false;
    }
    function tryFixingRange(range2, schema) {
      if (range2.isCollapsed) {
        return tryFixingCollapsedRange(range2, schema);
      }
      return tryFixingNonCollapsedRage(range2, schema);
    }
    function tryFixingCollapsedRange(range2, schema) {
      const originalPosition = range2.start;
      const nearestSelectionRange = schema.getNearestSelectionRange(originalPosition);
      if (!nearestSelectionRange) {
        const ancestorObject = originalPosition.getAncestors().reverse().find((item) => schema.isObject(item));
        if (ancestorObject) {
          return Range._createOn(ancestorObject);
        }
        return null;
      }
      if (!nearestSelectionRange.isCollapsed) {
        return nearestSelectionRange;
      }
      const fixedPosition = nearestSelectionRange.start;
      if (originalPosition.isEqual(fixedPosition)) {
        return null;
      }
      return new Range(fixedPosition);
    }
    function tryFixingNonCollapsedRage(range2, schema) {
      const { start: start2, end: end2 } = range2;
      const isTextAllowedOnStart = schema.checkChild(start2, "$text");
      const isTextAllowedOnEnd = schema.checkChild(end2, "$text");
      const startLimitElement = schema.getLimitElement(start2);
      const endLimitElement = schema.getLimitElement(end2);
      if (startLimitElement === endLimitElement) {
        if (isTextAllowedOnStart && isTextAllowedOnEnd) {
          return null;
        }
        if (checkSelectionOnNonLimitElements(start2, end2, schema)) {
          const isStartBeforeSelectable = start2.nodeAfter && schema.isSelectable(start2.nodeAfter);
          const fixedStart = isStartBeforeSelectable ? null : schema.getNearestSelectionRange(start2, "forward");
          const isEndAfterSelectable = end2.nodeBefore && schema.isSelectable(end2.nodeBefore);
          const fixedEnd = isEndAfterSelectable ? null : schema.getNearestSelectionRange(end2, "backward");
          const rangeStart = fixedStart ? fixedStart.start : start2;
          const rangeEnd = fixedEnd ? fixedEnd.end : end2;
          return new Range(rangeStart, rangeEnd);
        }
      }
      const isStartInLimit = startLimitElement && !startLimitElement.is("rootElement");
      const isEndInLimit = endLimitElement && !endLimitElement.is("rootElement");
      if (isStartInLimit || isEndInLimit) {
        const bothInSameParent = start2.nodeAfter && end2.nodeBefore && start2.nodeAfter.parent === end2.nodeBefore.parent;
        const expandStart = isStartInLimit && (!bothInSameParent || !isSelectable(start2.nodeAfter, schema));
        const expandEnd = isEndInLimit && (!bothInSameParent || !isSelectable(end2.nodeBefore, schema));
        let fixedStart = start2;
        let fixedEnd = end2;
        if (expandStart) {
          fixedStart = Position._createBefore(findOutermostLimitAncestor(startLimitElement, schema));
        }
        if (expandEnd) {
          fixedEnd = Position._createAfter(findOutermostLimitAncestor(endLimitElement, schema));
        }
        return new Range(fixedStart, fixedEnd);
      }
      return null;
    }
    function findOutermostLimitAncestor(startingNode, schema) {
      let isLimitNode = startingNode;
      let parent2 = isLimitNode;
      while (schema.isLimit(parent2) && parent2.parent) {
        isLimitNode = parent2;
        parent2 = parent2.parent;
      }
      return isLimitNode;
    }
    function checkSelectionOnNonLimitElements(start2, end2, schema) {
      const startIsOnBlock = start2.nodeAfter && !schema.isLimit(start2.nodeAfter) || schema.checkChild(start2, "$text");
      const endIsOnBlock = end2.nodeBefore && !schema.isLimit(end2.nodeBefore) || schema.checkChild(end2, "$text");
      return startIsOnBlock || endIsOnBlock;
    }
    function mergeIntersectingRanges(ranges) {
      const rangesToMerge = [
        ...ranges
      ];
      const rangeIndexesToRemove = /* @__PURE__ */ new Set();
      let currentRangeIndex = 1;
      while (currentRangeIndex < rangesToMerge.length) {
        const currentRange = rangesToMerge[currentRangeIndex];
        const previousRanges = rangesToMerge.slice(0, currentRangeIndex);
        for (const [previousRangeIndex, previousRange] of previousRanges.entries()) {
          if (rangeIndexesToRemove.has(previousRangeIndex)) {
            continue;
          }
          if (currentRange.isEqual(previousRange)) {
            rangeIndexesToRemove.add(previousRangeIndex);
          } else if (currentRange.isIntersecting(previousRange)) {
            rangeIndexesToRemove.add(previousRangeIndex);
            rangeIndexesToRemove.add(currentRangeIndex);
            const mergedRange = currentRange.getJoined(previousRange);
            rangesToMerge.push(mergedRange);
          }
        }
        currentRangeIndex++;
      }
      const nonIntersectingRanges = rangesToMerge.filter((_2, index) => !rangeIndexesToRemove.has(index));
      return nonIntersectingRanges;
    }
    function isSelectable(node, schema) {
      return node && schema.isSelectable(node);
    }
    class EditingController extends (/* @__PURE__ */ ObservableMixin()) {
      /**
      * Creates an editing controller instance.
      *
      * @param model Editing model.
      * @param stylesProcessor The styles processor instance.
      */
      constructor(model, stylesProcessor) {
        super();
        /**
        * Editor model.
        */
        __publicField(this, "model");
        /**
        * Editing view controller.
        */
        __publicField(this, "view");
        /**
        * A mapper that describes the model-view binding.
        */
        __publicField(this, "mapper");
        /**
        * Downcast dispatcher that converts changes from the model to the {@link #view editing view}.
        */
        __publicField(this, "downcastDispatcher");
        this.model = model;
        this.view = new View$1(stylesProcessor);
        this.mapper = new Mapper();
        this.downcastDispatcher = new DowncastDispatcher({
          mapper: this.mapper,
          schema: model.schema
        });
        const doc = this.model.document;
        const selection = doc.selection;
        const markers = this.model.markers;
        this.listenTo(this.model, "_beforeChanges", () => {
          this.view._disableRendering(true);
        }, {
          priority: "highest"
        });
        this.listenTo(this.model, "_afterChanges", () => {
          this.view._disableRendering(false);
        }, {
          priority: "lowest"
        });
        this.listenTo(doc, "change", () => {
          this.view.change((writer) => {
            this.downcastDispatcher.convertChanges(doc.differ, markers, writer);
            this.downcastDispatcher.convertSelection(selection, markers, writer);
          });
        }, {
          priority: "low"
        });
        this.listenTo(this.view.document, "selectionChange", convertSelectionChange(this.model, this.mapper));
        this.listenTo(this.view.document, "beforeinput", fixTargetRanges(this.mapper, this.model.schema, this.view), {
          priority: "high"
        });
        this.downcastDispatcher.on("insert:$text", insertText(), {
          priority: "lowest"
        });
        this.downcastDispatcher.on("insert", insertAttributesAndChildren(), {
          priority: "lowest"
        });
        this.downcastDispatcher.on("remove", remove(), {
          priority: "low"
        });
        this.downcastDispatcher.on("cleanSelection", cleanSelection());
        this.downcastDispatcher.on("selection", convertRangeSelection(), {
          priority: "low"
        });
        this.downcastDispatcher.on("selection", convertCollapsedSelection(), {
          priority: "low"
        });
        this.view.document.roots.bindTo(this.model.document.roots).using((root2) => {
          if (root2.rootName == "$graveyard") {
            return null;
          }
          const viewRoot = new RootEditableElement(this.view.document, root2.name);
          viewRoot.rootName = root2.rootName;
          this.mapper.bindElements(root2, viewRoot);
          return viewRoot;
        });
      }
      /**
      * Removes all event listeners attached to the `EditingController`. Destroys all objects created
      * by `EditingController` that need to be destroyed.
      */
      destroy() {
        this.view.destroy();
        this.stopListening();
      }
      /**
      * Calling this method will refresh the marker by triggering the downcast conversion for it.
      *
      * Reconverting the marker is useful when you want to change its {@link module:engine/view/element~Element view element}
      * without changing any marker data. For instance:
      *
      * ```ts
      * let isCommentActive = false;
      *
      * model.conversion.markerToHighlight( {
      * 	model: 'comment',
      * 	view: data => {
      * 		const classes = [ 'comment-marker' ];
      *
      * 		if ( isCommentActive ) {
      * 			classes.push( 'comment-marker--active' );
      * 		}
      *
      * 		return { classes };
      * 	}
      * } );
      *
      * // ...
      *
      * // Change the property that indicates if marker is displayed as active or not.
      * isCommentActive = true;
      *
      * // Reconverting will downcast and synchronize the marker with the new isCommentActive state value.
      * editor.editing.reconvertMarker( 'comment' );
      * ```
      *
      * **Note**: If you want to reconvert a model item, use {@link #reconvertItem} instead.
      *
      * @param markerOrName Name of a marker to update, or a marker instance.
      */
      reconvertMarker(markerOrName) {
        const markerName = typeof markerOrName == "string" ? markerOrName : markerOrName.name;
        const currentMarker = this.model.markers.get(markerName);
        if (!currentMarker) {
          throw new CKEditorError("editingcontroller-reconvertmarker-marker-not-exist", this, {
            markerName
          });
        }
        this.model.change(() => {
          this.model.markers._refresh(currentMarker);
        });
      }
      /**
      * Calling this method will downcast a model item on demand (by requesting a refresh in the {@link module:engine/model/differ~Differ}).
      *
      * You can use it if you want the view representation of a specific item updated as a response to external modifications. For instance,
      * when the view structure depends not only on the associated model data but also on some external state.
      *
      * **Note**: If you want to reconvert a model marker, use {@link #reconvertMarker} instead.
      *
      * @param item Item to refresh.
      */
      reconvertItem(item) {
        this.model.change(() => {
          this.model.document.differ._refreshItem(item);
        });
      }
    }
    function fixTargetRanges(mapper, schema, view) {
      return (evt, data) => {
        if (view.document.isComposing && !env.isAndroid) {
          return;
        }
        for (let i2 = 0; i2 < data.targetRanges.length; i2++) {
          const viewRange = data.targetRanges[i2];
          const modelRange = mapper.toModelRange(viewRange);
          const correctedRange = tryFixingRange(modelRange, schema);
          if (!correctedRange || correctedRange.isEqual(modelRange)) {
            continue;
          }
          data.targetRanges[i2] = mapper.toViewRange(correctedRange);
        }
      };
    }
    class ViewConsumable {
      constructor() {
        /**
        * Map of consumable elements. If {@link module:engine/view/element~Element element} is used as a key,
        * {@link module:engine/conversion/viewconsumable~ViewElementConsumables ViewElementConsumables} instance is stored as value.
        * For {@link module:engine/view/text~Text text nodes} and
        * {@link module:engine/view/documentfragment~DocumentFragment document fragments} boolean value is stored as value.
        */
        __publicField(this, "_consumables", /* @__PURE__ */ new Map());
      }
      add(element, consumables) {
        let elementConsumables;
        if (element.is("$text") || element.is("documentFragment")) {
          this._consumables.set(element, true);
          return;
        }
        if (!this._consumables.has(element)) {
          elementConsumables = new ViewElementConsumables(element);
          this._consumables.set(element, elementConsumables);
        } else {
          elementConsumables = this._consumables.get(element);
        }
        elementConsumables.add(consumables);
      }
      /**
      * Tests if {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or
      * {@link module:engine/view/documentfragment~DocumentFragment document fragment} can be consumed.
      * It returns `true` when all items included in method's call can be consumed. Returns `false` when
      * first already consumed item is found and `null` when first non-consumable item is found.
      *
      * ```ts
      * viewConsumable.test( p, { name: true } ); // Tests element's name.
      * viewConsumable.test( p, { attributes: 'name' } ); // Tests attribute.
      * viewConsumable.test( p, { classes: 'foobar' } ); // Tests class.
      * viewConsumable.test( p, { styles: 'color' } ); // Tests style.
      * viewConsumable.test( p, { attributes: 'name', styles: 'color' } ); // Tests attribute and style.
      * viewConsumable.test( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be tested.
      * viewConsumable.test( textNode ); // Tests text node.
      * viewConsumable.test( docFragment ); // Tests document fragment.
      * ```
      *
      * Testing classes and styles as attribute will test if all added classes/styles can be consumed.
      *
      * ```ts
      * viewConsumable.test( p, { attributes: 'class' } ); // Tests if all added classes can be consumed.
      * viewConsumable.test( p, { attributes: 'style' } ); // Tests if all added styles can be consumed.
      * ```
      *
      * @param consumables Used only if first parameter is {@link module:engine/view/element~Element view element} instance.
      * @param consumables.name If set to true element's name will be included.
      * @param consumables.attributes Attribute name or array of attribute names.
      * @param consumables.classes Class name or array of class names.
      * @param consumables.styles Style name or array of style names.
      * @returns Returns `true` when all items included in method's call can be consumed. Returns `false`
      * when first already consumed item is found and `null` when first non-consumable item is found.
      */
      test(element, consumables) {
        const elementConsumables = this._consumables.get(element);
        if (elementConsumables === void 0) {
          return null;
        }
        if (element.is("$text") || element.is("documentFragment")) {
          return elementConsumables;
        }
        return elementConsumables.test(consumables);
      }
      /**
      * Consumes {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or
      * {@link module:engine/view/documentfragment~DocumentFragment document fragment}.
      * It returns `true` when all items included in method's call can be consumed, otherwise returns `false`.
      *
      * ```ts
      * viewConsumable.consume( p, { name: true } ); // Consumes element's name.
      * viewConsumable.consume( p, { attributes: 'name' } ); // Consumes element's attribute.
      * viewConsumable.consume( p, { classes: 'foobar' } ); // Consumes element's class.
      * viewConsumable.consume( p, { styles: 'color' } ); // Consumes element's style.
      * viewConsumable.consume( p, { attributes: 'name', styles: 'color' } ); // Consumes attribute and style.
      * viewConsumable.consume( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be consumed.
      * viewConsumable.consume( textNode ); // Consumes text node.
      * viewConsumable.consume( docFragment ); // Consumes document fragment.
      * ```
      *
      * Consuming classes and styles as attribute will test if all added classes/styles can be consumed.
      *
      * ```ts
      * viewConsumable.consume( p, { attributes: 'class' } ); // Consume only if all added classes can be consumed.
      * viewConsumable.consume( p, { attributes: 'style' } ); // Consume only if all added styles can be consumed.
      * ```
      *
      * @param consumables Used only if first parameter is {@link module:engine/view/element~Element view element} instance.
      * @param consumables.name If set to true element's name will be included.
      * @param consumables.attributes Attribute name or array of attribute names.
      * @param consumables.classes Class name or array of class names.
      * @param consumables.styles Style name or array of style names.
      * @returns Returns `true` when all items included in method's call can be consumed,
      * otherwise returns `false`.
      */
      consume(element, consumables) {
        if (this.test(element, consumables)) {
          if (element.is("$text") || element.is("documentFragment")) {
            this._consumables.set(element, false);
          } else {
            this._consumables.get(element).consume(consumables);
          }
          return true;
        }
        return false;
      }
      /**
      * Reverts {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or
      * {@link module:engine/view/documentfragment~DocumentFragment document fragment} so they can be consumed once again.
      * Method does not revert items that were never previously added for consumption, even if they are included in
      * method's call.
      *
      * ```ts
      * viewConsumable.revert( p, { name: true } ); // Reverts element's name.
      * viewConsumable.revert( p, { attributes: 'name' } ); // Reverts element's attribute.
      * viewConsumable.revert( p, { classes: 'foobar' } ); // Reverts element's class.
      * viewConsumable.revert( p, { styles: 'color' } ); // Reverts element's style.
      * viewConsumable.revert( p, { attributes: 'name', styles: 'color' } ); // Reverts attribute and style.
      * viewConsumable.revert( p, { classes: [ 'baz', 'bar' ] } ); // Multiple names can be reverted.
      * viewConsumable.revert( textNode ); // Reverts text node.
      * viewConsumable.revert( docFragment ); // Reverts document fragment.
      * ```
      *
      * Reverting classes and styles as attribute will revert all classes/styles that were previously added for
      * consumption.
      *
      * ```ts
      * viewConsumable.revert( p, { attributes: 'class' } ); // Reverts all classes added for consumption.
      * viewConsumable.revert( p, { attributes: 'style' } ); // Reverts all styles added for consumption.
      * ```
      *
      * @param consumables Used only if first parameter is {@link module:engine/view/element~Element view element} instance.
      * @param consumables.name If set to true element's name will be included.
      * @param consumables.attributes Attribute name or array of attribute names.
      * @param consumables.classes Class name or array of class names.
      * @param consumables.styles Style name or array of style names.
      */
      revert(element, consumables) {
        const elementConsumables = this._consumables.get(element);
        if (elementConsumables !== void 0) {
          if (element.is("$text") || element.is("documentFragment")) {
            this._consumables.set(element, true);
          } else {
            elementConsumables.revert(consumables);
          }
        }
      }
      /**
      * Creates consumable object from {@link module:engine/view/element~Element view element}. Consumable object will include
      * element's name and all its attributes, classes and styles.
      */
      static consumablesFromElement(element) {
        const consumables = {
          element,
          name: true,
          attributes: [],
          classes: [],
          styles: []
        };
        const attributes = element.getAttributeKeys();
        for (const attribute of attributes) {
          if (attribute == "style" || attribute == "class") {
            continue;
          }
          consumables.attributes.push(attribute);
        }
        const classes = element.getClassNames();
        for (const className of classes) {
          consumables.classes.push(className);
        }
        const styles = element.getStyleNames();
        for (const style of styles) {
          consumables.styles.push(style);
        }
        return consumables;
      }
      /**
      * Creates {@link module:engine/conversion/viewconsumable~ViewConsumable ViewConsumable} instance from
      * {@link module:engine/view/node~Node node} or {@link module:engine/view/documentfragment~DocumentFragment document fragment}.
      * Instance will contain all elements, child nodes, attributes, styles and classes added for consumption.
      *
      * @param from View node or document fragment from which `ViewConsumable` will be created.
      * @param instance If provided, given `ViewConsumable` instance will be used
      * to add all consumables. It will be returned instead of a new instance.
      */
      static createFrom(from, instance) {
        if (!instance) {
          instance = new ViewConsumable();
        }
        if (from.is("$text")) {
          instance.add(from);
          return instance;
        }
        if (from.is("element")) {
          instance.add(from, ViewConsumable.consumablesFromElement(from));
        }
        if (from.is("documentFragment")) {
          instance.add(from);
        }
        for (const child of from.getChildren()) {
          instance = ViewConsumable.createFrom(child, instance);
        }
        return instance;
      }
    }
    const CONSUMABLE_TYPES = [
      "attributes",
      "classes",
      "styles"
    ];
    class ViewElementConsumables {
      /**
      * Creates ViewElementConsumables instance.
      *
      * @param from View node or document fragment from which `ViewElementConsumables` is being created.
      */
      constructor(from) {
        __publicField(this, "element");
        /**
        * Flag indicating if name of the element can be consumed.
        */
        __publicField(this, "_canConsumeName");
        /**
        * Contains maps of element's consumables: attributes, classes and styles.
        */
        __publicField(this, "_consumables");
        this.element = from;
        this._canConsumeName = null;
        this._consumables = {
          attributes: /* @__PURE__ */ new Map(),
          styles: /* @__PURE__ */ new Map(),
          classes: /* @__PURE__ */ new Map()
        };
      }
      /**
      * Adds consumable parts of the {@link module:engine/view/element~Element view element}.
      * Element's name itself can be marked to be consumed (when element's name is consumed its attributes, classes and
      * styles still could be consumed):
      *
      * ```ts
      * consumables.add( { name: true } );
      * ```
      *
      * Attributes classes and styles:
      *
      * ```ts
      * consumables.add( { attributes: 'title', classes: 'foo', styles: 'color' } );
      * consumables.add( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );
      * ```
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`
      * attribute is provided - it should be handled separately by providing `style` and `class` in consumables object.
      *
      * @param consumables Object describing which parts of the element can be consumed.
      * @param consumables.name If set to `true` element's name will be added as consumable.
      * @param consumables.attributes Attribute name or array of attribute names to add as consumable.
      * @param consumables.classes Class name or array of class names to add as consumable.
      * @param consumables.styles Style name or array of style names to add as consumable.
      */
      add(consumables) {
        if (consumables.name) {
          this._canConsumeName = true;
        }
        for (const type of CONSUMABLE_TYPES) {
          if (type in consumables) {
            this._add(type, consumables[type]);
          }
        }
      }
      /**
      * Tests if parts of the {@link module:engine/view/node~Node view node} can be consumed.
      *
      * Element's name can be tested:
      *
      * ```ts
      * consumables.test( { name: true } );
      * ```
      *
      * Attributes classes and styles:
      *
      * ```ts
      * consumables.test( { attributes: 'title', classes: 'foo', styles: 'color' } );
      * consumables.test( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );
      * ```
      *
      * @param consumables Object describing which parts of the element should be tested.
      * @param consumables.name If set to `true` element's name will be tested.
      * @param consumables.attributes Attribute name or array of attribute names to test.
      * @param consumables.classes Class name or array of class names to test.
      * @param consumables.styles Style name or array of style names to test.
      * @returns `true` when all tested items can be consumed, `null` when even one of the items
      * was never marked for consumption and `false` when even one of the items was already consumed.
      */
      test(consumables) {
        if (consumables.name && !this._canConsumeName) {
          return this._canConsumeName;
        }
        for (const type of CONSUMABLE_TYPES) {
          if (type in consumables) {
            const value = this._test(type, consumables[type]);
            if (value !== true) {
              return value;
            }
          }
        }
        return true;
      }
      /**
      * Consumes parts of {@link module:engine/view/element~Element view element}. This function does not check if consumable item
      * is already consumed - it consumes all consumable items provided.
      * Element's name can be consumed:
      *
      * ```ts
      * consumables.consume( { name: true } );
      * ```
      *
      * Attributes classes and styles:
      *
      * ```ts
      * consumables.consume( { attributes: 'title', classes: 'foo', styles: 'color' } );
      * consumables.consume( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );
      * ```
      *
      * @param consumables Object describing which parts of the element should be consumed.
      * @param consumables.name If set to `true` element's name will be consumed.
      * @param consumables.attributes Attribute name or array of attribute names to consume.
      * @param consumables.classes Class name or array of class names to consume.
      * @param consumables.styles Style name or array of style names to consume.
      */
      consume(consumables) {
        if (consumables.name) {
          this._canConsumeName = false;
        }
        for (const type of CONSUMABLE_TYPES) {
          if (type in consumables) {
            this._consume(type, consumables[type]);
          }
        }
      }
      /**
      * Revert already consumed parts of {@link module:engine/view/element~Element view Element}, so they can be consumed once again.
      * Element's name can be reverted:
      *
      * ```ts
      * consumables.revert( { name: true } );
      * ```
      *
      * Attributes classes and styles:
      *
      * ```ts
      * consumables.revert( { attributes: 'title', classes: 'foo', styles: 'color' } );
      * consumables.revert( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );
      * ```
      *
      * @param consumables Object describing which parts of the element should be reverted.
      * @param consumables.name If set to `true` element's name will be reverted.
      * @param consumables.attributes Attribute name or array of attribute names to revert.
      * @param consumables.classes Class name or array of class names to revert.
      * @param consumables.styles Style name or array of style names to revert.
      */
      revert(consumables) {
        if (consumables.name) {
          this._canConsumeName = true;
        }
        for (const type of CONSUMABLE_TYPES) {
          if (type in consumables) {
            this._revert(type, consumables[type]);
          }
        }
      }
      /**
      * Helper method that adds consumables of a given type: attribute, class or style.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`
      * type is provided - it should be handled separately by providing actual style/class type.
      *
      * @param type Type of the consumable item: `attributes`, `classes` or `styles`.
      * @param item Consumable item or array of items.
      */
      _add(type, item) {
        const items = toArray$2(item);
        const consumables = this._consumables[type];
        for (const name of items) {
          if (type === "attributes" && (name === "class" || name === "style")) {
            throw new CKEditorError("viewconsumable-invalid-attribute", this);
          }
          consumables.set(name, true);
          if (type === "styles") {
            for (const alsoName of this.element.document.stylesProcessor.getRelatedStyles(name)) {
              consumables.set(alsoName, true);
            }
          }
        }
      }
      /**
      * Helper method that tests consumables of a given type: attribute, class or style.
      *
      * @param type Type of the consumable item: `attributes`, `classes` or `styles`.
      * @param item Consumable item or array of items.
      * @returns Returns `true` if all items can be consumed, `null` when one of the items cannot be
      * consumed and `false` when one of the items is already consumed.
      */
      _test(type, item) {
        const items = toArray$2(item);
        const consumables = this._consumables[type];
        for (const name of items) {
          if (type === "attributes" && (name === "class" || name === "style")) {
            const consumableName = name == "class" ? "classes" : "styles";
            const value = this._test(consumableName, [
              ...this._consumables[consumableName].keys()
            ]);
            if (value !== true) {
              return value;
            }
          } else {
            const value = consumables.get(name);
            if (value === void 0) {
              return null;
            }
            if (!value) {
              return false;
            }
          }
        }
        return true;
      }
      /**
      * Helper method that consumes items of a given type: attribute, class or style.
      *
      * @param type Type of the consumable item: `attributes`, `classes` or `styles`.
      * @param item Consumable item or array of items.
      */
      _consume(type, item) {
        const items = toArray$2(item);
        const consumables = this._consumables[type];
        for (const name of items) {
          if (type === "attributes" && (name === "class" || name === "style")) {
            const consumableName = name == "class" ? "classes" : "styles";
            this._consume(consumableName, [
              ...this._consumables[consumableName].keys()
            ]);
          } else {
            consumables.set(name, false);
            if (type == "styles") {
              for (const toConsume of this.element.document.stylesProcessor.getRelatedStyles(name)) {
                consumables.set(toConsume, false);
              }
            }
          }
        }
      }
      /**
      * Helper method that reverts items of a given type: attribute, class or style.
      *
      * @param type Type of the consumable item: `attributes`, `classes` or , `styles`.
      * @param item Consumable item or array of items.
      */
      _revert(type, item) {
        const items = toArray$2(item);
        const consumables = this._consumables[type];
        for (const name of items) {
          if (type === "attributes" && (name === "class" || name === "style")) {
            const consumableName = name == "class" ? "classes" : "styles";
            this._revert(consumableName, [
              ...this._consumables[consumableName].keys()
            ]);
          } else {
            const value = consumables.get(name);
            if (value === false) {
              consumables.set(name, true);
            }
          }
        }
      }
    }
    class Schema extends (/* @__PURE__ */ ObservableMixin()) {
      /**
      * Creates a schema instance.
      */
      constructor() {
        super();
        __publicField(this, "_sourceDefinitions", {});
        /**
        * A dictionary containing attribute properties.
        */
        __publicField(this, "_attributeProperties", /* @__PURE__ */ Object.create(null));
        /**
        * Stores additional callbacks registered for schema items, which are evaluated when {@link ~Schema#checkChild} is called.
        *
        * Keys are schema item names for which the callbacks are registered. Values are arrays with the callbacks.
        *
        * Some checks are added under {@link ~Schema#_genericCheckSymbol} key, these are evaluated for every {@link ~Schema#checkChild} call.
        */
        __publicField(this, "_customChildChecks", /* @__PURE__ */ new Map());
        /**
        * Stores additional callbacks registered for attribute names, which are evaluated when {@link ~Schema#checkAttribute} is called.
        *
        * Keys are schema attribute names for which the callbacks are registered. Values are arrays with the callbacks.
        *
        * Some checks are added under {@link ~Schema#_genericCheckSymbol} key, these are evaluated for every
        * {@link ~Schema#checkAttribute} call.
        */
        __publicField(this, "_customAttributeChecks", /* @__PURE__ */ new Map());
        __publicField(this, "_genericCheckSymbol", Symbol("$generic"));
        __publicField(this, "_compiledDefinitions");
        this.decorate("checkChild");
        this.decorate("checkAttribute");
        this.on("checkAttribute", (evt, args) => {
          args[0] = new SchemaContext(args[0]);
        }, {
          priority: "highest"
        });
        this.on("checkChild", (evt, args) => {
          args[0] = new SchemaContext(args[0]);
          args[1] = this.getDefinition(args[1]);
        }, {
          priority: "highest"
        });
      }
      /**
      * Registers a schema item. Can only be called once for every item name.
      *
      * ```ts
      * schema.register( 'paragraph', {
      * 	inheritAllFrom: '$block'
      * } );
      * ```
      */
      register(itemName, definition) {
        if (this._sourceDefinitions[itemName]) {
          throw new CKEditorError("schema-cannot-register-item-twice", this, {
            itemName
          });
        }
        this._sourceDefinitions[itemName] = [
          Object.assign({}, definition)
        ];
        this._clearCache();
      }
      /**
      * Extends a {@link #register registered} item's definition.
      *
      * Extending properties such as `allowIn` will add more items to the existing properties,
      * while redefining properties such as `isBlock` will override the previously defined ones.
      *
      * ```ts
      * schema.register( 'foo', {
      * 	allowIn: '$root',
      * 	isBlock: true;
      * } );
      * schema.extend( 'foo', {
      * 	allowIn: 'blockQuote',
      * 	isBlock: false
      * } );
      *
      * schema.getDefinition( 'foo' );
      * //	{
      * //		allowIn: [ '$root', 'blockQuote' ],
      * // 		isBlock: false
      * //	}
      * ```
      */
      extend(itemName, definition) {
        if (!this._sourceDefinitions[itemName]) {
          throw new CKEditorError("schema-cannot-extend-missing-item", this, {
            itemName
          });
        }
        this._sourceDefinitions[itemName].push(Object.assign({}, definition));
        this._clearCache();
      }
      /**
      * Returns data of all registered items.
      *
      * This method should normally be used for reflection purposes (e.g. defining a clone of a certain element,
      * checking a list of all block elements, etc).
      * Use specific methods (such as {@link #checkChild `checkChild()`} or {@link #isLimit `isLimit()`})
      * in other cases.
      */
      getDefinitions() {
        if (!this._compiledDefinitions) {
          this._compile();
        }
        return this._compiledDefinitions;
      }
      /**
      * Returns a definition of the given item or `undefined` if an item is not registered.
      *
      * This method should normally be used for reflection purposes (e.g. defining a clone of a certain element,
      * checking a list of all block elements, etc).
      * Use specific methods (such as {@link #checkChild `checkChild()`} or {@link #isLimit `isLimit()`})
      * in other cases.
      */
      getDefinition(item) {
        let itemName;
        if (typeof item == "string") {
          itemName = item;
        } else if ("is" in item && (item.is("$text") || item.is("$textProxy"))) {
          itemName = "$text";
        } else {
          itemName = item.name;
        }
        return this.getDefinitions()[itemName];
      }
      /**
      * Returns `true` if the given item is registered in the schema.
      *
      * ```ts
      * schema.isRegistered( 'paragraph' ); // -> true
      * schema.isRegistered( editor.model.document.getRoot() ); // -> true
      * schema.isRegistered( 'foo' ); // -> false
      * ```
      */
      isRegistered(item) {
        return !!this.getDefinition(item);
      }
      /**
      * Returns `true` if the given item is defined to be
      * a block by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isBlock` property.
      *
      * ```ts
      * schema.isBlock( 'paragraph' ); // -> true
      * schema.isBlock( '$root' ); // -> false
      *
      * const paragraphElement = writer.createElement( 'paragraph' );
      * schema.isBlock( paragraphElement ); // -> true
      * ```
      *
      * See the {@glink framework/deep-dive/schema#block-elements Block elements} section of
      * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
      */
      isBlock(item) {
        const def = this.getDefinition(item);
        return !!(def && def.isBlock);
      }
      /**
      * Returns `true` if the given item should be treated as a limit element.
      *
      * It considers an item to be a limit element if its
      * {@link module:engine/model/schema~SchemaItemDefinition}'s
      * {@link module:engine/model/schema~SchemaItemDefinition#isLimit `isLimit`} or
      * {@link module:engine/model/schema~SchemaItemDefinition#isObject `isObject`} property
      * was set to `true`.
      *
      * ```ts
      * schema.isLimit( 'paragraph' ); // -> false
      * schema.isLimit( '$root' ); // -> true
      * schema.isLimit( editor.model.document.getRoot() ); // -> true
      * schema.isLimit( 'imageBlock' ); // -> true
      * ```
      *
      * See the {@glink framework/deep-dive/schema#limit-elements Limit elements} section of
      * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
      */
      isLimit(item) {
        const def = this.getDefinition(item);
        if (!def) {
          return false;
        }
        return !!(def.isLimit || def.isObject);
      }
      /**
      * Returns `true` if the given item should be treated as an object element.
      *
      * It considers an item to be an object element if its
      * {@link module:engine/model/schema~SchemaItemDefinition}'s
      * {@link module:engine/model/schema~SchemaItemDefinition#isObject `isObject`} property
      * was set to `true`.
      *
      * ```ts
      * schema.isObject( 'paragraph' ); // -> false
      * schema.isObject( 'imageBlock' ); // -> true
      *
      * const imageElement = writer.createElement( 'imageBlock' );
      * schema.isObject( imageElement ); // -> true
      * ```
      *
      * See the {@glink framework/deep-dive/schema#object-elements Object elements} section of
      * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
      */
      isObject(item) {
        const def = this.getDefinition(item);
        if (!def) {
          return false;
        }
        return !!(def.isObject || def.isLimit && def.isSelectable && def.isContent);
      }
      /**
      * Returns `true` if the given item is defined to be
      * an inline element by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isInline` property.
      *
      * ```ts
      * schema.isInline( 'paragraph' ); // -> false
      * schema.isInline( 'softBreak' ); // -> true
      *
      * const text = writer.createText( 'foo' );
      * schema.isInline( text ); // -> true
      * ```
      *
      * See the {@glink framework/deep-dive/schema#inline-elements Inline elements} section of
      * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
      */
      isInline(item) {
        const def = this.getDefinition(item);
        return !!(def && def.isInline);
      }
      /**
      * Returns `true` if the given item is defined to be
      * a selectable element by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isSelectable` property.
      *
      * ```ts
      * schema.isSelectable( 'paragraph' ); // -> false
      * schema.isSelectable( 'heading1' ); // -> false
      * schema.isSelectable( 'imageBlock' ); // -> true
      * schema.isSelectable( 'tableCell' ); // -> true
      *
      * const text = writer.createText( 'foo' );
      * schema.isSelectable( text ); // -> false
      * ```
      *
      * See the {@glink framework/deep-dive/schema#selectable-elements Selectable elements section} of
      * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
      */
      isSelectable(item) {
        const def = this.getDefinition(item);
        if (!def) {
          return false;
        }
        return !!(def.isSelectable || def.isObject);
      }
      /**
      * Returns `true` if the given item is defined to be
      * a content by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isContent` property.
      *
      * ```ts
      * schema.isContent( 'paragraph' ); // -> false
      * schema.isContent( 'heading1' ); // -> false
      * schema.isContent( 'imageBlock' ); // -> true
      * schema.isContent( 'horizontalLine' ); // -> true
      *
      * const text = writer.createText( 'foo' );
      * schema.isContent( text ); // -> true
      * ```
      *
      * See the {@glink framework/deep-dive/schema#content-elements Content elements section} of
      * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
      */
      isContent(item) {
        const def = this.getDefinition(item);
        if (!def) {
          return false;
        }
        return !!(def.isContent || def.isObject);
      }
      /**
      * Checks whether the given node can be a child of the given context.
      *
      * ```ts
      * schema.checkChild( model.document.getRoot(), paragraph ); // -> false
      *
      * schema.register( 'paragraph', {
      * 	allowIn: '$root'
      * } );
      *
      * schema.checkChild( model.document.getRoot(), paragraph ); // -> true
      * ```
      *
      * Both {@link module:engine/model/schema~Schema#addChildCheck callback checks} and declarative rules (added when
      * {@link module:engine/model/schema~Schema#register registering} and {@link module:engine/model/schema~Schema#extend extending} items)
      * are evaluated when this method is called.
      *
      * Note that callback checks have bigger priority than declarative rules checks and may overwrite them.
      *
      * Note that when verifying whether the given node can be a child of the given context, the schema also verifies the entire
      * context &ndash; from its root to its last element. Therefore, it is possible for `checkChild()` to return `false` even though
      * the `context` last element can contain the checked child. It happens if one of the `context` elements does not allow its child.
      * When `context` is verified, {@link module:engine/model/schema~Schema#addChildCheck custom checks} are considered as well.
      *
      * @fires checkChild
      * @param context The context in which the child will be checked.
      * @param def The child to check.
      */
      checkChild(context, def) {
        if (!def) {
          return false;
        }
        return this._checkContextMatch(context, def);
      }
      /**
      * Checks whether the given attribute can be applied in the given context (on the last item of the context).
      *
      * ```ts
      * schema.checkAttribute( textNode, 'bold' ); // -> false
      *
      * schema.extend( '$text', {
      * 	allowAttributes: 'bold'
      * } );
      *
      * schema.checkAttribute( textNode, 'bold' ); // -> true
      * ```
      *
      * Both {@link module:engine/model/schema~Schema#addAttributeCheck callback checks} and declarative rules (added when
      * {@link module:engine/model/schema~Schema#register registering} and {@link module:engine/model/schema~Schema#extend extending} items)
      * are evaluated when this method is called.
      *
      * Note that callback checks have bigger priority than declarative rules checks and may overwrite them.
      *
      * @fires checkAttribute
      * @param context The context in which the attribute will be checked.
      * @param attributeName Name of attribute to check in the given context.
      */
      checkAttribute(context, attributeName) {
        const def = this.getDefinition(context.last);
        if (!def) {
          return false;
        }
        const isAllowed = this._evaluateAttributeChecks(context, attributeName);
        return isAllowed !== void 0 ? isAllowed : def.allowAttributes.includes(attributeName);
      }
      /**
      * Checks whether the given element (`elementToMerge`) can be merged with the specified base element (`positionOrBaseElement`).
      *
      * In other words &ndash; both elements are not a limit elements and whether `elementToMerge`'s children
      * {@link #checkChild are allowed} in the `positionOrBaseElement`.
      *
      * This check ensures that elements merged with {@link module:engine/model/writer~Writer#merge `Writer#merge()`}
      * will be valid.
      *
      * Instead of elements, you can pass the instance of the {@link module:engine/model/position~Position} class as the
      * `positionOrBaseElement`. It means that the elements before and after the position will be checked whether they can be merged.
      *
      * @param positionOrBaseElement The position or base element to which the `elementToMerge` will be merged.
      * @param elementToMerge The element to merge. Required if `positionOrBaseElement` is an element.
      */
      checkMerge(positionOrBaseElement, elementToMerge) {
        if (positionOrBaseElement instanceof Position) {
          const nodeBefore = positionOrBaseElement.nodeBefore;
          const nodeAfter = positionOrBaseElement.nodeAfter;
          if (!(nodeBefore instanceof Element$2)) {
            throw new CKEditorError("schema-check-merge-no-element-before", this);
          }
          if (!(nodeAfter instanceof Element$2)) {
            throw new CKEditorError("schema-check-merge-no-element-after", this);
          }
          return this.checkMerge(nodeBefore, nodeAfter);
        }
        if (this.isLimit(positionOrBaseElement) || this.isLimit(elementToMerge)) {
          return false;
        }
        for (const child of elementToMerge.getChildren()) {
          if (!this.checkChild(positionOrBaseElement, child)) {
            return false;
          }
        }
        return true;
      }
      /**
      * Allows registering a callback to the {@link #checkChild} method calls.
      *
      * Callbacks allow you to implement rules which are not otherwise possible to achieve
      * by using the declarative API of {@link module:engine/model/schema~SchemaItemDefinition}.
      *
      * Note that callback checks have bigger priority than declarative rules checks and may overwrite them.
      *
      * For example, by using this method you can disallow elements in specific contexts:
      *
      * ```ts
      * // Disallow `heading1` inside a `blockQuote` that is inside a table.
      * schema.addChildCheck( ( context, childDefinition ) => {
      * 	if ( context.endsWith( 'tableCell blockQuote' ) ) {
      * 		return false;
      * 	}
      * }, 'heading1' );
      * ```
      *
      * You can skip the optional `itemName` parameter to evaluate the callback for every `checkChild()` call.
      *
      * ```ts
      * // Inside specific custom element, allow only children, which allows for a specific attribute.
      * schema.addChildCheck( ( context, childDefinition ) => {
      * 	if ( context.endsWith( 'myElement' ) ) {
      * 		return childDefinition.allowAttributes.includes( 'myAttribute' );
      * 	}
      * } );
      * ```
      *
      * Please note that the generic callbacks may affect the editor performance and should be avoided if possible.
      *
      * When one of the callbacks makes a decision (returns `true` or `false`) the processing is finished and other callbacks are not fired.
      * Callbacks are fired in the order they were added, however generic callbacks are fired before callbacks added for a specified item.
      *
      * You can also use `checkChild` event, if you need even better control. The result from the example above could also be
      * achieved with following event callback:
      *
      * ```ts
      * schema.on( 'checkChild', ( evt, args ) => {
      * 	const context = args[ 0 ];
      * 	const childDefinition = args[ 1 ];
      *
      * 	if ( context.endsWith( 'myElement' ) ) {
      * 		// Prevent next listeners from being called.
      * 		evt.stop();
      * 		// Set the `checkChild()` return value.
      * 		evt.return = childDefinition.allowAttributes.includes( 'myAttribute' );
      * 	}
      * }, { priority: 'high' } );
      * ```
      *
      * Note that the callback checks and declarative rules checks are processed on `normal` priority.
      *
      * Adding callbacks this way can also negatively impact editor performance.
      *
      * @param callback The callback to be called. It is called with two parameters:
      * {@link module:engine/model/schema~SchemaContext} (context) instance and
      * {@link module:engine/model/schema~SchemaCompiledItemDefinition} (definition). The callback may return `true/false` to override
      * `checkChild()`'s return value. If it does not return a boolean value, the default algorithm (or other callbacks) will define
      * `checkChild()`'s return value.
      * @param itemName Name of the schema item for which the callback is registered. If specified, the callback will be run only for
      * `checkChild()` calls which `def` parameter matches the `itemName`. Otherwise, the callback will run for every `checkChild` call.
      */
      addChildCheck(callback, itemName) {
        const key = itemName !== void 0 ? itemName : this._genericCheckSymbol;
        const checks = this._customChildChecks.get(key) || [];
        checks.push(callback);
        this._customChildChecks.set(key, checks);
      }
      /**
      * Allows registering a callback to the {@link #checkAttribute} method calls.
      *
      * Callbacks allow you to implement rules which are not otherwise possible to achieve
      * by using the declarative API of {@link module:engine/model/schema~SchemaItemDefinition}.
      *
      * Note that callback checks have bigger priority than declarative rules checks and may overwrite them.
      *
      * For example, by using this method you can disallow setting attributes on nodes in specific contexts:
      *
      * ```ts
      * // Disallow setting `bold` on text inside `heading1` element:
      * schema.addAttributeCheck( context => {
      * 	if ( context.endsWith( 'heading1 $text' ) ) {
      * 		return false;
      * 	}
      * }, 'bold' );
      * ```
      *
      * You can skip the optional `attributeName` parameter to evaluate the callback for every `checkAttribute()` call.
      *
      * ```ts
      * // Disallow formatting attributes on text inside custom `myTitle` element:
      * schema.addAttributeCheck( ( context, attributeName ) => {
      * 	if ( context.endsWith( 'myTitle $text' ) && schema.getAttributeProperties( attributeName ).isFormatting ) {
      * 		return false;
      * 	}
      * } );
      * ```
      *
      * Please note that the generic callbacks may affect the editor performance and should be avoided if possible.
      *
      * When one of the callbacks makes a decision (returns `true` or `false`) the processing is finished and other callbacks are not fired.
      * Callbacks are fired in the order they were added, however generic callbacks are fired before callbacks added for a specified item.
      *
      * You can also use {@link #event:checkAttribute} event, if you need even better control. The result from the example above could also
      * be achieved with following event callback:
      *
      * ```ts
      * schema.on( 'checkAttribute', ( evt, args ) => {
      * 	const context = args[ 0 ];
      * 	const attributeName = args[ 1 ];
      *
      * 	if ( context.endsWith( 'myTitle $text' ) && schema.getAttributeProperties( attributeName ).isFormatting ) {
      * 		// Prevent next listeners from being called.
      * 		evt.stop();
      * 		// Set the `checkAttribute()` return value.
      * 		evt.return = false;
      * 	}
      * }, { priority: 'high' } );
      * ```
      *
      * Note that the callback checks and declarative rules checks are processed on `normal` priority.
      *
      * Adding callbacks this way can also negatively impact editor performance.
      *
      * @param callback The callback to be called. It is called with two parameters:
      * {@link module:engine/model/schema~SchemaContext `context`} and attribute name. The callback may return `true` or `false`, to
      * override `checkAttribute()`'s return value. If it does not return a boolean value, the default algorithm (or other callbacks)
      * will define `checkAttribute()`'s return value.
      * @param attributeName Name of the attribute for which the callback is registered. If specified, the callback will be run only for
      * `checkAttribute()` calls with matching `attributeName`. Otherwise, the callback will run for every `checkAttribute()` call.
      */
      addAttributeCheck(callback, attributeName) {
        const key = attributeName !== void 0 ? attributeName : this._genericCheckSymbol;
        const checks = this._customAttributeChecks.get(key) || [];
        checks.push(callback);
        this._customAttributeChecks.set(key, checks);
      }
      /**
      * This method allows assigning additional metadata to the model attributes. For example,
      * {@link module:engine/model/schema~AttributeProperties `AttributeProperties#isFormatting` property} is
      * used to mark formatting attributes (like `bold` or `italic`).
      *
      * ```ts
      * // Mark bold as a formatting attribute.
      * schema.setAttributeProperties( 'bold', {
      * 	isFormatting: true
      * } );
      *
      * // Override code not to be considered a formatting markup.
      * schema.setAttributeProperties( 'code', {
      * 	isFormatting: false
      * } );
      * ```
      *
      * Properties are not limited to members defined in the
      * {@link module:engine/model/schema~AttributeProperties `AttributeProperties` type} and you can also use custom properties:
      *
      * ```ts
      * schema.setAttributeProperties( 'blockQuote', {
      * 	customProperty: 'value'
      * } );
      * ```
      *
      * Subsequent calls with the same attribute will extend its custom properties:
      *
      * ```ts
      * schema.setAttributeProperties( 'blockQuote', {
      * 	one: 1
      * } );
      *
      * schema.setAttributeProperties( 'blockQuote', {
      * 	two: 2
      * } );
      *
      * console.log( schema.getAttributeProperties( 'blockQuote' ) );
      * // Logs: { one: 1, two: 2 }
      * ```
      *
      * @param attributeName A name of the attribute to receive the properties.
      * @param properties A dictionary of properties.
      */
      setAttributeProperties(attributeName, properties) {
        this._attributeProperties[attributeName] = Object.assign(this.getAttributeProperties(attributeName), properties);
      }
      /**
      * Returns properties associated with a given model attribute. See {@link #setAttributeProperties `setAttributeProperties()`}.
      *
      * @param attributeName A name of the attribute.
      */
      getAttributeProperties(attributeName) {
        return this._attributeProperties[attributeName] || /* @__PURE__ */ Object.create(null);
      }
      /**
      * Returns the lowest {@link module:engine/model/schema~Schema#isLimit limit element} containing the entire
      * selection/range/position or the root otherwise.
      *
      * @param selectionOrRangeOrPosition The selection/range/position to check.
      * @returns The lowest limit element containing the entire `selectionOrRangeOrPosition`.
      */
      getLimitElement(selectionOrRangeOrPosition) {
        let element;
        if (selectionOrRangeOrPosition instanceof Position) {
          element = selectionOrRangeOrPosition.parent;
        } else {
          const ranges = selectionOrRangeOrPosition instanceof Range ? [
            selectionOrRangeOrPosition
          ] : Array.from(selectionOrRangeOrPosition.getRanges());
          element = ranges.reduce((element2, range2) => {
            const rangeCommonAncestor = range2.getCommonAncestor();
            if (!element2) {
              return rangeCommonAncestor;
            }
            return element2.getCommonAncestor(rangeCommonAncestor, {
              includeSelf: true
            });
          }, null);
        }
        while (!this.isLimit(element)) {
          if (element.parent) {
            element = element.parent;
          } else {
            break;
          }
        }
        return element;
      }
      /**
      * Checks whether the attribute is allowed in selection:
      *
      * * if the selection is not collapsed, then checks if the attribute is allowed on any of nodes in that range,
      * * if the selection is collapsed, then checks if on the selection position there's a text with the
      * specified attribute allowed.
      *
      * @param selection Selection which will be checked.
      * @param attribute The name of the attribute to check.
      */
      checkAttributeInSelection(selection, attribute) {
        if (selection.isCollapsed) {
          const firstPosition = selection.getFirstPosition();
          const context = [
            ...firstPosition.getAncestors(),
            new Text("", selection.getAttributes())
          ];
          return this.checkAttribute(context, attribute);
        } else {
          const ranges = selection.getRanges();
          for (const range2 of ranges) {
            for (const value of range2) {
              if (this.checkAttribute(value.item, attribute)) {
                return true;
              }
            }
          }
        }
        return false;
      }
      /**
      * Transforms the given set of ranges into a set of ranges where the given attribute is allowed (and can be applied).
      *
      * @param ranges Ranges to be validated.
      * @param attribute The name of the attribute to check.
      * @returns Ranges in which the attribute is allowed.
      */
      *getValidRanges(ranges, attribute) {
        ranges = convertToMinimalFlatRanges(ranges);
        for (const range2 of ranges) {
          yield* this._getValidRangesForRange(range2, attribute);
        }
      }
      /**
      * Basing on given `position`, finds and returns a {@link module:engine/model/range~Range range} which is
      * nearest to that `position` and is a correct range for selection.
      *
      * The correct selection range might be collapsed when it is located in a position where the text node can be placed.
      * Non-collapsed range is returned when selection can be placed around element marked as an "object" in
      * the {@link module:engine/model/schema~Schema schema}.
      *
      * Direction of searching for the nearest correct selection range can be specified as:
      *
      * * `both` - searching will be performed in both ways,
      * * `forward` - searching will be performed only forward,
      * * `backward` - searching will be performed only backward.
      *
      * When valid selection range cannot be found, `null` is returned.
      *
      * @param position Reference position where new selection range should be looked for.
      * @param direction Search direction.
      * @returns Nearest selection range or `null` if one cannot be found.
      */
      getNearestSelectionRange(position, direction = "both") {
        if (position.root.rootName == "$graveyard") {
          return null;
        }
        if (this.checkChild(position, "$text")) {
          return new Range(position);
        }
        let backwardWalker, forwardWalker;
        const limitElement = position.getAncestors().reverse().find((item) => this.isLimit(item)) || position.root;
        if (direction == "both" || direction == "backward") {
          backwardWalker = new TreeWalker({
            boundaries: Range._createIn(limitElement),
            startPosition: position,
            direction: "backward"
          });
        }
        if (direction == "both" || direction == "forward") {
          forwardWalker = new TreeWalker({
            boundaries: Range._createIn(limitElement),
            startPosition: position
          });
        }
        for (const data of combineWalkers(backwardWalker, forwardWalker)) {
          const type = data.walker == backwardWalker ? "elementEnd" : "elementStart";
          const value = data.value;
          if (value.type == type && this.isObject(value.item)) {
            return Range._createOn(value.item);
          }
          if (this.checkChild(value.nextPosition, "$text")) {
            return new Range(value.nextPosition);
          }
        }
        return null;
      }
      /**
      * Tries to find position ancestors that allow to insert a given node.
      * It starts searching from the given position and goes node by node to the top of the model tree
      * as long as a {@link module:engine/model/schema~Schema#isLimit limit element}, an
      * {@link module:engine/model/schema~Schema#isObject object element} or a topmost ancestor is not reached.
      *
      * @param position The position that the search will start from.
      * @param node The node for which an allowed parent should be found or its name.
      * @returns Allowed parent or null if nothing was found.
      */
      findAllowedParent(position, node) {
        let parent2 = position.parent;
        while (parent2) {
          if (this.checkChild(parent2, node)) {
            return parent2;
          }
          if (this.isLimit(parent2)) {
            return null;
          }
          parent2 = parent2.parent;
        }
        return null;
      }
      /**
      * Sets attributes allowed by the schema on a given node.
      *
      * @param node A node to set attributes on.
      * @param attributes Attributes keys and values.
      * @param writer An instance of the model writer.
      */
      setAllowedAttributes(node, attributes, writer) {
        const model = writer.model;
        for (const [attributeName, attributeValue] of Object.entries(attributes)) {
          if (model.schema.checkAttribute(node, attributeName)) {
            writer.setAttribute(attributeName, attributeValue, node);
          }
        }
      }
      /**
      * Removes attributes disallowed by the schema.
      *
      * @param nodes Nodes that will be filtered.
      */
      removeDisallowedAttributes(nodes, writer) {
        for (const node of nodes) {
          if (node.is("$text")) {
            removeDisallowedAttributeFromNode(this, node, writer);
          } else {
            const rangeInNode = Range._createIn(node);
            const positionsInRange = rangeInNode.getPositions();
            for (const position of positionsInRange) {
              const item = position.nodeBefore || position.parent;
              removeDisallowedAttributeFromNode(this, item, writer);
            }
          }
        }
      }
      /**
      * Gets attributes of a node that have a given property.
      *
      * @param node Node to get attributes from.
      * @param propertyName Name of the property that attribute must have to return it.
      * @param propertyValue Desired value of the property that we want to check.
      * When `undefined` attributes will be returned if they have set a given property no matter what the value is. If specified it will
      * return attributes which given property's value is equal to this parameter.
      * @returns Object with attributes' names as key and attributes' values as value.
      */
      getAttributesWithProperty(node, propertyName, propertyValue) {
        const attributes = {};
        for (const [attributeName, attributeValue] of node.getAttributes()) {
          const attributeProperties = this.getAttributeProperties(attributeName);
          if (attributeProperties[propertyName] === void 0) {
            continue;
          }
          if (propertyValue === void 0 || propertyValue === attributeProperties[propertyName]) {
            attributes[attributeName] = attributeValue;
          }
        }
        return attributes;
      }
      /**
      * Creates an instance of the schema context.
      */
      createContext(context) {
        return new SchemaContext(context);
      }
      _clearCache() {
        this._compiledDefinitions = null;
      }
      _compile() {
        const definitions = {};
        const sourceRules = this._sourceDefinitions;
        const itemNames = Object.keys(sourceRules);
        for (const itemName of itemNames) {
          definitions[itemName] = compileBaseItemRule(sourceRules[itemName], itemName);
        }
        const items = Object.values(definitions);
        for (const item of items) {
          propagateAllowIn(definitions, item);
          propagateAllowChildren(definitions, item);
          propagateDisallowIn(definitions, item);
          propagateDisallowChildren(definitions, item);
        }
        for (const item of items) {
          resolveDisallows(definitions, item);
        }
        for (const item of items) {
          compileAllowContentOf(definitions, item);
        }
        for (const item of items) {
          compileAllowWhere(definitions, item);
        }
        for (const item of items) {
          compileAllowAttributesOf(definitions, item);
        }
        for (const item of items) {
          compileInheritPropertiesFrom(definitions, item);
        }
        this._compiledDefinitions = compileDefinitions(definitions);
      }
      _checkContextMatch(context, def) {
        const parentItem = context.last;
        let isAllowed = this._evaluateChildChecks(context, def);
        isAllowed = isAllowed !== void 0 ? isAllowed : def.allowIn.includes(parentItem.name);
        if (!isAllowed) {
          return false;
        }
        const parentItemDefinition = this.getDefinition(parentItem);
        const parentContext = context.trimLast();
        if (!parentItemDefinition) {
          return false;
        }
        if (parentContext.length == 0) {
          return true;
        }
        return this._checkContextMatch(parentContext, parentItemDefinition);
      }
      /**
      * Calls child check callbacks to decide whether `def` is allowed in `context`. It uses both generic and specific (defined for `def`
      * item) callbacks. If neither callback makes a decision, `undefined` is returned.
      *
      * Note that the first callback that makes a decision "wins", i.e., if any callback returns `true` or `false`, then the processing
      * is over and that result is returned.
      */
      _evaluateChildChecks(context, def) {
        const genericChecks = this._customChildChecks.get(this._genericCheckSymbol) || [];
        const childChecks = this._customChildChecks.get(def.name) || [];
        for (const check2 of [
          ...genericChecks,
          ...childChecks
        ]) {
          const result2 = check2(context, def);
          if (result2 !== void 0) {
            return result2;
          }
        }
      }
      /**
      * Calls attribute check callbacks to decide whether `attributeName` can be set on the last element of `context`. It uses both
      * generic and specific (defined for `attributeName`) callbacks. If neither callback makes a decision, `undefined` is returned.
      *
      * Note that the first callback that makes a decision "wins", i.e., if any callback returns `true` or `false`, then the processing
      * is over and that result is returned.
      */
      _evaluateAttributeChecks(context, attributeName) {
        const genericChecks = this._customAttributeChecks.get(this._genericCheckSymbol) || [];
        const childChecks = this._customAttributeChecks.get(attributeName) || [];
        for (const check2 of [
          ...genericChecks,
          ...childChecks
        ]) {
          const result2 = check2(context, attributeName);
          if (result2 !== void 0) {
            return result2;
          }
        }
      }
      /**
      * Takes a flat range and an attribute name. Traverses the range recursively and deeply to find and return all ranges
      * inside the given range on which the attribute can be applied.
      *
      * This is a helper function for {@link ~Schema#getValidRanges}.
      *
      * @param range The range to process.
      * @param attribute The name of the attribute to check.
      * @returns Ranges in which the attribute is allowed.
      */
      *_getValidRangesForRange(range2, attribute) {
        let start2 = range2.start;
        let end2 = range2.start;
        for (const item of range2.getItems({
          shallow: true
        })) {
          if (item.is("element")) {
            yield* this._getValidRangesForRange(Range._createIn(item), attribute);
          }
          if (!this.checkAttribute(item, attribute)) {
            if (!start2.isEqual(end2)) {
              yield new Range(start2, end2);
            }
            start2 = Position._createAfter(item);
          }
          end2 = Position._createAfter(item);
        }
        if (!start2.isEqual(end2)) {
          yield new Range(start2, end2);
        }
      }
      /**
      * Returns a model range which is optimal (in terms of UX) for inserting a widget block.
      *
      * For instance, if a selection is in the middle of a paragraph, the collapsed range before this paragraph
      * will be returned so that it is not split. If the selection is at the end of a paragraph,
      * the collapsed range after this paragraph will be returned.
      *
      * Note: If the selection is placed in an empty block, the range in that block will be returned. If that range
      * is then passed to {@link module:engine/model/model~Model#insertContent}, the block will be fully replaced
      * by the inserted widget block.
      *
      * @internal
      * @param selection The selection based on which the insertion position should be calculated.
      * @param place The place where to look for optimal insertion range.
      * The `auto` value will determine itself the best position for insertion.
      * The `before` value will try to find a position before selection.
      * The `after` value will try to find a position after selection.
      * @returns The optimal range.
      */
      findOptimalInsertionRange(selection, place) {
        const selectedElement = selection.getSelectedElement();
        if (selectedElement && this.isObject(selectedElement) && !this.isInline(selectedElement)) {
          if (place == "before" || place == "after") {
            return new Range(Position._createAt(selectedElement, place));
          }
          return Range._createOn(selectedElement);
        }
        const firstBlock = first(selection.getSelectedBlocks());
        if (!firstBlock) {
          return new Range(selection.focus);
        }
        if (firstBlock.isEmpty) {
          return new Range(Position._createAt(firstBlock, 0));
        }
        const positionAfter = Position._createAfter(firstBlock);
        if (selection.focus.isTouching(positionAfter)) {
          return new Range(positionAfter);
        }
        return new Range(Position._createBefore(firstBlock));
      }
    }
    class SchemaContext {
      /**
      * Creates an instance of the context.
      */
      constructor(context) {
        __publicField(this, "_items");
        if (context instanceof SchemaContext) {
          return context;
        }
        let items;
        if (typeof context == "string") {
          items = [
            context
          ];
        } else if (!Array.isArray(context)) {
          items = context.getAncestors({
            includeSelf: true
          });
        } else {
          items = context;
        }
        this._items = items.map(mapContextItem);
      }
      /**
      * The number of items.
      */
      get length() {
        return this._items.length;
      }
      /**
      * The last item (the lowest node).
      */
      get last() {
        return this._items[this._items.length - 1];
      }
      /**
      * Iterable interface.
      *
      * Iterates over all context items.
      */
      [Symbol.iterator]() {
        return this._items[Symbol.iterator]();
      }
      /**
      * Returns a new schema context instance with an additional item.
      *
      * Item can be added as:
      *
      * ```ts
      * const context = new SchemaContext( [ '$root' ] );
      *
      * // An element.
      * const fooElement = writer.createElement( 'fooElement' );
      * const newContext = context.push( fooElement ); // [ '$root', 'fooElement' ]
      *
      * // A text node.
      * const text = writer.createText( 'foobar' );
      * const newContext = context.push( text ); // [ '$root', '$text' ]
      *
      * // A string (element name).
      * const newContext = context.push( 'barElement' ); // [ '$root', 'barElement' ]
      * ```
      *
      * **Note** {@link module:engine/model/node~Node} that is already in the model tree will be added as the only item
      * (without ancestors).
      *
      * @param item An item that will be added to the current context.
      * @returns A new schema context instance with an additional item.
      */
      push(item) {
        const ctx = new SchemaContext([
          item
        ]);
        ctx._items = [
          ...this._items,
          ...ctx._items
        ];
        return ctx;
      }
      /**
      * Returns a new schema context that is based on this context but has the last item removed.
      *
      * ```ts
      * const ctxParagraph = new SchemaContext( [ '$root', 'blockQuote', 'paragraph' ] );
      * const ctxBlockQuote = ctxParagraph.trimLast(); // Items in `ctxBlockQuote` are: `$root` an `blockQuote`.
      * const ctxRoot = ctxBlockQuote.trimLast(); // Items in `ctxRoot` are: `$root`.
      * ```
      *
      * @returns A new reduced schema context instance.
      */
      trimLast() {
        const ctx = new SchemaContext([]);
        ctx._items = this._items.slice(0, -1);
        return ctx;
      }
      /**
      * Gets an item on the given index.
      */
      getItem(index) {
        return this._items[index];
      }
      /**
      * Returns the names of items.
      */
      *getNames() {
        yield* this._items.map((item) => item.name);
      }
      /**
      * Checks whether the context ends with the given nodes.
      *
      * ```ts
      * const ctx = new SchemaContext( [ rootElement, paragraphElement, textNode ] );
      *
      * ctx.endsWith( '$text' ); // -> true
      * ctx.endsWith( 'paragraph $text' ); // -> true
      * ctx.endsWith( '$root' ); // -> false
      * ctx.endsWith( 'paragraph' ); // -> false
      * ```
      */
      endsWith(query) {
        return Array.from(this.getNames()).join(" ").endsWith(query);
      }
      /**
      * Checks whether the context starts with the given nodes.
      *
      * ```ts
      * const ctx = new SchemaContext( [ rootElement, paragraphElement, textNode ] );
      *
      * ctx.endsWith( '$root' ); // -> true
      * ctx.endsWith( '$root paragraph' ); // -> true
      * ctx.endsWith( '$text' ); // -> false
      * ctx.endsWith( 'paragraph' ); // -> false
      * ```
      */
      startsWith(query) {
        return Array.from(this.getNames()).join(" ").startsWith(query);
      }
    }
    function compileBaseItemRule(sourceItemRules, itemName) {
      const itemRule = {
        name: itemName,
        allowIn: /* @__PURE__ */ new Set(),
        allowChildren: /* @__PURE__ */ new Set(),
        disallowIn: /* @__PURE__ */ new Set(),
        disallowChildren: /* @__PURE__ */ new Set(),
        allowContentOf: /* @__PURE__ */ new Set(),
        allowWhere: /* @__PURE__ */ new Set(),
        allowAttributes: /* @__PURE__ */ new Set(),
        disallowAttributes: /* @__PURE__ */ new Set(),
        allowAttributesOf: /* @__PURE__ */ new Set(),
        inheritTypesFrom: /* @__PURE__ */ new Set()
      };
      copyTypes(sourceItemRules, itemRule);
      copyProperty(sourceItemRules, itemRule, "allowIn");
      copyProperty(sourceItemRules, itemRule, "allowChildren");
      copyProperty(sourceItemRules, itemRule, "disallowIn");
      copyProperty(sourceItemRules, itemRule, "disallowChildren");
      copyProperty(sourceItemRules, itemRule, "allowContentOf");
      copyProperty(sourceItemRules, itemRule, "allowWhere");
      copyProperty(sourceItemRules, itemRule, "allowAttributes");
      copyProperty(sourceItemRules, itemRule, "disallowAttributes");
      copyProperty(sourceItemRules, itemRule, "allowAttributesOf");
      copyProperty(sourceItemRules, itemRule, "inheritTypesFrom");
      resolveInheritAll(sourceItemRules, itemRule);
      return itemRule;
    }
    function propagateAllowIn(definitions, item) {
      for (const parentName of item.allowIn) {
        const parentItem = definitions[parentName];
        if (parentItem) {
          parentItem.allowChildren.add(item.name);
        } else {
          item.allowIn.delete(parentName);
        }
      }
    }
    function propagateAllowChildren(definitions, item) {
      for (const childName of item.allowChildren) {
        const childItem = definitions[childName];
        if (childItem) {
          childItem.allowIn.add(item.name);
        } else {
          item.allowChildren.delete(childName);
        }
      }
    }
    function propagateDisallowIn(definitions, item) {
      for (const parentName of item.disallowIn) {
        const parentItem = definitions[parentName];
        if (parentItem) {
          parentItem.disallowChildren.add(item.name);
        } else {
          item.disallowIn.delete(parentName);
        }
      }
    }
    function propagateDisallowChildren(definitions, item) {
      for (const childName of item.disallowChildren) {
        const childItem = definitions[childName];
        if (childItem) {
          childItem.disallowIn.add(item.name);
        } else {
          item.disallowChildren.delete(childName);
        }
      }
    }
    function resolveDisallows(definitions, item) {
      for (const childName of item.disallowChildren) {
        item.allowChildren.delete(childName);
      }
      for (const parentName of item.disallowIn) {
        item.allowIn.delete(parentName);
      }
      for (const attributeName of item.disallowAttributes) {
        item.allowAttributes.delete(attributeName);
      }
    }
    function compileAllowContentOf(definitions, item) {
      for (const allowContentOfItemName of item.allowContentOf) {
        const baseItem = definitions[allowContentOfItemName];
        if (!baseItem) {
          continue;
        }
        baseItem.disallowChildren.forEach((childName) => {
          if (item.allowChildren.has(childName)) {
            return;
          }
          item.disallowChildren.add(childName);
          definitions[childName].disallowIn.add(item.name);
        });
        baseItem.allowChildren.forEach((childName) => {
          if (item.disallowChildren.has(childName)) {
            return;
          }
          item.allowChildren.add(childName);
          definitions[childName].allowIn.add(item.name);
        });
      }
    }
    function compileAllowWhere(definitions, item) {
      for (const allowWhereItemName of item.allowWhere) {
        const baseItem = definitions[allowWhereItemName];
        if (!baseItem) {
          continue;
        }
        baseItem.disallowIn.forEach((parentName) => {
          if (item.allowIn.has(parentName)) {
            return;
          }
          item.disallowIn.add(parentName);
          definitions[parentName].disallowChildren.add(item.name);
        });
        baseItem.allowIn.forEach((parentName) => {
          if (item.disallowIn.has(parentName)) {
            return;
          }
          item.allowIn.add(parentName);
          definitions[parentName].allowChildren.add(item.name);
        });
      }
    }
    function compileDefinitions(definitions) {
      const finalDefinitions = {};
      for (const item of Object.values(definitions)) {
        finalDefinitions[item.name] = {
          name: item.name,
          // `is*` properties may not be set - convert `undefined` to `false`.
          isBlock: !!item.isBlock,
          isContent: !!item.isContent,
          isInline: !!item.isInline,
          isLimit: !!item.isLimit,
          isObject: !!item.isObject,
          isSelectable: !!item.isSelectable,
          // Filter out non-existing items.
          allowIn: Array.from(item.allowIn).filter((name) => !!definitions[name]),
          allowChildren: Array.from(item.allowChildren).filter((name) => !!definitions[name]),
          allowAttributes: Array.from(item.allowAttributes)
        };
      }
      return finalDefinitions;
    }
    function compileAllowAttributesOf(definitions, item) {
      for (const allowAttributeOfItemName of item.allowAttributesOf) {
        const baseItem = definitions[allowAttributeOfItemName];
        if (!baseItem) {
          return;
        }
        baseItem.allowAttributes.forEach((attributeName) => {
          if (item.disallowAttributes.has(attributeName)) {
            return;
          }
          item.allowAttributes.add(attributeName);
        });
      }
    }
    function compileInheritPropertiesFrom(definitions, item) {
      for (const inheritPropertiesOfItemName of item.inheritTypesFrom) {
        const inheritFrom = definitions[inheritPropertiesOfItemName];
        if (inheritFrom) {
          const typeNames = Object.keys(inheritFrom).filter((name) => name.startsWith("is"));
          for (const name of typeNames) {
            if (!(name in item)) {
              item[name] = inheritFrom[name];
            }
          }
        }
      }
    }
    function copyTypes(sourceItemRules, itemRule) {
      for (const sourceItemRule of sourceItemRules) {
        const typeNames = Object.keys(sourceItemRule).filter((name) => name.startsWith("is"));
        for (const name of typeNames) {
          itemRule[name] = !!sourceItemRule[name];
        }
      }
    }
    function copyProperty(sourceItemRules, itemRule, propertyName) {
      for (const sourceItemRule of sourceItemRules) {
        let value = sourceItemRule[propertyName];
        if (typeof value == "string") {
          value = [
            value
          ];
        }
        if (Array.isArray(value)) {
          value.forEach((singleValue) => itemRule[propertyName].add(singleValue));
        }
      }
    }
    function resolveInheritAll(sourceItemRules, itemRule) {
      for (const sourceItemRule of sourceItemRules) {
        const inheritFrom = sourceItemRule.inheritAllFrom;
        if (inheritFrom) {
          itemRule.allowContentOf.add(inheritFrom);
          itemRule.allowWhere.add(inheritFrom);
          itemRule.allowAttributesOf.add(inheritFrom);
          itemRule.inheritTypesFrom.add(inheritFrom);
        }
      }
    }
    function mapContextItem(ctxItem) {
      if (typeof ctxItem == "string" || ctxItem.is("documentFragment")) {
        return {
          name: typeof ctxItem == "string" ? ctxItem : "$documentFragment",
          *getAttributeKeys() {
          },
          getAttribute() {
          }
        };
      } else {
        return {
          // '$text' means text nodes and text proxies.
          name: ctxItem.is("element") ? ctxItem.name : "$text",
          *getAttributeKeys() {
            yield* ctxItem.getAttributeKeys();
          },
          getAttribute(key) {
            return ctxItem.getAttribute(key);
          }
        };
      }
    }
    function* combineWalkers(backward, forward) {
      let done = false;
      while (!done) {
        done = true;
        if (backward) {
          const step = backward.next();
          if (!step.done) {
            done = false;
            yield {
              walker: backward,
              value: step.value
            };
          }
        }
        if (forward) {
          const step = forward.next();
          if (!step.done) {
            done = false;
            yield {
              walker: forward,
              value: step.value
            };
          }
        }
      }
    }
    function* convertToMinimalFlatRanges(ranges) {
      for (const range2 of ranges) {
        yield* range2.getMinimalFlatRanges();
      }
    }
    function removeDisallowedAttributeFromNode(schema, node, writer) {
      for (const attribute of node.getAttributeKeys()) {
        if (!schema.checkAttribute(node, attribute)) {
          writer.removeAttribute(attribute, node);
        }
      }
    }
    class UpcastDispatcher extends (/* @__PURE__ */ EmitterMixin()) {
      /**
      * Creates an upcast dispatcher that operates using the passed API.
      *
      * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi
      * @param conversionApi Additional properties for an interface that will be passed to events fired
      * by the upcast dispatcher.
      */
      constructor(conversionApi) {
        super();
        /**
        * An interface passed by the dispatcher to the event callbacks.
        */
        __publicField(this, "conversionApi");
        /**
        * The list of elements that were created during splitting.
        *
        * After the conversion process, the list is cleared.
        */
        __publicField(this, "_splitParts", /* @__PURE__ */ new Map());
        /**
        * The list of cursor parent elements that were created during splitting.
        *
        * After the conversion process the list is cleared.
        */
        __publicField(this, "_cursorParents", /* @__PURE__ */ new Map());
        /**
        * The position in the temporary structure where the converted content is inserted. The structure reflects the context of
        * the target position where the content will be inserted. This property is built based on the context parameter of the
        * convert method.
        */
        __publicField(this, "_modelCursor", null);
        /**
        * The list of elements that were created during the splitting but should not get removed on conversion end even if they are empty.
        *
        * The list is cleared after the conversion process.
        */
        __publicField(this, "_emptyElementsToKeep", /* @__PURE__ */ new Set());
        this.conversionApi = {
          ...conversionApi,
          consumable: null,
          writer: null,
          store: null,
          convertItem: (viewItem, modelCursor) => this._convertItem(viewItem, modelCursor),
          convertChildren: (viewElement, positionOrElement) => this._convertChildren(viewElement, positionOrElement),
          safeInsert: (modelNode, position) => this._safeInsert(modelNode, position),
          updateConversionResult: (modelElement, data) => this._updateConversionResult(modelElement, data),
          // Advanced API - use only if custom position handling is needed.
          splitToAllowedParent: (modelNode, modelCursor) => this._splitToAllowedParent(modelNode, modelCursor),
          getSplitParts: (modelElement) => this._getSplitParts(modelElement),
          keepEmptyElement: (modelElement) => this._keepEmptyElement(modelElement)
        };
      }
      /**
      * Starts the conversion process. The entry point for the conversion.
      *
      * @fires element
      * @fires text
      * @fires documentFragment
      * @param viewElement The part of the view to be converted.
      * @param writer An instance of the model writer.
      * @param context Elements will be converted according to this context.
      * @returns Model data that is the result of the conversion process
      * wrapped in `DocumentFragment`. Converted marker elements will be set as the document fragment's
      * {@link module:engine/model/documentfragment~DocumentFragment#markers static markers map}.
      */
      convert(viewElement, writer, context = [
        "$root"
      ]) {
        this.fire("viewCleanup", viewElement);
        this._modelCursor = createContextTree(context, writer);
        this.conversionApi.writer = writer;
        this.conversionApi.consumable = ViewConsumable.createFrom(viewElement);
        this.conversionApi.store = {};
        const { modelRange } = this._convertItem(viewElement, this._modelCursor);
        const documentFragment = writer.createDocumentFragment();
        if (modelRange) {
          this._removeEmptyElements();
          for (const item of Array.from(this._modelCursor.parent.getChildren())) {
            writer.append(item, documentFragment);
          }
          documentFragment.markers = extractMarkersFromModelFragment(documentFragment, writer);
        }
        this._modelCursor = null;
        this._splitParts.clear();
        this._cursorParents.clear();
        this._emptyElementsToKeep.clear();
        this.conversionApi.writer = null;
        this.conversionApi.store = null;
        return documentFragment;
      }
      /**
      * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#convertItem
      */
      _convertItem(viewItem, modelCursor) {
        const data = {
          viewItem,
          modelCursor,
          modelRange: null
        };
        if (viewItem.is("element")) {
          this.fire(`element:${viewItem.name}`, data, this.conversionApi);
        } else if (viewItem.is("$text")) {
          this.fire("text", data, this.conversionApi);
        } else {
          this.fire("documentFragment", data, this.conversionApi);
        }
        if (data.modelRange && !(data.modelRange instanceof Range)) {
          throw new CKEditorError("view-conversion-dispatcher-incorrect-result", this);
        }
        return {
          modelRange: data.modelRange,
          modelCursor: data.modelCursor
        };
      }
      /**
      * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#convertChildren
      */
      _convertChildren(viewItem, elementOrModelCursor) {
        let nextModelCursor = elementOrModelCursor.is("position") ? elementOrModelCursor : Position._createAt(elementOrModelCursor, 0);
        const modelRange = new Range(nextModelCursor);
        for (const viewChild of Array.from(viewItem.getChildren())) {
          const result2 = this._convertItem(viewChild, nextModelCursor);
          if (result2.modelRange instanceof Range) {
            modelRange.end = result2.modelRange.end;
            nextModelCursor = result2.modelCursor;
          }
        }
        return {
          modelRange,
          modelCursor: nextModelCursor
        };
      }
      /**
      * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#safeInsert
      */
      _safeInsert(modelNode, position) {
        const splitResult = this._splitToAllowedParent(modelNode, position);
        if (!splitResult) {
          return false;
        }
        this.conversionApi.writer.insert(modelNode, splitResult.position);
        return true;
      }
      /**
      * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#updateConversionResult
      */
      _updateConversionResult(modelElement, data) {
        const parts = this._getSplitParts(modelElement);
        const writer = this.conversionApi.writer;
        if (!data.modelRange) {
          data.modelRange = writer.createRange(writer.createPositionBefore(modelElement), writer.createPositionAfter(parts[parts.length - 1]));
        }
        const savedCursorParent = this._cursorParents.get(modelElement);
        if (savedCursorParent) {
          data.modelCursor = writer.createPositionAt(savedCursorParent, 0);
        } else {
          data.modelCursor = data.modelRange.end;
        }
      }
      /**
      * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#splitToAllowedParent
      */
      _splitToAllowedParent(node, modelCursor) {
        const { schema, writer } = this.conversionApi;
        let allowedParent = schema.findAllowedParent(modelCursor, node);
        if (allowedParent) {
          if (allowedParent === modelCursor.parent) {
            return {
              position: modelCursor
            };
          }
          if (this._modelCursor.parent.getAncestors().includes(allowedParent)) {
            allowedParent = null;
          }
        }
        if (!allowedParent) {
          if (!isParagraphable(modelCursor, node, schema)) {
            return null;
          }
          return {
            position: wrapInParagraph(modelCursor, writer)
          };
        }
        const splitResult = this.conversionApi.writer.split(modelCursor, allowedParent);
        const stack = [];
        for (const treeWalkerValue of splitResult.range.getWalker()) {
          if (treeWalkerValue.type == "elementEnd") {
            stack.push(treeWalkerValue.item);
          } else {
            const originalPart = stack.pop();
            const splitPart = treeWalkerValue.item;
            this._registerSplitPair(originalPart, splitPart);
          }
        }
        const cursorParent = splitResult.range.end.parent;
        this._cursorParents.set(node, cursorParent);
        return {
          position: splitResult.position,
          cursorParent
        };
      }
      /**
      * Registers that a `splitPart` element is a split part of the `originalPart` element.
      *
      * The data set by this method is used by {@link #_getSplitParts} and {@link #_removeEmptyElements}.
      */
      _registerSplitPair(originalPart, splitPart) {
        if (!this._splitParts.has(originalPart)) {
          this._splitParts.set(originalPart, [
            originalPart
          ]);
        }
        const list = this._splitParts.get(originalPart);
        this._splitParts.set(splitPart, list);
        list.push(splitPart);
      }
      /**
      * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#getSplitParts
      */
      _getSplitParts(element) {
        let parts;
        if (!this._splitParts.has(element)) {
          parts = [
            element
          ];
        } else {
          parts = this._splitParts.get(element);
        }
        return parts;
      }
      /**
      * Mark an element that were created during the splitting to not get removed on conversion end even if it is empty.
      */
      _keepEmptyElement(element) {
        this._emptyElementsToKeep.add(element);
      }
      /**
      * Checks if there are any empty elements created while splitting and removes them.
      *
      * This method works recursively to re-check empty elements again after at least one element was removed in the initial call,
      * as some elements might have become empty after other empty elements were removed from them.
      */
      _removeEmptyElements() {
        let anyRemoved = false;
        for (const element of this._splitParts.keys()) {
          if (element.isEmpty && !this._emptyElementsToKeep.has(element)) {
            this.conversionApi.writer.remove(element);
            this._splitParts.delete(element);
            anyRemoved = true;
          }
        }
        if (anyRemoved) {
          this._removeEmptyElements();
        }
      }
    }
    function extractMarkersFromModelFragment(modelItem, writer) {
      const markerElements = /* @__PURE__ */ new Set();
      const markers = /* @__PURE__ */ new Map();
      const range2 = Range._createIn(modelItem).getItems();
      for (const item of range2) {
        if (item.is("element", "$marker")) {
          markerElements.add(item);
        }
      }
      for (const markerElement of markerElements) {
        const markerName = markerElement.getAttribute("data-name");
        const currentPosition = writer.createPositionBefore(markerElement);
        if (!markers.has(markerName)) {
          markers.set(markerName, new Range(currentPosition.clone()));
        } else {
          markers.get(markerName).end = currentPosition.clone();
        }
        writer.remove(markerElement);
      }
      return markers;
    }
    function createContextTree(contextDefinition, writer) {
      let position;
      for (const item of new SchemaContext(contextDefinition)) {
        const attributes = {};
        for (const key of item.getAttributeKeys()) {
          attributes[key] = item.getAttribute(key);
        }
        const current = writer.createElement(item.name, attributes);
        if (position) {
          writer.insert(current, position);
        }
        position = Position._createAt(current, 0);
      }
      return position;
    }
    class BasicHtmlWriter {
      /**
      * Returns an HTML string created from the document fragment.
      */
      getHtml(fragment) {
        const doc = global$1.document.implementation.createHTMLDocument("");
        const container2 = doc.createElement("div");
        container2.appendChild(fragment);
        return container2.innerHTML;
      }
    }
    class HtmlDataProcessor {
      /**
      * Creates a new instance of the HTML data processor class.
      *
      * @param document The view document instance.
      */
      constructor(document2) {
        /**
        * A DOM parser instance used to parse an HTML string to an HTML document.
        */
        __publicField(this, "domParser");
        /**
        * A DOM converter used to convert DOM elements to view elements.
        */
        __publicField(this, "domConverter");
        /**
        * A basic HTML writer instance used to convert DOM elements to an HTML string.
        */
        __publicField(this, "htmlWriter");
        __publicField(this, "skipComments", true);
        this.domParser = new DOMParser();
        this.domConverter = new DomConverter(document2, {
          renderingMode: "data"
        });
        this.htmlWriter = new BasicHtmlWriter();
      }
      /**
      * Converts a provided {@link module:engine/view/documentfragment~DocumentFragment document fragment}
      * to data format &ndash; in this case to an HTML string.
      *
      * @returns HTML string.
      */
      toData(viewFragment) {
        const domFragment = this.domConverter.viewToDom(viewFragment);
        return this.htmlWriter.getHtml(domFragment);
      }
      /**
      * Converts the provided HTML string to a view tree.
      *
      * @param data An HTML string.
      * @returns A converted view element.
      */
      toView(data) {
        const domFragment = this._toDom(data);
        return this.domConverter.domToView(domFragment, {
          skipComments: this.skipComments
        });
      }
      /**
      * Registers a {@link module:engine/view/matcher~MatcherPattern} for view elements whose content should be treated as raw data
      * and not processed during the conversion from the DOM to the view elements.
      *
      * The raw data can be later accessed by a
      * {@link module:engine/view/element~Element#getCustomProperty custom property of a view element} called `"$rawContent"`.
      *
      * @param pattern Pattern matching all view elements whose content should be treated as raw data.
      */
      registerRawContentMatcher(pattern) {
        this.domConverter.registerRawContentMatcher(pattern);
      }
      /**
      * If the processor is set to use marked fillers, it will insert `&nbsp;` fillers wrapped in `<span>` elements
      * (`<span data-cke-filler="true">&nbsp;</span>`) instead of regular `&nbsp;` characters.
      *
      * This mode allows for a more precise handling of the block fillers (so they do not leak into the editor content) but
      * bloats the editor data with additional markup.
      *
      * This mode may be required by some features and will be turned on by them automatically.
      *
      * @param type Whether to use the default or the marked `&nbsp;` block fillers.
      */
      useFillerType(type) {
        this.domConverter.blockFillerMode = type == "marked" ? "markedNbsp" : "nbsp";
      }
      /**
      * Converts an HTML string to its DOM representation. Returns a document fragment containing nodes parsed from
      * the provided data.
      */
      _toDom(data) {
        if (!/<(?:html|body|head|meta)(?:\s[^>]*)?>/i.test(data.trim().slice(0, 1e4))) {
          data = `<body>${data}</body>`;
        }
        const document2 = this.domParser.parseFromString(data, "text/html");
        const fragment = document2.createDocumentFragment();
        const bodyChildNodes = document2.body.childNodes;
        while (bodyChildNodes.length > 0) {
          fragment.appendChild(bodyChildNodes[0]);
        }
        return fragment;
      }
    }
    class DataController extends (/* @__PURE__ */ EmitterMixin()) {
      /**
      * Creates a data controller instance.
      *
      * @param model Data model.
      * @param stylesProcessor The styles processor instance.
      */
      constructor(model, stylesProcessor) {
        super();
        /**
        * Data model.
        */
        __publicField(this, "model");
        /**
        * Mapper used for the conversion. It has no permanent bindings, because these are created while getting data and
        * are cleared directly after the data are converted. However, the mapper is defined as a class property, because
        * it needs to be passed to the `DowncastDispatcher` as a conversion API.
        */
        __publicField(this, "mapper");
        /**
        * Downcast dispatcher used by the {@link #get get method}. Downcast converters should be attached to it.
        */
        __publicField(this, "downcastDispatcher");
        /**
        * Upcast dispatcher used by the {@link #set set method}. Upcast converters should be attached to it.
        */
        __publicField(this, "upcastDispatcher");
        /**
        * The view document used by the data controller.
        */
        __publicField(this, "viewDocument");
        /**
        * Styles processor used during the conversion.
        */
        __publicField(this, "stylesProcessor");
        /**
        * Data processor used specifically for HTML conversion.
        */
        __publicField(this, "htmlProcessor");
        /**
        * Data processor used during the conversion.
        * Same instance as {@link #htmlProcessor} by default. Can be replaced at run time to handle different format, e.g. XML or Markdown.
        */
        __publicField(this, "processor");
        /**
        * The view downcast writer just for data conversion purposes, i.e. to modify
        * the {@link #viewDocument}.
        */
        __publicField(this, "_viewWriter");
        this.model = model;
        this.mapper = new Mapper();
        this.downcastDispatcher = new DowncastDispatcher({
          mapper: this.mapper,
          schema: model.schema
        });
        this.downcastDispatcher.on("insert:$text", insertText(), {
          priority: "lowest"
        });
        this.downcastDispatcher.on("insert", insertAttributesAndChildren(), {
          priority: "lowest"
        });
        this.upcastDispatcher = new UpcastDispatcher({
          schema: model.schema
        });
        this.viewDocument = new Document$1(stylesProcessor);
        this.stylesProcessor = stylesProcessor;
        this.htmlProcessor = new HtmlDataProcessor(this.viewDocument);
        this.processor = this.htmlProcessor;
        this._viewWriter = new DowncastWriter(this.viewDocument);
        this.upcastDispatcher.on("text", convertText(), {
          priority: "lowest"
        });
        this.upcastDispatcher.on("element", convertToModelFragment$1(), {
          priority: "lowest"
        });
        this.upcastDispatcher.on("documentFragment", convertToModelFragment$1(), {
          priority: "lowest"
        });
        ObservableMixin().prototype.decorate.call(this, "init");
        ObservableMixin().prototype.decorate.call(this, "set");
        ObservableMixin().prototype.decorate.call(this, "get");
        ObservableMixin().prototype.decorate.call(this, "toView");
        ObservableMixin().prototype.decorate.call(this, "toModel");
        this.on("init", () => {
          this.fire("ready");
        }, {
          priority: "lowest"
        });
        this.on("ready", () => {
          this.model.enqueueChange({
            isUndoable: false
          }, autoParagraphEmptyRoots);
        }, {
          priority: "lowest"
        });
      }
      /**
      * Returns the model's data converted by downcast dispatchers attached to {@link #downcastDispatcher} and
      * formatted by the {@link #processor data processor}.
      *
      * A warning is logged when you try to retrieve data for a detached root, as most probably this is a mistake. A detached root should
      * be treated like it is removed, and you should not save its data. Note, that the detached root data is always an empty string.
      *
      * @fires get
      * @param options Additional configuration for the retrieved data. `DataController` provides two optional
      * properties: `rootName` and `trim`. Other properties of this object are specified by various editor features.
      * @param options.rootName Root name. Default 'main'.
      * @param options.trim Whether returned data should be trimmed. This option is set to `empty` by default,
      * which means whenever editor content is considered empty, an empty string will be returned. To turn off trimming completely
      * use `'none'`. In such cases the exact content will be returned (for example a `<p>&nbsp;</p>` for an empty editor).
      * @returns Output data.
      */
      get(options = {}) {
        const { rootName = "main", trim: trim2 = "empty" } = options;
        if (!this._checkIfRootsExists([
          rootName
        ])) {
          throw new CKEditorError("datacontroller-get-non-existent-root", this);
        }
        const root2 = this.model.document.getRoot(rootName);
        if (!root2.isAttached()) {
          logWarning("datacontroller-get-detached-root", this);
        }
        if (trim2 === "empty" && !this.model.hasContent(root2, {
          ignoreWhitespaces: true
        })) {
          return "";
        }
        return this.stringify(root2, options);
      }
      /**
      * Returns the content of the given {@link module:engine/model/element~Element model's element} or
      * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the downcast converters
      * attached to the {@link #downcastDispatcher} and formatted by the {@link #processor data processor}.
      *
      * @param modelElementOrFragment The element whose content will be stringified.
      * @param options Additional configuration passed to the conversion process.
      * @returns Output data.
      */
      stringify(modelElementOrFragment, options = {}) {
        const viewDocumentFragment = this.toView(modelElementOrFragment, options);
        return this.processor.toData(viewDocumentFragment);
      }
      /**
      * Returns the content of the given {@link module:engine/model/element~Element model element} or
      * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the downcast
      * converters attached to {@link #downcastDispatcher} into a
      * {@link module:engine/view/documentfragment~DocumentFragment view document fragment}.
      *
      * @fires toView
      * @param modelElementOrFragment Element or document fragment whose content will be converted.
      * @param options Additional configuration that will be available through the
      * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi#options} during the conversion process.
      * @returns Output view DocumentFragment.
      */
      toView(modelElementOrFragment, options = {}) {
        const viewDocument = this.viewDocument;
        const viewWriter = this._viewWriter;
        this.mapper.clearBindings();
        const modelRange = Range._createIn(modelElementOrFragment);
        const viewDocumentFragment = new DocumentFragment$1(viewDocument);
        this.mapper.bindElements(modelElementOrFragment, viewDocumentFragment);
        const markers = modelElementOrFragment.is("documentFragment") ? modelElementOrFragment.markers : _getMarkersRelativeToElement(modelElementOrFragment);
        this.downcastDispatcher.convert(modelRange, markers, viewWriter, options);
        return viewDocumentFragment;
      }
      /**
      * Sets the initial input data parsed by the {@link #processor data processor} and
      * converted by the {@link #upcastDispatcher view-to-model converters}.
      * Initial data can be only set to a document whose {@link module:engine/model/document~Document#version} is equal 0.
      *
      * **Note** This method is {@link module:utils/observablemixin~Observable#decorate decorated} which is
      * used by e.g. collaborative editing plugin that syncs remote data on init.
      *
      * When data is passed as a string, it is initialized on the default `main` root:
      *
      * ```ts
      * dataController.init( '<p>Foo</p>' ); // Initializes data on the `main` root only, as no other is specified.
      * ```
      *
      * To initialize data on a different root or multiple roots at once, an object containing `rootName` - `data` pairs should be passed:
      *
      * ```ts
      * dataController.init( { main: '<p>Foo</p>', title: '<h1>Bar</h1>' } ); // Initializes data on both the `main` and `title` roots.
      * ```
      *
      * @fires init
      * @param data Input data as a string or an object containing the `rootName` - `data`
      * pairs to initialize data on multiple roots at once.
      * @returns Promise that is resolved after the data is set on the editor.
      */
      init(data) {
        if (this.model.document.version) {
          throw new CKEditorError("datacontroller-init-document-not-empty", this);
        }
        let initialData = {};
        if (typeof data === "string") {
          initialData.main = data;
        } else {
          initialData = data;
        }
        if (!this._checkIfRootsExists(Object.keys(initialData))) {
          throw new CKEditorError("datacontroller-init-non-existent-root", this);
        }
        this.model.enqueueChange({
          isUndoable: false
        }, (writer) => {
          for (const rootName of Object.keys(initialData)) {
            const modelRoot = this.model.document.getRoot(rootName);
            writer.insert(this.parse(initialData[rootName], modelRoot), modelRoot, 0);
          }
        });
        return Promise.resolve();
      }
      /**
      * Sets the input data parsed by the {@link #processor data processor} and
      * converted by the {@link #upcastDispatcher view-to-model converters}.
      * This method can be used any time to replace existing editor data with the new one without clearing the
      * {@link module:engine/model/document~Document#history document history}.
      *
      * This method also creates a batch with all the changes applied. If all you need is to parse data, use
      * the {@link #parse} method.
      *
      * When data is passed as a string it is set on the default `main` root:
      *
      * ```ts
      * dataController.set( '<p>Foo</p>' ); // Sets data on the `main` root, as no other is specified.
      * ```
      *
      * To set data on a different root or multiple roots at once, an object containing `rootName` - `data` pairs should be passed:
      *
      * ```ts
      * dataController.set( { main: '<p>Foo</p>', title: '<h1>Bar</h1>' } ); // Sets data on the `main` and `title` roots as specified.
      * ```
      *
      * To set the data with a preserved undo stack and add the change to the undo stack, set `{ isUndoable: true }` as a `batchType` option.
      *
      * ```ts
      * dataController.set( '<p>Foo</p>', { batchType: { isUndoable: true } } );
      * ```
      *
      * @fires set
      * @param data Input data as a string or an object containing the `rootName` - `data`
      * pairs to set data on multiple roots at once.
      * @param options Options for setting data.
      * @param options.batchType The batch type that will be used to create a batch for the changes applied by this method.
      * By default, the batch will be set as {@link module:engine/model/batch~Batch#isUndoable not undoable} and the undo stack will be
      * cleared after the new data is applied (all undo steps will be removed). If the batch type `isUndoable` flag is be set to `true`,
      * the undo stack will be preserved instead and not cleared when new data is applied.
      */
      set(data, options = {}) {
        let newData = {};
        if (typeof data === "string") {
          newData.main = data;
        } else {
          newData = data;
        }
        if (!this._checkIfRootsExists(Object.keys(newData))) {
          throw new CKEditorError("datacontroller-set-non-existent-root", this);
        }
        this.model.enqueueChange(options.batchType || {}, (writer) => {
          writer.setSelection(null);
          writer.removeSelectionAttribute(this.model.document.selection.getAttributeKeys());
          for (const rootName of Object.keys(newData)) {
            const modelRoot = this.model.document.getRoot(rootName);
            writer.remove(writer.createRangeIn(modelRoot));
            writer.insert(this.parse(newData[rootName], modelRoot), modelRoot, 0);
          }
        });
      }
      /**
      * Returns the data parsed by the {@link #processor data processor} and then converted by upcast converters
      * attached to the {@link #upcastDispatcher}.
      *
      * @see #set
      * @param data Data to parse.
      * @param context Base context in which the view will be converted to the model.
      * See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.
      * @returns Parsed data.
      */
      parse(data, context = "$root") {
        const viewDocumentFragment = this.processor.toView(data);
        return this.toModel(viewDocumentFragment, context);
      }
      /**
      * Returns the result of the given {@link module:engine/view/element~Element view element} or
      * {@link module:engine/view/documentfragment~DocumentFragment view document fragment} converted by the
      * {@link #upcastDispatcher view-to-model converters}, wrapped by {@link module:engine/model/documentfragment~DocumentFragment}.
      *
      * When marker elements were converted during the conversion process, it will be set as a document fragment's
      * {@link module:engine/model/documentfragment~DocumentFragment#markers static markers map}.
      *
      * @fires toModel
      * @param viewElementOrFragment The element or document fragment whose content will be converted.
      * @param context Base context in which the view will be converted to the model.
      * See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.
      * @returns Output document fragment.
      */
      toModel(viewElementOrFragment, context = "$root") {
        return this.model.change((writer) => {
          return this.upcastDispatcher.convert(viewElementOrFragment, writer, context);
        });
      }
      /**
      * Adds the style processor normalization rules.
      *
      * You can implement your own rules as well as use one of the available processor rules:
      *
      * * background: {@link module:engine/view/styles/background~addBackgroundRules}
      * * border: {@link module:engine/view/styles/border~addBorderRules}
      * * margin: {@link module:engine/view/styles/margin~addMarginRules}
      * * padding: {@link module:engine/view/styles/padding~addPaddingRules}
      */
      addStyleProcessorRules(callback) {
        callback(this.stylesProcessor);
      }
      /**
      * Registers a {@link module:engine/view/matcher~MatcherPattern} on an {@link #htmlProcessor htmlProcessor}
      * and a {@link #processor processor} for view elements whose content should be treated as raw data
      * and not processed during the conversion from DOM to view elements.
      *
      * The raw data can be later accessed by the {@link module:engine/view/element~Element#getCustomProperty view element custom property}
      * `"$rawContent"`.
      *
      * @param pattern Pattern matching all view elements whose content should be treated as a raw data.
      */
      registerRawContentMatcher(pattern) {
        if (this.processor && this.processor !== this.htmlProcessor) {
          this.processor.registerRawContentMatcher(pattern);
        }
        this.htmlProcessor.registerRawContentMatcher(pattern);
      }
      /**
      * Removes all event listeners set by the DataController.
      */
      destroy() {
        this.stopListening();
      }
      /**
      * Checks whether all provided root names are actually existing editor roots.
      *
      * @param rootNames Root names to check.
      * @returns Whether all provided root names are existing editor roots.
      */
      _checkIfRootsExists(rootNames) {
        for (const rootName of rootNames) {
          if (!this.model.document.getRoot(rootName)) {
            return false;
          }
        }
        return true;
      }
    }
    function _getMarkersRelativeToElement(element) {
      const result2 = [];
      const doc = element.root.document;
      if (!doc) {
        return /* @__PURE__ */ new Map();
      }
      const elementRange = Range._createIn(element);
      for (const marker of doc.model.markers) {
        const markerRange = marker.getRange();
        const isMarkerCollapsed = markerRange.isCollapsed;
        const isMarkerAtElementBoundary = markerRange.start.isEqual(elementRange.start) || markerRange.end.isEqual(elementRange.end);
        if (isMarkerCollapsed && isMarkerAtElementBoundary) {
          result2.push([
            marker.name,
            markerRange
          ]);
        } else {
          const updatedMarkerRange = elementRange.getIntersection(markerRange);
          if (updatedMarkerRange) {
            result2.push([
              marker.name,
              updatedMarkerRange
            ]);
          }
        }
      }
      result2.sort(([n1, r1], [n2, r2]) => {
        if (r1.end.compareWith(r2.start) !== "after") {
          return 1;
        } else if (r1.start.compareWith(r2.end) !== "before") {
          return -1;
        } else {
          switch (r1.start.compareWith(r2.start)) {
            case "before":
              return 1;
            case "after":
              return -1;
            default:
              switch (r1.end.compareWith(r2.end)) {
                case "before":
                  return 1;
                case "after":
                  return -1;
                default:
                  return n2.localeCompare(n1);
              }
          }
        }
      });
      return new Map(result2);
    }
    class Conversion {
      /**
      * Creates a new conversion instance.
      */
      constructor(downcastDispatchers, upcastDispatchers) {
        /**
        * Maps dispatchers group name to ConversionHelpers instances.
        */
        __publicField(this, "_helpers", /* @__PURE__ */ new Map());
        __publicField(this, "_downcast");
        __publicField(this, "_upcast");
        this._downcast = toArray$2(downcastDispatchers);
        this._createConversionHelpers({
          name: "downcast",
          dispatchers: this._downcast,
          isDowncast: true
        });
        this._upcast = toArray$2(upcastDispatchers);
        this._createConversionHelpers({
          name: "upcast",
          dispatchers: this._upcast,
          isDowncast: false
        });
      }
      /**
      * Define an alias for registered dispatcher.
      *
      * ```ts
      * const conversion = new Conversion(
      * 	[ dataDowncastDispatcher, editingDowncastDispatcher ],
      * 	upcastDispatcher
      * );
      *
      * conversion.addAlias( 'dataDowncast', dataDowncastDispatcher );
      * ```
      *
      * @param alias An alias of a dispatcher.
      * @param dispatcher Dispatcher which should have an alias.
      */
      addAlias(alias, dispatcher) {
        const isDowncast = this._downcast.includes(dispatcher);
        const isUpcast = this._upcast.includes(dispatcher);
        if (!isUpcast && !isDowncast) {
          throw new CKEditorError("conversion-add-alias-dispatcher-not-registered", this);
        }
        this._createConversionHelpers({
          name: alias,
          dispatchers: [
            dispatcher
          ],
          isDowncast
        });
      }
      /**
      * Provides a chainable API to assign converters to a conversion dispatchers group.
      *
      * If the given group name has not been registered, the
      * {@link module:utils/ckeditorerror~CKEditorError `conversion-for-unknown-group` error} is thrown.
      *
      * You can use conversion helpers available directly in the `for()` chain or your custom ones via
      * the {@link module:engine/conversion/conversionhelpers~ConversionHelpers#add `add()`} method.
      *
      * # Using built-in conversion helpers
      *
      * The `for()` chain comes with a set of conversion helpers which you can use like this:
      *
      * ```ts
      * editor.conversion.for( 'downcast' )
      * 	.elementToElement( config1 )        // Adds an element-to-element downcast converter.
      * 	.attributeToElement( config2 );     // Adds an attribute-to-element downcast converter.
      *
      * editor.conversion.for( 'upcast' )
      * 	.elementToAttribute( config3 );     // Adds an element-to-attribute upcast converter.
      * ```
      *
      * Refer to the documentation of built-in conversion helpers to learn about their configuration options.
      *
      * * downcast (model-to-view) conversion helpers:
      *
      *	* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`},
      *	* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToElement `attributeToElement()`},
      *	* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToAttribute `attributeToAttribute()`}.
      *	* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToElement `markerToElement()`}.
      *	* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToHighlight `markerToHighlight()`}.
      *
      * * upcast (view-to-model) conversion helpers:
      *
      *	* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToElement `elementToElement()`},
      *	* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToAttribute `elementToAttribute()`},
      *	* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#attributeToAttribute `attributeToAttribute()`}.
      *	* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToMarker `elementToMarker()`}.
      *
      * # Using custom conversion helpers
      *
      * If you need to implement an atypical converter, you can do so by calling:
      *
      * ```ts
      * editor.conversion.for( direction ).add( customHelper );
      * ```
      *
      * The `.add()` method takes exactly one parameter, which is a function. This function should accept one parameter that
      * is a dispatcher instance. The function should add an actual converter to the passed dispatcher instance.
      *
      * Example:
      *
      * ```ts
      * editor.conversion.for( 'upcast' ).add( dispatcher => {
      * 	dispatcher.on( 'element:a',  ( evt, data, conversionApi ) => {
      * 		// Do something with a view <a> element.
      * 	} );
      * } );
      * ```
      *
      * Refer to the documentation of {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher}
      * and {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher} to learn how to write
      * custom converters.
      *
      * @param groupName The name of dispatchers group to add the converters to.
      */
      for(groupName) {
        if (!this._helpers.has(groupName)) {
          throw new CKEditorError("conversion-for-unknown-group", this);
        }
        return this._helpers.get(groupName);
      }
      /**
      * Sets up converters between the model and the view that convert a model element to a view element (and vice versa).
      * For example, the model `<paragraph>Foo</paragraph>` is turned into `<p>Foo</p>` in the view.
      *
      * ```ts
      * // A simple conversion from the `paragraph` model element to the `<p>` view element (and vice versa).
      * editor.conversion.elementToElement( { model: 'paragraph', view: 'p' } );
      *
      * // Override other converters by specifying a converter definition with a higher priority.
      * editor.conversion.elementToElement( { model: 'paragraph', view: 'div', converterPriority: 'high' } );
      *
      * // View specified as an object instead of a string.
      * editor.conversion.elementToElement( {
      * 	model: 'fancyParagraph',
      * 	view: {
      * 		name: 'p',
      * 		classes: 'fancy'
      * 	}
      * } );
      *
      * // Use `upcastAlso` to define other view elements that should also be converted to a `paragraph` element.
      * editor.conversion.elementToElement( {
      * 	model: 'paragraph',
      * 	view: 'p',
      * 	upcastAlso: [
      * 		'div',
      * 		{
      * 			// Any element with the `display: block` style.
      * 			styles: {
      * 				display: 'block'
      * 			}
      * 		}
      * 	]
      * } );
      *
      * // `upcastAlso` set as callback enables a conversion of a wide range of different view elements.
      * editor.conversion.elementToElement( {
      * 	model: 'heading',
      * 	view: 'h2',
      * 	// Convert "heading-like" paragraphs to headings.
      * 	upcastAlso: viewElement => {
      * 		const fontSize = viewElement.getStyle( 'font-size' );
      *
      * 		if ( !fontSize ) {
      * 			return null;
      * 		}
      *
      * 		const match = fontSize.match( /(\d+)\s*px/ );
      *
      * 		if ( !match ) {
      * 			return null;
      * 		}
      *
      * 		const size = Number( match[ 1 ] );
      *
      * 		if ( size > 26 ) {
      * 			// Returned value can be an object with the matched properties.
      * 			// These properties will be "consumed" during the conversion.
      * 			// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.
      *
      * 			return { name: true, styles: [ 'font-size' ] };
      * 		}
      *
      * 		return null;
      * 	}
      * } );
      * ```
      *
      * `definition.model` is a `String` with a model element name to convert from or to.
      *
      * @param definition The converter definition.
      */
      elementToElement(definition) {
        this.for("downcast").elementToElement(definition);
        for (const { model, view } of _getAllUpcastDefinitions(definition)) {
          this.for("upcast").elementToElement({
            model,
            view,
            converterPriority: definition.converterPriority
          });
        }
      }
      /**
      * Sets up converters between the model and the view that convert a model attribute to a view element (and vice versa).
      * For example, a model text node with `"Foo"` as data and the `bold` attribute will be turned to `<strong>Foo</strong>` in the view.
      *
      * ```ts
      * // A simple conversion from the `bold=true` attribute to the `<strong>` view element (and vice versa).
      * editor.conversion.attributeToElement( { model: 'bold', view: 'strong' } );
      *
      * // Override other converters by specifying a converter definition with a higher priority.
      * editor.conversion.attributeToElement( { model: 'bold', view: 'b', converterPriority: 'high' } );
      *
      * // View specified as an object instead of a string.
      * editor.conversion.attributeToElement( {
      * 	model: 'bold',
      * 	view: {
      * 		name: 'span',
      * 		classes: 'bold'
      * 	}
      * } );
      *
      * // Use `config.model.name` to define the conversion only from a given node type, `$text` in this case.
      * // The same attribute on different elements may then be handled by a different converter.
      * editor.conversion.attributeToElement( {
      * 	model: {
      * 		key: 'textDecoration',
      * 		values: [ 'underline', 'lineThrough' ],
      * 		name: '$text'
      * 	},
      * 	view: {
      * 		underline: {
      * 			name: 'span',
      * 			styles: {
      * 				'text-decoration': 'underline'
      * 			}
      * 		},
      * 		lineThrough: {
      * 			name: 'span',
      * 			styles: {
      * 				'text-decoration': 'line-through'
      * 			}
      * 		}
      * 	}
      * } );
      *
      * // Use `upcastAlso` to define other view elements that should also be converted to the `bold` attribute.
      * editor.conversion.attributeToElement( {
      * 	model: 'bold',
      * 	view: 'strong',
      * 	upcastAlso: [
      * 		'b',
      * 		{
      * 			name: 'span',
      * 			classes: 'bold'
      * 		},
      * 		{
      * 			name: 'span',
      * 			styles: {
      * 				'font-weight': 'bold'
      * 			}
      * 		},
      * 		viewElement => {
      * 			const fontWeight = viewElement.getStyle( 'font-weight' );
      *
      * 			if ( viewElement.is( 'element', 'span' ) && fontWeight && /\d+/.test() && Number( fontWeight ) > 500 ) {
      * 				// Returned value can be an object with the matched properties.
      * 				// These properties will be "consumed" during the conversion.
      * 				// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.
      *
      * 				return {
      * 					name: true,
      * 					styles: [ 'font-weight' ]
      * 				};
      * 			}
      * 		}
      * 	]
      * } );
      *
      * // Conversion from and to a model attribute key whose value is an enum (`fontSize=big|small`).
      * // `upcastAlso` set as callback enables a conversion of a wide range of different view elements.
      * editor.conversion.attributeToElement( {
      * 	model: {
      * 		key: 'fontSize',
      * 		values: [ 'big', 'small' ]
      * 	},
      * 	view: {
      * 		big: {
      * 			name: 'span',
      * 			styles: {
      * 				'font-size': '1.2em'
      * 			}
      * 		},
      * 		small: {
      * 			name: 'span',
      * 			styles: {
      * 				'font-size': '0.8em'
      * 			}
      * 		}
      * 	},
      * 	upcastAlso: {
      * 		big: viewElement => {
      * 			const fontSize = viewElement.getStyle( 'font-size' );
      *
      * 			if ( !fontSize ) {
      * 				return null;
      * 			}
      *
      * 			const match = fontSize.match( /(\d+)\s*px/ );
      *
      * 			if ( !match ) {
      * 				return null;
      * 			}
      *
      * 			const size = Number( match[ 1 ] );
      *
      * 			if ( viewElement.is( 'element', 'span' ) && size > 10 ) {
      * 				// Returned value can be an object with the matched properties.
      * 				// These properties will be "consumed" during the conversion.
      * 				// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.
      *
      * 				return { name: true, styles: [ 'font-size' ] };
      * 			}
      *
      * 			return null;
      * 		},
      * 		small: viewElement => {
      * 			const fontSize = viewElement.getStyle( 'font-size' );
      *
      * 			if ( !fontSize ) {
      * 				return null;
      * 			}
      *
      * 			const match = fontSize.match( /(\d+)\s*px/ );
      *
      * 			if ( !match ) {
      * 				return null;
      * 			}
      *
      * 			const size = Number( match[ 1 ] );
      *
      * 			if ( viewElement.is( 'element', 'span' ) && size < 10 ) {
      * 				// Returned value can be an object with the matched properties.
      * 				// These properties will be "consumed" during the conversion.
      * 				// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.
      *
      * 				return { name: true, styles: [ 'font-size' ] };
      * 			}
      *
      * 			return null;
      * 		}
      * 	}
      * } );
      * ```
      *
      * The `definition.model` parameter specifies which model attribute should be converted from or to. It can be a `{ key, value }` object
      * describing the attribute key and value to convert or a `String` specifying just the attribute key (in such a case
      * `value` is set to `true`).
      *
      * @param definition The converter definition.
      */
      attributeToElement(definition) {
        this.for("downcast").attributeToElement(definition);
        for (const { model, view } of _getAllUpcastDefinitions(definition)) {
          this.for("upcast").elementToAttribute({
            view,
            model,
            converterPriority: definition.converterPriority
          });
        }
      }
      /**
      * Sets up converters between the model and the view that convert a model attribute to a view attribute (and vice versa). For example,
      * `<imageBlock src='foo.jpg'></imageBlock>` is converted to `<img src='foo.jpg'></img>` (the same attribute key and value).
      * This type of converters is intended to be used with {@link module:engine/model/element~Element model element} nodes.
      * To convert the text attributes,
      * the {@link module:engine/conversion/conversion~Conversion#attributeToElement `attributeToElement converter`}should be set up.
      *
      * ```ts
      * // A simple conversion from the `source` model attribute to the `src` view attribute (and vice versa).
      * editor.conversion.attributeToAttribute( { model: 'source', view: 'src' } );
      *
      * // Attribute values are strictly specified.
      * editor.conversion.attributeToAttribute( {
      * 	model: {
      * 		name: 'imageInline',
      * 		key: 'aside',
      * 		values: [ 'aside' ]
      * 	},
      * 	view: {
      * 		aside: {
      * 			name: 'img',
      * 			key: 'class',
      * 			value: [ 'aside', 'half-size' ]
      * 		}
      * 	}
      * } );
      *
      * // Set the style attribute.
      * editor.conversion.attributeToAttribute( {
      * 	model: {
      * 		name: 'imageInline',
      * 		key: 'aside',
      * 		values: [ 'aside' ]
      * 	},
      * 	view: {
      * 		aside: {
      * 			name: 'img',
      * 			key: 'style',
      * 			value: {
      * 				float: 'right',
      * 				width: '50%',
      * 				margin: '5px'
      * 			}
      * 		}
      * 	}
      * } );
      *
      * // Conversion from and to a model attribute key whose value is an enum (`align=right|center`).
      * // Use `upcastAlso` to define other view elements that should also be converted to the `align=right` attribute.
      * editor.conversion.attributeToAttribute( {
      * 	model: {
      * 		key: 'align',
      * 		values: [ 'right', 'center' ]
      * 	},
      * 	view: {
      * 		right: {
      * 			key: 'class',
      * 			value: 'align-right'
      * 		},
      * 		center: {
      * 			key: 'class',
      * 			value: 'align-center'
      * 		}
      * 	},
      * 	upcastAlso: {
      * 		right: {
      * 			styles: {
      * 				'text-align': 'right'
      * 			}
      * 		},
      * 		center: {
      * 			styles: {
      * 				'text-align': 'center'
      * 			}
      * 		}
      * 	}
      * } );
      * ```
      *
      * The `definition.model` parameter specifies which model attribute should be converted from and to.
      * It can be a `{ key, [ values ], [ name ] }` object or a `String`, which will be treated like `{ key: definition.model }`.
      * The `key` property is the model attribute key to convert from and to.
      * The `values` are the possible model attribute values. If the `values` parameter is not set, the model attribute value
      * will be the same as the view attribute value.
      * If `name` is set, the conversion will be set up only for model elements with the given name.
      *
      * The `definition.view` parameter specifies which view attribute should be converted from and to.
      * It can be a `{ key, value, [ name ] }` object or a `String`, which will be treated like `{ key: definition.view }`.
      * The `key` property is the view attribute key to convert from and to.
      * The `value` is the view attribute value to convert from and to. If `definition.value` is not set, the view attribute value will be
      * the same as the model attribute value.
      * If `key` is `'class'`, `value` can be a `String` or an array of `String`s.
      * If `key` is `'style'`, `value` is an object with key-value pairs.
      * In other cases, `value` is a `String`.
      * If `name` is set, the conversion will be set up only for model elements with the given name.
      * If `definition.model.values` is set, `definition.view` is an object that assigns values from `definition.model.values`
      * to `{ key, value, [ name ] }` objects.
      *
      * `definition.upcastAlso` specifies which other matching view elements should also be upcast to the given model configuration.
      * If `definition.model.values` is set, `definition.upcastAlso` should be an object assigning values from `definition.model.values`
      * to {@link module:engine/view/matcher~MatcherPattern}s or arrays of {@link module:engine/view/matcher~MatcherPattern}s.
      *
      * **Note:** `definition.model` and `definition.view` form should be mirrored, so the same types of parameters should
      * be given in both parameters.
      *
      * @param definition The converter definition.
      * @param definition.model The model attribute to convert from and to.
      * @param definition.view The view attribute to convert from and to.
      * @param definition.upcastAlso Any view element matching `definition.upcastAlso` will also be converted to the given model attribute.
      * `definition.upcastAlso` is used only if `config.model.values` is specified.
      */
      attributeToAttribute(definition) {
        this.for("downcast").attributeToAttribute(definition);
        for (const { model, view } of _getAllUpcastDefinitions(definition)) {
          this.for("upcast").attributeToAttribute({
            view,
            model
          });
        }
      }
      /**
      * Creates and caches conversion helpers for given dispatchers group.
      *
      * @param options.name Group name.
      */
      _createConversionHelpers({ name, dispatchers, isDowncast }) {
        if (this._helpers.has(name)) {
          throw new CKEditorError("conversion-group-exists", this);
        }
        const helpers = isDowncast ? new DowncastHelpers(dispatchers) : new UpcastHelpers(dispatchers);
        this._helpers.set(name, helpers);
      }
    }
    function* _getAllUpcastDefinitions(definition) {
      if (definition.model.values) {
        for (const value of definition.model.values) {
          const model = {
            key: definition.model.key,
            value
          };
          const view = definition.view[value];
          const upcastAlso = definition.upcastAlso ? definition.upcastAlso[value] : void 0;
          yield* _getUpcastDefinition(model, view, upcastAlso);
        }
      } else {
        yield* _getUpcastDefinition(definition.model, definition.view, definition.upcastAlso);
      }
    }
    function* _getUpcastDefinition(model, view, upcastAlso) {
      yield {
        model,
        view
      };
      if (upcastAlso) {
        for (const upcastAlsoItem of toArray$2(upcastAlso)) {
          yield {
            model,
            view: upcastAlsoItem
          };
        }
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class Operation {
      /**
      * Base operation constructor.
      *
      * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
      * can be applied or `null` if the operation operates on detached (non-document) tree.
      */
      constructor(baseVersion) {
        /**
        * {@link module:engine/model/document~Document#version} on which operation can be applied. If you try to
        * {@link module:engine/model/model~Model#applyOperation apply} operation with different base version than the
        * {@link module:engine/model/document~Document#version document version} the
        * {@link module:utils/ckeditorerror~CKEditorError model-document-applyOperation-wrong-version} error is thrown.
        */
        __publicField(this, "baseVersion");
        /**
        * Defines whether operation is executed on attached or detached {@link module:engine/model/item~Item items}.
        */
        __publicField(this, "isDocumentOperation");
        /**
        * {@link module:engine/model/batch~Batch Batch} to which the operation is added or `null` if the operation is not
        * added to any batch yet.
        */
        __publicField(this, "batch");
        this.baseVersion = baseVersion;
        this.isDocumentOperation = this.baseVersion !== null;
        this.batch = null;
      }
      /**
      * Checks whether the operation's parameters are correct and the operation can be correctly executed. Throws
      * an error if operation is not valid.
      *
      * @internal
      */
      _validate() {
      }
      /**
      * Custom toJSON method to solve child-parent circular dependencies.
      *
      * @returns Clone of this object with the operation property replaced with string.
      */
      toJSON() {
        const json = Object.assign({}, this);
        json.__className = this.constructor.className;
        delete json.batch;
        delete json.isDocumentOperation;
        return json;
      }
      /**
      * Name of the operation class used for serialization.
      */
      static get className() {
        return "Operation";
      }
      /**
      * Creates `Operation` object from deserialized object, i.e. from parsed JSON string.
      *
      * @param json Deserialized JSON object.
      * @param doc Document on which this operation will be applied.
      */
      static fromJSON(json, document2) {
        return new this(json.baseVersion);
      }
    }
    function _insert(position, nodes) {
      const normalizedNodes = _normalizeNodes(nodes);
      const offset2 = normalizedNodes.reduce((sum2, node) => sum2 + node.offsetSize, 0);
      const parent2 = position.parent;
      _splitNodeAtPosition(position);
      const index = position.index;
      parent2._insertChild(index, normalizedNodes);
      _mergeNodesAtIndex(parent2, index + normalizedNodes.length);
      _mergeNodesAtIndex(parent2, index);
      return new Range(position, position.getShiftedBy(offset2));
    }
    function _remove(range2) {
      if (!range2.isFlat) {
        throw new CKEditorError("operation-utils-remove-range-not-flat", this);
      }
      const parent2 = range2.start.parent;
      _splitNodeAtPosition(range2.start);
      _splitNodeAtPosition(range2.end);
      const removed = parent2._removeChildren(range2.start.index, range2.end.index - range2.start.index);
      _mergeNodesAtIndex(parent2, range2.start.index);
      return removed;
    }
    function _move(sourceRange, targetPosition) {
      if (!sourceRange.isFlat) {
        throw new CKEditorError("operation-utils-move-range-not-flat", this);
      }
      const nodes = _remove(sourceRange);
      targetPosition = targetPosition._getTransformedByDeletion(sourceRange.start, sourceRange.end.offset - sourceRange.start.offset);
      return _insert(targetPosition, nodes);
    }
    function _setAttribute(range2, key, value) {
      _splitNodeAtPosition(range2.start);
      _splitNodeAtPosition(range2.end);
      for (const item of range2.getItems({
        shallow: true
      })) {
        const node = item.is("$textProxy") ? item.textNode : item;
        if (value !== null) {
          node._setAttribute(key, value);
        } else {
          node._removeAttribute(key);
        }
        _mergeNodesAtIndex(node.parent, node.index);
      }
      _mergeNodesAtIndex(range2.end.parent, range2.end.index);
    }
    function _normalizeNodes(nodes) {
      const normalized = [];
      function convert2(nodes2) {
        if (typeof nodes2 == "string") {
          normalized.push(new Text(nodes2));
        } else if (nodes2 instanceof TextProxy) {
          normalized.push(new Text(nodes2.data, nodes2.getAttributes()));
        } else if (nodes2 instanceof Node$1) {
          normalized.push(nodes2);
        } else if (isIterable(nodes2)) {
          for (const node of nodes2) {
            convert2(node);
          }
        } else ;
      }
      convert2(nodes);
      for (let i2 = 1; i2 < normalized.length; i2++) {
        const node = normalized[i2];
        const prev = normalized[i2 - 1];
        if (node instanceof Text && prev instanceof Text && _haveSameAttributes(node, prev)) {
          normalized.splice(i2 - 1, 2, new Text(prev.data + node.data, prev.getAttributes()));
          i2--;
        }
      }
      return normalized;
    }
    function _mergeNodesAtIndex(element, index) {
      const nodeBefore = element.getChild(index - 1);
      const nodeAfter = element.getChild(index);
      if (nodeBefore && nodeAfter && nodeBefore.is("$text") && nodeAfter.is("$text") && _haveSameAttributes(nodeBefore, nodeAfter)) {
        const mergedNode = new Text(nodeBefore.data + nodeAfter.data, nodeBefore.getAttributes());
        element._removeChildren(index - 1, 2);
        element._insertChild(index - 1, mergedNode);
      }
    }
    function _splitNodeAtPosition(position) {
      const textNode = position.textNode;
      const element = position.parent;
      if (textNode) {
        const offsetDiff = position.offset - textNode.startOffset;
        const index = textNode.index;
        element._removeChildren(index, 1);
        const firstPart = new Text(textNode.data.substr(0, offsetDiff), textNode.getAttributes());
        const secondPart = new Text(textNode.data.substr(offsetDiff), textNode.getAttributes());
        element._insertChild(index, [
          firstPart,
          secondPart
        ]);
      }
    }
    function _haveSameAttributes(nodeA, nodeB) {
      const iteratorA = nodeA.getAttributes();
      const iteratorB = nodeB.getAttributes();
      for (const attr of iteratorA) {
        if (attr[1] !== nodeB.getAttribute(attr[0])) {
          return false;
        }
        iteratorB.next();
      }
      return iteratorB.next().done;
    }
    class MoveOperation extends Operation {
      /**
      * Creates a move operation.
      *
      * @param sourcePosition Position before the first {@link module:engine/model/item~Item model item} to move.
      * @param howMany Offset size of moved range. Moved range will start from `sourcePosition` and end at
      * `sourcePosition` with offset shifted by `howMany`.
      * @param targetPosition Position at which moved nodes will be inserted.
      * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
      * can be applied or `null` if the operation operates on detached (non-document) tree.
      */
      constructor(sourcePosition, howMany, targetPosition, baseVersion) {
        super(baseVersion);
        /**
        * Position before the first {@link module:engine/model/item~Item model item} to move.
        */
        __publicField(this, "sourcePosition");
        /**
        * Offset size of moved range.
        */
        __publicField(this, "howMany");
        /**
        * Position at which moved nodes will be inserted.
        */
        __publicField(this, "targetPosition");
        this.sourcePosition = sourcePosition.clone();
        this.sourcePosition.stickiness = "toNext";
        this.howMany = howMany;
        this.targetPosition = targetPosition.clone();
        this.targetPosition.stickiness = "toNone";
      }
      /**
      * @inheritDoc
      */
      get type() {
        if (this.targetPosition.root.rootName == "$graveyard") {
          return "remove";
        } else if (this.sourcePosition.root.rootName == "$graveyard") {
          return "reinsert";
        }
        return "move";
      }
      /**
      * @inheritDoc
      */
      get affectedSelectable() {
        return [
          Range._createFromPositionAndShift(this.sourcePosition, this.howMany),
          Range._createFromPositionAndShift(this.targetPosition, 0)
        ];
      }
      /**
      * Creates and returns an operation that has the same parameters as this operation.
      */
      clone() {
        return new MoveOperation(this.sourcePosition, this.howMany, this.targetPosition, this.baseVersion);
      }
      /**
      * Returns the start position of the moved range after it got moved. This may be different than
      * {@link module:engine/model/operation/moveoperation~MoveOperation#targetPosition} in some cases, i.e. when a range is moved
      * inside the same parent but {@link module:engine/model/operation/moveoperation~MoveOperation#targetPosition targetPosition}
      * is after {@link module:engine/model/operation/moveoperation~MoveOperation#sourcePosition sourcePosition}.
      *
      * ```
      *  vv              vv
      * abcdefg ===> adefbcg
      *      ^          ^
      *      targetPos  movedRangeStart
      *      offset 6   offset 4
      *```
      */
      getMovedRangeStart() {
        return this.targetPosition._getTransformedByDeletion(this.sourcePosition, this.howMany);
      }
      /**
      * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
      */
      getReversed() {
        const newTargetPosition = this.sourcePosition._getTransformedByInsertion(this.targetPosition, this.howMany);
        return new MoveOperation(this.getMovedRangeStart(), this.howMany, newTargetPosition, this.baseVersion + 1);
      }
      /**
      * @inheritDoc
      * @internal
      */
      _validate() {
        const sourceElement = this.sourcePosition.parent;
        const targetElement = this.targetPosition.parent;
        const sourceOffset = this.sourcePosition.offset;
        const targetOffset = this.targetPosition.offset;
        if (sourceOffset + this.howMany > sourceElement.maxOffset) {
          throw new CKEditorError("move-operation-nodes-do-not-exist", this);
        } else if (sourceElement === targetElement && sourceOffset < targetOffset && targetOffset < sourceOffset + this.howMany) {
          throw new CKEditorError("move-operation-range-into-itself", this);
        } else if (this.sourcePosition.root == this.targetPosition.root) {
          if (compareArrays(this.sourcePosition.getParentPath(), this.targetPosition.getParentPath()) == "prefix") {
            const i2 = this.sourcePosition.path.length - 1;
            if (this.targetPosition.path[i2] >= sourceOffset && this.targetPosition.path[i2] < sourceOffset + this.howMany) {
              throw new CKEditorError("move-operation-node-into-itself", this);
            }
          }
        }
      }
      /**
      * @inheritDoc
      * @internal
      */
      _execute() {
        _move(Range._createFromPositionAndShift(this.sourcePosition, this.howMany), this.targetPosition);
      }
      /**
      * @inheritDoc
      */
      toJSON() {
        const json = super.toJSON();
        json.sourcePosition = this.sourcePosition.toJSON();
        json.targetPosition = this.targetPosition.toJSON();
        return json;
      }
      /**
      * @inheritDoc
      */
      static get className() {
        return "MoveOperation";
      }
      /**
      * Creates `MoveOperation` object from deserialized object, i.e. from parsed JSON string.
      *
      * @param json Deserialized JSON object.
      * @param document Document on which this operation will be applied.
      */
      static fromJSON(json, document2) {
        const sourcePosition = Position.fromJSON(json.sourcePosition, document2);
        const targetPosition = Position.fromJSON(json.targetPosition, document2);
        return new this(sourcePosition, json.howMany, targetPosition, json.baseVersion);
      }
    }
    class InsertOperation extends Operation {
      /**
      * Creates an insert operation.
      *
      * @param position Position of insertion.
      * @param nodes The list of nodes to be inserted.
      * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
      * can be applied or `null` if the operation operates on detached (non-document) tree.
      */
      constructor(position, nodes, baseVersion) {
        super(baseVersion);
        /**
        * Position of insertion.
        *
        * @readonly
        */
        __publicField(this, "position");
        /**
        * List of nodes to insert.
        *
        * @readonly
        */
        __publicField(this, "nodes");
        /**
        * Flag deciding how the operation should be transformed. If set to `true`, nodes might get additional attributes
        * during operational transformation. This happens when the operation insertion position is inside of a range
        * where attributes have changed.
        */
        __publicField(this, "shouldReceiveAttributes");
        this.position = position.clone();
        this.position.stickiness = "toNone";
        this.nodes = new NodeList(_normalizeNodes(nodes));
        this.shouldReceiveAttributes = false;
      }
      /**
      * @inheritDoc
      */
      get type() {
        return "insert";
      }
      /**
      * Total offset size of inserted nodes.
      */
      get howMany() {
        return this.nodes.maxOffset;
      }
      /**
      * @inheritDoc
      */
      get affectedSelectable() {
        return this.position.clone();
      }
      /**
      * Creates and returns an operation that has the same parameters as this operation.
      */
      clone() {
        const nodes = new NodeList([
          ...this.nodes
        ].map((node) => node._clone(true)));
        const insert = new InsertOperation(this.position, nodes, this.baseVersion);
        insert.shouldReceiveAttributes = this.shouldReceiveAttributes;
        return insert;
      }
      /**
      * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
      */
      getReversed() {
        const graveyard = this.position.root.document.graveyard;
        const gyPosition = new Position(graveyard, [
          0
        ]);
        return new MoveOperation(this.position, this.nodes.maxOffset, gyPosition, this.baseVersion + 1);
      }
      /**
      * @inheritDoc
      * @internal
      */
      _validate() {
        const targetElement = this.position.parent;
        if (!targetElement || targetElement.maxOffset < this.position.offset) {
          throw new CKEditorError("insert-operation-position-invalid", this);
        }
      }
      /**
      * @inheritDoc
      * @internal
      */
      _execute() {
        const originalNodes = this.nodes;
        this.nodes = new NodeList([
          ...originalNodes
        ].map((node) => node._clone(true)));
        _insert(this.position, originalNodes);
      }
      /**
      * @inheritDoc
      */
      toJSON() {
        const json = super.toJSON();
        json.position = this.position.toJSON();
        json.nodes = this.nodes.toJSON();
        return json;
      }
      /**
      * @inheritDoc
      */
      static get className() {
        return "InsertOperation";
      }
      /**
      * Creates `InsertOperation` object from deserialized object, i.e. from parsed JSON string.
      *
      * @param json Deserialized JSON object.
      * @param document Document on which this operation will be applied.
      */
      static fromJSON(json, document2) {
        const children = [];
        for (const child of json.nodes) {
          if (child.name) {
            children.push(Element$2.fromJSON(child));
          } else {
            children.push(Text.fromJSON(child));
          }
        }
        const insert = new InsertOperation(Position.fromJSON(json.position, document2), children, json.baseVersion);
        insert.shouldReceiveAttributes = json.shouldReceiveAttributes;
        return insert;
      }
    }
    class SplitOperation extends Operation {
      /**
      * Creates a split operation.
      *
      * @param splitPosition Position at which an element should be split.
      * @param howMany Total offset size of elements that are in the split element after `position`.
      * @param insertionPosition Position at which the clone of split element (or element from graveyard) will be inserted.
      * @param graveyardPosition Position in the graveyard root before the element which
      * should be used as a parent of the nodes after `position`. If it is not set, a copy of the the `position` parent will be used.
      * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
      * can be applied or `null` if the operation operates on detached (non-document) tree.
      */
      constructor(splitPosition, howMany, insertionPosition, graveyardPosition, baseVersion) {
        super(baseVersion);
        /**
        * Position at which an element should be split.
        */
        __publicField(this, "splitPosition");
        /**
        * Total offset size of elements that are in the split element after `position`.
        */
        __publicField(this, "howMany");
        /**
        * Position at which the clone of split element (or element from graveyard) will be inserted.
        */
        __publicField(this, "insertionPosition");
        /**
        * Position in the graveyard root before the element which should be used as a parent of the nodes after `position`.
        * If it is not set, a copy of the the `position` parent will be used.
        *
        * The default behavior is to clone the split element. Element from graveyard is used during undo.
        */
        __publicField(this, "graveyardPosition");
        this.splitPosition = splitPosition.clone();
        this.splitPosition.stickiness = "toNext";
        this.howMany = howMany;
        this.insertionPosition = insertionPosition;
        this.graveyardPosition = graveyardPosition ? graveyardPosition.clone() : null;
        if (this.graveyardPosition) {
          this.graveyardPosition.stickiness = "toNext";
        }
      }
      /**
      * @inheritDoc
      */
      get type() {
        return "split";
      }
      /**
      * Position inside the new clone of a split element.
      *
      * This is a position where nodes that are after the split position will be moved to.
      */
      get moveTargetPosition() {
        const path = this.insertionPosition.path.slice();
        path.push(0);
        return new Position(this.insertionPosition.root, path);
      }
      /**
      * Artificial range that contains all the nodes from the split element that will be moved to the new element.
      * The range starts at {@link #splitPosition} and ends in the same parent, at `POSITIVE_INFINITY` offset.
      */
      get movedRange() {
        const end2 = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);
        return new Range(this.splitPosition, end2);
      }
      /**
      * @inheritDoc
      */
      get affectedSelectable() {
        const ranges = [
          Range._createFromPositionAndShift(this.splitPosition, 0),
          Range._createFromPositionAndShift(this.insertionPosition, 0)
        ];
        if (this.graveyardPosition) {
          ranges.push(Range._createFromPositionAndShift(this.graveyardPosition, 0));
        }
        return ranges;
      }
      /**
      * Creates and returns an operation that has the same parameters as this operation.
      *
      * @returns Clone of this operation.
      */
      clone() {
        return new SplitOperation(this.splitPosition, this.howMany, this.insertionPosition, this.graveyardPosition, this.baseVersion);
      }
      /**
      * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
      */
      getReversed() {
        const graveyard = this.splitPosition.root.document.graveyard;
        const graveyardPosition = new Position(graveyard, [
          0
        ]);
        return new MergeOperation(this.moveTargetPosition, this.howMany, this.splitPosition, graveyardPosition, this.baseVersion + 1);
      }
      /**
      * @inheritDoc
      * @internal
      */
      _validate() {
        const element = this.splitPosition.parent;
        const offset2 = this.splitPosition.offset;
        if (!element || element.maxOffset < offset2) {
          throw new CKEditorError("split-operation-position-invalid", this);
        } else if (!element.parent) {
          throw new CKEditorError("split-operation-split-in-root", this);
        } else if (this.howMany != element.maxOffset - this.splitPosition.offset) {
          throw new CKEditorError("split-operation-how-many-invalid", this);
        } else if (this.graveyardPosition && !this.graveyardPosition.nodeAfter) {
          throw new CKEditorError("split-operation-graveyard-position-invalid", this);
        }
      }
      /**
      * @inheritDoc
      * @internal
      */
      _execute() {
        const splitElement = this.splitPosition.parent;
        if (this.graveyardPosition) {
          _move(Range._createFromPositionAndShift(this.graveyardPosition, 1), this.insertionPosition);
        } else {
          const newElement = splitElement._clone();
          _insert(this.insertionPosition, newElement);
        }
        const sourceRange = new Range(Position._createAt(splitElement, this.splitPosition.offset), Position._createAt(splitElement, splitElement.maxOffset));
        _move(sourceRange, this.moveTargetPosition);
      }
      /**
      * @inheritDoc
      */
      toJSON() {
        const json = super.toJSON();
        json.splitPosition = this.splitPosition.toJSON();
        json.insertionPosition = this.insertionPosition.toJSON();
        if (this.graveyardPosition) {
          json.graveyardPosition = this.graveyardPosition.toJSON();
        }
        return json;
      }
      /**
      * @inheritDoc
      */
      static get className() {
        return "SplitOperation";
      }
      /**
      * Helper function that returns a default insertion position basing on given `splitPosition`. The default insertion
      * position is after the split element.
      */
      static getInsertionPosition(splitPosition) {
        const path = splitPosition.path.slice(0, -1);
        path[path.length - 1]++;
        return new Position(splitPosition.root, path, "toPrevious");
      }
      /**
      * Creates `SplitOperation` object from deserialized object, i.e. from parsed JSON string.
      *
      * @param json Deserialized JSON object.
      * @param document Document on which this operation will be applied.
      */
      static fromJSON(json, document2) {
        const splitPosition = Position.fromJSON(json.splitPosition, document2);
        const insertionPosition = Position.fromJSON(json.insertionPosition, document2);
        const graveyardPosition = json.graveyardPosition ? Position.fromJSON(json.graveyardPosition, document2) : null;
        return new this(splitPosition, json.howMany, insertionPosition, graveyardPosition, json.baseVersion);
      }
    }
    class MergeOperation extends Operation {
      /**
      * Creates a merge operation.
      *
      * @param sourcePosition Position inside the merged element. All nodes from that
      * element after that position will be moved to {@link #targetPosition}.
      * @param howMany Summary offset size of nodes which will be moved from the merged element to the new parent.
      * @param targetPosition Position which the nodes from the merged elements will be moved to.
      * @param graveyardPosition Position in graveyard to which the merged element will be moved.
      * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
      * can be applied or `null` if the operation operates on detached (non-document) tree.
      */
      constructor(sourcePosition, howMany, targetPosition, graveyardPosition, baseVersion) {
        super(baseVersion);
        /**
        * Position inside the merged element. All nodes from that element after that position will be moved to {@link #targetPosition}.
        */
        __publicField(this, "sourcePosition");
        /**
        * Summary offset size of nodes which will be moved from the merged element to the new parent.
        */
        __publicField(this, "howMany");
        /**
        * Position which the nodes from the merged elements will be moved to.
        */
        __publicField(this, "targetPosition");
        /**
        * Position in graveyard to which the merged element will be moved.
        */
        __publicField(this, "graveyardPosition");
        this.sourcePosition = sourcePosition.clone();
        this.sourcePosition.stickiness = "toPrevious";
        this.howMany = howMany;
        this.targetPosition = targetPosition.clone();
        this.targetPosition.stickiness = "toNext";
        this.graveyardPosition = graveyardPosition.clone();
      }
      /**
      * @inheritDoc
      */
      get type() {
        return "merge";
      }
      /**
      * Position before the merged element (which will be deleted).
      */
      get deletionPosition() {
        return new Position(this.sourcePosition.root, this.sourcePosition.path.slice(0, -1));
      }
      /**
      * Artificial range that contains all the nodes from the merged element that will be moved to {@link ~MergeOperation#sourcePosition}.
      * The range starts at {@link ~MergeOperation#sourcePosition} and ends in the same parent, at `POSITIVE_INFINITY` offset.
      */
      get movedRange() {
        const end2 = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY);
        return new Range(this.sourcePosition, end2);
      }
      /**
      * @inheritDoc
      */
      get affectedSelectable() {
        const mergedElement = this.sourcePosition.parent;
        return [
          Range._createOn(mergedElement),
          // These could be positions but `Selectable` type only supports `Iterable<Range>`.
          Range._createFromPositionAndShift(this.targetPosition, 0),
          Range._createFromPositionAndShift(this.graveyardPosition, 0)
        ];
      }
      /**
      * Creates and returns an operation that has the same parameters as this operation.
      */
      clone() {
        return new MergeOperation(this.sourcePosition, this.howMany, this.targetPosition, this.graveyardPosition, this.baseVersion);
      }
      /**
      * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
      */
      getReversed() {
        const targetPosition = this.targetPosition._getTransformedByMergeOperation(this);
        const path = this.sourcePosition.path.slice(0, -1);
        const insertionPosition = new Position(this.sourcePosition.root, path)._getTransformedByMergeOperation(this);
        return new SplitOperation(targetPosition, this.howMany, insertionPosition, this.graveyardPosition, this.baseVersion + 1);
      }
      /**
      * @inheritDoc
      * @internal
      */
      _validate() {
        const sourceElement = this.sourcePosition.parent;
        const targetElement = this.targetPosition.parent;
        if (!sourceElement.parent) {
          throw new CKEditorError("merge-operation-source-position-invalid", this);
        } else if (!targetElement.parent) {
          throw new CKEditorError("merge-operation-target-position-invalid", this);
        } else if (this.howMany != sourceElement.maxOffset) {
          throw new CKEditorError("merge-operation-how-many-invalid", this);
        }
      }
      /**
      * @inheritDoc
      * @internal
      */
      _execute() {
        const mergedElement = this.sourcePosition.parent;
        const sourceRange = Range._createIn(mergedElement);
        _move(sourceRange, this.targetPosition);
        _move(Range._createOn(mergedElement), this.graveyardPosition);
      }
      /**
      * @inheritDoc
      */
      toJSON() {
        const json = super.toJSON();
        json.sourcePosition = json.sourcePosition.toJSON();
        json.targetPosition = json.targetPosition.toJSON();
        json.graveyardPosition = json.graveyardPosition.toJSON();
        return json;
      }
      /**
      * @inheritDoc
      */
      static get className() {
        return "MergeOperation";
      }
      /**
      * Creates `MergeOperation` object from deserialized object, i.e. from parsed JSON string.
      *
      * @param json Deserialized JSON object.
      * @param document Document on which this operation will be applied.
      */
      static fromJSON(json, document2) {
        const sourcePosition = Position.fromJSON(json.sourcePosition, document2);
        const targetPosition = Position.fromJSON(json.targetPosition, document2);
        const graveyardPosition = Position.fromJSON(json.graveyardPosition, document2);
        return new this(sourcePosition, json.howMany, targetPosition, graveyardPosition, json.baseVersion);
      }
    }
    class MarkerOperation extends Operation {
      /**
      * @param name Marker name.
      * @param oldRange Marker range before the change.
      * @param newRange Marker range after the change.
      * @param markers Marker collection on which change should be executed.
      * @param affectsData Specifies whether the marker operation affects the data produced by the data pipeline
      * (is persisted in the editor's data).
      * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
      * can be applied or `null` if the operation operates on detached (non-document) tree.
      */
      constructor(name, oldRange, newRange, markers, affectsData, baseVersion) {
        super(baseVersion);
        /**
        * Marker name.
        *
        * @readonly
        */
        __publicField(this, "name");
        /**
        * Marker range before the change.
        *
        * @readonly
        */
        __publicField(this, "oldRange");
        /**
        * Marker range after the change.
        *
        * @readonly
        */
        __publicField(this, "newRange");
        /**
        * Specifies whether the marker operation affects the data produced by the data pipeline
        * (is persisted in the editor's data).
        *
        * @readonly
        */
        __publicField(this, "affectsData");
        /**
        * Marker collection on which change should be executed.
        */
        __publicField(this, "_markers");
        this.name = name;
        this.oldRange = oldRange ? oldRange.clone() : null;
        this.newRange = newRange ? newRange.clone() : null;
        this.affectsData = affectsData;
        this._markers = markers;
      }
      /**
      * @inheritDoc
      */
      get type() {
        return "marker";
      }
      /**
      * @inheritDoc
      */
      get affectedSelectable() {
        const ranges = [];
        if (this.oldRange) {
          ranges.push(this.oldRange.clone());
        }
        if (this.newRange) {
          if (this.oldRange) {
            ranges.push(...this.newRange.getDifference(this.oldRange));
          } else {
            ranges.push(this.newRange.clone());
          }
        }
        return ranges;
      }
      /**
      * Creates and returns an operation that has the same parameters as this operation.
      */
      clone() {
        return new MarkerOperation(this.name, this.oldRange, this.newRange, this._markers, this.affectsData, this.baseVersion);
      }
      /**
      * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
      */
      getReversed() {
        return new MarkerOperation(this.name, this.newRange, this.oldRange, this._markers, this.affectsData, this.baseVersion + 1);
      }
      /**
      * @inheritDoc
      * @internal
      */
      _execute() {
        if (this.newRange) {
          this._markers._set(this.name, this.newRange, true, this.affectsData);
        } else {
          this._markers._remove(this.name);
        }
      }
      /**
      * @inheritDoc
      * @internal
      */
      toJSON() {
        const json = super.toJSON();
        if (this.oldRange) {
          json.oldRange = this.oldRange.toJSON();
        }
        if (this.newRange) {
          json.newRange = this.newRange.toJSON();
        }
        delete json._markers;
        return json;
      }
      /**
      * @inheritDoc
      */
      static get className() {
        return "MarkerOperation";
      }
      /**
      * Creates `MarkerOperation` object from deserialized object, i.e. from parsed JSON string.
      *
      * @param json Deserialized JSON object.
      * @param document Document on which this operation will be applied.
      */
      static fromJSON(json, document2) {
        return new MarkerOperation(json.name, json.oldRange ? Range.fromJSON(json.oldRange, document2) : null, json.newRange ? Range.fromJSON(json.newRange, document2) : null, document2.model.markers, json.affectsData, json.baseVersion);
      }
    }
    class AttributeOperation extends Operation {
      /**
      * Creates an operation that changes, removes or adds attributes.
      *
      * If only `newValue` is set, attribute will be added on a node. Note that all nodes in operation's range must not
      * have an attribute with the same key as the added attribute.
      *
      * If only `oldValue` is set, then attribute with given key will be removed. Note that all nodes in operation's range
      * must have an attribute with that key added.
      *
      * If both `newValue` and `oldValue` are set, then the operation will change the attribute value. Note that all nodes in
      * operation's ranges must already have an attribute with given key and `oldValue` as value
      *
      * @param range Range on which the operation should be applied. Must be a flat range.
      * @param key Key of an attribute to change or remove.
      * @param oldValue Old value of the attribute with given key or `null`, if attribute was not set before.
      * @param newValue New value of the attribute with given key or `null`, if operation should remove attribute.
      * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
      * can be applied or `null` if the operation operates on detached (non-document) tree.
      */
      constructor(range2, key, oldValue, newValue, baseVersion) {
        super(baseVersion);
        /**
        * Range on which operation should be applied.
        *
        * @readonly
        */
        __publicField(this, "range");
        /**
        * Key of an attribute to change or remove.
        *
        * @readonly
        */
        __publicField(this, "key");
        /**
        * Old value of the attribute with given key or `null`, if attribute was not set before.
        *
        * @readonly
        */
        __publicField(this, "oldValue");
        /**
        * New value of the attribute with given key or `null`, if operation should remove attribute.
        *
        * @readonly
        */
        __publicField(this, "newValue");
        this.range = range2.clone();
        this.key = key;
        this.oldValue = oldValue === void 0 ? null : oldValue;
        this.newValue = newValue === void 0 ? null : newValue;
      }
      /**
      * @inheritDoc
      */
      get type() {
        if (this.oldValue === null) {
          return "addAttribute";
        } else if (this.newValue === null) {
          return "removeAttribute";
        } else {
          return "changeAttribute";
        }
      }
      /**
      * @inheritDoc
      */
      get affectedSelectable() {
        return this.range.clone();
      }
      /**
      * Creates and returns an operation that has the same parameters as this operation.
      */
      clone() {
        return new AttributeOperation(this.range, this.key, this.oldValue, this.newValue, this.baseVersion);
      }
      /**
      * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
      */
      getReversed() {
        return new AttributeOperation(this.range, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
      }
      /**
      * @inheritDoc
      */
      toJSON() {
        const json = super.toJSON();
        json.range = this.range.toJSON();
        return json;
      }
      /**
      * @inheritDoc
      * @internal
      */
      _validate() {
        if (!this.range.isFlat) {
          throw new CKEditorError("attribute-operation-range-not-flat", this);
        }
        for (const item of this.range.getItems({
          shallow: true
        })) {
          if (this.oldValue !== null && !isEqual(item.getAttribute(this.key), this.oldValue)) {
            throw new CKEditorError("attribute-operation-wrong-old-value", this, {
              item,
              key: this.key,
              value: this.oldValue
            });
          }
          if (this.oldValue === null && this.newValue !== null && item.hasAttribute(this.key)) {
            throw new CKEditorError("attribute-operation-attribute-exists", this, {
              node: item,
              key: this.key
            });
          }
        }
      }
      /**
      * @inheritDoc
      * @internal
      */
      _execute() {
        if (!isEqual(this.oldValue, this.newValue)) {
          _setAttribute(this.range, this.key, this.newValue);
        }
      }
      /**
      * @inheritDoc
      */
      static get className() {
        return "AttributeOperation";
      }
      /**
      * Creates `AttributeOperation` object from deserialized object, i.e. from parsed JSON string.
      *
      * @param json Deserialized JSON object.
      * @param document Document on which this operation will be applied.
      */
      static fromJSON(json, document2) {
        return new AttributeOperation(Range.fromJSON(json.range, document2), json.key, json.oldValue, json.newValue, json.baseVersion);
      }
    }
    class NoOperation extends Operation {
      get type() {
        return "noop";
      }
      /**
      * @inheritDoc
      */
      get affectedSelectable() {
        return null;
      }
      /**
      * Creates and returns an operation that has the same parameters as this operation.
      */
      clone() {
        return new NoOperation(this.baseVersion);
      }
      /**
      * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
      */
      getReversed() {
        return new NoOperation(this.baseVersion + 1);
      }
      /** @internal */
      _execute() {
      }
      /**
      * @inheritDoc
      */
      static get className() {
        return "NoOperation";
      }
    }
    class RenameOperation extends Operation {
      /**
      * Creates an operation that changes element's name.
      *
      * @param position Position before an element to change.
      * @param oldName Current name of the element.
      * @param newName New name for the element.
      * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
      * can be applied or `null` if the operation operates on detached (non-document) tree.
      */
      constructor(position, oldName, newName, baseVersion) {
        super(baseVersion);
        /**
        * Position before an element to change.
        */
        __publicField(this, "position");
        /**
        * Current name of the element.
        */
        __publicField(this, "oldName");
        /**
        * New name for the element.
        */
        __publicField(this, "newName");
        this.position = position;
        this.position.stickiness = "toNext";
        this.oldName = oldName;
        this.newName = newName;
      }
      /**
      * @inheritDoc
      */
      get type() {
        return "rename";
      }
      /**
      * @inheritDoc
      */
      get affectedSelectable() {
        return this.position.nodeAfter;
      }
      /**
      * Creates and returns an operation that has the same parameters as this operation.
      *
      * @returns Clone of this operation.
      */
      clone() {
        return new RenameOperation(this.position.clone(), this.oldName, this.newName, this.baseVersion);
      }
      /**
      * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
      */
      getReversed() {
        return new RenameOperation(this.position.clone(), this.newName, this.oldName, this.baseVersion + 1);
      }
      /**
      * @inheritDoc
      * @internal
      */
      _validate() {
        const element = this.position.nodeAfter;
        if (!(element instanceof Element$2)) {
          throw new CKEditorError("rename-operation-wrong-position", this);
        } else if (element.name !== this.oldName) {
          throw new CKEditorError("rename-operation-wrong-name", this);
        }
      }
      /**
      * @inheritDoc
      * @internal
      */
      _execute() {
        const element = this.position.nodeAfter;
        element.name = this.newName;
      }
      /**
      * @inheritDoc
      */
      toJSON() {
        const json = super.toJSON();
        json.position = this.position.toJSON();
        return json;
      }
      /**
      * @inheritDoc
      */
      static get className() {
        return "RenameOperation";
      }
      /**
      * Creates `RenameOperation` object from deserialized object, i.e. from parsed JSON string.
      *
      * @param json Deserialized JSON object.
      * @param document Document on which this operation will be applied.
      */
      static fromJSON(json, document2) {
        return new RenameOperation(Position.fromJSON(json.position, document2), json.oldName, json.newName, json.baseVersion);
      }
    }
    class RootAttributeOperation extends Operation {
      /**
      * Creates an operation that changes, removes or adds attributes on root element.
      *
      * @see module:engine/model/operation/attributeoperation~AttributeOperation
      * @param root Root element to change.
      * @param key Key of an attribute to change or remove.
      * @param oldValue Old value of the attribute with given key or `null`, if attribute was not set before.
      * @param newValue New value of the attribute with given key or `null`, if operation should remove attribute.
      * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
      * can be applied or `null` if the operation operates on detached (non-document) tree.
      */
      constructor(root2, key, oldValue, newValue, baseVersion) {
        super(baseVersion);
        /**
        * Root element to change.
        */
        __publicField(this, "root");
        /**
        * Key of an attribute to change or remove.
        */
        __publicField(this, "key");
        /**
        * Old value of the attribute with given key or `null`, if attribute was not set before.
        *
        * @readonly
        */
        __publicField(this, "oldValue");
        /**
        * New value of the attribute with given key or `null`, if operation should remove attribute.
        *
        * @readonly
        */
        __publicField(this, "newValue");
        this.root = root2;
        this.key = key;
        this.oldValue = oldValue === void 0 ? null : oldValue;
        this.newValue = newValue === void 0 ? null : newValue;
      }
      /**
      * @inheritDoc
      */
      get type() {
        if (this.oldValue === null) {
          return "addRootAttribute";
        } else if (this.newValue === null) {
          return "removeRootAttribute";
        } else {
          return "changeRootAttribute";
        }
      }
      /**
      * @inheritDoc
      */
      get affectedSelectable() {
        return this.root;
      }
      /**
      * Creates and returns an operation that has the same parameters as this operation.
      *
      * @returns Clone of this operation.
      */
      clone() {
        return new RootAttributeOperation(this.root, this.key, this.oldValue, this.newValue, this.baseVersion);
      }
      /**
      * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
      */
      getReversed() {
        return new RootAttributeOperation(this.root, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
      }
      /**
      * @inheritDoc
      * @internal
      */
      _validate() {
        if (this.root != this.root.root || this.root.is("documentFragment")) {
          throw new CKEditorError("rootattribute-operation-not-a-root", this, {
            root: this.root,
            key: this.key
          });
        }
        if (this.oldValue !== null && this.root.getAttribute(this.key) !== this.oldValue) {
          throw new CKEditorError("rootattribute-operation-wrong-old-value", this, {
            root: this.root,
            key: this.key
          });
        }
        if (this.oldValue === null && this.newValue !== null && this.root.hasAttribute(this.key)) {
          throw new CKEditorError("rootattribute-operation-attribute-exists", this, {
            root: this.root,
            key: this.key
          });
        }
      }
      /**
      * @inheritDoc
      * @internal
      */
      _execute() {
        if (this.newValue !== null) {
          this.root._setAttribute(this.key, this.newValue);
        } else {
          this.root._removeAttribute(this.key);
        }
      }
      /**
      * @inheritDoc
      */
      toJSON() {
        const json = super.toJSON();
        json.root = this.root.toJSON();
        return json;
      }
      /**
      * @inheritDoc
      */
      static get className() {
        return "RootAttributeOperation";
      }
      /**
      * Creates `RootAttributeOperation` object from deserialized object, i.e. from parsed JSON string.
      *
      * @param json Deserialized JSON object.
      * @param document Document on which this operation will be applied.
      */
      static fromJSON(json, document2) {
        if (!document2.getRoot(json.root)) {
          throw new CKEditorError("rootattribute-operation-fromjson-no-root", this, {
            rootName: json.root
          });
        }
        return new RootAttributeOperation(document2.getRoot(json.root), json.key, json.oldValue, json.newValue, json.baseVersion);
      }
    }
    class RootOperation extends Operation {
      /**
      * Creates an operation that creates or removes a root element.
      *
      * @param rootName Root name to create or detach.
      * @param elementName Root element name.
      * @param isAdd Specifies whether the operation adds (`true`) or detaches the root (`false`).
      * @param document Document which owns the root.
      * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation can be applied.
      */
      constructor(rootName, elementName, isAdd, document2, baseVersion) {
        super(baseVersion);
        /**
        * Root name to create or detach.
        */
        __publicField(this, "rootName");
        /**
        * Root element name.
        */
        __publicField(this, "elementName");
        /**
        * Specifies whether the operation adds (`true`) or detaches the root (`false`).
        */
        __publicField(this, "isAdd");
        /**
        * Document which owns the root.
        */
        __publicField(this, "_document");
        this.rootName = rootName;
        this.elementName = elementName;
        this.isAdd = isAdd;
        this._document = document2;
        if (!this._document.getRoot(this.rootName)) {
          const root2 = this._document.createRoot(this.elementName, this.rootName);
          root2._isAttached = false;
        }
      }
      /**
      * @inheritDoc
      */
      get type() {
        return this.isAdd ? "addRoot" : "detachRoot";
      }
      /**
      * @inheritDoc
      */
      get affectedSelectable() {
        return this._document.getRoot(this.rootName);
      }
      /**
      * @inheritDoc
      */
      clone() {
        return new RootOperation(this.rootName, this.elementName, this.isAdd, this._document, this.baseVersion);
      }
      /**
      * @inheritDoc
      */
      getReversed() {
        return new RootOperation(this.rootName, this.elementName, !this.isAdd, this._document, this.baseVersion + 1);
      }
      /**
      * @inheritDoc
      */
      _execute() {
        this._document.getRoot(this.rootName)._isAttached = this.isAdd;
      }
      /**
      * @inheritDoc
      */
      toJSON() {
        const json = super.toJSON();
        delete json._document;
        return json;
      }
      /**
      * @inheritDoc
      */
      static get className() {
        return "RootOperation";
      }
      /**
      * Creates `RootOperation` object from deserialized object, i.e. from parsed JSON string.
      *
      * @param json Deserialized JSON object.
      * @param document Document on which this operation will be applied.
      */
      static fromJSON(json, document2) {
        return new RootOperation(json.rootName, json.elementName, json.isAdd, document2, json.baseVersion);
      }
    }
    const operations = {};
    operations[AttributeOperation.className] = AttributeOperation;
    operations[InsertOperation.className] = InsertOperation;
    operations[MarkerOperation.className] = MarkerOperation;
    operations[MoveOperation.className] = MoveOperation;
    operations[NoOperation.className] = NoOperation;
    operations[Operation.className] = Operation;
    operations[RenameOperation.className] = RenameOperation;
    operations[RootAttributeOperation.className] = RootAttributeOperation;
    operations[RootOperation.className] = RootOperation;
    operations[SplitOperation.className] = SplitOperation;
    operations[MergeOperation.className] = MergeOperation;
    class OperationFactory {
      /**
      * Creates an operation instance from a JSON object (parsed JSON string).
      *
      * @param json Deserialized JSON object.
      * @param document Document on which this operation will be applied.
      */
      static fromJSON(json, document2) {
        return operations[json.__className].fromJSON(json, document2);
      }
    }
    const transformations = /* @__PURE__ */ new Map();
    function setTransformation(OperationA, OperationB, transformationFunction) {
      let aGroup = transformations.get(OperationA);
      if (!aGroup) {
        aGroup = /* @__PURE__ */ new Map();
        transformations.set(OperationA, aGroup);
      }
      aGroup.set(OperationB, transformationFunction);
    }
    function getTransformation(OperationA, OperationB) {
      const aGroup = transformations.get(OperationA);
      if (aGroup && aGroup.has(OperationB)) {
        return aGroup.get(OperationB);
      }
      return noUpdateTransformation;
    }
    function noUpdateTransformation(a2) {
      return [
        a2
      ];
    }
    function transform$1(a2, b2, context = {}) {
      const transformationFunction = getTransformation(a2.constructor, b2.constructor);
      try {
        a2 = a2.clone();
        return transformationFunction(a2, b2, context);
      } catch (e2) {
        throw e2;
      }
    }
    function transformSets(operationsA, operationsB, options) {
      operationsA = operationsA.slice();
      operationsB = operationsB.slice();
      const contextFactory = new ContextFactory(options.document, options.useRelations, options.forceWeakRemove);
      contextFactory.setOriginalOperations(operationsA);
      contextFactory.setOriginalOperations(operationsB);
      const originalOperations = contextFactory.originalOperations;
      if (operationsA.length == 0 || operationsB.length == 0) {
        return {
          operationsA,
          operationsB,
          originalOperations
        };
      }
      const nextTransformIndex = /* @__PURE__ */ new WeakMap();
      for (const op of operationsA) {
        nextTransformIndex.set(op, 0);
      }
      const data = {
        nextBaseVersionA: operationsA[operationsA.length - 1].baseVersion + 1,
        nextBaseVersionB: operationsB[operationsB.length - 1].baseVersion + 1,
        originalOperationsACount: operationsA.length,
        originalOperationsBCount: operationsB.length
      };
      let i2 = 0;
      while (i2 < operationsA.length) {
        const opA = operationsA[i2];
        const indexB = nextTransformIndex.get(opA);
        if (indexB == operationsB.length) {
          i2++;
          continue;
        }
        const opB = operationsB[indexB];
        const newOpsA = transform$1(opA, opB, contextFactory.getContext(opA, opB, true));
        const newOpsB = transform$1(opB, opA, contextFactory.getContext(opB, opA, false));
        contextFactory.updateRelation(opA, opB);
        contextFactory.setOriginalOperations(newOpsA, opA);
        contextFactory.setOriginalOperations(newOpsB, opB);
        for (const newOpA of newOpsA) {
          nextTransformIndex.set(newOpA, indexB + newOpsB.length);
        }
        operationsA.splice(i2, 1, ...newOpsA);
        operationsB.splice(indexB, 1, ...newOpsB);
      }
      handlePartialMarkerOperations(operationsA);
      handlePartialMarkerOperations(operationsB);
      updateBaseVersions(operationsA, data.nextBaseVersionB);
      updateBaseVersions(operationsB, data.nextBaseVersionA);
      return {
        operationsA,
        operationsB,
        originalOperations
      };
    }
    class ContextFactory {
      /**
      * Creates `ContextFactory` instance.
      *
      * @param document Document which the operations change.
      * @param useRelations Whether during transformation relations should be used (used during undo for
      * better conflict resolution).
      * @param forceWeakRemove If set to `false`, remove operation will be always stronger than move operation,
      * so the removed nodes won't end up back in the document root. When set to `true`, context data will be used.
      */
      constructor(document2, useRelations, forceWeakRemove = false) {
        __publicField(this, "originalOperations");
        __publicField(this, "_history");
        __publicField(this, "_useRelations");
        __publicField(this, "_forceWeakRemove");
        __publicField(this, "_relations");
        this.originalOperations = /* @__PURE__ */ new Map();
        this._history = document2.history;
        this._useRelations = useRelations;
        this._forceWeakRemove = !!forceWeakRemove;
        this._relations = /* @__PURE__ */ new Map();
      }
      /**
      * Sets "original operation" for given operations.
      *
      * During transformation process, operations are cloned, then changed, then processed again, sometimes broken into two
      * or multiple operations. When gathering additional data it is important that all operations can be somehow linked
      * so a cloned and transformed "version" still kept track of the data assigned earlier to it.
      *
      * The original operation object will be used as such an universal linking id. Throughout the transformation process
      * all cloned operations will refer to "the original operation" when storing and reading additional data.
      *
      * If `takeFrom` is not set, each operation from `operations` array will be assigned itself as "the original operation".
      * This should be used as an initialization step.
      *
      * If `takeFrom` is set, each operation from `operations` will be assigned the same original operation as assigned
      * for `takeFrom` operation. This should be used to update original operations. It should be used in a way that
      * `operations` are the result of `takeFrom` transformation to ensure proper "original operation propagation".
      */
      setOriginalOperations(operations2, takeFrom = null) {
        const originalOperation = takeFrom ? this.originalOperations.get(takeFrom) : null;
        for (const operation of operations2) {
          this.originalOperations.set(operation, originalOperation || operation);
        }
      }
      /**
      * Saves a relation between operations `opA` and `opB`.
      *
      * Relations are then later used to help solve conflicts when operations are transformed.
      */
      updateRelation(opA, opB) {
        if (opA instanceof MoveOperation) {
          if (opB instanceof MergeOperation) {
            if (opA.targetPosition.isEqual(opB.sourcePosition) || opB.movedRange.containsPosition(opA.targetPosition)) {
              this._setRelation(opA, opB, "insertAtSource");
            } else if (opA.targetPosition.isEqual(opB.deletionPosition)) {
              this._setRelation(opA, opB, "insertBetween");
            } else if (opA.targetPosition.isAfter(opB.sourcePosition)) {
              this._setRelation(opA, opB, "moveTargetAfter");
            }
          } else if (opB instanceof MoveOperation) {
            if (opA.targetPosition.isEqual(opB.sourcePosition) || opA.targetPosition.isBefore(opB.sourcePosition)) {
              this._setRelation(opA, opB, "insertBefore");
            } else {
              this._setRelation(opA, opB, "insertAfter");
            }
          }
        } else if (opA instanceof SplitOperation) {
          if (opB instanceof MergeOperation) {
            if (opA.splitPosition.isBefore(opB.sourcePosition)) {
              this._setRelation(opA, opB, "splitBefore");
            }
          } else if (opB instanceof MoveOperation) {
            if (opA.splitPosition.isEqual(opB.sourcePosition) || opA.splitPosition.isBefore(opB.sourcePosition)) {
              this._setRelation(opA, opB, "splitBefore");
            } else {
              const range2 = Range._createFromPositionAndShift(opB.sourcePosition, opB.howMany);
              if (opA.splitPosition.hasSameParentAs(opB.sourcePosition) && range2.containsPosition(opA.splitPosition)) {
                const howMany = range2.end.offset - opA.splitPosition.offset;
                const offset2 = opA.splitPosition.offset - range2.start.offset;
                this._setRelation(opA, opB, {
                  howMany,
                  offset: offset2
                });
              }
            }
          }
        } else if (opA instanceof MergeOperation) {
          if (opB instanceof MergeOperation) {
            if (!opA.targetPosition.isEqual(opB.sourcePosition)) {
              this._setRelation(opA, opB, "mergeTargetNotMoved");
            }
            if (opA.sourcePosition.isEqual(opB.targetPosition)) {
              this._setRelation(opA, opB, "mergeSourceNotMoved");
            }
            if (opA.sourcePosition.isEqual(opB.sourcePosition)) {
              this._setRelation(opA, opB, "mergeSameElement");
            }
          } else if (opB instanceof SplitOperation) {
            if (opA.sourcePosition.isEqual(opB.splitPosition)) {
              this._setRelation(opA, opB, "splitAtSource");
            }
          } else if (opB instanceof MoveOperation && opB.howMany > 0) {
            if (opA.sourcePosition.isEqual(opB.sourcePosition.getShiftedBy(opB.howMany))) {
              this._setRelation(opA, opB, "mergeSourceAffected");
            }
            if (opA.targetPosition.isEqual(opB.sourcePosition)) {
              this._setRelation(opA, opB, "mergeTargetWasBefore");
            }
          }
        } else if (opA instanceof MarkerOperation) {
          const markerRange = opA.newRange;
          if (!markerRange) {
            return;
          }
          if (opB instanceof MergeOperation) {
            const wasInLeftElement = markerRange.start.isEqual(opB.targetPosition);
            const wasStartBeforeMergedElement = markerRange.start.isEqual(opB.deletionPosition);
            const wasEndBeforeMergedElement = markerRange.end.isEqual(opB.deletionPosition);
            const wasInRightElement = markerRange.end.isEqual(opB.sourcePosition);
            if (wasInLeftElement || wasStartBeforeMergedElement || wasEndBeforeMergedElement || wasInRightElement) {
              this._setRelation(opA, opB, {
                wasInLeftElement,
                wasStartBeforeMergedElement,
                wasEndBeforeMergedElement,
                wasInRightElement
              });
            }
          }
        }
      }
      /**
      * Evaluates and returns contextual information about two given operations `opA` and `opB` which are about to be transformed.
      */
      getContext(opA, opB, aIsStrong) {
        return {
          aIsStrong,
          aWasUndone: this._wasUndone(opA),
          bWasUndone: this._wasUndone(opB),
          abRelation: this._useRelations ? this._getRelation(opA, opB) : null,
          baRelation: this._useRelations ? this._getRelation(opB, opA) : null,
          forceWeakRemove: this._forceWeakRemove
        };
      }
      /**
      * Returns whether given operation `op` has already been undone.
      *
      * Information whether an operation was undone gives more context when making a decision when two operations are in conflict.
      */
      _wasUndone(op) {
        const originalOp = this.originalOperations.get(op);
        return originalOp.wasUndone || this._history.isUndoneOperation(originalOp);
      }
      /**
      * Returns a relation between `opA` and an operation which is undone by `opB`. This can be `String` value if a relation
      * was set earlier or `null` if there was no relation between those operations.
      *
      * This is a little tricky to understand, so let's compare it to `ContextFactory#_wasUndone`.
      *
      * When `wasUndone( opB )` is used, we check if the `opB` has already been undone. It is obvious, that the
      * undoing operation must happen after the undone operation. So, essentially, we have `opB`, we take document history,
      * we look forward in the future and ask if in that future `opB` was undone.
      *
      * Relations is a backward process to `wasUndone()`.
      *
      * Long story short - using relations is asking what happened in the past. Looking back. This time we have an undoing
      * operation `opB` which has undone some other operation. When there is a transformation `opA` x `opB` and there is
      * a conflict to solve and `opB` is an undoing operation, we can look back in the history and see what was a relation
      * between `opA` and the operation which `opB` undone. Basing on that relation from the past, we can now make
      * a better decision when resolving a conflict between two operations, because we know more about the context of
      * those two operations.
      *
      * This is why this function does not return a relation directly between `opA` and `opB` because we need to look
      * back to search for a meaningful contextual information.
      */
      _getRelation(opA, opB) {
        const origB = this.originalOperations.get(opB);
        const undoneB = this._history.getUndoneOperation(origB);
        if (!undoneB) {
          return null;
        }
        const origA = this.originalOperations.get(opA);
        const relationsA = this._relations.get(origA);
        if (relationsA) {
          return relationsA.get(undoneB) || null;
        }
        return null;
      }
      /**
      * Helper function for `ContextFactory#updateRelations`.
      */
      _setRelation(opA, opB, relation) {
        const origA = this.originalOperations.get(opA);
        const origB = this.originalOperations.get(opB);
        let relationsA = this._relations.get(origA);
        if (!relationsA) {
          relationsA = /* @__PURE__ */ new Map();
          this._relations.set(origA, relationsA);
        }
        relationsA.set(origB, relation);
      }
    }
    function updateBaseVersions(operations2, baseVersion) {
      for (const operation of operations2) {
        operation.baseVersion = baseVersion++;
      }
    }
    function handlePartialMarkerOperations(operations2) {
      const markerOps = /* @__PURE__ */ new Map();
      for (let i2 = 0; i2 < operations2.length; i2++) {
        const op = operations2[i2];
        if (!(op instanceof MarkerOperation)) {
          continue;
        }
        if (op.baseVersion !== -1) {
          markerOps.set(op.name, {
            op,
            ranges: op.newRange ? [
              op.newRange
            ] : []
          });
        } else {
          if (op.newRange) {
            markerOps.get(op.name).ranges.push(op.newRange);
          }
          operations2.splice(i2, 1);
          i2--;
        }
      }
      for (const { op, ranges } of markerOps.values()) {
        if (ranges.length) {
          op.newRange = Range._createFromRanges(ranges);
        } else {
          op.newRange = null;
        }
      }
    }
    setTransformation(AttributeOperation, AttributeOperation, (a2, b2, context) => {
      if (a2.key === b2.key && a2.range.start.hasSameParentAs(b2.range.start)) {
        const operations2 = a2.range.getDifference(b2.range).map((range2) => {
          return new AttributeOperation(range2, a2.key, a2.oldValue, a2.newValue, 0);
        });
        const common2 = a2.range.getIntersection(b2.range);
        if (common2) {
          if (context.aIsStrong) {
            operations2.push(new AttributeOperation(common2, b2.key, b2.newValue, a2.newValue, 0));
          }
        }
        if (operations2.length == 0) {
          return [
            new NoOperation(0)
          ];
        }
        return operations2;
      } else {
        return [
          a2
        ];
      }
    });
    setTransformation(AttributeOperation, InsertOperation, (a2, b2) => {
      if (a2.range.start.hasSameParentAs(b2.position) && a2.range.containsPosition(b2.position)) {
        const range2 = a2.range._getTransformedByInsertion(b2.position, b2.howMany, !b2.shouldReceiveAttributes);
        const result2 = range2.map((r2) => {
          return new AttributeOperation(r2, a2.key, a2.oldValue, a2.newValue, a2.baseVersion);
        });
        if (b2.shouldReceiveAttributes) {
          const op = _getComplementaryAttributeOperations(b2, a2.key, a2.oldValue);
          if (op) {
            result2.unshift(op);
          }
        }
        return result2;
      }
      a2.range = a2.range._getTransformedByInsertion(b2.position, b2.howMany, false)[0];
      return [
        a2
      ];
    });
    function _getComplementaryAttributeOperations(insertOperation, key, newValue) {
      const nodes = insertOperation.nodes;
      const insertValue = nodes.getNode(0).getAttribute(key);
      if (insertValue == newValue) {
        return null;
      }
      const range2 = new Range(insertOperation.position, insertOperation.position.getShiftedBy(insertOperation.howMany));
      return new AttributeOperation(range2, key, insertValue, newValue, 0);
    }
    setTransformation(AttributeOperation, MergeOperation, (a2, b2) => {
      const ranges = [];
      if (a2.range.start.hasSameParentAs(b2.deletionPosition)) {
        if (a2.range.containsPosition(b2.deletionPosition) || a2.range.start.isEqual(b2.deletionPosition)) {
          ranges.push(Range._createFromPositionAndShift(b2.graveyardPosition, 1));
        }
      }
      const range2 = a2.range._getTransformedByMergeOperation(b2);
      if (!range2.isCollapsed) {
        ranges.push(range2);
      }
      return ranges.map((range3) => {
        return new AttributeOperation(range3, a2.key, a2.oldValue, a2.newValue, a2.baseVersion);
      });
    });
    setTransformation(AttributeOperation, MoveOperation, (a2, b2) => {
      const ranges = _breakRangeByMoveOperation(a2.range, b2);
      return ranges.map((range2) => new AttributeOperation(range2, a2.key, a2.oldValue, a2.newValue, a2.baseVersion));
    });
    function _breakRangeByMoveOperation(range2, moveOp) {
      const moveRange = Range._createFromPositionAndShift(moveOp.sourcePosition, moveOp.howMany);
      let common2 = null;
      let difference2 = [];
      if (moveRange.containsRange(range2, true)) {
        common2 = range2;
      } else if (range2.start.hasSameParentAs(moveRange.start)) {
        difference2 = range2.getDifference(moveRange);
        common2 = range2.getIntersection(moveRange);
      } else {
        difference2 = [
          range2
        ];
      }
      const result2 = [];
      for (let diff2 of difference2) {
        diff2 = diff2._getTransformedByDeletion(moveOp.sourcePosition, moveOp.howMany);
        const targetPosition = moveOp.getMovedRangeStart();
        const spread2 = diff2.start.hasSameParentAs(targetPosition);
        const diffs = diff2._getTransformedByInsertion(targetPosition, moveOp.howMany, spread2);
        result2.push(...diffs);
      }
      if (common2) {
        result2.push(common2._getTransformedByMove(moveOp.sourcePosition, moveOp.targetPosition, moveOp.howMany, false)[0]);
      }
      return result2;
    }
    setTransformation(AttributeOperation, SplitOperation, (a2, b2) => {
      if (a2.range.end.isEqual(b2.insertionPosition)) {
        if (!b2.graveyardPosition) {
          a2.range.end.offset++;
        }
        return [
          a2
        ];
      }
      if (a2.range.start.hasSameParentAs(b2.splitPosition) && a2.range.containsPosition(b2.splitPosition)) {
        const secondPart = a2.clone();
        secondPart.range = new Range(b2.moveTargetPosition.clone(), a2.range.end._getCombined(b2.splitPosition, b2.moveTargetPosition));
        a2.range.end = b2.splitPosition.clone();
        a2.range.end.stickiness = "toPrevious";
        return [
          a2,
          secondPart
        ];
      }
      a2.range = a2.range._getTransformedBySplitOperation(b2);
      return [
        a2
      ];
    });
    setTransformation(InsertOperation, AttributeOperation, (a2, b2) => {
      const result2 = [
        a2
      ];
      if (a2.shouldReceiveAttributes && a2.position.hasSameParentAs(b2.range.start) && b2.range.containsPosition(a2.position)) {
        const op = _getComplementaryAttributeOperations(a2, b2.key, b2.newValue);
        if (op) {
          result2.push(op);
        }
      }
      return result2;
    });
    setTransformation(InsertOperation, InsertOperation, (a2, b2, context) => {
      if (a2.position.isEqual(b2.position) && context.aIsStrong) {
        return [
          a2
        ];
      }
      a2.position = a2.position._getTransformedByInsertOperation(b2);
      return [
        a2
      ];
    });
    setTransformation(InsertOperation, MoveOperation, (a2, b2) => {
      a2.position = a2.position._getTransformedByMoveOperation(b2);
      return [
        a2
      ];
    });
    setTransformation(InsertOperation, SplitOperation, (a2, b2) => {
      a2.position = a2.position._getTransformedBySplitOperation(b2);
      return [
        a2
      ];
    });
    setTransformation(InsertOperation, MergeOperation, (a2, b2) => {
      a2.position = a2.position._getTransformedByMergeOperation(b2);
      return [
        a2
      ];
    });
    setTransformation(MarkerOperation, InsertOperation, (a2, b2) => {
      if (a2.oldRange) {
        a2.oldRange = a2.oldRange._getTransformedByInsertOperation(b2)[0];
      }
      if (a2.newRange) {
        a2.newRange = a2.newRange._getTransformedByInsertOperation(b2)[0];
      }
      return [
        a2
      ];
    });
    setTransformation(MarkerOperation, MarkerOperation, (a2, b2, context) => {
      if (a2.name == b2.name) {
        if (context.aIsStrong) {
          a2.oldRange = b2.newRange ? b2.newRange.clone() : null;
        } else {
          return [
            new NoOperation(0)
          ];
        }
      }
      return [
        a2
      ];
    });
    setTransformation(MarkerOperation, MergeOperation, (a2, b2) => {
      if (a2.oldRange) {
        a2.oldRange = a2.oldRange._getTransformedByMergeOperation(b2);
      }
      if (a2.newRange) {
        a2.newRange = a2.newRange._getTransformedByMergeOperation(b2);
      }
      return [
        a2
      ];
    });
    setTransformation(MarkerOperation, MoveOperation, (a2, b2) => {
      const result2 = [
        a2
      ];
      if (a2.oldRange) {
        a2.oldRange = Range._createFromRanges(a2.oldRange._getTransformedByMoveOperation(b2));
      }
      if (a2.newRange) {
        const ranges = a2.newRange._getTransformedByMoveOperation(b2);
        a2.newRange = ranges[0];
        for (let i2 = 1; i2 < ranges.length; i2++) {
          const op = a2.clone();
          op.oldRange = null;
          op.newRange = ranges[i2];
          op.baseVersion = -1;
          result2.push(op);
        }
      }
      return result2;
    });
    setTransformation(MarkerOperation, SplitOperation, (a2, b2, context) => {
      if (a2.oldRange) {
        a2.oldRange = a2.oldRange._getTransformedBySplitOperation(b2);
      }
      if (a2.newRange) {
        if (context.abRelation) {
          const aNewRange = a2.newRange._getTransformedBySplitOperation(b2);
          if (a2.newRange.start.isEqual(b2.splitPosition) && context.abRelation.wasStartBeforeMergedElement) {
            a2.newRange.start = Position._createAt(b2.insertionPosition);
          } else if (a2.newRange.start.isEqual(b2.splitPosition) && !context.abRelation.wasInLeftElement) {
            a2.newRange.start = Position._createAt(b2.moveTargetPosition);
          } else {
            a2.newRange.start = aNewRange.start;
          }
          if (a2.newRange.end.isEqual(b2.splitPosition) && context.abRelation.wasInRightElement) {
            a2.newRange.end = Position._createAt(b2.moveTargetPosition);
          } else if (a2.newRange.end.isEqual(b2.splitPosition) && context.abRelation.wasEndBeforeMergedElement) {
            a2.newRange.end = Position._createAt(b2.insertionPosition);
          } else {
            a2.newRange.end = aNewRange.end;
          }
          return [
            a2
          ];
        }
        a2.newRange = a2.newRange._getTransformedBySplitOperation(b2);
      }
      return [
        a2
      ];
    });
    setTransformation(MergeOperation, InsertOperation, (a2, b2) => {
      if (a2.sourcePosition.hasSameParentAs(b2.position)) {
        a2.howMany += b2.howMany;
      }
      a2.sourcePosition = a2.sourcePosition._getTransformedByInsertOperation(b2);
      a2.targetPosition = a2.targetPosition._getTransformedByInsertOperation(b2);
      return [
        a2
      ];
    });
    setTransformation(MergeOperation, MergeOperation, (a2, b2, context) => {
      if (a2.sourcePosition.isEqual(b2.sourcePosition) && a2.targetPosition.isEqual(b2.targetPosition)) {
        if (!context.bWasUndone) {
          return [
            new NoOperation(0)
          ];
        } else {
          const path = b2.graveyardPosition.path.slice();
          path.push(0);
          a2.sourcePosition = new Position(b2.graveyardPosition.root, path);
          a2.howMany = 0;
          return [
            a2
          ];
        }
      }
      if (a2.sourcePosition.isEqual(b2.sourcePosition) && !a2.targetPosition.isEqual(b2.targetPosition) && !context.bWasUndone && context.abRelation != "splitAtSource") {
        const aToGraveyard = a2.targetPosition.root.rootName == "$graveyard";
        const bToGraveyard = b2.targetPosition.root.rootName == "$graveyard";
        const aIsWeak = aToGraveyard && !bToGraveyard;
        const bIsWeak = bToGraveyard && !aToGraveyard;
        const forceMove = bIsWeak || !aIsWeak && context.aIsStrong;
        if (forceMove) {
          const sourcePosition = b2.targetPosition._getTransformedByMergeOperation(b2);
          const targetPosition = a2.targetPosition._getTransformedByMergeOperation(b2);
          return [
            new MoveOperation(sourcePosition, a2.howMany, targetPosition, 0)
          ];
        } else {
          return [
            new NoOperation(0)
          ];
        }
      }
      if (a2.sourcePosition.hasSameParentAs(b2.targetPosition)) {
        a2.howMany += b2.howMany;
      }
      a2.sourcePosition = a2.sourcePosition._getTransformedByMergeOperation(b2);
      a2.targetPosition = a2.targetPosition._getTransformedByMergeOperation(b2);
      if (!a2.graveyardPosition.isEqual(b2.graveyardPosition) || !context.aIsStrong) {
        a2.graveyardPosition = a2.graveyardPosition._getTransformedByMergeOperation(b2);
      }
      return [
        a2
      ];
    });
    setTransformation(MergeOperation, MoveOperation, (a2, b2, context) => {
      const removedRange = Range._createFromPositionAndShift(b2.sourcePosition, b2.howMany);
      if (b2.type == "remove" && !context.bWasUndone) {
        if (a2.deletionPosition.hasSameParentAs(b2.sourcePosition) && removedRange.containsPosition(a2.sourcePosition)) {
          return [
            new NoOperation(0)
          ];
        }
      }
      if (b2.sourcePosition.getShiftedBy(b2.howMany).isEqual(a2.sourcePosition)) {
        a2.sourcePosition.stickiness = "toNone";
      } else if (b2.targetPosition.isEqual(a2.sourcePosition) && context.abRelation == "mergeSourceAffected") {
        a2.sourcePosition.stickiness = "toNext";
      } else if (b2.sourcePosition.isEqual(a2.targetPosition)) {
        a2.targetPosition.stickiness = "toNone";
        a2.howMany -= b2.howMany;
      } else if (b2.targetPosition.isEqual(a2.targetPosition) && context.abRelation == "mergeTargetWasBefore") {
        a2.targetPosition.stickiness = "toPrevious";
        a2.howMany += b2.howMany;
      } else {
        if (a2.sourcePosition.hasSameParentAs(b2.targetPosition)) {
          a2.howMany += b2.howMany;
        }
        if (a2.sourcePosition.hasSameParentAs(b2.sourcePosition)) {
          a2.howMany -= b2.howMany;
        }
      }
      a2.sourcePosition = a2.sourcePosition._getTransformedByMoveOperation(b2);
      a2.targetPosition = a2.targetPosition._getTransformedByMoveOperation(b2);
      a2.sourcePosition.stickiness = "toPrevious";
      a2.targetPosition.stickiness = "toNext";
      if (!a2.graveyardPosition.isEqual(b2.targetPosition)) {
        a2.graveyardPosition = a2.graveyardPosition._getTransformedByMoveOperation(b2);
      }
      return [
        a2
      ];
    });
    setTransformation(MergeOperation, SplitOperation, (a2, b2, context) => {
      if (b2.graveyardPosition) {
        a2.graveyardPosition = a2.graveyardPosition._getTransformedByDeletion(b2.graveyardPosition, 1);
        if (a2.deletionPosition.isEqual(b2.graveyardPosition)) {
          a2.howMany = b2.howMany;
        }
      }
      if (a2.targetPosition.isEqual(b2.splitPosition)) {
        const mergeSplittingElement = b2.graveyardPosition && a2.deletionPosition.isEqual(b2.graveyardPosition);
        if (mergeSplittingElement || context.abRelation == "mergeTargetNotMoved") {
          a2.sourcePosition = a2.sourcePosition._getTransformedBySplitOperation(b2);
          return [
            a2
          ];
        }
      }
      if (a2.sourcePosition.isEqual(b2.splitPosition)) {
        if (context.abRelation == "mergeSourceNotMoved") {
          a2.howMany = 0;
          a2.targetPosition = a2.targetPosition._getTransformedBySplitOperation(b2);
          return [
            a2
          ];
        }
        if (context.abRelation == "mergeSameElement" || a2.sourcePosition.offset > 0) {
          a2.sourcePosition = b2.moveTargetPosition.clone();
          a2.targetPosition = a2.targetPosition._getTransformedBySplitOperation(b2);
          return [
            a2
          ];
        }
      }
      if (a2.sourcePosition.hasSameParentAs(b2.splitPosition)) {
        a2.howMany = b2.splitPosition.offset;
      }
      a2.sourcePosition = a2.sourcePosition._getTransformedBySplitOperation(b2);
      a2.targetPosition = a2.targetPosition._getTransformedBySplitOperation(b2);
      return [
        a2
      ];
    });
    setTransformation(MoveOperation, InsertOperation, (a2, b2) => {
      const moveRange = Range._createFromPositionAndShift(a2.sourcePosition, a2.howMany);
      const transformed = moveRange._getTransformedByInsertOperation(b2, false)[0];
      a2.sourcePosition = transformed.start;
      a2.howMany = transformed.end.offset - transformed.start.offset;
      if (!a2.targetPosition.isEqual(b2.position)) {
        a2.targetPosition = a2.targetPosition._getTransformedByInsertOperation(b2);
      }
      return [
        a2
      ];
    });
    setTransformation(MoveOperation, MoveOperation, (a2, b2, context) => {
      const rangeA = Range._createFromPositionAndShift(a2.sourcePosition, a2.howMany);
      const rangeB = Range._createFromPositionAndShift(b2.sourcePosition, b2.howMany);
      let aIsStrong = context.aIsStrong;
      let insertBefore = !context.aIsStrong;
      if (context.abRelation == "insertBefore" || context.baRelation == "insertAfter") {
        insertBefore = true;
      } else if (context.abRelation == "insertAfter" || context.baRelation == "insertBefore") {
        insertBefore = false;
      }
      let newTargetPosition;
      if (a2.targetPosition.isEqual(b2.targetPosition) && insertBefore) {
        newTargetPosition = a2.targetPosition._getTransformedByDeletion(b2.sourcePosition, b2.howMany);
      } else {
        newTargetPosition = a2.targetPosition._getTransformedByMove(b2.sourcePosition, b2.targetPosition, b2.howMany);
      }
      if (_moveTargetIntoMovedRange(a2, b2) && _moveTargetIntoMovedRange(b2, a2)) {
        return [
          b2.getReversed()
        ];
      }
      const bTargetsToA = rangeA.containsPosition(b2.targetPosition);
      if (bTargetsToA && rangeA.containsRange(rangeB, true)) {
        rangeA.start = rangeA.start._getTransformedByMove(b2.sourcePosition, b2.targetPosition, b2.howMany);
        rangeA.end = rangeA.end._getTransformedByMove(b2.sourcePosition, b2.targetPosition, b2.howMany);
        return _makeMoveOperationsFromRanges([
          rangeA
        ], newTargetPosition);
      }
      const aTargetsToB = rangeB.containsPosition(a2.targetPosition);
      if (aTargetsToB && rangeB.containsRange(rangeA, true)) {
        rangeA.start = rangeA.start._getCombined(b2.sourcePosition, b2.getMovedRangeStart());
        rangeA.end = rangeA.end._getCombined(b2.sourcePosition, b2.getMovedRangeStart());
        return _makeMoveOperationsFromRanges([
          rangeA
        ], newTargetPosition);
      }
      const aCompB = compareArrays(a2.sourcePosition.getParentPath(), b2.sourcePosition.getParentPath());
      if (aCompB == "prefix" || aCompB == "extension") {
        rangeA.start = rangeA.start._getTransformedByMove(b2.sourcePosition, b2.targetPosition, b2.howMany);
        rangeA.end = rangeA.end._getTransformedByMove(b2.sourcePosition, b2.targetPosition, b2.howMany);
        return _makeMoveOperationsFromRanges([
          rangeA
        ], newTargetPosition);
      }
      if (a2.type == "remove" && b2.type != "remove" && !context.aWasUndone && !context.forceWeakRemove) {
        aIsStrong = true;
      } else if (a2.type != "remove" && b2.type == "remove" && !context.bWasUndone && !context.forceWeakRemove) {
        aIsStrong = false;
      }
      const ranges = [];
      const difference2 = rangeA.getDifference(rangeB);
      for (const range2 of difference2) {
        range2.start = range2.start._getTransformedByDeletion(b2.sourcePosition, b2.howMany);
        range2.end = range2.end._getTransformedByDeletion(b2.sourcePosition, b2.howMany);
        const shouldSpread = compareArrays(range2.start.getParentPath(), b2.getMovedRangeStart().getParentPath()) == "same";
        const newRanges = range2._getTransformedByInsertion(b2.getMovedRangeStart(), b2.howMany, shouldSpread);
        ranges.push(...newRanges);
      }
      const common2 = rangeA.getIntersection(rangeB);
      if (common2 !== null && aIsStrong) {
        common2.start = common2.start._getCombined(b2.sourcePosition, b2.getMovedRangeStart());
        common2.end = common2.end._getCombined(b2.sourcePosition, b2.getMovedRangeStart());
        if (ranges.length === 0) {
          ranges.push(common2);
        } else if (ranges.length == 1) {
          if (rangeB.start.isBefore(rangeA.start) || rangeB.start.isEqual(rangeA.start)) {
            ranges.unshift(common2);
          } else {
            ranges.push(common2);
          }
        } else {
          ranges.splice(1, 0, common2);
        }
      }
      if (ranges.length === 0) {
        return [
          new NoOperation(a2.baseVersion)
        ];
      }
      return _makeMoveOperationsFromRanges(ranges, newTargetPosition);
    });
    setTransformation(MoveOperation, SplitOperation, (a2, b2, context) => {
      let newTargetPosition = a2.targetPosition.clone();
      if (!a2.targetPosition.isEqual(b2.insertionPosition) || !b2.graveyardPosition || context.abRelation == "moveTargetAfter") {
        newTargetPosition = a2.targetPosition._getTransformedBySplitOperation(b2);
      }
      const moveRange = Range._createFromPositionAndShift(a2.sourcePosition, a2.howMany);
      if (moveRange.end.isEqual(b2.insertionPosition)) {
        if (!b2.graveyardPosition) {
          a2.howMany++;
        }
        a2.targetPosition = newTargetPosition;
        return [
          a2
        ];
      }
      if (moveRange.start.hasSameParentAs(b2.splitPosition) && moveRange.containsPosition(b2.splitPosition)) {
        let rightRange = new Range(b2.splitPosition, moveRange.end);
        rightRange = rightRange._getTransformedBySplitOperation(b2);
        const ranges2 = [
          new Range(moveRange.start, b2.splitPosition),
          rightRange
        ];
        return _makeMoveOperationsFromRanges(ranges2, newTargetPosition);
      }
      if (a2.targetPosition.isEqual(b2.splitPosition) && context.abRelation == "insertAtSource") {
        newTargetPosition = b2.moveTargetPosition;
      }
      if (a2.targetPosition.isEqual(b2.insertionPosition) && context.abRelation == "insertBetween") {
        newTargetPosition = a2.targetPosition;
      }
      const transformed = moveRange._getTransformedBySplitOperation(b2);
      const ranges = [
        transformed
      ];
      if (b2.graveyardPosition) {
        const movesGraveyardElement = moveRange.start.isEqual(b2.graveyardPosition) || moveRange.containsPosition(b2.graveyardPosition);
        if (a2.howMany > 1 && movesGraveyardElement && !context.aWasUndone) {
          ranges.push(Range._createFromPositionAndShift(b2.insertionPosition, 1));
        }
      }
      return _makeMoveOperationsFromRanges(ranges, newTargetPosition);
    });
    setTransformation(MoveOperation, MergeOperation, (a2, b2, context) => {
      const movedRange = Range._createFromPositionAndShift(a2.sourcePosition, a2.howMany);
      if (b2.deletionPosition.hasSameParentAs(a2.sourcePosition) && movedRange.containsPosition(b2.sourcePosition)) {
        if (a2.type == "remove" && !context.forceWeakRemove) {
          if (!context.aWasUndone) {
            const results = [];
            let gyMoveSource = b2.graveyardPosition.clone();
            let splitNodesMoveSource = b2.targetPosition._getTransformedByMergeOperation(b2);
            const aTarget = a2.targetPosition.getTransformedByOperation(b2);
            if (a2.howMany > 1) {
              results.push(new MoveOperation(a2.sourcePosition, a2.howMany - 1, aTarget, 0));
              gyMoveSource = gyMoveSource._getTransformedByMove(a2.sourcePosition, aTarget, a2.howMany - 1);
              splitNodesMoveSource = splitNodesMoveSource._getTransformedByMove(a2.sourcePosition, aTarget, a2.howMany - 1);
            }
            const gyMoveTarget = b2.deletionPosition._getCombined(a2.sourcePosition, aTarget);
            const gyMove = new MoveOperation(gyMoveSource, 1, gyMoveTarget, 0);
            const splitNodesMoveTargetPath = gyMove.getMovedRangeStart().path.slice();
            splitNodesMoveTargetPath.push(0);
            const splitNodesMoveTarget = new Position(gyMove.targetPosition.root, splitNodesMoveTargetPath);
            splitNodesMoveSource = splitNodesMoveSource._getTransformedByMove(gyMoveSource, gyMoveTarget, 1);
            const splitNodesMove = new MoveOperation(splitNodesMoveSource, b2.howMany, splitNodesMoveTarget, 0);
            results.push(gyMove);
            results.push(splitNodesMove);
            return results;
          }
        } else {
          if (a2.howMany == 1) {
            if (!context.bWasUndone) {
              return [
                new NoOperation(0)
              ];
            } else {
              a2.sourcePosition = b2.graveyardPosition.clone();
              a2.targetPosition = a2.targetPosition._getTransformedByMergeOperation(b2);
              return [
                a2
              ];
            }
          }
        }
      }
      const moveRange = Range._createFromPositionAndShift(a2.sourcePosition, a2.howMany);
      const transformed = moveRange._getTransformedByMergeOperation(b2);
      a2.sourcePosition = transformed.start;
      a2.howMany = transformed.end.offset - transformed.start.offset;
      a2.targetPosition = a2.targetPosition._getTransformedByMergeOperation(b2);
      return [
        a2
      ];
    });
    setTransformation(RenameOperation, InsertOperation, (a2, b2) => {
      a2.position = a2.position._getTransformedByInsertOperation(b2);
      return [
        a2
      ];
    });
    setTransformation(RenameOperation, MergeOperation, (a2, b2) => {
      if (a2.position.isEqual(b2.deletionPosition)) {
        a2.position = b2.graveyardPosition.clone();
        a2.position.stickiness = "toNext";
        return [
          a2
        ];
      }
      a2.position = a2.position._getTransformedByMergeOperation(b2);
      return [
        a2
      ];
    });
    setTransformation(RenameOperation, MoveOperation, (a2, b2) => {
      a2.position = a2.position._getTransformedByMoveOperation(b2);
      return [
        a2
      ];
    });
    setTransformation(RenameOperation, RenameOperation, (a2, b2, context) => {
      if (a2.position.isEqual(b2.position)) {
        if (context.aIsStrong) {
          a2.oldName = b2.newName;
        } else {
          return [
            new NoOperation(0)
          ];
        }
      }
      return [
        a2
      ];
    });
    setTransformation(RenameOperation, SplitOperation, (a2, b2) => {
      const renamePath = a2.position.path;
      const splitPath = b2.splitPosition.getParentPath();
      if (compareArrays(renamePath, splitPath) == "same" && !b2.graveyardPosition) {
        const extraRename = new RenameOperation(a2.position.getShiftedBy(1), a2.oldName, a2.newName, 0);
        return [
          a2,
          extraRename
        ];
      }
      a2.position = a2.position._getTransformedBySplitOperation(b2);
      return [
        a2
      ];
    });
    setTransformation(RootAttributeOperation, RootAttributeOperation, (a2, b2, context) => {
      if (a2.root === b2.root && a2.key === b2.key) {
        if (!context.aIsStrong || a2.newValue === b2.newValue) {
          return [
            new NoOperation(0)
          ];
        } else {
          a2.oldValue = b2.newValue;
        }
      }
      return [
        a2
      ];
    });
    setTransformation(RootOperation, RootOperation, (a2, b2) => {
      if (a2.rootName === b2.rootName && a2.isAdd === b2.isAdd) {
        return [
          new NoOperation(0)
        ];
      }
      return [
        a2
      ];
    });
    setTransformation(SplitOperation, InsertOperation, (a2, b2) => {
      if (a2.splitPosition.hasSameParentAs(b2.position) && a2.splitPosition.offset < b2.position.offset) {
        a2.howMany += b2.howMany;
      }
      a2.splitPosition = a2.splitPosition._getTransformedByInsertOperation(b2);
      a2.insertionPosition = a2.insertionPosition._getTransformedByInsertOperation(b2);
      return [
        a2
      ];
    });
    setTransformation(SplitOperation, MergeOperation, (a2, b2, context) => {
      if (!a2.graveyardPosition && !context.bWasUndone && a2.splitPosition.hasSameParentAs(b2.sourcePosition)) {
        const splitPath = b2.graveyardPosition.path.slice();
        splitPath.push(0);
        const splitPosition = new Position(b2.graveyardPosition.root, splitPath);
        const insertionPosition = SplitOperation.getInsertionPosition(new Position(b2.graveyardPosition.root, splitPath));
        const additionalSplit = new SplitOperation(splitPosition, 0, insertionPosition, null, 0);
        a2.splitPosition = a2.splitPosition._getTransformedByMergeOperation(b2);
        a2.insertionPosition = SplitOperation.getInsertionPosition(a2.splitPosition);
        a2.graveyardPosition = additionalSplit.insertionPosition.clone();
        a2.graveyardPosition.stickiness = "toNext";
        return [
          additionalSplit,
          a2
        ];
      }
      if (a2.splitPosition.hasSameParentAs(b2.deletionPosition) && !a2.splitPosition.isAfter(b2.deletionPosition)) {
        a2.howMany--;
      }
      if (a2.splitPosition.hasSameParentAs(b2.targetPosition)) {
        a2.howMany += b2.howMany;
      }
      a2.splitPosition = a2.splitPosition._getTransformedByMergeOperation(b2);
      a2.insertionPosition = SplitOperation.getInsertionPosition(a2.splitPosition);
      if (a2.graveyardPosition) {
        a2.graveyardPosition = a2.graveyardPosition._getTransformedByMergeOperation(b2);
      }
      return [
        a2
      ];
    });
    setTransformation(SplitOperation, MoveOperation, (a2, b2, context) => {
      const rangeToMove = Range._createFromPositionAndShift(b2.sourcePosition, b2.howMany);
      if (a2.graveyardPosition) {
        const gyElementMoved = rangeToMove.start.isEqual(a2.graveyardPosition) || rangeToMove.containsPosition(a2.graveyardPosition);
        if (!context.bWasUndone && gyElementMoved) {
          const sourcePosition = a2.splitPosition._getTransformedByMoveOperation(b2);
          const newParentPosition = a2.graveyardPosition._getTransformedByMoveOperation(b2);
          const newTargetPath = newParentPosition.path.slice();
          newTargetPath.push(0);
          const newTargetPosition = new Position(newParentPosition.root, newTargetPath);
          const moveOp = new MoveOperation(sourcePosition, a2.howMany, newTargetPosition, 0);
          return [
            moveOp
          ];
        }
        a2.graveyardPosition = a2.graveyardPosition._getTransformedByMoveOperation(b2);
      }
      const splitAtTarget = a2.splitPosition.isEqual(b2.targetPosition);
      if (splitAtTarget && (context.baRelation == "insertAtSource" || context.abRelation == "splitBefore")) {
        a2.howMany += b2.howMany;
        a2.splitPosition = a2.splitPosition._getTransformedByDeletion(b2.sourcePosition, b2.howMany);
        a2.insertionPosition = SplitOperation.getInsertionPosition(a2.splitPosition);
        return [
          a2
        ];
      }
      if (splitAtTarget && context.abRelation && context.abRelation.howMany) {
        const { howMany, offset: offset2 } = context.abRelation;
        a2.howMany += howMany;
        a2.splitPosition = a2.splitPosition.getShiftedBy(offset2);
        return [
          a2
        ];
      }
      if (a2.splitPosition.hasSameParentAs(b2.sourcePosition) && rangeToMove.containsPosition(a2.splitPosition)) {
        const howManyRemoved = b2.howMany - (a2.splitPosition.offset - b2.sourcePosition.offset);
        a2.howMany -= howManyRemoved;
        if (a2.splitPosition.hasSameParentAs(b2.targetPosition) && a2.splitPosition.offset < b2.targetPosition.offset) {
          a2.howMany += b2.howMany;
        }
        a2.splitPosition = b2.sourcePosition.clone();
        a2.insertionPosition = SplitOperation.getInsertionPosition(a2.splitPosition);
        return [
          a2
        ];
      }
      if (!b2.sourcePosition.isEqual(b2.targetPosition)) {
        if (a2.splitPosition.hasSameParentAs(b2.sourcePosition) && a2.splitPosition.offset <= b2.sourcePosition.offset) {
          a2.howMany -= b2.howMany;
        }
        if (a2.splitPosition.hasSameParentAs(b2.targetPosition) && a2.splitPosition.offset < b2.targetPosition.offset) {
          a2.howMany += b2.howMany;
        }
      }
      a2.splitPosition.stickiness = "toNone";
      a2.splitPosition = a2.splitPosition._getTransformedByMoveOperation(b2);
      a2.splitPosition.stickiness = "toNext";
      if (a2.graveyardPosition) {
        a2.insertionPosition = a2.insertionPosition._getTransformedByMoveOperation(b2);
      } else {
        a2.insertionPosition = SplitOperation.getInsertionPosition(a2.splitPosition);
      }
      return [
        a2
      ];
    });
    setTransformation(SplitOperation, SplitOperation, (a2, b2, context) => {
      if (a2.splitPosition.isEqual(b2.splitPosition)) {
        if (!a2.graveyardPosition && !b2.graveyardPosition) {
          return [
            new NoOperation(0)
          ];
        }
        if (a2.graveyardPosition && b2.graveyardPosition && a2.graveyardPosition.isEqual(b2.graveyardPosition)) {
          return [
            new NoOperation(0)
          ];
        }
        if (context.abRelation == "splitBefore") {
          a2.howMany = 0;
          a2.graveyardPosition = a2.graveyardPosition._getTransformedBySplitOperation(b2);
          return [
            a2
          ];
        }
      }
      if (a2.graveyardPosition && b2.graveyardPosition && a2.graveyardPosition.isEqual(b2.graveyardPosition)) {
        const aInGraveyard = a2.splitPosition.root.rootName == "$graveyard";
        const bInGraveyard = b2.splitPosition.root.rootName == "$graveyard";
        const aIsWeak = aInGraveyard && !bInGraveyard;
        const bIsWeak = bInGraveyard && !aInGraveyard;
        const forceMove = bIsWeak || !aIsWeak && context.aIsStrong;
        if (forceMove) {
          const result2 = [];
          if (b2.howMany) {
            result2.push(new MoveOperation(b2.moveTargetPosition, b2.howMany, b2.splitPosition, 0));
          }
          if (a2.howMany) {
            result2.push(new MoveOperation(a2.splitPosition, a2.howMany, a2.moveTargetPosition, 0));
          }
          return result2;
        } else {
          return [
            new NoOperation(0)
          ];
        }
      }
      if (a2.graveyardPosition) {
        a2.graveyardPosition = a2.graveyardPosition._getTransformedBySplitOperation(b2);
      }
      if (a2.splitPosition.isEqual(b2.insertionPosition) && context.abRelation == "splitBefore") {
        a2.howMany++;
        return [
          a2
        ];
      }
      if (b2.splitPosition.isEqual(a2.insertionPosition) && context.baRelation == "splitBefore") {
        const newPositionPath = b2.insertionPosition.path.slice();
        newPositionPath.push(0);
        const newPosition = new Position(b2.insertionPosition.root, newPositionPath);
        const moveOp = new MoveOperation(a2.insertionPosition, 1, newPosition, 0);
        return [
          a2,
          moveOp
        ];
      }
      if (a2.splitPosition.hasSameParentAs(b2.splitPosition) && a2.splitPosition.offset < b2.splitPosition.offset) {
        a2.howMany -= b2.howMany;
      }
      a2.splitPosition = a2.splitPosition._getTransformedBySplitOperation(b2);
      a2.insertionPosition = SplitOperation.getInsertionPosition(a2.splitPosition);
      return [
        a2
      ];
    });
    function _moveTargetIntoMovedRange(a2, b2) {
      return a2.targetPosition._getTransformedByDeletion(b2.sourcePosition, b2.howMany) === null;
    }
    function _makeMoveOperationsFromRanges(ranges, targetPosition) {
      const operations2 = [];
      for (let i2 = 0; i2 < ranges.length; i2++) {
        const range2 = ranges[i2];
        const op = new MoveOperation(range2.start, range2.end.offset - range2.start.offset, targetPosition, 0);
        operations2.push(op);
        for (let j2 = i2 + 1; j2 < ranges.length; j2++) {
          ranges[j2] = ranges[j2]._getTransformedByMove(op.sourcePosition, op.targetPosition, op.howMany)[0];
        }
        targetPosition = targetPosition._getTransformedByMove(op.sourcePosition, op.targetPosition, op.howMany);
      }
      return operations2;
    }
    class LivePosition extends (/* @__PURE__ */ EmitterMixin(Position)) {
      /**
      * Creates a live position.
      *
      * @see module:engine/model/position~Position
      */
      constructor(root2, path, stickiness = "toNone") {
        super(root2, path, stickiness);
        if (!this.root.is("rootElement")) {
          throw new CKEditorError("model-liveposition-root-not-rootelement", root2);
        }
        bindWithDocument.call(this);
      }
      /**
      * Unbinds all events previously bound by `LivePosition`. Use it whenever you don't need `LivePosition` instance
      * anymore (i.e. when leaving scope in which it was declared or before re-assigning variable that was
      * referring to it).
      */
      detach() {
        this.stopListening();
      }
      /**
      * Creates a {@link module:engine/model/position~Position position instance}, which is equal to this live position.
      */
      toPosition() {
        return new Position(this.root, this.path.slice(), this.stickiness);
      }
      /**
      * Creates a `LivePosition` instance that is equal to position.
      */
      static fromPosition(position, stickiness) {
        return new this(position.root, position.path.slice(), stickiness ? stickiness : position.stickiness);
      }
    }
    LivePosition.prototype.is = function(type) {
      return type === "livePosition" || type === "model:livePosition" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
      type == "position" || type === "model:position";
    };
    function bindWithDocument() {
      this.listenTo(this.root.document.model, "applyOperation", (event, args) => {
        const operation = args[0];
        if (!operation.isDocumentOperation) {
          return;
        }
        transform.call(this, operation);
      }, {
        priority: "low"
      });
    }
    function transform(operation) {
      const result2 = this.getTransformedByOperation(operation);
      if (!this.isEqual(result2)) {
        const oldPosition = this.toPosition();
        this.path = result2.path;
        this.root = result2.root;
        this.fire("change", oldPosition);
      }
    }
    class Batch {
      /**
      * Creates a batch instance.
      *
      * @see module:engine/model/model~Model#enqueueChange
      * @see module:engine/model/model~Model#change
      * @param type A set of flags that specify the type of the batch. Batch type can alter how some of the features work
      * when encountering a given `Batch` instance (for example, when a feature listens to applied operations).
      */
      constructor(type = {}) {
        /**
        * An array of operations that compose this batch.
        */
        __publicField(this, "operations");
        /**
        * Whether the batch can be undone through the undo feature.
        */
        __publicField(this, "isUndoable");
        /**
        * Whether the batch includes operations created locally (`true`) or operations created on other, remote editors (`false`).
        */
        __publicField(this, "isLocal");
        /**
        * Whether the batch was created by the undo feature and undoes other operations.
        */
        __publicField(this, "isUndo");
        /**
        * Whether the batch includes operations connected with typing.
        */
        __publicField(this, "isTyping");
        if (typeof type === "string") {
          type = type === "transparent" ? {
            isUndoable: false
          } : {};
          logWarning("batch-constructor-deprecated-string-type");
        }
        const { isUndoable = true, isLocal = true, isUndo = false, isTyping = false } = type;
        this.operations = [];
        this.isUndoable = isUndoable;
        this.isLocal = isLocal;
        this.isUndo = isUndo;
        this.isTyping = isTyping;
      }
      /**
      * The type of the batch.
      *
      * **This property has been deprecated and is always set to the `'default'` value.**
      *
      * It can be one of the following values:
      * * `'default'` &ndash; All "normal" batches. This is the most commonly used type.
      * * `'transparent'` &ndash; A batch that should be ignored by other features, i.e. an initial batch or collaborative editing
      * changes.
      *
      * @deprecated
      */
      get type() {
        logWarning("batch-type-deprecated");
        return "default";
      }
      /**
      * Returns the base version of this batch, which is equal to the base version of the first operation in the batch.
      * If there are no operations in the batch or neither operation has the base version set, it returns `null`.
      */
      get baseVersion() {
        for (const op of this.operations) {
          if (op.baseVersion !== null) {
            return op.baseVersion;
          }
        }
        return null;
      }
      /**
      * Adds an operation to the batch instance.
      *
      * @param operation An operation to add.
      * @returns The added operation.
      */
      addOperation(operation) {
        operation.batch = this;
        this.operations.push(operation);
        return operation;
      }
    }
    const _Differ = class _Differ {
      /**
      * Creates a `Differ` instance.
      *
      * @param markerCollection Model's marker collection.
      */
      constructor(markerCollection) {
        /**
        * Reference to the model's marker collection.
        */
        __publicField(this, "_markerCollection");
        /**
        * A map that stores changes that happened in a given element.
        *
        * The keys of the map are references to the model elements.
        * The values of the map are arrays with changes that were done on this element.
        */
        __publicField(this, "_changesInElement", /* @__PURE__ */ new Map());
        /**
        * Stores a snapshot for these model nodes that might have changed.
        *
        * This complements {@link ~Differ#_elementChildrenSnapshots `_elementChildrenSnapshots`}.
        *
        * See also {@link ~DifferSnapshot}.
        */
        __publicField(this, "_elementsSnapshots", /* @__PURE__ */ new Map());
        /**
        * For each element or document fragment inside which there was a change, it stores a snapshot of the child nodes list (an array
        * of children snapshots that represent the state in the element / fragment before any change has happened).
        *
        * This complements {@link ~Differ#_elementsSnapshots `_elementsSnapshots`}.
        *
        * See also {@link ~DifferSnapshot}.
        */
        __publicField(this, "_elementChildrenSnapshots", /* @__PURE__ */ new Map());
        /**
        * Keeps the state for a given element, describing how the element was changed so far. It is used to evaluate the `action` property
        * of diff items returned by {@link ~Differ#getChanges}.
        *
        * Possible values, in the order from the lowest priority to the highest priority:
        *
        * * `'refresh'` - element was refreshed,
        * * `'rename'` - element was renamed,
        * * `'move'` - element was moved (or, usually, removed, that is moved to the graveyard).
        *
        * Element that was refreshed, may change its state to `'rename'` if it was later renamed, or to `'move'` if it was removed.
        * But the element cannot change its state from `'move'` to `'rename'`, or from `'rename'` to `'refresh'`.
        *
        * Only already existing elements are registered in `_elementState`. If a new element was inserted as a result of a buffered operation,
        * it is not be registered in `_elementState`.
        */
        __publicField(this, "_elementState", /* @__PURE__ */ new Map());
        /**
        * A map that stores all changed markers.
        *
        * The keys of the map are marker names.
        *
        * The values of the map are objects with the following properties:
        *
        * * `oldMarkerData`,
        * * `newMarkerData`.
        */
        __publicField(this, "_changedMarkers", /* @__PURE__ */ new Map());
        /**
        * A map that stores all roots that have been changed.
        *
        * The keys are the names of the roots while value represents the changes.
        */
        __publicField(this, "_changedRoots", /* @__PURE__ */ new Map());
        /**
        * Stores the number of changes that were processed. Used to order the changes chronologically. It is important
        * when changes are sorted.
        */
        __publicField(this, "_changeCount", 0);
        /**
        * For efficiency purposes, `Differ` stores the change set returned by the differ after {@link #getChanges} call.
        * Cache is reset each time a new operation is buffered. If the cache has not been reset, {@link #getChanges} will
        * return the cached value instead of calculating it again.
        *
        * This property stores those changes that did not take place in graveyard root.
        */
        __publicField(this, "_cachedChanges", null);
        /**
        * For efficiency purposes, `Differ` stores the change set returned by the differ after the {@link #getChanges} call.
        * The cache is reset each time a new operation is buffered. If the cache has not been reset, {@link #getChanges} will
        * return the cached value instead of calculating it again.
        *
        * This property stores all changes evaluated by `Differ`, including those that took place in the graveyard.
        */
        __publicField(this, "_cachedChangesWithGraveyard", null);
        /**
        * Set of model items that were marked to get refreshed in {@link #_refreshItem}.
        */
        __publicField(this, "_refreshedItems", /* @__PURE__ */ new Set());
        this._markerCollection = markerCollection;
      }
      /**
      * Informs whether there are any changes buffered in `Differ`.
      */
      get isEmpty() {
        return this._changesInElement.size == 0 && this._changedMarkers.size == 0 && this._changedRoots.size == 0;
      }
      /**
      * Buffers the given operation. **An operation has to be buffered before it is executed.**
      *
      * @param operationToBuffer An operation to buffer.
      */
      bufferOperation(operationToBuffer) {
        const operation = operationToBuffer;
        switch (operation.type) {
          case "insert": {
            if (this._isInInsertedElement(operation.position.parent)) {
              return;
            }
            this._markInsert(operation.position.parent, operation.position.offset, operation.nodes.maxOffset);
            break;
          }
          case "addAttribute":
          case "removeAttribute":
          case "changeAttribute": {
            for (const item of operation.range.getItems({
              shallow: true
            })) {
              if (this._isInInsertedElement(item.parent)) {
                continue;
              }
              this._markAttribute(item);
            }
            break;
          }
          case "remove":
          case "move":
          case "reinsert": {
            if (operation.sourcePosition.isEqual(operation.targetPosition) || operation.sourcePosition.getShiftedBy(operation.howMany).isEqual(operation.targetPosition)) {
              return;
            }
            const sourceParentInserted = this._isInInsertedElement(operation.sourcePosition.parent);
            const targetParentInserted = this._isInInsertedElement(operation.targetPosition.parent);
            if (!sourceParentInserted) {
              this._markRemove(operation.sourcePosition.parent, operation.sourcePosition.offset, operation.howMany);
            }
            if (!targetParentInserted) {
              this._markInsert(operation.targetPosition.parent, operation.getMovedRangeStart().offset, operation.howMany);
            }
            const range2 = Range._createFromPositionAndShift(operation.sourcePosition, operation.howMany);
            for (const node of range2.getItems({
              shallow: true
            })) {
              this._setElementState(node, "move");
            }
            break;
          }
          case "rename": {
            if (this._isInInsertedElement(operation.position.parent)) {
              return;
            }
            this._markRemove(operation.position.parent, operation.position.offset, 1);
            this._markInsert(operation.position.parent, operation.position.offset, 1);
            const range2 = Range._createFromPositionAndShift(operation.position, 1);
            for (const marker of this._markerCollection.getMarkersIntersectingRange(range2)) {
              const markerData = marker.getData();
              this.bufferMarkerChange(marker.name, markerData, markerData);
            }
            this._setElementState(operation.position.nodeAfter, "rename");
            break;
          }
          case "split": {
            const splitElement = operation.splitPosition.parent;
            if (!this._isInInsertedElement(splitElement)) {
              this._markRemove(splitElement, operation.splitPosition.offset, operation.howMany);
              const range2 = Range._createFromPositionAndShift(operation.splitPosition, operation.howMany);
              for (const node of range2.getItems({
                shallow: true
              })) {
                this._setElementState(node, "move");
              }
            }
            if (!this._isInInsertedElement(operation.insertionPosition.parent)) {
              this._markInsert(operation.insertionPosition.parent, operation.insertionPosition.offset, 1);
            }
            if (operation.graveyardPosition) {
              this._markRemove(operation.graveyardPosition.parent, operation.graveyardPosition.offset, 1);
              this._setElementState(operation.graveyardPosition.nodeAfter, "move");
            }
            break;
          }
          case "merge": {
            const mergedElement = operation.sourcePosition.parent;
            if (!this._isInInsertedElement(mergedElement.parent)) {
              this._markRemove(mergedElement.parent, mergedElement.startOffset, 1);
            }
            const graveyardParent = operation.graveyardPosition.parent;
            this._markInsert(graveyardParent, operation.graveyardPosition.offset, 1);
            this._setElementState(mergedElement, "move");
            const mergedIntoElement = operation.targetPosition.parent;
            if (!this._isInInsertedElement(mergedIntoElement)) {
              this._markInsert(mergedIntoElement, operation.targetPosition.offset, mergedElement.maxOffset);
              const range2 = Range._createFromPositionAndShift(operation.sourcePosition, operation.howMany);
              for (const node of range2.getItems({
                shallow: true
              })) {
                this._setElementState(node, "move");
              }
            }
            break;
          }
          case "detachRoot":
          case "addRoot": {
            const root2 = operation.affectedSelectable;
            if (!root2._isLoaded) {
              return;
            }
            if (root2.isAttached() == operation.isAdd) {
              return;
            }
            this._bufferRootStateChange(operation.rootName, operation.isAdd);
            break;
          }
          case "addRootAttribute":
          case "removeRootAttribute":
          case "changeRootAttribute": {
            if (!operation.root._isLoaded) {
              return;
            }
            const rootName = operation.root.rootName;
            this._bufferRootAttributeChange(rootName, operation.key, operation.oldValue, operation.newValue);
            break;
          }
        }
        this._cachedChanges = null;
      }
      /**
      * Buffers a marker change.
      *
      * @param markerName The name of the marker that changed.
      * @param oldMarkerData Marker data before the change.
      * @param newMarkerData Marker data after the change.
      */
      bufferMarkerChange(markerName, oldMarkerData, newMarkerData) {
        if (oldMarkerData.range && oldMarkerData.range.root.is("rootElement") && !oldMarkerData.range.root._isLoaded) {
          oldMarkerData.range = null;
        }
        if (newMarkerData.range && newMarkerData.range.root.is("rootElement") && !newMarkerData.range.root._isLoaded) {
          newMarkerData.range = null;
        }
        let buffered = this._changedMarkers.get(markerName);
        if (!buffered) {
          buffered = {
            newMarkerData,
            oldMarkerData
          };
          this._changedMarkers.set(markerName, buffered);
        } else {
          buffered.newMarkerData = newMarkerData;
        }
        if (buffered.oldMarkerData.range == null && newMarkerData.range == null) {
          this._changedMarkers.delete(markerName);
        }
      }
      /**
      * Returns all markers that should be removed as a result of buffered changes.
      *
      * @returns Markers to remove. Each array item is an object containing the `name` and `range` properties.
      */
      getMarkersToRemove() {
        const result2 = [];
        for (const [name, change] of this._changedMarkers) {
          if (change.oldMarkerData.range != null) {
            result2.push({
              name,
              range: change.oldMarkerData.range
            });
          }
        }
        return result2;
      }
      /**
      * Returns all markers which should be added as a result of buffered changes.
      *
      * @returns Markers to add. Each array item is an object containing the `name` and `range` properties.
      */
      getMarkersToAdd() {
        const result2 = [];
        for (const [name, change] of this._changedMarkers) {
          if (change.newMarkerData.range != null) {
            result2.push({
              name,
              range: change.newMarkerData.range
            });
          }
        }
        return result2;
      }
      /**
      * Returns all markers which changed.
      */
      getChangedMarkers() {
        return Array.from(this._changedMarkers).map(([name, change]) => ({
          name,
          data: {
            oldRange: change.oldMarkerData.range,
            newRange: change.newMarkerData.range
          }
        }));
      }
      /**
      * Checks whether some of the buffered changes affect the editor data.
      *
      * Types of changes which affect the editor data:
      *
      * * model structure changes,
      * * attribute changes,
      * * a root is added or detached,
      * * changes of markers which were defined as `affectsData`,
      * * changes of markers' `affectsData` property.
      */
      hasDataChanges() {
        if (this.getChanges().length) {
          return true;
        }
        if (this._changedRoots.size > 0) {
          return true;
        }
        for (const { newMarkerData, oldMarkerData } of this._changedMarkers.values()) {
          if (newMarkerData.affectsData !== oldMarkerData.affectsData) {
            return true;
          }
          if (newMarkerData.affectsData) {
            const markerAdded = newMarkerData.range && !oldMarkerData.range;
            const markerRemoved = !newMarkerData.range && oldMarkerData.range;
            const markerChanged = newMarkerData.range && oldMarkerData.range && !newMarkerData.range.isEqual(oldMarkerData.range);
            if (markerAdded || markerRemoved || markerChanged) {
              return true;
            }
          }
        }
        return false;
      }
      /**
      * Calculates the diff between the old model tree state (the state before the first buffered operations since the last {@link #reset}
      * call) and the new model tree state (actual one). It should be called after all buffered operations are executed.
      *
      * The diff set is returned as an array of {@link module:engine/model/differ~DiffItem diff items}, each describing a change done
      * on the model. The items are sorted by the position on which the change happened. If a position
      * {@link module:engine/model/position~Position#isBefore is before} another one, it will be on an earlier index in the diff set.
      *
      * **Note**: Elements inside inserted element will not have a separate diff item, only the top most element change will be reported.
      *
      * Because calculating the diff is a costly operation, the result is cached. If no new operation was buffered since the
      * previous {@link #getChanges} call, the next call will return the cached value.
      *
      * @param options Additional options.
      * @param options.includeChangesInGraveyard If set to `true`, also changes that happened
      * in the graveyard root will be returned. By default, changes in the graveyard root are not returned.
      * @returns Diff between the old and the new model tree state.
      */
      getChanges(options = {}) {
        if (this._cachedChanges) {
          if (options.includeChangesInGraveyard) {
            return this._cachedChangesWithGraveyard.slice();
          } else {
            return this._cachedChanges.slice();
          }
        }
        let diffSet = [];
        for (const element of this._changesInElement.keys()) {
          const changes = this._changesInElement.get(element).sort((a2, b2) => {
            if (a2.offset === b2.offset) {
              if (a2.type != b2.type) {
                return a2.type == "remove" ? -1 : 1;
              }
              return 0;
            }
            return a2.offset < b2.offset ? -1 : 1;
          });
          const childrenBefore = this._elementChildrenSnapshots.get(element);
          const childrenAfter = _getChildrenSnapshots(element.getChildren());
          const diffInstructions = _generateDiffInstructionsFromChanges(childrenBefore.length, changes);
          let i2 = 0;
          let j2 = 0;
          for (const instruction of diffInstructions) {
            if (instruction === "i") {
              const action = this._getDiffActionForNode(childrenAfter[i2].node, "insert");
              const childSnapshotBefore = this._elementsSnapshots.get(childrenAfter[i2].node);
              const diffItem = this._getInsertDiff(element, i2, action, childrenAfter[i2], childSnapshotBefore);
              diffSet.push(diffItem);
              i2++;
            } else if (instruction === "r") {
              const action = this._getDiffActionForNode(childrenBefore[j2].node, "remove");
              const diffItem = this._getRemoveDiff(element, i2, action, childrenBefore[j2]);
              diffSet.push(diffItem);
              j2++;
            } else if (instruction === "a") {
              const beforeAttributes = childrenBefore[j2].attributes;
              const afterAttributes = childrenAfter[i2].attributes;
              let range2;
              if (childrenAfter[i2].name == "$text") {
                range2 = new Range(Position._createAt(element, i2), Position._createAt(element, i2 + 1));
              } else {
                const index = element.offsetToIndex(i2);
                range2 = new Range(Position._createAt(element, i2), Position._createAt(element.getChild(index), 0));
              }
              const diffItems = this._getAttributesDiff(range2, beforeAttributes, afterAttributes);
              diffSet.push(...diffItems);
              i2++;
              j2++;
            } else {
              i2++;
              j2++;
            }
          }
        }
        diffSet.sort((a2, b2) => {
          if (a2.position.root != b2.position.root) {
            return a2.position.root.rootName < b2.position.root.rootName ? -1 : 1;
          }
          if (a2.position.isEqual(b2.position)) {
            return a2.changeCount - b2.changeCount;
          }
          return a2.position.isBefore(b2.position) ? -1 : 1;
        });
        for (let i2 = 1, prevIndex = 0; i2 < diffSet.length; i2++) {
          const prevDiff = diffSet[prevIndex];
          const thisDiff = diffSet[i2];
          const isConsecutiveTextRemove = prevDiff.type == "remove" && thisDiff.type == "remove" && prevDiff.name == "$text" && thisDiff.name == "$text" && prevDiff.position.isEqual(thisDiff.position);
          const isConsecutiveTextAdd = prevDiff.type == "insert" && thisDiff.type == "insert" && prevDiff.name == "$text" && thisDiff.name == "$text" && prevDiff.position.parent == thisDiff.position.parent && prevDiff.position.offset + prevDiff.length == thisDiff.position.offset;
          const isConsecutiveAttributeChange = prevDiff.type == "attribute" && thisDiff.type == "attribute" && prevDiff.position.parent == thisDiff.position.parent && prevDiff.range.isFlat && thisDiff.range.isFlat && prevDiff.position.offset + prevDiff.length == thisDiff.position.offset && prevDiff.attributeKey == thisDiff.attributeKey && prevDiff.attributeOldValue == thisDiff.attributeOldValue && prevDiff.attributeNewValue == thisDiff.attributeNewValue;
          if (isConsecutiveTextRemove || isConsecutiveTextAdd || isConsecutiveAttributeChange) {
            prevDiff.length++;
            if (isConsecutiveAttributeChange) {
              prevDiff.range.end = prevDiff.range.end.getShiftedBy(1);
            }
            diffSet[i2] = null;
          } else {
            prevIndex = i2;
          }
        }
        diffSet = diffSet.filter((v2) => v2);
        for (const item of diffSet) {
          delete item.changeCount;
          if (item.type == "attribute") {
            delete item.position;
            delete item.length;
          }
        }
        this._changeCount = 0;
        this._cachedChangesWithGraveyard = diffSet;
        this._cachedChanges = diffSet.filter(_changesInGraveyardFilter);
        if (options.includeChangesInGraveyard) {
          return this._cachedChangesWithGraveyard.slice();
        } else {
          return this._cachedChanges.slice();
        }
      }
      /**
      * Returns all roots that have changed (either were attached, or detached, or their attributes changed).
      *
      * @returns Diff between the old and the new roots state.
      */
      getChangedRoots() {
        return Array.from(this._changedRoots.values()).map((diffItem) => {
          const entry = {
            ...diffItem
          };
          if (entry.state !== void 0) {
            delete entry.attributes;
          }
          return entry;
        });
      }
      /**
      * Returns a set of model items that were marked to get refreshed.
      */
      getRefreshedItems() {
        return new Set(this._refreshedItems);
      }
      /**
      * Resets `Differ`. Removes all buffered changes.
      */
      reset() {
        this._changesInElement.clear();
        this._elementChildrenSnapshots.clear();
        this._elementsSnapshots.clear();
        this._elementState.clear();
        this._changedMarkers.clear();
        this._changedRoots.clear();
        this._refreshedItems.clear();
        this._cachedChanges = null;
      }
      /**
      * Marks the given `item` in differ to be "refreshed". It means that the item will be marked as removed and inserted
      * in the differ changes set, so it will be effectively re-converted when the differ changes are handled by a dispatcher.
      *
      * @internal
      * @param item Item to refresh.
      */
      _refreshItem(item) {
        if (this._isInInsertedElement(item.parent)) {
          return;
        }
        this._markRemove(item.parent, item.startOffset, item.offsetSize);
        this._markInsert(item.parent, item.startOffset, item.offsetSize);
        this._refreshedItems.add(item);
        this._setElementState(item, "refresh");
        const range2 = Range._createOn(item);
        for (const marker of this._markerCollection.getMarkersIntersectingRange(range2)) {
          const markerData = marker.getData();
          this.bufferMarkerChange(marker.name, markerData, markerData);
        }
        this._cachedChanges = null;
      }
      /**
      * Buffers all the data related to given root like it was all just added to the editor.
      *
      * Following changes are buffered:
      *
      * * root is attached,
      * * all root content is inserted,
      * * all root attributes are added,
      * * all markers inside the root are added.
      *
      * @internal
      */
      _bufferRootLoad(root2) {
        if (!root2.isAttached()) {
          return;
        }
        this._bufferRootStateChange(root2.rootName, true);
        this._markInsert(root2, 0, root2.maxOffset);
        for (const key of root2.getAttributeKeys()) {
          this._bufferRootAttributeChange(root2.rootName, key, null, root2.getAttribute(key));
        }
        for (const marker of this._markerCollection) {
          if (marker.getRange().root == root2) {
            const markerData = marker.getData();
            this.bufferMarkerChange(marker.name, {
              ...markerData,
              range: null
            }, markerData);
          }
        }
      }
      /**
      * Buffers the root state change after the root was attached or detached
      */
      _bufferRootStateChange(rootName, isAttached) {
        if (!this._changedRoots.has(rootName)) {
          this._changedRoots.set(rootName, {
            name: rootName,
            state: isAttached ? "attached" : "detached"
          });
          return;
        }
        const diffItem = this._changedRoots.get(rootName);
        if (diffItem.state !== void 0) {
          delete diffItem.state;
          if (diffItem.attributes === void 0) {
            this._changedRoots.delete(rootName);
          }
        } else {
          diffItem.state = isAttached ? "attached" : "detached";
        }
      }
      /**
      * Buffers a root attribute change.
      */
      _bufferRootAttributeChange(rootName, key, oldValue, newValue) {
        const diffItem = this._changedRoots.get(rootName) || {
          name: rootName
        };
        const attrs = diffItem.attributes || {};
        if (attrs[key]) {
          const attrEntry = attrs[key];
          if (newValue === attrEntry.oldValue) {
            delete attrs[key];
          } else {
            attrEntry.newValue = newValue;
          }
        } else {
          attrs[key] = {
            oldValue,
            newValue
          };
        }
        if (Object.entries(attrs).length === 0) {
          delete diffItem.attributes;
          if (diffItem.state === void 0) {
            this._changedRoots.delete(rootName);
          }
        } else {
          diffItem.attributes = attrs;
          this._changedRoots.set(rootName, diffItem);
        }
      }
      /**
      * Saves and handles an insert change.
      */
      _markInsert(parent2, offset2, howMany) {
        if (parent2.root.is("rootElement") && !parent2.root._isLoaded) {
          return;
        }
        const changeItem = {
          type: "insert",
          offset: offset2,
          howMany,
          count: this._changeCount++
        };
        this._markChange(parent2, changeItem);
      }
      /**
      * Saves and handles a remove change.
      */
      _markRemove(parent2, offset2, howMany) {
        if (parent2.root.is("rootElement") && !parent2.root._isLoaded) {
          return;
        }
        const changeItem = {
          type: "remove",
          offset: offset2,
          howMany,
          count: this._changeCount++
        };
        this._markChange(parent2, changeItem);
        this._removeAllNestedChanges(parent2, offset2, howMany);
      }
      /**
      * Saves and handles an attribute change.
      */
      _markAttribute(item) {
        if (item.root.is("rootElement") && !item.root._isLoaded) {
          return;
        }
        const changeItem = {
          type: "attribute",
          offset: item.startOffset,
          howMany: item.offsetSize,
          count: this._changeCount++
        };
        this._markChange(item.parent, changeItem);
      }
      /**
      * Saves and handles a model change.
      */
      _markChange(parent2, changeItem) {
        this._makeSnapshots(parent2);
        const changes = this._getChangesForElement(parent2);
        this._handleChange(changeItem, changes);
        changes.push(changeItem);
        for (let i2 = 0; i2 < changes.length; i2++) {
          if (changes[i2].howMany < 1) {
            changes.splice(i2, 1);
            i2--;
          }
        }
      }
      /**
      * Tries to set given state for given item.
      *
      * This method does simple validation (it sets the state only for model elements, not for text proxy nodes). It also follows state
      * setting rules, that is, `'refresh'` cannot overwrite `'rename'`, and `'rename'` cannot overwrite `'move'`.
      */
      _setElementState(node, state) {
        if (!node.is("element")) {
          return;
        }
        const currentStatePriority = _Differ._statesPriority.indexOf(this._elementState.get(node));
        const newStatePriority = _Differ._statesPriority.indexOf(state);
        if (newStatePriority > currentStatePriority) {
          this._elementState.set(node, state);
        }
      }
      /**
      * Returns a value for {@link ~DifferItemAction `action`} property for diff items returned by {@link ~Differ#getChanges}.
      * This method aims to return `'rename'` or `'refresh'` when it should, and `diffItemType` ("default action") in all other cases.
      *
      * It bases on a few factors:
      *
      * * for text nodes, the method always returns `diffItemType`,
      * * for newly inserted element, the method returns `diffItemType`,
      * * if {@link ~Differ#_elementState element state} was not recorded, the method returns `diffItemType`,
      * * if state was recorded, and it was `'move'` (default action), the method returns `diffItemType`,
      * * finally, if state was `'refresh'` or `'rename'`, the method returns the state value.
      */
      _getDiffActionForNode(node, diffItemType) {
        if (!node.is("element")) {
          return diffItemType;
        }
        if (!this._elementsSnapshots.has(node)) {
          return diffItemType;
        }
        const state = this._elementState.get(node);
        if (!state || state == "move") {
          return diffItemType;
        }
        return state;
      }
      /**
      * Gets an array of changes that have already been saved for a given element.
      */
      _getChangesForElement(element) {
        let changes;
        if (this._changesInElement.has(element)) {
          changes = this._changesInElement.get(element);
        } else {
          changes = [];
          this._changesInElement.set(element, changes);
        }
        return changes;
      }
      /**
      * Creates and saves a snapshot for all children of the given element.
      */
      _makeSnapshots(element) {
        if (this._elementChildrenSnapshots.has(element)) {
          return;
        }
        const childrenSnapshots = _getChildrenSnapshots(element.getChildren());
        this._elementChildrenSnapshots.set(element, childrenSnapshots);
        for (const snapshot of childrenSnapshots) {
          this._elementsSnapshots.set(snapshot.node, snapshot);
        }
      }
      /**
      * For a given newly saved change, compares it with a change already done on the element and modifies the incoming
      * change and/or the old change.
      *
      * @param inc Incoming (new) change.
      * @param changes An array containing all the changes done on that element.
      */
      _handleChange(inc, changes) {
        inc.nodesToHandle = inc.howMany;
        for (const old of changes) {
          const incEnd = inc.offset + inc.howMany;
          const oldEnd = old.offset + old.howMany;
          if (inc.type == "insert") {
            if (old.type == "insert") {
              if (inc.offset <= old.offset) {
                old.offset += inc.howMany;
              } else if (inc.offset < oldEnd) {
                old.howMany += inc.nodesToHandle;
                inc.nodesToHandle = 0;
              }
            }
            if (old.type == "remove") {
              if (inc.offset < old.offset) {
                old.offset += inc.howMany;
              }
            }
            if (old.type == "attribute") {
              if (inc.offset <= old.offset) {
                old.offset += inc.howMany;
              } else if (inc.offset < oldEnd) {
                const howMany = old.howMany;
                old.howMany = inc.offset - old.offset;
                changes.unshift({
                  type: "attribute",
                  offset: incEnd,
                  howMany: howMany - old.howMany,
                  count: this._changeCount++
                });
              }
            }
          }
          if (inc.type == "remove") {
            if (old.type == "insert") {
              if (incEnd <= old.offset) {
                old.offset -= inc.howMany;
              } else if (incEnd <= oldEnd) {
                if (inc.offset < old.offset) {
                  const intersectionLength = incEnd - old.offset;
                  old.offset = inc.offset;
                  old.howMany -= intersectionLength;
                  inc.nodesToHandle -= intersectionLength;
                } else {
                  old.howMany -= inc.nodesToHandle;
                  inc.nodesToHandle = 0;
                }
              } else {
                if (inc.offset <= old.offset) {
                  inc.nodesToHandle -= old.howMany;
                  old.howMany = 0;
                } else if (inc.offset < oldEnd) {
                  const intersectionLength = oldEnd - inc.offset;
                  old.howMany -= intersectionLength;
                  inc.nodesToHandle -= intersectionLength;
                }
              }
            }
            if (old.type == "remove") {
              if (incEnd <= old.offset) {
                old.offset -= inc.howMany;
              } else if (inc.offset < old.offset) {
                inc.nodesToHandle += old.howMany;
                old.howMany = 0;
              }
            }
            if (old.type == "attribute") {
              if (incEnd <= old.offset) {
                old.offset -= inc.howMany;
              } else if (inc.offset < old.offset) {
                const intersectionLength = incEnd - old.offset;
                old.offset = inc.offset;
                old.howMany -= intersectionLength;
              } else if (inc.offset < oldEnd) {
                if (incEnd <= oldEnd) {
                  const howMany = old.howMany;
                  old.howMany = inc.offset - old.offset;
                  const howManyAfter = howMany - old.howMany - inc.nodesToHandle;
                  changes.unshift({
                    type: "attribute",
                    offset: inc.offset,
                    howMany: howManyAfter,
                    count: this._changeCount++
                  });
                } else {
                  old.howMany -= oldEnd - inc.offset;
                }
              }
            }
          }
          if (inc.type == "attribute") {
            if (old.type == "insert") {
              if (inc.offset < old.offset && incEnd > old.offset) {
                if (incEnd > oldEnd) {
                  const attributePart = {
                    type: "attribute",
                    offset: oldEnd,
                    howMany: incEnd - oldEnd,
                    count: this._changeCount++
                  };
                  this._handleChange(attributePart, changes);
                  changes.push(attributePart);
                }
                inc.nodesToHandle = old.offset - inc.offset;
                inc.howMany = inc.nodesToHandle;
              } else if (inc.offset >= old.offset && inc.offset < oldEnd) {
                if (incEnd > oldEnd) {
                  inc.nodesToHandle = incEnd - oldEnd;
                  inc.offset = oldEnd;
                } else {
                  inc.nodesToHandle = 0;
                }
              }
            }
            if (old.type == "remove") {
              if (inc.offset < old.offset && incEnd > old.offset) {
                const attributePart = {
                  type: "attribute",
                  offset: old.offset,
                  howMany: incEnd - old.offset,
                  count: this._changeCount++
                };
                this._handleChange(attributePart, changes);
                changes.push(attributePart);
                inc.nodesToHandle = old.offset - inc.offset;
                inc.howMany = inc.nodesToHandle;
              }
            }
            if (old.type == "attribute") {
              if (inc.offset >= old.offset && incEnd <= oldEnd) {
                inc.nodesToHandle = 0;
                inc.howMany = 0;
                inc.offset = 0;
              } else if (inc.offset <= old.offset && incEnd >= oldEnd) {
                old.howMany = 0;
              }
            }
          }
        }
        inc.howMany = inc.nodesToHandle;
        delete inc.nodesToHandle;
      }
      /**
      * Returns an object with a single insert change description.
      *
      * @param parent The element in which the change happened.
      * @param offset The offset at which change happened.
      * @param action Further specifies what kind of action led to generating this change.
      * @param elementSnapshot Snapshot of the inserted node after changes.
      * @param elementSnapshotBefore Snapshot of the inserted node before changes.
      * @returns The diff item.
      */
      _getInsertDiff(parent2, offset2, action, elementSnapshot, elementSnapshotBefore) {
        const diffItem = {
          type: "insert",
          position: Position._createAt(parent2, offset2),
          name: elementSnapshot.name,
          attributes: new Map(elementSnapshot.attributes),
          length: 1,
          changeCount: this._changeCount++,
          action
        };
        if (action != "insert" && elementSnapshotBefore) {
          diffItem.before = {
            name: elementSnapshotBefore.name,
            attributes: new Map(elementSnapshotBefore.attributes)
          };
        }
        return diffItem;
      }
      /**
      * Returns an object with a single remove change description.
      *
      * @param parent The element in which change happened.
      * @param offset The offset at which change happened.
      * @param action Further specifies what kind of action led to generating this change.
      * @param elementSnapshot The snapshot of the removed node before changes.
      * @returns The diff item.
      */
      _getRemoveDiff(parent2, offset2, action, elementSnapshot) {
        return {
          type: "remove",
          action,
          position: Position._createAt(parent2, offset2),
          name: elementSnapshot.name,
          attributes: new Map(elementSnapshot.attributes),
          length: 1,
          changeCount: this._changeCount++
        };
      }
      /**
      * Returns an array of objects where each one is a single attribute change description.
      *
      * @param range The range where the change happened.
      * @param oldAttributes A map, map iterator or compatible object that contains attributes before the change.
      * @param newAttributes A map, map iterator or compatible object that contains attributes after the change.
      * @returns An array containing one or more diff items.
      */
      _getAttributesDiff(range2, oldAttributes, newAttributes) {
        const diffs = [];
        newAttributes = new Map(newAttributes);
        for (const [key, oldValue] of oldAttributes) {
          const newValue = newAttributes.has(key) ? newAttributes.get(key) : null;
          if (newValue !== oldValue) {
            diffs.push({
              type: "attribute",
              position: range2.start,
              range: range2.clone(),
              length: 1,
              attributeKey: key,
              attributeOldValue: oldValue,
              attributeNewValue: newValue,
              changeCount: this._changeCount++
            });
          }
          newAttributes.delete(key);
        }
        for (const [key, newValue] of newAttributes) {
          diffs.push({
            type: "attribute",
            position: range2.start,
            range: range2.clone(),
            length: 1,
            attributeKey: key,
            attributeOldValue: null,
            attributeNewValue: newValue,
            changeCount: this._changeCount++
          });
        }
        return diffs;
      }
      /**
      * Checks whether given element or any of its parents is an element that is buffered as an inserted element.
      */
      _isInInsertedElement(element) {
        const parent2 = element.parent;
        if (!parent2) {
          return false;
        }
        const changes = this._changesInElement.get(parent2);
        const offset2 = element.startOffset;
        if (changes) {
          for (const change of changes) {
            if (change.type == "insert" && offset2 >= change.offset && offset2 < change.offset + change.howMany) {
              return true;
            }
          }
        }
        return this._isInInsertedElement(parent2);
      }
      /**
      * Removes deeply all buffered changes that are registered in elements from range specified by `parent`, `offset`
      * and `howMany`.
      */
      _removeAllNestedChanges(parent2, offset2, howMany) {
        const range2 = new Range(Position._createAt(parent2, offset2), Position._createAt(parent2, offset2 + howMany));
        for (const item of range2.getItems({
          shallow: true
        })) {
          if (item.is("element")) {
            this._changesInElement.delete(item);
            this._removeAllNestedChanges(item, 0, item.maxOffset);
          }
        }
      }
    };
    /**
    * Priority of the {@link ~Differ#_elementState element states}. States on higher indexes of the array can overwrite states on the lower
    * indexes.
    */
    __publicField(_Differ, "_statesPriority", [
      void 0,
      "refresh",
      "rename",
      "move"
    ]);
    let Differ = _Differ;
    function _getSingleNodeSnapshot(node) {
      return {
        node,
        name: node.is("$text") ? "$text" : node.name,
        attributes: new Map(node.getAttributes())
      };
    }
    function _getChildrenSnapshots(children) {
      const snapshots = [];
      for (const child of children) {
        if (child.is("$text")) {
          for (let i2 = 0; i2 < child.data.length; ++i2) {
            snapshots.push(_getSingleNodeSnapshot(child));
          }
        } else {
          snapshots.push(_getSingleNodeSnapshot(child));
        }
      }
      return snapshots;
    }
    function _generateDiffInstructionsFromChanges(oldChildrenLength, changes) {
      const diff2 = [];
      let offset2 = 0;
      let oldChildrenHandled = 0;
      for (const change of changes) {
        if (change.offset > offset2) {
          for (let i2 = 0; i2 < change.offset - offset2; i2++) {
            diff2.push("e");
          }
          oldChildrenHandled += change.offset - offset2;
        }
        if (change.type == "insert") {
          for (let i2 = 0; i2 < change.howMany; i2++) {
            diff2.push("i");
          }
          offset2 = change.offset + change.howMany;
        } else if (change.type == "remove") {
          for (let i2 = 0; i2 < change.howMany; i2++) {
            diff2.push("r");
          }
          offset2 = change.offset;
          oldChildrenHandled += change.howMany;
        } else {
          if (change.howMany > 1500) {
            for (let i2 = 0; i2 < change.howMany; i2++) {
              diff2.push("a");
            }
          } else {
            diff2.push(..."a".repeat(change.howMany).split(""));
          }
          offset2 = change.offset + change.howMany;
          oldChildrenHandled += change.howMany;
        }
      }
      if (oldChildrenHandled < oldChildrenLength) {
        for (let i2 = 0; i2 < oldChildrenLength - oldChildrenHandled - offset2; i2++) {
          diff2.push("e");
        }
      }
      return diff2;
    }
    function _changesInGraveyardFilter(entry) {
      const posInGy = "position" in entry && entry.position.root.rootName == "$graveyard";
      const rangeInGy = "range" in entry && entry.range.root.rootName == "$graveyard";
      return !posInGy && !rangeInGy;
    }
    class History {
      constructor() {
        /**
        * Operations added to the history.
        */
        __publicField(this, "_operations", []);
        /**
        * Holds an information which {@link module:engine/model/operation/operation~Operation operation} undoes which
        * {@link module:engine/model/operation/operation~Operation operation}.
        *
        * Keys of the map are "undoing operations", that is operations that undone some other operations. For each key, the
        * value is an operation that has been undone by the "undoing operation".
        */
        __publicField(this, "_undoPairs", /* @__PURE__ */ new Map());
        /**
        * Holds all undone operations.
        */
        __publicField(this, "_undoneOperations", /* @__PURE__ */ new Set());
        /**
        * A map that allows retrieving the operations fast based on the given base version.
        */
        __publicField(this, "_baseVersionToOperationIndex", /* @__PURE__ */ new Map());
        /**
        * The history version.
        */
        __publicField(this, "_version", 0);
        /**
        * The gap pairs kept in the <from,to> format.
        *
        * Anytime the `history.version` is set to a version larger than `history.version + 1`,
        * a new <lastHistoryVersion, newHistoryVersion> entry is added to the map.
        */
        __publicField(this, "_gaps", /* @__PURE__ */ new Map());
      }
      /**
      * The version of the last operation in the history.
      *
      * The history version is incremented automatically when a new operation is added to the history.
      * Setting the version manually should be done only in rare circumstances when a gap is planned
      * between history versions. When doing so, a gap will be created and the history will accept adding
      * an operation with base version equal to the new history version.
      */
      get version() {
        return this._version;
      }
      set version(version2) {
        if (this._operations.length && version2 > this._version + 1) {
          this._gaps.set(this._version, version2);
        }
        this._version = version2;
      }
      /**
      * The last history operation.
      */
      get lastOperation() {
        return this._operations[this._operations.length - 1];
      }
      /**
      * Adds an operation to the history and increments the history version.
      *
      * The operation's base version should be equal to the history version. Otherwise an error is thrown.
      */
      addOperation(operation) {
        if (operation.baseVersion !== this.version) {
          throw new CKEditorError("model-document-history-addoperation-incorrect-version", this, {
            operation,
            historyVersion: this.version
          });
        }
        this._operations.push(operation);
        this._version++;
        this._baseVersionToOperationIndex.set(operation.baseVersion, this._operations.length - 1);
      }
      /**
      * Returns operations from the given range of operation base versions that were added to the history.
      *
      * Note that there may be gaps in operations base versions.
      *
      * @param fromBaseVersion Base version from which operations should be returned (inclusive).
      * @param toBaseVersion Base version up to which operations should be returned (exclusive).
         * @returns History operations for the given range, in chronological order.
      */
      getOperations(fromBaseVersion, toBaseVersion = this.version) {
        if (!this._operations.length) {
          return [];
        }
        const firstOperation = this._operations[0];
        if (fromBaseVersion === void 0) {
          fromBaseVersion = firstOperation.baseVersion;
        }
        let inclusiveTo = toBaseVersion - 1;
        for (const [gapFrom, gapTo] of this._gaps) {
          if (fromBaseVersion > gapFrom && fromBaseVersion < gapTo) {
            fromBaseVersion = gapTo;
          }
          if (inclusiveTo > gapFrom && inclusiveTo < gapTo) {
            inclusiveTo = gapFrom - 1;
          }
        }
        if (inclusiveTo < firstOperation.baseVersion || fromBaseVersion > this.lastOperation.baseVersion) {
          return [];
        }
        let fromIndex = this._baseVersionToOperationIndex.get(fromBaseVersion);
        if (fromIndex === void 0) {
          fromIndex = 0;
        }
        let toIndex = this._baseVersionToOperationIndex.get(inclusiveTo);
        if (toIndex === void 0) {
          toIndex = this._operations.length - 1;
        }
        return this._operations.slice(
          fromIndex,
          // The `toIndex` should be included in the returned operations, so add `1`.
          toIndex + 1
        );
      }
      /**
      * Returns operation from the history that bases on given `baseVersion`.
      *
      * @param baseVersion Base version of the operation to get.
      * @returns Operation with given base version or `undefined` if there is no such operation in history.
      */
      getOperation(baseVersion) {
        const operationIndex = this._baseVersionToOperationIndex.get(baseVersion);
        if (operationIndex === void 0) {
          return;
        }
        return this._operations[operationIndex];
      }
      /**
      * Marks in history that one operation is an operation that is undoing the other operation. By marking operation this way,
      * history is keeping more context information about operations, which helps in operational transformation.
      *
      * @param undoneOperation Operation which is undone by `undoingOperation`.
      * @param undoingOperation Operation which undoes `undoneOperation`.
      */
      setOperationAsUndone(undoneOperation, undoingOperation) {
        this._undoPairs.set(undoingOperation, undoneOperation);
        this._undoneOperations.add(undoneOperation);
      }
      /**
      * Checks whether given `operation` is undoing any other operation.
      *
      * @param operation Operation to check.
      * @returns `true` if given `operation` is undoing any other operation, `false` otherwise.
      */
      isUndoingOperation(operation) {
        return this._undoPairs.has(operation);
      }
      /**
      * Checks whether given `operation` has been undone by any other operation.
      *
      * @param operation Operation to check.
      * @returns `true` if given `operation` has been undone any other operation, `false` otherwise.
      */
      isUndoneOperation(operation) {
        return this._undoneOperations.has(operation);
      }
      /**
      * For given `undoingOperation`, returns the operation which has been undone by it.
      *
      * @returns Operation that has been undone by given `undoingOperation` or `undefined`
      * if given `undoingOperation` is not undoing any other operation.
      */
      getUndoneOperation(undoingOperation) {
        return this._undoPairs.get(undoingOperation);
      }
      /**
      * Resets the history of operations.
      */
      reset() {
        this._version = 0;
        this._undoPairs = /* @__PURE__ */ new Map();
        this._operations = [];
        this._undoneOperations = /* @__PURE__ */ new Set();
        this._gaps = /* @__PURE__ */ new Map();
        this._baseVersionToOperationIndex = /* @__PURE__ */ new Map();
      }
    }
    class RootElement extends Element$2 {
      /**
      * Creates root element.
      *
      * @param document Document that is an owner of this root.
      * @param name Node name.
      * @param rootName Unique root name used to identify this root element by {@link module:engine/model/document~Document}.
      */
      constructor(document2, name, rootName = "main") {
        super(name);
        /**
        * Unique root name used to identify this root element by {@link module:engine/model/document~Document}.
        */
        __publicField(this, "rootName");
        /**
        * Document that is an owner of this root.
        */
        __publicField(this, "_document");
        /**
        * @internal
        */
        __publicField(this, "_isAttached", true);
        /**
        * Informs if the root element is loaded (default).
        *
        * @internal
        */
        __publicField(this, "_isLoaded", true);
        this._document = document2;
        this.rootName = rootName;
      }
      /**
      * {@link module:engine/model/document~Document Document} that owns this root element.
      */
      get document() {
        return this._document;
      }
      /**
      * Informs if the root element is currently attached to the document, or not.
      *
      * A detached root is equivalent to being removed and cannot contain any children or markers.
      *
      * By default, a newly added root is attached. It can be detached using
      * {@link module:engine/model/writer~Writer#detachRoot `Writer#detachRoot`}. A detached root can be re-attached again using
      * {@link module:engine/model/writer~Writer#addRoot `Writer#addRoot`}.
      */
      isAttached() {
        return this._isAttached;
      }
      /**
      * Converts `RootElement` instance to `string` containing its name.
      *
      * @returns `RootElement` instance converted to `string`.
      */
      toJSON() {
        return this.rootName;
      }
    }
    RootElement.prototype.is = function(type, name) {
      if (!name) {
        return type === "rootElement" || type === "model:rootElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === "element" || type === "model:element" || type === "node" || type === "model:node";
      }
      return name === this.name && (type === "rootElement" || type === "model:rootElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
      type === "element" || type === "model:element");
    };
    const graveyardName = "$graveyard";
    class Document extends (/* @__PURE__ */ EmitterMixin()) {
      /**
      * Creates an empty document instance with no {@link #roots} (other than
      * the {@link #graveyard graveyard root}).
      */
      constructor(model) {
        super();
        /**
        * The {@link module:engine/model/model~Model model} that the document is a part of.
        */
        __publicField(this, "model");
        /**
        * The document's history.
        */
        __publicField(this, "history");
        /**
        * The selection in this document.
        */
        __publicField(this, "selection");
        /**
        * A list of roots that are owned and managed by this document. Use {@link #createRoot}, {@link #getRoot} and
        * {@link #getRootNames} to manipulate it.
        */
        __publicField(this, "roots");
        /**
        * The model differ object. Its role is to buffer changes done on the model document and then calculate a diff of those changes.
        */
        __publicField(this, "differ");
        /**
        * Defines whether the document is in a read-only mode.
        *
        * The user should not be able to change the data of a document that is read-only.
        *
        * @readonly
        */
        __publicField(this, "isReadOnly");
        /**
        * Post-fixer callbacks registered to the model document.
        */
        __publicField(this, "_postFixers");
        /**
        * A flag that indicates whether the selection has changed since last change block.
        */
        __publicField(this, "_hasSelectionChangedFromTheLastChangeBlock");
        this.model = model;
        this.history = new History();
        this.selection = new DocumentSelection(this);
        this.roots = new Collection({
          idProperty: "rootName"
        });
        this.differ = new Differ(model.markers);
        this.isReadOnly = false;
        this._postFixers = /* @__PURE__ */ new Set();
        this._hasSelectionChangedFromTheLastChangeBlock = false;
        this.createRoot("$root", graveyardName);
        this.listenTo(model, "applyOperation", (evt, args) => {
          const operation = args[0];
          if (operation.isDocumentOperation) {
            this.differ.bufferOperation(operation);
          }
        }, {
          priority: "high"
        });
        this.listenTo(model, "applyOperation", (evt, args) => {
          const operation = args[0];
          if (operation.isDocumentOperation) {
            this.history.addOperation(operation);
          }
        }, {
          priority: "low"
        });
        this.listenTo(this.selection, "change", () => {
          this._hasSelectionChangedFromTheLastChangeBlock = true;
        });
        this.listenTo(model.markers, "update", (evt, marker, oldRange, newRange, oldMarkerData) => {
          const newMarkerData = {
            ...marker.getData(),
            range: newRange
          };
          this.differ.bufferMarkerChange(marker.name, oldMarkerData, newMarkerData);
          if (oldRange === null) {
            marker.on("change", (evt2, oldRange2) => {
              const markerData = marker.getData();
              this.differ.bufferMarkerChange(marker.name, {
                ...markerData,
                range: oldRange2
              }, markerData);
            });
          }
        });
        this.registerPostFixer((writer) => {
          let result2 = false;
          for (const root2 of this.roots) {
            if (!root2.isAttached() && !root2.isEmpty) {
              writer.remove(writer.createRangeIn(root2));
              result2 = true;
            }
          }
          for (const marker of this.model.markers) {
            if (!marker.getRange().root.isAttached()) {
              writer.removeMarker(marker);
              result2 = true;
            }
          }
          return result2;
        });
      }
      /**
      * The document version. Every applied operation increases the version number. It is used to
      * ensure that operations are applied on a proper document version.
      *
      * This property is equal to {@link module:engine/model/history~History#version `model.Document#history#version`}.
      *
      * If the {@link module:engine/model/operation/operation~Operation#baseVersion base version} does not match the document version,
      * a {@link module:utils/ckeditorerror~CKEditorError model-document-applyoperation-wrong-version} error is thrown.
      */
      get version() {
        return this.history.version;
      }
      set version(version2) {
        this.history.version = version2;
      }
      /**
      * The graveyard tree root. A document always has a graveyard root that stores removed nodes.
      */
      get graveyard() {
        return this.getRoot(graveyardName);
      }
      /**
      * Creates a new root.
      *
      * **Note:** do not use this method after the editor has been initialized! If you want to dynamically add a root, use
      * {@link module:engine/model/writer~Writer#addRoot `model.Writer#addRoot`} instead.
      *
      * @param elementName The element name. Defaults to `'$root'` which also has some basic schema defined
      * (e.g. `$block` elements are allowed inside the `$root`). Make sure to define a proper schema if you use a different name.
      * @param rootName A unique root name.
      * @returns The created root.
      */
      createRoot(elementName = "$root", rootName = "main") {
        if (this.roots.get(rootName)) {
          throw new CKEditorError("model-document-createroot-name-exists", this, {
            name: rootName
          });
        }
        const root2 = new RootElement(this, elementName, rootName);
        this.roots.add(root2);
        return root2;
      }
      /**
      * Removes all event listeners set by the document instance.
      */
      destroy() {
        this.selection.destroy();
        this.stopListening();
      }
      /**
      * Returns a root by its name.
      *
      * Detached roots are returned by this method. This is to be able to operate on the detached root (for example, to be able to create
      * a position inside such a root for undo feature purposes).
      *
      * @param name The root name of the root to return.
      * @returns The root registered under a given name or `null` when there is no root with the given name.
      */
      getRoot(name = "main") {
        return this.roots.get(name);
      }
      /**
      * Returns an array with names of all roots added to the document (except the {@link #graveyard graveyard root}).
      *
      * Detached roots **are not** returned by this method by default. This is to make sure that all features or algorithms that operate
      * on the document data know which roots are still a part of the document and should be processed.
      *
      * @param includeDetached Specified whether detached roots should be returned as well.
      */
      getRootNames(includeDetached = false) {
        return this.getRoots(includeDetached).map((root2) => root2.rootName);
      }
      /**
      * Returns an array with all roots added to the document (except the {@link #graveyard graveyard root}).
      *
      * Detached roots **are not** returned by this method by default. This is to make sure that all features or algorithms that operate
      * on the document data know which roots are still a part of the document and should be processed.
      *
      * @param includeDetached Specified whether detached roots should be returned as well.
      */
      getRoots(includeDetached = false) {
        return this.roots.filter((root2) => root2 != this.graveyard && (includeDetached || root2.isAttached()) && root2._isLoaded);
      }
      /**
      * Used to register a post-fixer callback. A post-fixer mechanism guarantees that the features
      * will operate on a correct model state.
      *
      * An execution of a feature may lead to an incorrect document tree state. The callbacks are used to fix the document tree after
      * it has changed. Post-fixers are fired just after all changes from the outermost change block were applied but
      * before the {@link module:engine/model/document~Document#event:change change event} is fired. If a post-fixer callback made
      * a change, it should return `true`. When this happens, all post-fixers are fired again to check if something else should
      * not be fixed in the new document tree state.
      *
      * As a parameter, a post-fixer callback receives a {@link module:engine/model/writer~Writer writer} instance connected with the
      * executed changes block. Thanks to that, all changes done by the callback will be added to the same
      * {@link module:engine/model/batch~Batch batch} (and undo step) as the original changes. This makes post-fixer changes transparent
      * for the user.
      *
      * An example of a post-fixer is a callback that checks if all the data were removed from the editor. If so, the
      * callback should add an empty paragraph so that the editor is never empty:
      *
      * ```ts
      * document.registerPostFixer( writer => {
      * 	const changes = document.differ.getChanges();
      *
      * 	// Check if the changes lead to an empty root in the editor.
      * 	for ( const entry of changes ) {
      * 		if ( entry.type == 'remove' && entry.position.root.isEmpty ) {
      * 			writer.insertElement( 'paragraph', entry.position.root, 0 );
      *
      * 			// It is fine to return early, even if multiple roots would need to be fixed.
      * 			// All post-fixers will be fired again, so if there are more empty roots, those will be fixed, too.
      * 			return true;
      * 		}
      * 	}
      *
      * 	return false;
      * } );
      * ```
      */
      registerPostFixer(postFixer) {
        this._postFixers.add(postFixer);
      }
      /**
      * A custom `toJSON()` method to solve child-parent circular dependencies.
      *
      * @returns A clone of this object with the document property changed to a string.
      */
      toJSON() {
        const json = clone$1(this);
        json.selection = "[engine.model.DocumentSelection]";
        json.model = "[engine.model.Model]";
        return json;
      }
      /**
      * Check if there were any changes done on document, and if so, call post-fixers,
      * fire `change` event for features and conversion and then reset the differ.
      * Fire `change:data` event when at least one operation or buffered marker changes the data.
      *
      * @internal
      * @fires change
      * @fires change:data
      * @param writer The writer on which post-fixers will be called.
      */
      _handleChangeBlock(writer) {
        if (this._hasDocumentChangedFromTheLastChangeBlock()) {
          this._callPostFixers(writer);
          this.selection.refresh();
          if (this.differ.hasDataChanges()) {
            this.fire("change:data", writer.batch);
          } else {
            this.fire("change", writer.batch);
          }
          this.selection.refresh();
          this.differ.reset();
        }
        this._hasSelectionChangedFromTheLastChangeBlock = false;
      }
      /**
      * Returns whether there is a buffered change or if the selection has changed from the last
      * {@link module:engine/model/model~Model#enqueueChange `enqueueChange()` block}
      * or {@link module:engine/model/model~Model#change `change()` block}.
      *
      * @returns Returns `true` if document has changed from the last `change()` or `enqueueChange()` block.
      */
      _hasDocumentChangedFromTheLastChangeBlock() {
        return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock;
      }
      /**
      * Returns the default root for this document which is either the first root that was added to the document using
      * {@link #createRoot} or the {@link #graveyard graveyard root} if no other roots were created.
      *
      * @returns The default root for this document.
      */
      _getDefaultRoot() {
        const roots = this.getRoots();
        return roots.length ? roots[0] : this.graveyard;
      }
      /**
      * Returns the default range for this selection. The default range is a collapsed range that starts and ends
      * at the beginning of this selection's document {@link #_getDefaultRoot default root}.
      *
      * @internal
      */
      _getDefaultRange() {
        const defaultRoot = this._getDefaultRoot();
        const model = this.model;
        const schema = model.schema;
        const position = model.createPositionFromPath(defaultRoot, [
          0
        ]);
        const nearestRange = schema.getNearestSelectionRange(position);
        return nearestRange || model.createRange(position);
      }
      /**
      * Checks whether a given {@link module:engine/model/range~Range range} is a valid range for
      * the {@link #selection document's selection}.
      *
      * @internal
      * @param range A range to check.
      * @returns `true` if `range` is valid, `false` otherwise.
      */
      _validateSelectionRange(range2) {
        return range2.start.isValid() && range2.end.isValid() && validateTextNodePosition(range2.start) && validateTextNodePosition(range2.end);
      }
      /**
      * Performs post-fixer loops. Executes post-fixer callbacks as long as none of them has done any changes to the model.
      *
      * @param writer The writer on which post-fixer callbacks will be called.
      */
      _callPostFixers(writer) {
        let wasFixed = false;
        do {
          for (const callback of this._postFixers) {
            this.selection.refresh();
            wasFixed = callback(writer);
            if (wasFixed) {
              break;
            }
          }
        } while (wasFixed);
      }
    }
    function validateTextNodePosition(rangeBoundary) {
      const textNode = rangeBoundary.textNode;
      if (textNode) {
        const data = textNode.data;
        const offset2 = rangeBoundary.offset - textNode.startOffset;
        return !isInsideSurrogatePair(data, offset2) && !isInsideCombinedSymbol(data, offset2);
      }
      return true;
    }
    class MarkerCollection extends (/* @__PURE__ */ EmitterMixin()) {
      constructor() {
        super(...arguments);
        /**
        * Stores {@link ~Marker markers} added to the collection.
        */
        __publicField(this, "_markers", /* @__PURE__ */ new Map());
      }
      /**
      * Iterable interface.
      *
      * Iterates over all {@link ~Marker markers} added to the collection.
      */
      [Symbol.iterator]() {
        return this._markers.values();
      }
      /**
      * Checks if given {@link ~Marker marker} or marker name is in the collection.
      *
      * @param markerOrName Name of marker or marker instance to check.
      * @returns `true` if marker is in the collection, `false` otherwise.
      */
      has(markerOrName) {
        const markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;
        return this._markers.has(markerName);
      }
      /**
      * Returns {@link ~Marker marker} with given `markerName`.
      *
      * @param markerName Name of marker to get.
      * @returns Marker with given name or `null` if such marker was
      * not added to the collection.
      */
      get(markerName) {
        return this._markers.get(markerName) || null;
      }
      /**
      * Creates and adds a {@link ~Marker marker} to the `MarkerCollection` with given name on given
      * {@link module:engine/model/range~Range range}.
      *
      * If `MarkerCollection` already had a marker with given name (or {@link ~Marker marker} was passed), the marker in
      * collection is updated and {@link module:engine/model/markercollection~MarkerCollection#event:update} event is fired
      * but only if there was a change (marker range or {@link module:engine/model/markercollection~Marker#managedUsingOperations}
      * flag has changed.
      *
      * @internal
      * @fires update
      * @param markerOrName Name of marker to set or marker instance to update.
      * @param range Marker range.
      * @param managedUsingOperations Specifies whether the marker is managed using operations.
      * @param affectsData Specifies whether the marker affects the data produced by the data pipeline
      * (is persisted in the editor's data).
      * @returns `Marker` instance which was added or updated.
      */
      _set(markerOrName, range2, managedUsingOperations = false, affectsData = false) {
        const markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;
        if (markerName.includes(",")) {
          throw new CKEditorError("markercollection-incorrect-marker-name", this);
        }
        const oldMarker = this._markers.get(markerName);
        if (oldMarker) {
          const oldMarkerData = oldMarker.getData();
          const oldRange = oldMarker.getRange();
          let hasChanged = false;
          if (!oldRange.isEqual(range2)) {
            oldMarker._attachLiveRange(LiveRange.fromRange(range2));
            hasChanged = true;
          }
          if (managedUsingOperations != oldMarker.managedUsingOperations) {
            oldMarker._managedUsingOperations = managedUsingOperations;
            hasChanged = true;
          }
          if (typeof affectsData === "boolean" && affectsData != oldMarker.affectsData) {
            oldMarker._affectsData = affectsData;
            hasChanged = true;
          }
          if (hasChanged) {
            this.fire(`update:${markerName}`, oldMarker, oldRange, range2, oldMarkerData);
          }
          return oldMarker;
        }
        const liveRange = LiveRange.fromRange(range2);
        const marker = new Marker(markerName, liveRange, managedUsingOperations, affectsData);
        this._markers.set(markerName, marker);
        this.fire(`update:${markerName}`, marker, null, range2, {
          ...marker.getData(),
          range: null
        });
        return marker;
      }
      /**
      * Removes given {@link ~Marker marker} or a marker with given name from the `MarkerCollection`.
      *
      * @internal
      * @fires update
      * @param markerOrName Marker or name of a marker to remove.
      * @returns `true` if marker was found and removed, `false` otherwise.
      */
      _remove(markerOrName) {
        const markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;
        const oldMarker = this._markers.get(markerName);
        if (oldMarker) {
          this._markers.delete(markerName);
          this.fire(`update:${markerName}`, oldMarker, oldMarker.getRange(), null, oldMarker.getData());
          this._destroyMarker(oldMarker);
          return true;
        }
        return false;
      }
      /**
      * Fires an {@link module:engine/model/markercollection~MarkerCollection#event:update} event for the given {@link ~Marker marker}
      * but does not change the marker. Useful to force {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher downcast
      * conversion} for the marker.
      *
      * @internal
      * @fires update
      * @param markerOrName Marker or name of a marker to refresh.
      */
      _refresh(markerOrName) {
        const markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;
        const marker = this._markers.get(markerName);
        if (!marker) {
          throw new CKEditorError("markercollection-refresh-marker-not-exists", this);
        }
        const range2 = marker.getRange();
        this.fire(`update:${markerName}`, marker, range2, range2, marker.getData());
      }
      /**
      * Returns iterator that iterates over all markers, which ranges contain given {@link module:engine/model/position~Position position}.
      */
      *getMarkersAtPosition(position) {
        for (const marker of this) {
          if (marker.getRange().containsPosition(position)) {
            yield marker;
          }
        }
      }
      /**
      * Returns iterator that iterates over all markers, which intersects with given {@link module:engine/model/range~Range range}.
      */
      *getMarkersIntersectingRange(range2) {
        for (const marker of this) {
          if (marker.getRange().getIntersection(range2) !== null) {
            yield marker;
          }
        }
      }
      /**
      * Destroys marker collection and all markers inside it.
      */
      destroy() {
        for (const marker of this._markers.values()) {
          this._destroyMarker(marker);
        }
        this._markers = null;
        this.stopListening();
      }
      /**
      * Iterates over all markers that starts with given `prefix`.
      *
      * ```ts
      * const markerFooA = markersCollection._set( 'foo:a', rangeFooA );
      * const markerFooB = markersCollection._set( 'foo:b', rangeFooB );
      * const markerBarA = markersCollection._set( 'bar:a', rangeBarA );
      * const markerFooBarA = markersCollection._set( 'foobar:a', rangeFooBarA );
      * Array.from( markersCollection.getMarkersGroup( 'foo' ) ); // [ markerFooA, markerFooB ]
      * Array.from( markersCollection.getMarkersGroup( 'a' ) ); // []
      * ```
      */
      *getMarkersGroup(prefix) {
        for (const marker of this._markers.values()) {
          if (marker.name.startsWith(prefix + ":")) {
            yield marker;
          }
        }
      }
      /**
      * Destroys the marker.
      */
      _destroyMarker(marker) {
        marker.stopListening();
        marker._detachLiveRange();
      }
    }
    class Marker extends (/* @__PURE__ */ EmitterMixin(TypeCheckable)) {
      /**
      * Creates a marker instance.
      *
      * @param name Marker name.
      * @param liveRange Range marked by the marker.
      * @param managedUsingOperations Specifies whether the marker is managed using operations.
      * @param affectsData Specifies whether the marker affects the data produced by the data pipeline (is persisted in the editor's data).
      */
      constructor(name, liveRange, managedUsingOperations, affectsData) {
        super();
        /**
        * Marker's name.
        */
        __publicField(this, "name");
        /**
        * Flag indicates if the marker is managed using operations or not.
        *
        * @internal
        */
        __publicField(this, "_managedUsingOperations");
        /**
        * Specifies whether the marker affects the data produced by the data pipeline
        * (is persisted in the editor's data).
        *
        * @internal
        */
        __publicField(this, "_affectsData");
        /**
        * Range marked by the marker.
        */
        __publicField(this, "_liveRange");
        this.name = name;
        this._liveRange = this._attachLiveRange(liveRange);
        this._managedUsingOperations = managedUsingOperations;
        this._affectsData = affectsData;
      }
      /**
      * A value indicating if the marker is managed using operations.
      * See {@link ~Marker marker class description} to learn more about marker types.
      * See {@link module:engine/model/writer~Writer#addMarker}.
      */
      get managedUsingOperations() {
        if (!this._liveRange) {
          throw new CKEditorError("marker-destroyed", this);
        }
        return this._managedUsingOperations;
      }
      /**
      * A value indicating if the marker changes the data.
      */
      get affectsData() {
        if (!this._liveRange) {
          throw new CKEditorError("marker-destroyed", this);
        }
        return this._affectsData;
      }
      /**
      * Returns the marker data (properties defining the marker).
      */
      getData() {
        return {
          range: this.getRange(),
          affectsData: this.affectsData,
          managedUsingOperations: this.managedUsingOperations
        };
      }
      /**
      * Returns current marker start position.
      */
      getStart() {
        if (!this._liveRange) {
          throw new CKEditorError("marker-destroyed", this);
        }
        return this._liveRange.start.clone();
      }
      /**
      * Returns current marker end position.
      */
      getEnd() {
        if (!this._liveRange) {
          throw new CKEditorError("marker-destroyed", this);
        }
        return this._liveRange.end.clone();
      }
      /**
      * Returns a range that represents the current state of the marker.
      *
      * Keep in mind that returned value is a {@link module:engine/model/range~Range Range}, not a
      * {@link module:engine/model/liverange~LiveRange LiveRange}. This means that it is up-to-date and relevant only
      * until next model document change. Do not store values returned by this method. Instead, store {@link ~Marker#name}
      * and get `Marker` instance from {@link module:engine/model/markercollection~MarkerCollection MarkerCollection} every
      * time there is a need to read marker properties. This will guarantee that the marker has not been removed and
      * that it's data is up-to-date.
      */
      getRange() {
        if (!this._liveRange) {
          throw new CKEditorError("marker-destroyed", this);
        }
        return this._liveRange.toRange();
      }
      /**
      * Binds new live range to the marker and detach the old one if is attached.
      *
      * @internal
      * @param liveRange Live range to attach
      * @returns Attached live range.
      */
      _attachLiveRange(liveRange) {
        if (this._liveRange) {
          this._detachLiveRange();
        }
        liveRange.delegate("change:range").to(this);
        liveRange.delegate("change:content").to(this);
        this._liveRange = liveRange;
        return liveRange;
      }
      /**
      * Unbinds and destroys currently attached live range.
      *
      * @internal
      */
      _detachLiveRange() {
        this._liveRange.stopDelegating("change:range", this);
        this._liveRange.stopDelegating("change:content", this);
        this._liveRange.detach();
        this._liveRange = null;
      }
    }
    Marker.prototype.is = function(type) {
      return type === "marker" || type === "model:marker";
    };
    class DetachOperation extends Operation {
      /**
      * Creates an insert operation.
      *
      * @param sourcePosition Position before the first {@link module:engine/model/item~Item model item} to move.
      * @param howMany Offset size of moved range. Moved range will start from `sourcePosition` and end at
      * `sourcePosition` with offset shifted by `howMany`.
      */
      constructor(sourcePosition, howMany) {
        super(null);
        /**
        * Position before the first {@link module:engine/model/item~Item model item} to detach.
        */
        __publicField(this, "sourcePosition");
        /**
        * Offset size of moved range.
        */
        __publicField(this, "howMany");
        this.sourcePosition = sourcePosition.clone();
        this.howMany = howMany;
      }
      /**
      * @inheritDoc
      */
      get type() {
        return "detach";
      }
      /**
      * @inheritDoc
      */
      get affectedSelectable() {
        return null;
      }
      /**
      * @inheritDoc
      */
      toJSON() {
        const json = super.toJSON();
        json.sourcePosition = this.sourcePosition.toJSON();
        return json;
      }
      /**
      * @inheritDoc
      * @internal
      */
      _validate() {
        if (this.sourcePosition.root.document) {
          throw new CKEditorError("detach-operation-on-document-node", this);
        }
      }
      /**
      * @inheritDoc
      * @internal
      */
      _execute() {
        _remove(Range._createFromPositionAndShift(this.sourcePosition, this.howMany));
      }
      /**
      * @inheritDoc
      */
      static get className() {
        return "DetachOperation";
      }
    }
    let DocumentFragment$2 = class DocumentFragment2 extends TypeCheckable {
      /**
      * Creates an empty `DocumentFragment`.
      *
      * **Note:** Constructor of this class shouldn't be used directly in the code.
      * Use the {@link module:engine/model/writer~Writer#createDocumentFragment} method instead.
      *
      * @internal
      * @param children Nodes to be contained inside the `DocumentFragment`.
      */
      constructor(children) {
        super();
        /**
        * DocumentFragment static markers map. This is a list of names and {@link module:engine/model/range~Range ranges}
        * which will be set as Markers to {@link module:engine/model/model~Model#markers model markers collection}
        * when DocumentFragment will be inserted to the document.
        */
        __publicField(this, "markers", /* @__PURE__ */ new Map());
        /**
        * List of nodes contained inside the document fragment.
        */
        __publicField(this, "_children", new NodeList());
        if (children) {
          this._insertChild(0, children);
        }
      }
      /**
      * Returns an iterator that iterates over all nodes contained inside this document fragment.
      */
      [Symbol.iterator]() {
        return this.getChildren();
      }
      /**
      * Number of this document fragment's children.
      */
      get childCount() {
        return this._children.length;
      }
      /**
      * Sum of {@link module:engine/model/node~Node#offsetSize offset sizes} of all of this document fragment's children.
      */
      get maxOffset() {
        return this._children.maxOffset;
      }
      /**
      * Is `true` if there are no nodes inside this document fragment, `false` otherwise.
      */
      get isEmpty() {
        return this.childCount === 0;
      }
      /**
      * Artificial next sibling. Returns `null`. Added for compatibility reasons.
      */
      get nextSibling() {
        return null;
      }
      /**
      * Artificial previous sibling. Returns `null`. Added for compatibility reasons.
      */
      get previousSibling() {
        return null;
      }
      /**
      * Artificial root of `DocumentFragment`. Returns itself. Added for compatibility reasons.
      */
      get root() {
        return this;
      }
      /**
      * Artificial parent of `DocumentFragment`. Returns `null`. Added for compatibility reasons.
      */
      get parent() {
        return null;
      }
      /**
      * Artificial owner of `DocumentFragment`. Returns `null`. Added for compatibility reasons.
      */
      get document() {
        return null;
      }
      /**
      * Returns `false` as `DocumentFragment` by definition is not attached to a document. Added for compatibility reasons.
      */
      isAttached() {
        return false;
      }
      /**
      * Returns empty array. Added for compatibility reasons.
      */
      getAncestors() {
        return [];
      }
      /**
      * Gets the child at the given index. Returns `null` if incorrect index was passed.
      *
      * @param index Index in this document fragment.
      * @returns Child node.
      */
      getChild(index) {
        return this._children.getNode(index);
      }
      /**
      * Gets the child at the given offset. Returns `null` if incorrect index was passed.
      *
      * @param offset Offset in this document fragment.
      * @returns Child node.
      */
      getChildAtOffset(offset2) {
        return this._children.getNodeAtOffset(offset2);
      }
      /**
      * Returns an iterator that iterates over all of this document fragment's children.
      */
      getChildren() {
        return this._children[Symbol.iterator]();
      }
      /**
      * Returns an index of the given child node. Returns `null` if given node is not a child of this document fragment.
      *
      * @param node Child node to look for.
      * @returns Child node's index.
      */
      getChildIndex(node) {
        return this._children.getNodeIndex(node);
      }
      /**
      * Returns the starting offset of given child. Starting offset is equal to the sum of
      * {@link module:engine/model/node~Node#offsetSize offset sizes} of all node's siblings that are before it. Returns `null` if
      * given node is not a child of this document fragment.
      *
      * @param node Child node to look for.
      * @returns Child node's starting offset.
      */
      getChildStartOffset(node) {
        return this._children.getNodeStartOffset(node);
      }
      /**
      * Returns path to a `DocumentFragment`, which is an empty array. Added for compatibility reasons.
      */
      getPath() {
        return [];
      }
      /**
      * Returns a descendant node by its path relative to this element.
      *
      * ```ts
      * // <this>a<b>c</b></this>
      * this.getNodeByPath( [ 0 ] );     // -> "a"
      * this.getNodeByPath( [ 1 ] );     // -> <b>
      * this.getNodeByPath( [ 1, 0 ] );  // -> "c"
      * ```
      *
      * @param relativePath Path of the node to find, relative to this element.
      */
      getNodeByPath(relativePath) {
        let node = this;
        for (const offset2 of relativePath) {
          node = node.getChildAtOffset(offset2);
        }
        return node;
      }
      /**
      * Converts offset "position" to index "position".
      *
      * Returns index of a node that occupies given offset. If given offset is too low, returns `0`. If given offset is
      * too high, returns index after last child.
      *
      * ```ts
      * const textNode = new Text( 'foo' );
      * const pElement = new Element( 'p' );
      * const docFrag = new DocumentFragment( [ textNode, pElement ] );
      * docFrag.offsetToIndex( -1 ); // Returns 0, because offset is too low.
      * docFrag.offsetToIndex( 0 ); // Returns 0, because offset 0 is taken by `textNode` which is at index 0.
      * docFrag.offsetToIndex( 1 ); // Returns 0, because `textNode` has `offsetSize` equal to 3, so it occupies offset 1 too.
      * docFrag.offsetToIndex( 2 ); // Returns 0.
      * docFrag.offsetToIndex( 3 ); // Returns 1.
      * docFrag.offsetToIndex( 4 ); // Returns 2. There are no nodes at offset 4, so last available index is returned.
      * ```
      *
      * @param offset Offset to look for.
      * @returns Index of a node that occupies given offset.
      */
      offsetToIndex(offset2) {
        return this._children.offsetToIndex(offset2);
      }
      /**
      * Converts `DocumentFragment` instance to plain object and returns it.
      * Takes care of converting all of this document fragment's children.
      *
      * @returns `DocumentFragment` instance converted to plain object.
      */
      toJSON() {
        const json = [];
        for (const node of this._children) {
          json.push(node.toJSON());
        }
        return json;
      }
      /**
      * Creates a `DocumentFragment` instance from given plain object (i.e. parsed JSON string).
      * Converts `DocumentFragment` children to proper nodes.
      *
      * @param json Plain object to be converted to `DocumentFragment`.
      * @returns `DocumentFragment` instance created using given plain object.
      */
      static fromJSON(json) {
        const children = [];
        for (const child of json) {
          if (child.name) {
            children.push(Element$2.fromJSON(child));
          } else {
            children.push(Text.fromJSON(child));
          }
        }
        return new DocumentFragment2(children);
      }
      /**
      * {@link #_insertChild Inserts} one or more nodes at the end of this document fragment.
      *
      * @internal
      * @param items Items to be inserted.
      */
      _appendChild(items) {
        this._insertChild(this.childCount, items);
      }
      /**
      * Inserts one or more nodes at the given index and sets {@link module:engine/model/node~Node#parent parent} of these nodes
      * to this document fragment.
      *
      * @internal
      * @param index Index at which nodes should be inserted.
      * @param items Items to be inserted.
      */
      _insertChild(index, items) {
        const nodes = normalize$4(items);
        for (const node of nodes) {
          if (node.parent !== null) {
            node._remove();
          }
          node.parent = this;
        }
        this._children._insertNodes(index, nodes);
      }
      /**
      * Removes one or more nodes starting at the given index
      * and sets {@link module:engine/model/node~Node#parent parent} of these nodes to `null`.
      *
      * @internal
      * @param index Index of the first node to remove.
      * @param howMany Number of nodes to remove.
      * @returns Array containing removed nodes.
      */
      _removeChildren(index, howMany = 1) {
        const nodes = this._children._removeNodes(index, howMany);
        for (const node of nodes) {
          node.parent = null;
        }
        return nodes;
      }
    };
    DocumentFragment$2.prototype.is = function(type) {
      return type === "documentFragment" || type === "model:documentFragment";
    };
    function normalize$4(nodes) {
      if (typeof nodes == "string") {
        return [
          new Text(nodes)
        ];
      }
      if (!isIterable(nodes)) {
        nodes = [
          nodes
        ];
      }
      return Array.from(nodes).map((node) => {
        if (typeof node == "string") {
          return new Text(node);
        }
        if (node instanceof TextProxy) {
          return new Text(node.data, node.getAttributes());
        }
        return node;
      });
    }
    class Writer {
      /**
      * Creates a writer instance.
      *
      * **Note:** It is not recommended to use it directly. Use {@link module:engine/model/model~Model#change `Model#change()`} or
      * {@link module:engine/model/model~Model#enqueueChange `Model#enqueueChange()`} instead.
      *
      * @internal
      */
      constructor(model, batch) {
        /**
        * Instance of the model on which this writer operates.
        */
        __publicField(this, "model");
        /**
        * The batch to which this writer will add changes.
        */
        __publicField(this, "batch");
        this.model = model;
        this.batch = batch;
      }
      /**
      * Creates a new {@link module:engine/model/text~Text text node}.
      *
      * ```ts
      * writer.createText( 'foo' );
      * writer.createText( 'foo', { bold: true } );
      * ```
      *
      * @param data Text data.
      * @param attributes Text attributes.
      * @returns {module:engine/model/text~Text} Created text node.
      */
      createText(data, attributes) {
        return new Text(data, attributes);
      }
      /**
      * Creates a new {@link module:engine/model/element~Element element}.
      *
      * ```ts
      * writer.createElement( 'paragraph' );
      * writer.createElement( 'paragraph', { alignment: 'center' } );
      * ```
      *
      * @param name Name of the element.
      * @param attributes Elements attributes.
      * @returns Created element.
      */
      createElement(name, attributes) {
        return new Element$2(name, attributes);
      }
      /**
      * Creates a new {@link module:engine/model/documentfragment~DocumentFragment document fragment}.
      *
      * @returns Created document fragment.
      */
      createDocumentFragment() {
        return new DocumentFragment$2();
      }
      /**
      * Creates a copy of the element and returns it. Created element has the same name and attributes as the original element.
      * If clone is deep, the original element's children are also cloned. If not, then empty element is returned.
      *
      * @param element The element to clone.
      * @param deep If set to `true` clones element and all its children recursively. When set to `false`,
      * element will be cloned without any child.
      */
      cloneElement(element, deep = true) {
        return element._clone(deep);
      }
      /**
      * Inserts item on given position.
      *
      * ```ts
      * const paragraph = writer.createElement( 'paragraph' );
      * writer.insert( paragraph, position );
      * ```
      *
      * Instead of using position you can use parent and offset:
      *
      * ```ts
      * const text = writer.createText( 'foo' );
      * writer.insert( text, paragraph, 5 );
      * ```
      *
      * You can also use `end` instead of the offset to insert at the end:
      *
      * ```ts
      * const text = writer.createText( 'foo' );
      * writer.insert( text, paragraph, 'end' );
      * ```
      *
      * Or insert before or after another element:
      *
      * ```ts
      * const paragraph = writer.createElement( 'paragraph' );
      * writer.insert( paragraph, anotherParagraph, 'after' );
      * ```
      *
      * These parameters works the same way as {@link #createPositionAt `writer.createPositionAt()`}.
      *
      * Note that if the item already has parent it will be removed from the previous parent.
      *
      * Note that you cannot re-insert a node from a document to a different document or a document fragment. In this case,
      * `model-writer-insert-forbidden-move` is thrown.
      *
      * If you want to move {@link module:engine/model/range~Range range} instead of an
      * {@link module:engine/model/item~Item item} use {@link module:engine/model/writer~Writer#move `Writer#move()`}.
      *
      * **Note:** For a paste-like content insertion mechanism see
      * {@link module:engine/model/model~Model#insertContent `model.insertContent()`}.
      *
      * @param item Item or document fragment to insert.
      * @param offset Offset or one of the flags. Used only when second parameter is a {@link module:engine/model/item~Item model item}.
      */
      insert(item, itemOrPosition, offset2 = 0) {
        this._assertWriterUsedCorrectly();
        if (item instanceof Text && item.data == "") {
          return;
        }
        const position = Position._createAt(itemOrPosition, offset2);
        if (item.parent) {
          if (isSameTree(item.root, position.root)) {
            this.move(Range._createOn(item), position);
            return;
          } else {
            if (item.root.document) {
              throw new CKEditorError("model-writer-insert-forbidden-move", this);
            } else {
              this.remove(item);
            }
          }
        }
        const version2 = position.root.document ? position.root.document.version : null;
        const insert = new InsertOperation(position, item, version2);
        if (item instanceof Text) {
          insert.shouldReceiveAttributes = true;
        }
        this.batch.addOperation(insert);
        this.model.applyOperation(insert);
        if (item instanceof DocumentFragment$2) {
          for (const [markerName, markerRange] of item.markers) {
            const rangeRootPosition = Position._createAt(markerRange.root, 0);
            const range2 = new Range(markerRange.start._getCombined(rangeRootPosition, position), markerRange.end._getCombined(rangeRootPosition, position));
            const options = {
              range: range2,
              usingOperation: true,
              affectsData: true
            };
            if (this.model.markers.has(markerName)) {
              this.updateMarker(markerName, options);
            } else {
              this.addMarker(markerName, options);
            }
          }
        }
      }
      insertText(text2, attributes, itemOrPosition, offset2) {
        if (attributes instanceof DocumentFragment$2 || attributes instanceof Element$2 || attributes instanceof Position) {
          this.insert(this.createText(text2), attributes, itemOrPosition);
        } else {
          this.insert(this.createText(text2, attributes), itemOrPosition, offset2);
        }
      }
      insertElement(name, attributes, itemOrPositionOrOffset, offset2) {
        if (attributes instanceof DocumentFragment$2 || attributes instanceof Element$2 || attributes instanceof Position) {
          this.insert(this.createElement(name), attributes, itemOrPositionOrOffset);
        } else {
          this.insert(this.createElement(name, attributes), itemOrPositionOrOffset, offset2);
        }
      }
      /**
      * Inserts item at the end of the given parent.
      *
      * ```ts
      * const paragraph = writer.createElement( 'paragraph' );
      * writer.append( paragraph, root );
      * ```
      *
      * Note that if the item already has parent it will be removed from the previous parent.
      *
      * If you want to move {@link module:engine/model/range~Range range} instead of an
      * {@link module:engine/model/item~Item item} use {@link module:engine/model/writer~Writer#move `Writer#move()`}.
      *
      * @param item Item or document fragment to insert.
      */
      append(item, parent2) {
        this.insert(item, parent2, "end");
      }
      appendText(text2, attributes, parent2) {
        if (attributes instanceof DocumentFragment$2 || attributes instanceof Element$2) {
          this.insert(this.createText(text2), attributes, "end");
        } else {
          this.insert(this.createText(text2, attributes), parent2, "end");
        }
      }
      appendElement(name, attributes, parent2) {
        if (attributes instanceof DocumentFragment$2 || attributes instanceof Element$2) {
          this.insert(this.createElement(name), attributes, "end");
        } else {
          this.insert(this.createElement(name, attributes), parent2, "end");
        }
      }
      /**
      * Sets value of the attribute with given key on a {@link module:engine/model/item~Item model item}
      * or on a {@link module:engine/model/range~Range range}.
      *
      * @param key Attribute key.
      * @param value Attribute new value.
      * @param itemOrRange Model item or range on which the attribute will be set.
      */
      setAttribute(key, value, itemOrRange) {
        this._assertWriterUsedCorrectly();
        if (itemOrRange instanceof Range) {
          const ranges = itemOrRange.getMinimalFlatRanges();
          for (const range2 of ranges) {
            setAttributeOnRange(this, key, value, range2);
          }
        } else {
          setAttributeOnItem(this, key, value, itemOrRange);
        }
      }
      /**
      * Sets values of attributes on a {@link module:engine/model/item~Item model item}
      * or on a {@link module:engine/model/range~Range range}.
      *
      * ```ts
      * writer.setAttributes( {
      * 	bold: true,
      * 	italic: true
      * }, range );
      * ```
      *
      * @param attributes Attributes keys and values.
      * @param itemOrRange Model item or range on which the attributes will be set.
      */
      setAttributes(attributes, itemOrRange) {
        for (const [key, val] of toMap(attributes)) {
          this.setAttribute(key, val, itemOrRange);
        }
      }
      /**
      * Removes an attribute with given key from a {@link module:engine/model/item~Item model item}
      * or from a {@link module:engine/model/range~Range range}.
      *
      * @param key Attribute key.
      * @param itemOrRange Model item or range from which the attribute will be removed.
      */
      removeAttribute(key, itemOrRange) {
        this._assertWriterUsedCorrectly();
        if (itemOrRange instanceof Range) {
          const ranges = itemOrRange.getMinimalFlatRanges();
          for (const range2 of ranges) {
            setAttributeOnRange(this, key, null, range2);
          }
        } else {
          setAttributeOnItem(this, key, null, itemOrRange);
        }
      }
      /**
      * Removes all attributes from all elements in the range or from the given item.
      *
      * @param itemOrRange Model item or range from which all attributes will be removed.
      */
      clearAttributes(itemOrRange) {
        this._assertWriterUsedCorrectly();
        const removeAttributesFromItem = (item) => {
          for (const attribute of item.getAttributeKeys()) {
            this.removeAttribute(attribute, item);
          }
        };
        if (!(itemOrRange instanceof Range)) {
          removeAttributesFromItem(itemOrRange);
        } else {
          for (const item of itemOrRange.getItems()) {
            removeAttributesFromItem(item);
          }
        }
      }
      /**
      * Moves all items in the source range to the target position.
      *
      * ```ts
      * writer.move( sourceRange, targetPosition );
      * ```
      *
      * Instead of the target position you can use parent and offset or define that range should be moved to the end
      * or before or after chosen item:
      *
      * ```ts
      * // Moves all items in the range to the paragraph at offset 5:
      * writer.move( sourceRange, paragraph, 5 );
      * // Moves all items in the range to the end of a blockquote:
      * writer.move( sourceRange, blockquote, 'end' );
      * // Moves all items in the range to a position after an image:
      * writer.move( sourceRange, image, 'after' );
      * ```
      *
      * These parameters work the same way as {@link #createPositionAt `writer.createPositionAt()`}.
      *
      * Note that items can be moved only within the same tree. It means that you can move items within the same root
      * (element or document fragment) or between {@link module:engine/model/document~Document#roots documents roots},
      * but you can not move items from document fragment to the document or from one detached element to another. Use
      * {@link module:engine/model/writer~Writer#insert} in such cases.
      *
      * @param range Source range.
      * @param offset Offset or one of the flags. Used only when second parameter is a {@link module:engine/model/item~Item model item}.
      */
      move(range2, itemOrPosition, offset2) {
        this._assertWriterUsedCorrectly();
        if (!(range2 instanceof Range)) {
          throw new CKEditorError("writer-move-invalid-range", this);
        }
        if (!range2.isFlat) {
          throw new CKEditorError("writer-move-range-not-flat", this);
        }
        const position = Position._createAt(itemOrPosition, offset2);
        if (position.isEqual(range2.start)) {
          return;
        }
        this._addOperationForAffectedMarkers("move", range2);
        if (!isSameTree(range2.root, position.root)) {
          throw new CKEditorError("writer-move-different-document", this);
        }
        const version2 = range2.root.document ? range2.root.document.version : null;
        const operation = new MoveOperation(range2.start, range2.end.offset - range2.start.offset, position, version2);
        this.batch.addOperation(operation);
        this.model.applyOperation(operation);
      }
      /**
      * Removes given model {@link module:engine/model/item~Item item} or {@link module:engine/model/range~Range range}.
      *
      * @param itemOrRange Model item or range to remove.
      */
      remove(itemOrRange) {
        this._assertWriterUsedCorrectly();
        const rangeToRemove = itemOrRange instanceof Range ? itemOrRange : Range._createOn(itemOrRange);
        const ranges = rangeToRemove.getMinimalFlatRanges().reverse();
        for (const flat of ranges) {
          this._addOperationForAffectedMarkers("move", flat);
          applyRemoveOperation(flat.start, flat.end.offset - flat.start.offset, this.batch, this.model);
        }
      }
      /**
      * Merges two siblings at the given position.
      *
      * Node before and after the position have to be an element. Otherwise `writer-merge-no-element-before` or
      * `writer-merge-no-element-after` error will be thrown.
      *
      * @param position Position between merged elements.
      */
      merge(position) {
        this._assertWriterUsedCorrectly();
        const nodeBefore = position.nodeBefore;
        const nodeAfter = position.nodeAfter;
        this._addOperationForAffectedMarkers("merge", position);
        if (!(nodeBefore instanceof Element$2)) {
          throw new CKEditorError("writer-merge-no-element-before", this);
        }
        if (!(nodeAfter instanceof Element$2)) {
          throw new CKEditorError("writer-merge-no-element-after", this);
        }
        if (!position.root.document) {
          this._mergeDetached(position);
        } else {
          this._merge(position);
        }
      }
      /**
      * Shortcut for {@link module:engine/model/model~Model#createPositionFromPath `Model#createPositionFromPath()`}.
      *
      * @param root Root of the position.
      * @param path Position path. See {@link module:engine/model/position~Position#path}.
      * @param stickiness Position stickiness. See {@link module:engine/model/position~PositionStickiness}.
      */
      createPositionFromPath(root2, path, stickiness) {
        return this.model.createPositionFromPath(root2, path, stickiness);
      }
      /**
      * Shortcut for {@link module:engine/model/model~Model#createPositionAt `Model#createPositionAt()`}.
      *
      * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/model/item~Item model item}.
      */
      createPositionAt(itemOrPosition, offset2) {
        return this.model.createPositionAt(itemOrPosition, offset2);
      }
      /**
      * Shortcut for {@link module:engine/model/model~Model#createPositionAfter `Model#createPositionAfter()`}.
      *
      * @param item Item after which the position should be placed.
      */
      createPositionAfter(item) {
        return this.model.createPositionAfter(item);
      }
      /**
      * Shortcut for {@link module:engine/model/model~Model#createPositionBefore `Model#createPositionBefore()`}.
      *
      * @param item Item after which the position should be placed.
      */
      createPositionBefore(item) {
        return this.model.createPositionBefore(item);
      }
      /**
      * Shortcut for {@link module:engine/model/model~Model#createRange `Model#createRange()`}.
      *
      * @param start Start position.
      * @param end End position. If not set, range will be collapsed at `start` position.
      */
      createRange(start2, end2) {
        return this.model.createRange(start2, end2);
      }
      /**
      * Shortcut for {@link module:engine/model/model~Model#createRangeIn `Model#createRangeIn()`}.
      *
      * @param element Element which is a parent for the range.
      */
      createRangeIn(element) {
        return this.model.createRangeIn(element);
      }
      /**
      * Shortcut for {@link module:engine/model/model~Model#createRangeOn `Model#createRangeOn()`}.
      *
      * @param element Element which is a parent for the range.
      */
      createRangeOn(element) {
        return this.model.createRangeOn(element);
      }
      createSelection(...args) {
        return this.model.createSelection(...args);
      }
      /**
      * Performs merge action in a detached tree.
      *
      * @param position Position between merged elements.
      */
      _mergeDetached(position) {
        const nodeBefore = position.nodeBefore;
        const nodeAfter = position.nodeAfter;
        this.move(Range._createIn(nodeAfter), Position._createAt(nodeBefore, "end"));
        this.remove(nodeAfter);
      }
      /**
      * Performs merge action in a non-detached tree.
      *
      * @param position Position between merged elements.
      */
      _merge(position) {
        const targetPosition = Position._createAt(position.nodeBefore, "end");
        const sourcePosition = Position._createAt(position.nodeAfter, 0);
        const graveyard = position.root.document.graveyard;
        const graveyardPosition = new Position(graveyard, [
          0
        ]);
        const version2 = position.root.document.version;
        const merge2 = new MergeOperation(sourcePosition, position.nodeAfter.maxOffset, targetPosition, graveyardPosition, version2);
        this.batch.addOperation(merge2);
        this.model.applyOperation(merge2);
      }
      /**
      * Renames the given element.
      *
      * @param element The element to rename.
      * @param newName New element name.
      */
      rename(element, newName) {
        this._assertWriterUsedCorrectly();
        if (!(element instanceof Element$2)) {
          throw new CKEditorError("writer-rename-not-element-instance", this);
        }
        const version2 = element.root.document ? element.root.document.version : null;
        const renameOperation = new RenameOperation(Position._createBefore(element), element.name, newName, version2);
        this.batch.addOperation(renameOperation);
        this.model.applyOperation(renameOperation);
      }
      /**
      * Splits elements starting from the given position and going to the top of the model tree as long as given
      * `limitElement` is reached. When `limitElement` is not defined then only the parent of the given position will be split.
      *
      * The element needs to have a parent. It cannot be a root element nor a document fragment.
      * The `writer-split-element-no-parent` error will be thrown if you try to split an element with no parent.
      *
      * @param position Position of split.
      * @param limitElement Stop splitting when this element will be reached.
      * @returns Split result with properties:
      * * `position` - Position between split elements.
      * * `range` - Range that stars from the end of the first split element and ends at the beginning of the first copy element.
      */
      split(position, limitElement) {
        this._assertWriterUsedCorrectly();
        let splitElement = position.parent;
        if (!splitElement.parent) {
          throw new CKEditorError("writer-split-element-no-parent", this);
        }
        if (!limitElement) {
          limitElement = splitElement.parent;
        }
        if (!position.parent.getAncestors({
          includeSelf: true
        }).includes(limitElement)) {
          throw new CKEditorError("writer-split-invalid-limit-element", this);
        }
        let firstSplitElement;
        let firstCopyElement;
        do {
          const version2 = splitElement.root.document ? splitElement.root.document.version : null;
          const howMany = splitElement.maxOffset - position.offset;
          const insertionPosition = SplitOperation.getInsertionPosition(position);
          const split2 = new SplitOperation(position, howMany, insertionPosition, null, version2);
          this.batch.addOperation(split2);
          this.model.applyOperation(split2);
          if (!firstSplitElement && !firstCopyElement) {
            firstSplitElement = splitElement;
            firstCopyElement = position.parent.nextSibling;
          }
          position = this.createPositionAfter(position.parent);
          splitElement = position.parent;
        } while (splitElement !== limitElement);
        return {
          position,
          range: new Range(Position._createAt(firstSplitElement, "end"), Position._createAt(firstCopyElement, 0))
        };
      }
      /**
      * Wraps the given range with the given element or with a new element (if a string was passed).
      *
      * **Note:** range to wrap should be a "flat range" (see {@link module:engine/model/range~Range#isFlat `Range#isFlat`}).
      * If not, an error will be thrown.
      *
      * @param range Range to wrap.
      * @param elementOrString Element or name of element to wrap the range with.
      */
      wrap(range2, elementOrString) {
        this._assertWriterUsedCorrectly();
        if (!range2.isFlat) {
          throw new CKEditorError("writer-wrap-range-not-flat", this);
        }
        const element = elementOrString instanceof Element$2 ? elementOrString : new Element$2(elementOrString);
        if (element.childCount > 0) {
          throw new CKEditorError("writer-wrap-element-not-empty", this);
        }
        if (element.parent !== null) {
          throw new CKEditorError("writer-wrap-element-attached", this);
        }
        this.insert(element, range2.start);
        const shiftedRange = new Range(range2.start.getShiftedBy(1), range2.end.getShiftedBy(1));
        this.move(shiftedRange, Position._createAt(element, 0));
      }
      /**
      * Unwraps children of the given element  all its children are moved before it and then the element is removed.
      * Throws error if you try to unwrap an element which does not have a parent.
      *
      * @param element Element to unwrap.
      */
      unwrap(element) {
        this._assertWriterUsedCorrectly();
        if (element.parent === null) {
          throw new CKEditorError("writer-unwrap-element-no-parent", this);
        }
        this.move(Range._createIn(element), this.createPositionAfter(element));
        this.remove(element);
      }
      /**
      * Adds a {@link module:engine/model/markercollection~Marker marker}. Marker is a named range, which tracks
      * changes in the document and updates its range automatically, when model tree changes.
      *
      * As the first parameter you can set marker name.
      *
      * The required `options.usingOperation` parameter lets you decide if the marker should be managed by operations or not. See
      * {@link module:engine/model/markercollection~Marker marker class description} to learn about the difference between
      * markers managed by operations and not-managed by operations.
      *
      * The `options.affectsData` parameter, which defaults to `false`, allows you to define if a marker affects the data. It should be
      * `true` when the marker change changes the data returned by the
      * {@link module:core/editor/editor~Editor#getData `editor.getData()`} method.
      * When set to `true` it fires the {@link module:engine/model/document~Document#event:change:data `change:data`} event.
      * When set to `false` it fires the {@link module:engine/model/document~Document#event:change `change`} event.
      *
      * Create marker directly base on marker's name:
      *
      * ```ts
      * addMarker( markerName, { range, usingOperation: false } );
      * ```
      *
      * Create marker using operation:
      *
      * ```ts
      * addMarker( markerName, { range, usingOperation: true } );
      * ```
      *
      * Create marker that affects the editor data:
      *
      * ```ts
      * addMarker( markerName, { range, usingOperation: false, affectsData: true } );
      * ```
      *
      * Note: For efficiency reasons, it's best to create and keep as little markers as possible.
      *
      * @see module:engine/model/markercollection~Marker
      * @param name Name of a marker to create - must be unique.
      * @param options.usingOperation Flag indicating that the marker should be added by MarkerOperation.
      * See {@link module:engine/model/markercollection~Marker#managedUsingOperations}.
      * @param options.range Marker range.
      * @param options.affectsData Flag indicating that the marker changes the editor data.
      * @returns Marker that was set.
      */
      addMarker(name, options) {
        this._assertWriterUsedCorrectly();
        if (!options || typeof options.usingOperation != "boolean") {
          throw new CKEditorError("writer-addmarker-no-usingoperation", this);
        }
        const usingOperation = options.usingOperation;
        const range2 = options.range;
        const affectsData = options.affectsData === void 0 ? false : options.affectsData;
        if (this.model.markers.has(name)) {
          throw new CKEditorError("writer-addmarker-marker-exists", this);
        }
        if (!range2) {
          throw new CKEditorError("writer-addmarker-no-range", this);
        }
        if (!usingOperation) {
          return this.model.markers._set(name, range2, usingOperation, affectsData);
        }
        applyMarkerOperation(this, name, null, range2, affectsData);
        return this.model.markers.get(name);
      }
      /**
      * Adds, updates or refreshes a {@link module:engine/model/markercollection~Marker marker}. Marker is a named range, which tracks
      * changes in the document and updates its range automatically, when model tree changes. Still, it is possible to change the
      * marker's range directly using this method.
      *
      * As the first parameter you can set marker name or instance. If none of them is provided, new marker, with a unique
      * name is created and returned.
      *
      * **Note**: If you want to change the {@link module:engine/view/element~Element view element} of the marker while its data in the model
      * remains the same, use the dedicated {@link module:engine/controller/editingcontroller~EditingController#reconvertMarker} method.
      *
      * The `options.usingOperation` parameter lets you change if the marker should be managed by operations or not. See
      * {@link module:engine/model/markercollection~Marker marker class description} to learn about the difference between
      * markers managed by operations and not-managed by operations. It is possible to change this option for an existing marker.
      *
      * The `options.affectsData` parameter, which defaults to `false`, allows you to define if a marker affects the data. It should be
      * `true` when the marker change changes the data returned by
      * the {@link module:core/editor/editor~Editor#getData `editor.getData()`} method.
      * When set to `true` it fires the {@link module:engine/model/document~Document#event:change:data `change:data`} event.
      * When set to `false` it fires the {@link module:engine/model/document~Document#event:change `change`} event.
      *
      * Update marker directly base on marker's name:
      *
      * ```ts
      * updateMarker( markerName, { range } );
      * ```
      *
      * Update marker using operation:
      *
      * ```ts
      * updateMarker( marker, { range, usingOperation: true } );
      * updateMarker( markerName, { range, usingOperation: true } );
      * ```
      *
      * Change marker's option (start using operations to manage it):
      *
      * ```ts
      * updateMarker( marker, { usingOperation: true } );
      * ```
      *
      * Change marker's option (inform the engine, that the marker does not affect the data anymore):
      *
      * ```ts
      * updateMarker( markerName, { affectsData: false } );
      * ```
      *
      * @see module:engine/model/markercollection~Marker
      * @param markerOrName Name of a marker to update, or a marker instance.
      * @param options If options object is not defined then marker will be refreshed by triggering
      * downcast conversion for this marker with the same data.
      * @param options.range Marker range to update.
      * @param options.usingOperation Flag indicated whether the marker should be added by MarkerOperation.
      * See {@link module:engine/model/markercollection~Marker#managedUsingOperations}.
      * @param options.affectsData Flag indicating that the marker changes the editor data.
      */
      updateMarker(markerOrName, options) {
        this._assertWriterUsedCorrectly();
        const markerName = typeof markerOrName == "string" ? markerOrName : markerOrName.name;
        const currentMarker = this.model.markers.get(markerName);
        if (!currentMarker) {
          throw new CKEditorError("writer-updatemarker-marker-not-exists", this);
        }
        if (!options) {
          logWarning("writer-updatemarker-reconvert-using-editingcontroller", {
            markerName
          });
          this.model.markers._refresh(currentMarker);
          return;
        }
        const hasUsingOperationDefined = typeof options.usingOperation == "boolean";
        const affectsDataDefined = typeof options.affectsData == "boolean";
        const affectsData = affectsDataDefined ? options.affectsData : currentMarker.affectsData;
        if (!hasUsingOperationDefined && !options.range && !affectsDataDefined) {
          throw new CKEditorError("writer-updatemarker-wrong-options", this);
        }
        const currentRange = currentMarker.getRange();
        const updatedRange = options.range ? options.range : currentRange;
        if (hasUsingOperationDefined && options.usingOperation !== currentMarker.managedUsingOperations) {
          if (options.usingOperation) {
            applyMarkerOperation(this, markerName, null, updatedRange, affectsData);
          } else {
            applyMarkerOperation(this, markerName, currentRange, null, affectsData);
            this.model.markers._set(markerName, updatedRange, void 0, affectsData);
          }
          return;
        }
        if (currentMarker.managedUsingOperations) {
          applyMarkerOperation(this, markerName, currentRange, updatedRange, affectsData);
        } else {
          this.model.markers._set(markerName, updatedRange, void 0, affectsData);
        }
      }
      /**
      * Removes given {@link module:engine/model/markercollection~Marker marker} or marker with given name.
      * The marker is removed accordingly to how it has been created, so if the marker was created using operation,
      * it will be destroyed using operation.
      *
      * @param markerOrName Marker or marker name to remove.
      */
      removeMarker(markerOrName) {
        this._assertWriterUsedCorrectly();
        const name = typeof markerOrName == "string" ? markerOrName : markerOrName.name;
        if (!this.model.markers.has(name)) {
          throw new CKEditorError("writer-removemarker-no-marker", this);
        }
        const marker = this.model.markers.get(name);
        if (!marker.managedUsingOperations) {
          this.model.markers._remove(name);
          return;
        }
        const oldRange = marker.getRange();
        applyMarkerOperation(this, name, oldRange, null, marker.affectsData);
      }
      /**
      * Adds a new root to the document (or re-attaches a {@link #detachRoot detached root}).
      *
      * Throws an error, if trying to add a root that is already added and attached.
      *
      * @param rootName Name of the added root.
      * @param elementName The element name. Defaults to `'$root'` which also has some basic schema defined
      * (e.g. `$block` elements are allowed inside the `$root`). Make sure to define a proper schema if you use a different name.
      * @returns The added root element.
      */
      addRoot(rootName, elementName = "$root") {
        this._assertWriterUsedCorrectly();
        const root2 = this.model.document.getRoot(rootName);
        if (root2 && root2.isAttached()) {
          throw new CKEditorError("writer-addroot-root-exists", this);
        }
        const document2 = this.model.document;
        const operation = new RootOperation(rootName, elementName, true, document2, document2.version);
        this.batch.addOperation(operation);
        this.model.applyOperation(operation);
        return this.model.document.getRoot(rootName);
      }
      /**
      * Detaches the root from the document.
      *
      * All content and markers are removed from the root upon detaching. New content and new markers cannot be added to the root, as long
      * as it is detached.
      *
      * A root cannot be fully removed from the document, it can be only detached. A root is permanently removed only after you
      * re-initialize the editor and do not specify the root in the initial data.
      *
      * A detached root can be re-attached using {@link #addRoot}.
      *
      * Throws an error if the root does not exist or the root is already detached.
      *
      * @param rootOrName Name of the detached root.
      */
      detachRoot(rootOrName) {
        this._assertWriterUsedCorrectly();
        const root2 = typeof rootOrName == "string" ? this.model.document.getRoot(rootOrName) : rootOrName;
        if (!root2 || !root2.isAttached()) {
          throw new CKEditorError("writer-detachroot-no-root", this);
        }
        for (const marker of this.model.markers) {
          if (marker.getRange().root === root2) {
            this.removeMarker(marker);
          }
        }
        for (const key of root2.getAttributeKeys()) {
          this.removeAttribute(key, root2);
        }
        this.remove(this.createRangeIn(root2));
        const document2 = this.model.document;
        const operation = new RootOperation(root2.rootName, root2.name, false, document2, document2.version);
        this.batch.addOperation(operation);
        this.model.applyOperation(operation);
      }
      setSelection(...args) {
        this._assertWriterUsedCorrectly();
        this.model.document.selection._setTo(...args);
      }
      /**
      * Moves {@link module:engine/model/documentselection~DocumentSelection#focus} to the specified location.
      *
      * The location can be specified in the same form as
      * {@link #createPositionAt `writer.createPositionAt()`} parameters.
      *
      * @param itemOrPosition
      * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/model/item~Item model item}.
      */
      setSelectionFocus(itemOrPosition, offset2) {
        this._assertWriterUsedCorrectly();
        this.model.document.selection._setFocus(itemOrPosition, offset2);
      }
      setSelectionAttribute(keyOrObjectOrIterable, value) {
        this._assertWriterUsedCorrectly();
        if (typeof keyOrObjectOrIterable === "string") {
          this._setSelectionAttribute(keyOrObjectOrIterable, value);
        } else {
          for (const [key, value2] of toMap(keyOrObjectOrIterable)) {
            this._setSelectionAttribute(key, value2);
          }
        }
      }
      /**
      * Removes attribute(s) with given key(s) from the selection.
      *
      * Remove one attribute:
      *
      * ```ts
      * writer.removeSelectionAttribute( 'italic' );
      * ```
      *
      * Remove multiple attributes:
      *
      * ```ts
      * writer.removeSelectionAttribute( [ 'italic', 'bold' ] );
      * ```
      *
      * @param keyOrIterableOfKeys Key of the attribute to remove or an iterable of attribute keys to remove.
      */
      removeSelectionAttribute(keyOrIterableOfKeys) {
        this._assertWriterUsedCorrectly();
        if (typeof keyOrIterableOfKeys === "string") {
          this._removeSelectionAttribute(keyOrIterableOfKeys);
        } else {
          for (const key of keyOrIterableOfKeys) {
            this._removeSelectionAttribute(key);
          }
        }
      }
      /**
      * Temporarily changes the {@link module:engine/model/documentselection~DocumentSelection#isGravityOverridden gravity}
      * of the selection from left to right.
      *
      * The gravity defines from which direction the selection inherits its attributes. If it's the default left gravity,
      * then the selection (after being moved by the user) inherits attributes from its left-hand side.
      * This method allows to temporarily override this behavior by forcing the gravity to the right.
      *
      * For the following model fragment:
      *
      * ```xml
      * <$text bold="true" linkHref="url">bar[]</$text><$text bold="true">biz</$text>
      * ```
      *
      * * Default gravity: selection will have the `bold` and `linkHref` attributes.
      * * Overridden gravity: selection will have `bold` attribute.
      *
      * **Note**: It returns an unique identifier which is required to restore the gravity. It guarantees the symmetry
      * of the process.
      *
      * @returns The unique id which allows restoring the gravity.
      */
      overrideSelectionGravity() {
        return this.model.document.selection._overrideGravity();
      }
      /**
      * Restores {@link ~Writer#overrideSelectionGravity} gravity to default.
      *
      * Restoring the gravity is only possible using the unique identifier returned by
      * {@link ~Writer#overrideSelectionGravity}. Note that the gravity remains overridden as long as won't be restored
      * the same number of times it was overridden.
      *
      * @param uid The unique id returned by {@link ~Writer#overrideSelectionGravity}.
      */
      restoreSelectionGravity(uid2) {
        this.model.document.selection._restoreGravity(uid2);
      }
      /**
      * @param key Key of the attribute to remove.
      * @param value Attribute value.
      */
      _setSelectionAttribute(key, value) {
        const selection = this.model.document.selection;
        if (selection.isCollapsed && selection.anchor.parent.isEmpty) {
          const storeKey = DocumentSelection._getStoreAttributeKey(key);
          this.setAttribute(storeKey, value, selection.anchor.parent);
        }
        selection._setAttribute(key, value);
      }
      /**
      * @param key Key of the attribute to remove.
      */
      _removeSelectionAttribute(key) {
        const selection = this.model.document.selection;
        if (selection.isCollapsed && selection.anchor.parent.isEmpty) {
          const storeKey = DocumentSelection._getStoreAttributeKey(key);
          this.removeAttribute(storeKey, selection.anchor.parent);
        }
        selection._removeAttribute(key);
      }
      /**
      * Throws `writer-detached-writer-tries-to-modify-model` error when the writer is used outside of the `change()` block.
      */
      _assertWriterUsedCorrectly() {
        if (this.model._currentWriter !== this) {
          throw new CKEditorError("writer-incorrect-use", this);
        }
      }
      /**
      * For given action `type` and `positionOrRange` where the action happens, this function finds all affected markers
      * and applies a marker operation with the new marker range equal to the current range. Thanks to this, the marker range
      * can be later correctly processed during undo.
      *
      * @param type Writer action type.
      * @param positionOrRange Position or range where the writer action happens.
      */
      _addOperationForAffectedMarkers(type, positionOrRange) {
        for (const marker of this.model.markers) {
          if (!marker.managedUsingOperations) {
            continue;
          }
          const markerRange = marker.getRange();
          let isAffected = false;
          if (type === "move") {
            const range2 = positionOrRange;
            isAffected = range2.containsPosition(markerRange.start) || range2.start.isEqual(markerRange.start) || range2.containsPosition(markerRange.end) || range2.end.isEqual(markerRange.end);
          } else {
            const position = positionOrRange;
            const elementBefore = position.nodeBefore;
            const elementAfter = position.nodeAfter;
            const affectedInLeftElement = markerRange.start.parent == elementBefore && markerRange.start.isAtEnd;
            const affectedInRightElement = markerRange.end.parent == elementAfter && markerRange.end.offset == 0;
            const affectedAfterLeftElement = markerRange.end.nodeAfter == elementAfter;
            const affectedBeforeRightElement = markerRange.start.nodeAfter == elementAfter;
            isAffected = affectedInLeftElement || affectedInRightElement || affectedAfterLeftElement || affectedBeforeRightElement;
          }
          if (isAffected) {
            this.updateMarker(marker.name, {
              range: markerRange
            });
          }
        }
      }
    }
    function setAttributeOnRange(writer, key, value, range2) {
      const model = writer.model;
      const doc = model.document;
      let lastSplitPosition = range2.start;
      let position;
      let valueBefore;
      let valueAfter;
      for (const val of range2.getWalker({
        shallow: true
      })) {
        valueAfter = val.item.getAttribute(key);
        if (position && valueBefore != valueAfter) {
          if (valueBefore != value) {
            addOperation();
          }
          lastSplitPosition = position;
        }
        position = val.nextPosition;
        valueBefore = valueAfter;
      }
      if (position instanceof Position && position != lastSplitPosition && valueBefore != value) {
        addOperation();
      }
      function addOperation() {
        const range3 = new Range(lastSplitPosition, position);
        const version2 = range3.root.document ? doc.version : null;
        const operation = new AttributeOperation(range3, key, valueBefore, value, version2);
        writer.batch.addOperation(operation);
        model.applyOperation(operation);
      }
    }
    function setAttributeOnItem(writer, key, value, item) {
      const model = writer.model;
      const doc = model.document;
      const previousValue = item.getAttribute(key);
      let range2, operation;
      if (previousValue != value) {
        const isRootChanged = item.root === item;
        if (isRootChanged) {
          const version2 = item.document ? doc.version : null;
          operation = new RootAttributeOperation(item, key, previousValue, value, version2);
        } else {
          range2 = new Range(Position._createBefore(item), writer.createPositionAfter(item));
          const version2 = range2.root.document ? doc.version : null;
          operation = new AttributeOperation(range2, key, previousValue, value, version2);
        }
        writer.batch.addOperation(operation);
        model.applyOperation(operation);
      }
    }
    function applyMarkerOperation(writer, name, oldRange, newRange, affectsData) {
      const model = writer.model;
      const doc = model.document;
      const operation = new MarkerOperation(name, oldRange, newRange, model.markers, !!affectsData, doc.version);
      writer.batch.addOperation(operation);
      model.applyOperation(operation);
    }
    function applyRemoveOperation(position, howMany, batch, model) {
      let operation;
      if (position.root.document) {
        const doc = model.document;
        const graveyardPosition = new Position(doc.graveyard, [
          0
        ]);
        operation = new MoveOperation(position, howMany, graveyardPosition, doc.version);
      } else {
        operation = new DetachOperation(position, howMany);
      }
      batch.addOperation(operation);
      model.applyOperation(operation);
    }
    function isSameTree(rootA, rootB) {
      if (rootA === rootB) {
        return true;
      }
      if (rootA instanceof RootElement && rootB instanceof RootElement) {
        return true;
      }
      return false;
    }
    function deleteContent(model, selection, options = {}) {
      if (selection.isCollapsed) {
        return;
      }
      const selRange = selection.getFirstRange();
      if (selRange.root.rootName == "$graveyard") {
        return;
      }
      const schema = model.schema;
      model.change((writer) => {
        if (!options.doNotResetEntireContent && shouldEntireContentBeReplacedWithParagraph(schema, selection)) {
          replaceEntireContentWithParagraph(writer, selection);
          return;
        }
        const attributesForAutoparagraph = {};
        if (!options.doNotAutoparagraph) {
          const selectedElement = selection.getSelectedElement();
          if (selectedElement) {
            Object.assign(attributesForAutoparagraph, schema.getAttributesWithProperty(selectedElement, "copyOnReplace", true));
          }
        }
        const [startPosition, endPosition] = getLivePositionsForSelectedBlocks(selRange);
        if (!startPosition.isTouching(endPosition)) {
          writer.remove(writer.createRange(startPosition, endPosition));
        }
        if (!options.leaveUnmerged) {
          mergeBranches(writer, startPosition, endPosition);
          schema.removeDisallowedAttributes(startPosition.parent.getChildren(), writer);
        }
        collapseSelectionAt(writer, selection, startPosition);
        if (!options.doNotAutoparagraph && shouldAutoparagraph(schema, startPosition)) {
          insertParagraph(writer, startPosition, selection, attributesForAutoparagraph);
        }
        startPosition.detach();
        endPosition.detach();
      });
    }
    function getLivePositionsForSelectedBlocks(range2) {
      const model = range2.root.document.model;
      const startPosition = range2.start;
      let endPosition = range2.end;
      if (model.hasContent(range2, {
        ignoreMarkers: true
      })) {
        const endBlock = getParentBlock(endPosition);
        if (endBlock && endPosition.isTouching(model.createPositionAt(endBlock, 0))) {
          const selection = model.createSelection(range2);
          model.modifySelection(selection, {
            direction: "backward"
          });
          const newEndPosition = selection.getLastPosition();
          const skippedRange = model.createRange(newEndPosition, endPosition);
          if (!model.hasContent(skippedRange, {
            ignoreMarkers: true
          })) {
            endPosition = newEndPosition;
          }
        }
      }
      return [
        LivePosition.fromPosition(startPosition, "toPrevious"),
        LivePosition.fromPosition(endPosition, "toNext")
      ];
    }
    function getParentBlock(position) {
      const element = position.parent;
      const schema = element.root.document.model.schema;
      const ancestors = element.getAncestors({
        parentFirst: true,
        includeSelf: true
      });
      for (const element2 of ancestors) {
        if (schema.isLimit(element2)) {
          return null;
        }
        if (schema.isBlock(element2)) {
          return element2;
        }
      }
    }
    function mergeBranches(writer, startPosition, endPosition) {
      const model = writer.model;
      if (!checkShouldMerge(writer.model.schema, startPosition, endPosition)) {
        return;
      }
      const [startAncestor, endAncestor] = getAncestorsJustBelowCommonAncestor(startPosition, endPosition);
      if (!startAncestor || !endAncestor) {
        return;
      }
      if (!model.hasContent(startAncestor, {
        ignoreMarkers: true
      }) && model.hasContent(endAncestor, {
        ignoreMarkers: true
      })) {
        mergeBranchesRight(writer, startPosition, endPosition, startAncestor.parent);
      } else {
        mergeBranchesLeft(writer, startPosition, endPosition, startAncestor.parent);
      }
    }
    function mergeBranchesLeft(writer, startPosition, endPosition, commonAncestor) {
      const startElement = startPosition.parent;
      const endElement = endPosition.parent;
      if (startElement == commonAncestor || endElement == commonAncestor) {
        return;
      }
      startPosition = writer.createPositionAfter(startElement);
      endPosition = writer.createPositionBefore(endElement);
      if (!endPosition.isEqual(startPosition)) {
        writer.insert(endElement, startPosition);
      }
      writer.merge(startPosition);
      while (endPosition.parent.isEmpty) {
        const parentToRemove = endPosition.parent;
        endPosition = writer.createPositionBefore(parentToRemove);
        writer.remove(parentToRemove);
      }
      if (!checkShouldMerge(writer.model.schema, startPosition, endPosition)) {
        return;
      }
      mergeBranchesLeft(writer, startPosition, endPosition, commonAncestor);
    }
    function mergeBranchesRight(writer, startPosition, endPosition, commonAncestor) {
      const startElement = startPosition.parent;
      const endElement = endPosition.parent;
      if (startElement == commonAncestor || endElement == commonAncestor) {
        return;
      }
      startPosition = writer.createPositionAfter(startElement);
      endPosition = writer.createPositionBefore(endElement);
      if (!endPosition.isEqual(startPosition)) {
        writer.insert(startElement, endPosition);
      }
      while (startPosition.parent.isEmpty) {
        const parentToRemove = startPosition.parent;
        startPosition = writer.createPositionBefore(parentToRemove);
        writer.remove(parentToRemove);
      }
      endPosition = writer.createPositionBefore(endElement);
      mergeRight(writer, endPosition);
      if (!checkShouldMerge(writer.model.schema, startPosition, endPosition)) {
        return;
      }
      mergeBranchesRight(writer, startPosition, endPosition, commonAncestor);
    }
    function mergeRight(writer, position) {
      const startElement = position.nodeBefore;
      const endElement = position.nodeAfter;
      if (startElement.name != endElement.name) {
        writer.rename(startElement, endElement.name);
      }
      writer.clearAttributes(startElement);
      writer.setAttributes(Object.fromEntries(endElement.getAttributes()), startElement);
      writer.merge(position);
    }
    function checkShouldMerge(schema, startPosition, endPosition) {
      const startElement = startPosition.parent;
      const endElement = endPosition.parent;
      if (startElement == endElement) {
        return false;
      }
      if (schema.isLimit(startElement) || schema.isLimit(endElement)) {
        return false;
      }
      return isCrossingLimitElement(startPosition, endPosition, schema);
    }
    function getAncestorsJustBelowCommonAncestor(positionA, positionB) {
      const ancestorsA = positionA.getAncestors();
      const ancestorsB = positionB.getAncestors();
      let i2 = 0;
      while (ancestorsA[i2] && ancestorsA[i2] == ancestorsB[i2]) {
        i2++;
      }
      return [
        ancestorsA[i2],
        ancestorsB[i2]
      ];
    }
    function shouldAutoparagraph(schema, position) {
      const isTextAllowed = schema.checkChild(position, "$text");
      const isParagraphAllowed = schema.checkChild(position, "paragraph");
      return !isTextAllowed && isParagraphAllowed;
    }
    function isCrossingLimitElement(leftPos, rightPos, schema) {
      const rangeToCheck = new Range(leftPos, rightPos);
      for (const value of rangeToCheck.getWalker()) {
        if (schema.isLimit(value.item)) {
          return false;
        }
      }
      return true;
    }
    function insertParagraph(writer, position, selection, attributes = {}) {
      const paragraph2 = writer.createElement("paragraph");
      writer.model.schema.setAllowedAttributes(paragraph2, attributes, writer);
      writer.insert(paragraph2, position);
      collapseSelectionAt(writer, selection, writer.createPositionAt(paragraph2, 0));
    }
    function replaceEntireContentWithParagraph(writer, selection) {
      const limitElement = writer.model.schema.getLimitElement(selection);
      writer.remove(writer.createRangeIn(limitElement));
      insertParagraph(writer, writer.createPositionAt(limitElement, 0), selection);
    }
    function shouldEntireContentBeReplacedWithParagraph(schema, selection) {
      const limitElement = schema.getLimitElement(selection);
      if (!selection.containsEntireContent(limitElement)) {
        return false;
      }
      const range2 = selection.getFirstRange();
      if (range2.start.parent == range2.end.parent) {
        return false;
      }
      return schema.checkChild(limitElement, "paragraph");
    }
    function collapseSelectionAt(writer, selection, positionOrRange) {
      if (selection instanceof DocumentSelection) {
        writer.setSelection(positionOrRange);
      } else {
        selection.setTo(positionOrRange);
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function getSelectedContent(model, selection) {
      return model.change((writer) => {
        const frag = writer.createDocumentFragment();
        const range2 = selection.getFirstRange();
        if (!range2 || range2.isCollapsed) {
          return frag;
        }
        const root2 = range2.start.root;
        const commonPath = range2.start.getCommonPath(range2.end);
        const commonParent = root2.getNodeByPath(commonPath);
        let flatSubtreeRange;
        if (range2.start.parent == range2.end.parent) {
          flatSubtreeRange = range2;
        } else {
          flatSubtreeRange = writer.createRange(writer.createPositionAt(commonParent, range2.start.path[commonPath.length]), writer.createPositionAt(commonParent, range2.end.path[commonPath.length] + 1));
        }
        const howMany = flatSubtreeRange.end.offset - flatSubtreeRange.start.offset;
        for (const item of flatSubtreeRange.getItems({
          shallow: true
        })) {
          if (item.is("$textProxy")) {
            writer.appendText(item.data, item.getAttributes(), frag);
          } else {
            writer.append(writer.cloneElement(item, true), frag);
          }
        }
        if (flatSubtreeRange != range2) {
          const newRange = range2._getTransformedByMove(flatSubtreeRange.start, writer.createPositionAt(frag, 0), howMany)[0];
          const leftExcessRange = writer.createRange(writer.createPositionAt(frag, 0), newRange.start);
          const rightExcessRange = writer.createRange(newRange.end, writer.createPositionAt(frag, "end"));
          removeRangeContent(rightExcessRange, writer);
          removeRangeContent(leftExcessRange, writer);
        }
        return frag;
      });
    }
    function removeRangeContent(range2, writer) {
      const parentsToCheck = [];
      Array.from(range2.getItems({
        direction: "backward"
      })).map((item) => writer.createRangeOn(item)).filter((itemRange) => {
        const contained = (itemRange.start.isAfter(range2.start) || itemRange.start.isEqual(range2.start)) && (itemRange.end.isBefore(range2.end) || itemRange.end.isEqual(range2.end));
        return contained;
      }).forEach((itemRange) => {
        parentsToCheck.push(itemRange.start.parent);
        writer.remove(itemRange);
      });
      parentsToCheck.forEach((parentToCheck) => {
        let parent2 = parentToCheck;
        while (parent2.parent && parent2.isEmpty) {
          const removeRange = writer.createRangeOn(parent2);
          parent2 = parent2.parent;
          writer.remove(removeRange);
        }
      });
    }
    function insertContent(model, content, selectable) {
      return model.change((writer) => {
        const selection = selectable ? selectable : model.document.selection;
        if (!selection.isCollapsed) {
          model.deleteContent(selection, {
            doNotAutoparagraph: true
          });
        }
        const insertion = new Insertion(model, writer, selection.anchor);
        const fakeMarkerElements = [];
        let nodesToInsert;
        if (content.is("documentFragment")) {
          if (content.markers.size) {
            const markersPosition = [];
            for (const [name, range2] of content.markers) {
              const { start: start2, end: end2 } = range2;
              const isCollapsed = start2.isEqual(end2);
              markersPosition.push({
                position: start2,
                name,
                isCollapsed
              }, {
                position: end2,
                name,
                isCollapsed
              });
            }
            markersPosition.sort(({ position: posA }, { position: posB }) => posA.isBefore(posB) ? 1 : -1);
            for (const { position, name, isCollapsed } of markersPosition) {
              let fakeElement = null;
              let collapsed = null;
              const isAtBeginning = position.parent === content && position.isAtStart;
              const isAtEnd = position.parent === content && position.isAtEnd;
              if (!isAtBeginning && !isAtEnd) {
                fakeElement = writer.createElement("$marker");
                writer.insert(fakeElement, position);
              } else if (isCollapsed) {
                collapsed = isAtBeginning ? "start" : "end";
              }
              fakeMarkerElements.push({
                name,
                element: fakeElement,
                collapsed
              });
            }
          }
          nodesToInsert = content.getChildren();
        } else {
          nodesToInsert = [
            content
          ];
        }
        insertion.handleNodes(nodesToInsert);
        let newRange = insertion.getSelectionRange();
        if (content.is("documentFragment") && fakeMarkerElements.length) {
          const selectionLiveRange = newRange ? LiveRange.fromRange(newRange) : null;
          const markersData = {};
          for (let i2 = fakeMarkerElements.length - 1; i2 >= 0; i2--) {
            const { name, element, collapsed } = fakeMarkerElements[i2];
            const isStartBoundary = !markersData[name];
            if (isStartBoundary) {
              markersData[name] = [];
            }
            if (element) {
              const elementPosition = writer.createPositionAt(element, "before");
              markersData[name].push(elementPosition);
              writer.remove(element);
            } else {
              const rangeOnInsertion = insertion.getAffectedRange();
              if (!rangeOnInsertion) {
                if (collapsed) {
                  markersData[name].push(insertion.position);
                }
                continue;
              }
              if (collapsed) {
                markersData[name].push(rangeOnInsertion[collapsed]);
              } else {
                markersData[name].push(isStartBoundary ? rangeOnInsertion.start : rangeOnInsertion.end);
              }
            }
          }
          for (const [name, [start2, end2]] of Object.entries(markersData)) {
            if (start2 && end2 && start2.root === end2.root && start2.root.document && !writer.model.markers.has(name)) {
              writer.addMarker(name, {
                usingOperation: true,
                affectsData: true,
                range: new Range(start2, end2)
              });
            }
          }
          if (selectionLiveRange) {
            newRange = selectionLiveRange.toRange();
            selectionLiveRange.detach();
          }
        }
        /* istanbul ignore else -- @preserve */
        if (newRange) {
          if (selection instanceof DocumentSelection) {
            writer.setSelection(newRange);
          } else {
            selection.setTo(newRange);
          }
        }
        const affectedRange = insertion.getAffectedRange() || model.createRange(selection.anchor);
        insertion.destroy();
        return affectedRange;
      });
    }
    class Insertion {
      constructor(model, writer, position) {
        /**
        * The model in context of which the insertion should be performed.
        */
        __publicField(this, "model");
        /**
        * Batch to which operations will be added.
        */
        __publicField(this, "writer");
        /**
        * The position at which (or near which) the next node will be inserted.
        */
        __publicField(this, "position");
        /**
        * Elements with which the inserted elements can be merged.
        *
        * ```html
        * <p>x^</p><p>y</p> + <p>z</p> (can merge to <p>x</p>)
        * <p>x</p><p>^y</p> + <p>z</p> (can merge to <p>y</p>)
        * <p>x^y</p> + <p>z</p> (can merge to <p>xy</p> which will be split during the action,
        * 						so both its pieces will be added to this set)
        * ```
        */
        __publicField(this, "canMergeWith");
        /**
        * Schema of the model.
        */
        __publicField(this, "schema");
        /**
        * The temporary DocumentFragment used for grouping multiple nodes for single insert operation.
        */
        __publicField(this, "_documentFragment");
        /**
        * The current position in the temporary DocumentFragment.
        */
        __publicField(this, "_documentFragmentPosition");
        /**
        * The reference to the first inserted node.
        */
        __publicField(this, "_firstNode", null);
        /**
        * The reference to the last inserted node.
        */
        __publicField(this, "_lastNode", null);
        /**
        * The reference to the last auto paragraph node.
        */
        __publicField(this, "_lastAutoParagraph", null);
        /**
        * The array of nodes that should be cleaned of not allowed attributes.
        */
        __publicField(this, "_filterAttributesOf", []);
        /**
        * Beginning of the affected range. See {@link module:engine/model/utils/insertcontent~Insertion#getAffectedRange}.
        */
        __publicField(this, "_affectedStart", null);
        /**
        * End of the affected range. See {@link module:engine/model/utils/insertcontent~Insertion#getAffectedRange}.
        */
        __publicField(this, "_affectedEnd", null);
        __publicField(this, "_nodeToSelect", null);
        this.model = model;
        this.writer = writer;
        this.position = position;
        this.canMergeWith = /* @__PURE__ */ new Set([
          this.position.parent
        ]);
        this.schema = model.schema;
        this._documentFragment = writer.createDocumentFragment();
        this._documentFragmentPosition = writer.createPositionAt(this._documentFragment, 0);
      }
      /**
      * Handles insertion of a set of nodes.
      *
      * @param nodes Nodes to insert.
      */
      handleNodes(nodes) {
        for (const node of Array.from(nodes)) {
          this._handleNode(node);
        }
        this._insertPartialFragment();
        if (this._lastAutoParagraph) {
          this._updateLastNodeFromAutoParagraph(this._lastAutoParagraph);
        }
        this._mergeOnRight();
        this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer);
        this._filterAttributesOf = [];
      }
      /**
      * Updates the last node after the auto paragraphing.
      *
      * @param node The last auto paragraphing node.
      */
      _updateLastNodeFromAutoParagraph(node) {
        const positionAfterLastNode = this.writer.createPositionAfter(this._lastNode);
        const positionAfterNode = this.writer.createPositionAfter(node);
        if (positionAfterNode.isAfter(positionAfterLastNode)) {
          this._lastNode = node;
          /* istanbul ignore if -- @preserve */
          if (this.position.parent != node || !this.position.isAtEnd) {
            throw new CKEditorError("insertcontent-invalid-insertion-position", this);
          }
          this.position = positionAfterNode;
          this._setAffectedBoundaries(this.position);
        }
      }
      /**
      * Returns range to be selected after insertion.
      * Returns `null` if there is no valid range to select after insertion.
      */
      getSelectionRange() {
        if (this._nodeToSelect) {
          return Range._createOn(this._nodeToSelect);
        }
        return this.model.schema.getNearestSelectionRange(this.position);
      }
      /**
      * Returns a range which contains all the performed changes. This is a range that, if removed, would return the model to the state
      * before the insertion. Returns `null` if no changes were done.
      */
      getAffectedRange() {
        if (!this._affectedStart) {
          return null;
        }
        return new Range(this._affectedStart, this._affectedEnd);
      }
      /**
      * Destroys `Insertion` instance.
      */
      destroy() {
        if (this._affectedStart) {
          this._affectedStart.detach();
        }
        if (this._affectedEnd) {
          this._affectedEnd.detach();
        }
      }
      /**
      * Handles insertion of a single node.
      */
      _handleNode(node) {
        if (!this._checkAndSplitToAllowedPosition(node)) {
          if (!this.schema.isObject(node)) {
            this._handleDisallowedNode(node);
          }
          return;
        }
        this._appendToFragment(node);
        if (!this._firstNode) {
          this._firstNode = node;
        }
        this._lastNode = node;
      }
      /**
      * Inserts the temporary DocumentFragment into the model.
      */
      _insertPartialFragment() {
        if (this._documentFragment.isEmpty) {
          return;
        }
        const livePosition = LivePosition.fromPosition(this.position, "toNext");
        this._setAffectedBoundaries(this.position);
        if (this._documentFragment.getChild(0) == this._firstNode) {
          this.writer.insert(this._firstNode, this.position);
          this._mergeOnLeft();
          this.position = livePosition.toPosition();
        }
        if (!this._documentFragment.isEmpty) {
          this.writer.insert(this._documentFragment, this.position);
        }
        this._documentFragmentPosition = this.writer.createPositionAt(this._documentFragment, 0);
        this.position = livePosition.toPosition();
        livePosition.detach();
      }
      /**
      * @param node The disallowed node which needs to be handled.
      */
      _handleDisallowedNode(node) {
        if (node.is("element")) {
          this.handleNodes(node.getChildren());
        }
      }
      /**
      * Append a node to the temporary DocumentFragment.
      *
      * @param node The node to insert.
      */
      _appendToFragment(node) {
        /* istanbul ignore if -- @preserve */
        if (!this.schema.checkChild(this.position, node)) {
          throw new CKEditorError("insertcontent-wrong-position", this, {
            node,
            position: this.position
          });
        }
        this.writer.insert(node, this._documentFragmentPosition);
        this._documentFragmentPosition = this._documentFragmentPosition.getShiftedBy(node.offsetSize);
        if (this.schema.isObject(node) && !this.schema.checkChild(this.position, "$text")) {
          this._nodeToSelect = node;
        } else {
          this._nodeToSelect = null;
        }
        this._filterAttributesOf.push(node);
      }
      /**
      * Sets `_affectedStart` and `_affectedEnd` to the given `position`. Should be used before a change is done during insertion process to
      * mark the affected range.
      *
      * This method is used before inserting a node or splitting a parent node. `_affectedStart` and `_affectedEnd` are also changed
      * during merging, but the logic there is more complicated so it is left out of this function.
      */
      _setAffectedBoundaries(position) {
        if (!this._affectedStart) {
          this._affectedStart = LivePosition.fromPosition(position, "toPrevious");
        }
        if (!this._affectedEnd || this._affectedEnd.isBefore(position)) {
          if (this._affectedEnd) {
            this._affectedEnd.detach();
          }
          this._affectedEnd = LivePosition.fromPosition(position, "toNext");
        }
      }
      /**
      * Merges the previous sibling of the first node if it should be merged.
      *
      * After the content was inserted we may try to merge it with its siblings.
      * This should happen only if the selection was in those elements initially.
      */
      _mergeOnLeft() {
        const node = this._firstNode;
        if (!(node instanceof Element$2)) {
          return;
        }
        if (!this._canMergeLeft(node)) {
          return;
        }
        const mergePosLeft = LivePosition._createBefore(node);
        mergePosLeft.stickiness = "toNext";
        const livePosition = LivePosition.fromPosition(this.position, "toNext");
        if (this._affectedStart.isEqual(mergePosLeft)) {
          this._affectedStart.detach();
          this._affectedStart = LivePosition._createAt(mergePosLeft.nodeBefore, "end", "toPrevious");
        }
        if (this._firstNode === this._lastNode) {
          this._firstNode = mergePosLeft.nodeBefore;
          this._lastNode = mergePosLeft.nodeBefore;
        }
        this.writer.merge(mergePosLeft);
        if (mergePosLeft.isEqual(this._affectedEnd) && this._firstNode === this._lastNode) {
          this._affectedEnd.detach();
          this._affectedEnd = LivePosition._createAt(mergePosLeft.nodeBefore, "end", "toNext");
        }
        this.position = livePosition.toPosition();
        livePosition.detach();
        this._filterAttributesOf.push(this.position.parent);
        mergePosLeft.detach();
      }
      /**
      * Merges the next sibling of the last node if it should be merged.
      *
      * After the content was inserted we may try to merge it with its siblings.
      * This should happen only if the selection was in those elements initially.
      */
      _mergeOnRight() {
        const node = this._lastNode;
        if (!(node instanceof Element$2)) {
          return;
        }
        if (!this._canMergeRight(node)) {
          return;
        }
        const mergePosRight = LivePosition._createAfter(node);
        mergePosRight.stickiness = "toNext";
        /* istanbul ignore if -- @preserve */
        if (!this.position.isEqual(mergePosRight)) {
          throw new CKEditorError("insertcontent-invalid-insertion-position", this);
        }
        this.position = Position._createAt(mergePosRight.nodeBefore, "end");
        const livePosition = LivePosition.fromPosition(this.position, "toPrevious");
        if (this._affectedEnd.isEqual(mergePosRight)) {
          this._affectedEnd.detach();
          this._affectedEnd = LivePosition._createAt(mergePosRight.nodeBefore, "end", "toNext");
        }
        if (this._firstNode === this._lastNode) {
          this._firstNode = mergePosRight.nodeBefore;
          this._lastNode = mergePosRight.nodeBefore;
        }
        this.writer.merge(mergePosRight);
        if (mergePosRight.getShiftedBy(-1).isEqual(this._affectedStart) && this._firstNode === this._lastNode) {
          this._affectedStart.detach();
          this._affectedStart = LivePosition._createAt(mergePosRight.nodeBefore, 0, "toPrevious");
        }
        this.position = livePosition.toPosition();
        livePosition.detach();
        this._filterAttributesOf.push(this.position.parent);
        mergePosRight.detach();
      }
      /**
      * Checks whether specified node can be merged with previous sibling element.
      *
      * @param node The node which could potentially be merged.
      */
      _canMergeLeft(node) {
        const previousSibling = node.previousSibling;
        return previousSibling instanceof Element$2 && this.canMergeWith.has(previousSibling) && this.model.schema.checkMerge(previousSibling, node);
      }
      /**
      * Checks whether specified node can be merged with next sibling element.
      *
      * @param node The node which could potentially be merged.
      */
      _canMergeRight(node) {
        const nextSibling = node.nextSibling;
        return nextSibling instanceof Element$2 && this.canMergeWith.has(nextSibling) && this.model.schema.checkMerge(node, nextSibling);
      }
      /**
      * Inserts a paragraph and moves the insertion position into it.
      */
      _insertAutoParagraph() {
        this._insertPartialFragment();
        const paragraph2 = this.writer.createElement("paragraph");
        this.writer.insert(paragraph2, this.position);
        this._setAffectedBoundaries(this.position);
        this._lastAutoParagraph = paragraph2;
        this.position = this.writer.createPositionAt(paragraph2, 0);
      }
      /**
      * @returns Whether an allowed position was found.
      * `false` is returned if the node isn't allowed at any position up in the tree, `true` if was.
      */
      _checkAndSplitToAllowedPosition(node) {
        const allowedIn = this._getAllowedIn(this.position.parent, node);
        if (!allowedIn) {
          return false;
        }
        if (allowedIn != this.position.parent) {
          this._insertPartialFragment();
        }
        while (allowedIn != this.position.parent) {
          if (this.position.isAtStart) {
            const parent2 = this.position.parent;
            this.position = this.writer.createPositionBefore(parent2);
            if (parent2.isEmpty && parent2.parent === allowedIn) {
              this.writer.remove(parent2);
            }
          } else if (this.position.isAtEnd) {
            this.position = this.writer.createPositionAfter(this.position.parent);
          } else {
            const tempPos = this.writer.createPositionAfter(this.position.parent);
            this._setAffectedBoundaries(this.position);
            this.writer.split(this.position);
            this.position = tempPos;
            this.canMergeWith.add(this.position.nodeAfter);
          }
        }
        if (!this.schema.checkChild(this.position.parent, node)) {
          this._insertAutoParagraph();
        }
        return true;
      }
      /**
      * Gets the element in which the given node is allowed. It checks the passed element and all its ancestors.
      *
      * It also verifies if auto-paragraphing could help.
      *
      * @param contextElement The element in which context the node should be checked.
      * @param childNode The node to check.
      */
      _getAllowedIn(contextElement, childNode) {
        if (this.schema.checkChild(contextElement, childNode)) {
          return contextElement;
        }
        if (this.schema.checkChild(contextElement, "paragraph") && this.schema.checkChild("paragraph", childNode)) {
          return contextElement;
        }
        if (this.schema.isLimit(contextElement)) {
          return null;
        }
        return this._getAllowedIn(contextElement.parent, childNode);
      }
    }
    function insertObject(model, object2, selectable, options = {}) {
      if (!model.schema.isObject(object2)) {
        throw new CKEditorError("insertobject-element-not-an-object", model, {
          object: object2
        });
      }
      const originalSelection = selectable ? selectable : model.document.selection;
      let insertionSelection = originalSelection;
      if (options.findOptimalPosition && model.schema.isBlock(object2)) {
        insertionSelection = model.createSelection(model.schema.findOptimalInsertionRange(originalSelection, options.findOptimalPosition));
      }
      const firstSelectedBlock = first(originalSelection.getSelectedBlocks());
      const attributesToCopy = {};
      if (firstSelectedBlock) {
        Object.assign(attributesToCopy, model.schema.getAttributesWithProperty(firstSelectedBlock, "copyOnReplace", true));
      }
      return model.change((writer) => {
        if (!insertionSelection.isCollapsed) {
          model.deleteContent(insertionSelection, {
            doNotAutoparagraph: true
          });
        }
        let elementToInsert = object2;
        const insertionPositionParent = insertionSelection.anchor.parent;
        if (!model.schema.checkChild(insertionPositionParent, object2) && model.schema.checkChild(insertionPositionParent, "paragraph") && model.schema.checkChild("paragraph", object2)) {
          elementToInsert = writer.createElement("paragraph");
          writer.insert(object2, elementToInsert);
        }
        model.schema.setAllowedAttributes(elementToInsert, attributesToCopy, writer);
        const affectedRange = model.insertContent(elementToInsert, insertionSelection);
        if (affectedRange.isCollapsed) {
          return affectedRange;
        }
        if (options.setSelection) {
          updateSelection(writer, object2, options.setSelection, attributesToCopy);
        }
        return affectedRange;
      });
    }
    function updateSelection(writer, contextElement, place, paragraphAttributes) {
      const model = writer.model;
      if (place == "on") {
        writer.setSelection(contextElement, "on");
        return;
      }
      if (place != "after") {
        throw new CKEditorError("insertobject-invalid-place-parameter-value", model);
      }
      let nextElement = contextElement.nextSibling;
      if (model.schema.isInline(contextElement)) {
        writer.setSelection(contextElement, "after");
        return;
      }
      const canSetSelection = nextElement && model.schema.checkChild(nextElement, "$text");
      if (!canSetSelection && model.schema.checkChild(contextElement.parent, "paragraph")) {
        nextElement = writer.createElement("paragraph");
        model.schema.setAllowedAttributes(nextElement, paragraphAttributes, writer);
        model.insertContent(nextElement, writer.createPositionAfter(contextElement));
      }
      if (nextElement) {
        writer.setSelection(nextElement, 0);
      }
    }
    const wordBoundaryCharacters = ' ,.?!:;"-()';
    function modifySelection(model, selection, options = {}) {
      const schema = model.schema;
      const isForward = options.direction != "backward";
      const unit = options.unit ? options.unit : "character";
      const treatEmojiAsSingleUnit = !!options.treatEmojiAsSingleUnit;
      const focus = selection.focus;
      const walker = new TreeWalker({
        boundaries: getSearchRange(focus, isForward),
        singleCharacters: true,
        direction: isForward ? "forward" : "backward"
      });
      const data = {
        walker,
        schema,
        isForward,
        unit,
        treatEmojiAsSingleUnit
      };
      let next;
      while (next = walker.next()) {
        if (next.done) {
          return;
        }
        const position = tryExtendingTo(data, next.value);
        if (position) {
          if (selection instanceof DocumentSelection) {
            model.change((writer) => {
              writer.setSelectionFocus(position);
            });
          } else {
            selection.setFocus(position);
          }
          return;
        }
      }
    }
    function tryExtendingTo(data, value) {
      const { isForward, walker, unit, schema, treatEmojiAsSingleUnit } = data;
      const { type, item, nextPosition } = value;
      if (type == "text") {
        if (data.unit === "word") {
          return getCorrectWordBreakPosition(walker, isForward);
        }
        return getCorrectPosition(walker, unit, treatEmojiAsSingleUnit);
      }
      if (type == (isForward ? "elementStart" : "elementEnd")) {
        if (schema.isSelectable(item)) {
          return Position._createAt(item, isForward ? "after" : "before");
        }
        if (schema.checkChild(nextPosition, "$text")) {
          return nextPosition;
        }
      } else {
        if (schema.isLimit(item)) {
          walker.skip(() => true);
          return;
        }
        if (schema.checkChild(nextPosition, "$text")) {
          return nextPosition;
        }
      }
    }
    function getCorrectPosition(walker, unit, treatEmojiAsSingleUnit) {
      const textNode = walker.position.textNode;
      if (textNode) {
        const data = textNode.data;
        let offset2 = walker.position.offset - textNode.startOffset;
        while (isInsideSurrogatePair(data, offset2) || unit == "character" && isInsideCombinedSymbol(data, offset2) || treatEmojiAsSingleUnit && isInsideEmojiSequence(data, offset2)) {
          walker.next();
          offset2 = walker.position.offset - textNode.startOffset;
        }
      }
      return walker.position;
    }
    function getCorrectWordBreakPosition(walker, isForward) {
      let textNode = walker.position.textNode;
      if (!textNode) {
        textNode = isForward ? walker.position.nodeAfter : walker.position.nodeBefore;
      }
      while (textNode && textNode.is("$text")) {
        const offset2 = walker.position.offset - textNode.startOffset;
        if (isAtNodeBoundary(textNode, offset2, isForward)) {
          textNode = isForward ? walker.position.nodeAfter : walker.position.nodeBefore;
        } else if (isAtWordBoundary(textNode.data, offset2, isForward)) {
          break;
        } else {
          walker.next();
        }
      }
      return walker.position;
    }
    function getSearchRange(start2, isForward) {
      const root2 = start2.root;
      const searchEnd = Position._createAt(root2, isForward ? "end" : 0);
      if (isForward) {
        return new Range(start2, searchEnd);
      } else {
        return new Range(searchEnd, start2);
      }
    }
    function isAtWordBoundary(data, offset2, isForward) {
      const offsetToCheck = offset2 + (isForward ? 0 : -1);
      return wordBoundaryCharacters.includes(data.charAt(offsetToCheck));
    }
    function isAtNodeBoundary(textNode, offset2, isForward) {
      return offset2 === (isForward ? textNode.offsetSize : 0);
    }
    let Model$1 = class Model extends (/* @__PURE__ */ ObservableMixin()) {
      // @if CK_DEBUG_ENGINE // private _operationLogs: Array<string>;
      // @if CK_DEBUG_ENGINE // private _appliedOperations: Array<Operation>;
      constructor() {
        super();
        /**
        * Model's marker collection.
        */
        __publicField(this, "markers");
        /**
        * Model's document.
        */
        __publicField(this, "document");
        /**
        * Model's schema.
        */
        __publicField(this, "schema");
        /**
        * All callbacks added by {@link module:engine/model/model~Model#change} or
        * {@link module:engine/model/model~Model#enqueueChange} methods waiting to be executed.
        */
        __publicField(this, "_pendingChanges");
        /**
        * The last created and currently used writer instance.
        */
        __publicField(this, "_currentWriter");
        this.markers = new MarkerCollection();
        this.document = new Document(this);
        this.schema = new Schema();
        this._pendingChanges = [];
        this._currentWriter = null;
        [
          "deleteContent",
          "modifySelection",
          "getSelectedContent",
          "applyOperation"
        ].forEach((methodName) => this.decorate(methodName));
        this.on("applyOperation", (evt, args) => {
          const operation = args[0];
          operation._validate();
        }, {
          priority: "highest"
        });
        this.schema.register("$root", {
          isLimit: true
        });
        this.schema.register("$container", {
          allowIn: [
            "$root",
            "$container"
          ]
        });
        this.schema.register("$block", {
          allowIn: [
            "$root",
            "$container"
          ],
          isBlock: true
        });
        this.schema.register("$blockObject", {
          allowWhere: "$block",
          isBlock: true,
          isObject: true
        });
        this.schema.register("$inlineObject", {
          allowWhere: "$text",
          allowAttributesOf: "$text",
          isInline: true,
          isObject: true
        });
        this.schema.register("$text", {
          allowIn: "$block",
          isInline: true,
          isContent: true
        });
        this.schema.register("$clipboardHolder", {
          allowContentOf: "$root",
          allowChildren: "$text",
          isLimit: true
        });
        this.schema.register("$documentFragment", {
          allowContentOf: "$root",
          allowChildren: "$text",
          isLimit: true
        });
        this.schema.register("$marker");
        this.schema.addChildCheck(() => true, "$marker");
        injectSelectionPostFixer(this);
        this.document.registerPostFixer(autoParagraphEmptyRoots);
        this.on("insertContent", (evt, [content, selectable]) => {
          evt.return = insertContent(this, content, selectable);
        });
        this.on("insertObject", (evt, [element, selection, options]) => {
          evt.return = insertObject(this, element, selection, options);
        });
        this.on("canEditAt", (evt) => {
          const canEditAt = !this.document.isReadOnly;
          evt.return = canEditAt;
          if (!canEditAt) {
            evt.stop();
          }
        });
      }
      /**
      * The `change()` method is the primary way of changing the model. You should use it to modify all document nodes
      * (including detached nodes  i.e. nodes not added to the {@link module:engine/model/model~Model#document model document}),
      * the {@link module:engine/model/document~Document#selection document's selection}, and
      * {@link module:engine/model/model~Model#markers model markers}.
      *
      * ```ts
      * model.change( writer => {
      * 	writer.insertText( 'foo', paragraph, 'end' );
      * } );
      * ```
      *
      * All changes inside the change block use the same {@link module:engine/model/batch~Batch} so they are combined
      * into a single undo step.
      *
      * ```ts
      * model.change( writer => {
      * 	writer.insertText( 'foo', paragraph, 'end' ); // foo.
      *
      * 	model.change( writer => {
      * 		writer.insertText( 'bar', paragraph, 'end' ); // foobar.
      * 	} );
      *
      * 	writer.insertText( 'bom', paragraph, 'end' ); // foobarbom.
      * } );
      * ```
      *
      * The callback of the `change()` block is executed synchronously.
      *
      * You can also return a value from the change block.
      *
      * ```ts
      * const img = model.change( writer => {
      * 	return writer.createElement( 'img' );
      * } );
      * ```
      *
      * @see #enqueueChange
      * @typeParam TReturn The return type of the provided callback.
      * @param callback Callback function which may modify the model.
      */
      change(callback) {
        try {
          if (this._pendingChanges.length === 0) {
            this._pendingChanges.push({
              batch: new Batch(),
              callback
            });
            return this._runPendingChanges()[0];
          } else {
            return callback(this._currentWriter);
          }
        } catch (err) {
          /* istanbul ignore next -- @preserve */
          CKEditorError.rethrowUnexpectedError(err, this);
        }
      }
      enqueueChange(batchOrType, callback) {
        try {
          if (!batchOrType) {
            batchOrType = new Batch();
          } else if (typeof batchOrType === "function") {
            callback = batchOrType;
            batchOrType = new Batch();
          } else if (!(batchOrType instanceof Batch)) {
            batchOrType = new Batch(batchOrType);
          }
          this._pendingChanges.push({
            batch: batchOrType,
            callback
          });
          if (this._pendingChanges.length == 1) {
            this._runPendingChanges();
          }
        } catch (err) {
          /* istanbul ignore next -- @preserve */
          CKEditorError.rethrowUnexpectedError(err, this);
        }
      }
      /**
      * {@link module:utils/observablemixin~Observable#decorate Decorated} function for applying
      * {@link module:engine/model/operation/operation~Operation operations} to the model.
      *
      * This is a low-level way of changing the model. It is exposed for very specific use cases (like the undo feature).
      * Normally, to modify the model, you will want to use {@link module:engine/model/writer~Writer `Writer`}.
      * See also {@glink framework/architecture/editing-engine#changing-the-model Changing the model} section
      * of the {@glink framework/architecture/editing-engine Editing architecture} guide.
      *
      * @param operation The operation to apply.
      */
      applyOperation(operation) {
        operation._execute();
      }
      // @if CK_DEBUG_ENGINE // public getAppliedOperation(): string {
      // @if CK_DEBUG_ENGINE // 	if ( !this._appliedOperations ) {
      // @if CK_DEBUG_ENGINE // 		return '';
      // @if CK_DEBUG_ENGINE // 	}
      // @if CK_DEBUG_ENGINE // 	return this._appliedOperations.map( operation => JSON.stringify( operation ) ).join( '-------' );
      // @if CK_DEBUG_ENGINE // }
      // @if CK_DEBUG_ENGINE // public createReplayer( stringifiedOperations: string ): typeof OperationReplayer {
      // @if CK_DEBUG_ENGINE // 	return new OperationReplayer( this, '-------', stringifiedOperations );
      // @if CK_DEBUG_ENGINE // }
      /**
      * Inserts content at the position in the editor specified by the selection, as one would expect the paste
      * functionality to work.
      *
      * **Note**: If you want to insert an {@glink framework/deep-dive/schema#object-elements object element}
      * (e.g. a {@link module:widget/utils~toWidget widget}), see {@link #insertObject} instead.
      *
      * This is a high-level method. It takes the {@link #schema schema} into consideration when inserting
      * the content, clears the given selection's content before inserting nodes and moves the selection
      * to its target position at the end of the process.
      * It can split elements, merge them, wrap bare text nodes with paragraphs, etc. &ndash; just like the
      * pasting feature should do.
      *
      * For lower-level methods see {@link module:engine/model/writer~Writer `Writer`}.
      *
      * This method, unlike {@link module:engine/model/writer~Writer `Writer`}'s methods, does not have to be used
      * inside a {@link #change `change()` block}.
      *
      * # Conversion and schema
      *
      * Inserting elements and text nodes into the model is not enough to make CKEditor 5 render that content
      * to the user. CKEditor 5 implements a model-view-controller architecture and what `model.insertContent()` does
      * is only adding nodes to the model. Additionally, you need to define
      * {@glink framework/architecture/editing-engine#conversion converters} between the model and view
      * and define those nodes in the {@glink framework/architecture/editing-engine#schema schema}.
      *
      * So, while this method may seem similar to CKEditor 4 `editor.insertHtml()` (in fact, both methods
      * are used for paste-like content insertion), the CKEditor 5 method cannot be use to insert arbitrary HTML
      * unless converters are defined for all elements and attributes in that HTML.
      *
      * # Examples
      *
      * Using `insertContent()` with a manually created model structure:
      *
      * ```ts
      * // Let's create a document fragment containing such content as:
      * //
      * // <paragraph>foo</paragraph>
      * // <blockQuote>
      * //    <paragraph>bar</paragraph>
      * // </blockQuote>
      * const docFrag = editor.model.change( writer => {
      * 	const p1 = writer.createElement( 'paragraph' );
      * 	const p2 = writer.createElement( 'paragraph' );
      * 	const blockQuote = writer.createElement( 'blockQuote' );
      * 	const docFrag = writer.createDocumentFragment();
      *
      * 	writer.append( p1, docFrag );
      * 	writer.append( blockQuote, docFrag );
      * 	writer.append( p2, blockQuote );
      * 	writer.insertText( 'foo', p1 );
      * 	writer.insertText( 'bar', p2 );
      *
      * 	return docFrag;
      * } );
      *
      * // insertContent() does not have to be used in a change() block. It can, though,
      * // so this code could be moved to the callback defined above.
      * editor.model.insertContent( docFrag );
      * ```
      *
      * Using `insertContent()` with an HTML string converted to a model document fragment (similar to the pasting mechanism):
      *
      * ```ts
      * // You can create your own HtmlDataProcessor instance or use editor.data.processor
      * // if you have not overridden the default one (which is the HtmlDataProcessor instance).
      * const htmlDP = new HtmlDataProcessor( viewDocument );
      *
      * // Convert an HTML string to a view document fragment:
      * const viewFragment = htmlDP.toView( htmlString );
      *
      * // Convert the view document fragment to a model document fragment
      * // in the context of $root. This conversion takes the schema into
      * // account so if, for example, the view document fragment contained a bare text node,
      * // this text node cannot be a child of $root, so it will be automatically
      * // wrapped with a <paragraph>. You can define the context yourself (in the second parameter),
      * // and e.g. convert the content like it would happen in a <paragraph>.
      * // Note: The clipboard feature uses a custom context called $clipboardHolder
      * // which has a loosened schema.
      * const modelFragment = editor.data.toModel( viewFragment );
      *
      * editor.model.insertContent( modelFragment );
      * ```
      *
      * By default this method will use the document selection but it can also be used with a position, range or selection instance.
      *
      * ```ts
      * // Insert text at the current document selection position.
      * editor.model.change( writer => {
      * 	editor.model.insertContent( writer.createText( 'x' ) );
      * } );
      *
      * // Insert text at a given position - the document selection will not be modified.
      * editor.model.change( writer => {
      * 	editor.model.insertContent( writer.createText( 'x' ), doc.getRoot(), 2 );
      *
      * 	// Which is a shorthand for:
      * 	editor.model.insertContent( writer.createText( 'x' ), writer.createPositionAt( doc.getRoot(), 2 ) );
      * } );
      * ```
      *
      * If you want the document selection to be moved to the inserted content, use the
      * {@link module:engine/model/writer~Writer#setSelection `setSelection()`} method of the writer after inserting
      * the content:
      *
      * ```ts
      * editor.model.change( writer => {
      * 	const paragraph = writer.createElement( 'paragraph' );
      *
      * 	// Insert an empty paragraph at the beginning of the root.
      * 	editor.model.insertContent( paragraph, writer.createPositionAt( editor.model.document.getRoot(), 0 ) );
      *
      * 	// Move the document selection to the inserted paragraph.
      * 	writer.setSelection( paragraph, 'in' );
      * } );
      * ```
      *
      * If an instance of the {@link module:engine/model/selection~Selection model selection} is passed as `selectable`,
      * the new content will be inserted at the passed selection (instead of document selection):
      *
      * ```ts
      * editor.model.change( writer => {
      * 	// Create a selection in a paragraph that will be used as a place of insertion.
      * 	const selection = writer.createSelection( paragraph, 'in' );
      *
      * 	// Insert the new text at the created selection.
      * 	editor.model.insertContent( writer.createText( 'x' ), selection );
      *
      * 	// insertContent() modifies the passed selection instance so it can be used to set the document selection.
      * 	// Note: This is not necessary when you passed the document selection to insertContent().
      * 	writer.setSelection( selection );
      * } );
      * ```
      *
      * @fires insertContent
      * @param content The content to insert.
      * @param selectable The selection into which the content should be inserted.
      * If not provided the current model document selection will be used.
      * @param placeOrOffset To be used when a model item was passed as `selectable`.
      * This param defines a position in relation to that item.
      * at the insertion position.
      */
      insertContent(content, selectable, placeOrOffset, ...rest2) {
        const selection = normalizeSelectable(selectable, placeOrOffset);
        return this.fire("insertContent", [
          content,
          selection,
          placeOrOffset,
          ...rest2
        ]);
      }
      /**
      * Inserts an {@glink framework/deep-dive/schema#object-elements object element} at a specific position in the editor content.
      *
      * This is a high-level API:
      * * It takes the {@link #schema schema} into consideration,
      * * It clears the content of passed `selectable` before inserting,
      * * It can move the selection at the end of the process,
      * * It will copy the selected block's attributes to preserve them upon insertion,
      * * It can split elements or wrap inline objects with paragraphs if they are not allowed in target position,
      * * etc.
      *
      * # Notes
      *
      * * If you want to insert a non-object content, see {@link #insertContent} instead.
      * * For lower-level API, see {@link module:engine/model/writer~Writer `Writer`}.
      * * Unlike {@link module:engine/model/writer~Writer `Writer`}, this method does not have to be used inside
      * a {@link #change `change()` block}.
      * * Inserting object into the model is not enough to make CKEditor 5 render that content to the user.
      * CKEditor 5 implements a model-view-controller architecture and what `model.insertObject()` does
      * is only adding nodes to the model. Additionally, you need to define
      * {@glink framework/architecture/editing-engine#conversion converters} between the model and view
      * and define those nodes in the {@glink framework/architecture/editing-engine#schema schema}.
      *
      * # Examples
      *
      * Use the following code to insert an object at the current selection and keep the selection on the inserted element:
      *
      * ```ts
      * const rawHtmlEmbedElement = writer.createElement( 'rawHtml' );
      *
      * model.insertObject( rawHtmlEmbedElement, null, null, {
      * 	setSelection: 'on'
      * } );
      * ```
      *
      * Use the following code to insert an object at the current selection and nudge the selection after the inserted object:
      *
      * ```ts
      * const pageBreakElement = writer.createElement( 'pageBreak' );
       *
      * model.insertObject( pageBreakElement, null, null, {
      * 	setSelection: 'after'
      * } );
      * ```
      *
      * Use the following code to insert an object at the current selection and avoid splitting the content (non-destructive insertion):
      *
      * ```ts
      * const tableElement = writer.createElement( 'table' );
       *
      * model.insertObject( tableElement, null, null, {
      * 	findOptimalPosition: 'auto'
      * } );
      * ```
      *
      * Use the following code to insert an object at the specific range (also: replace the content of the range):
      *
      * ```ts
      * const tableElement = writer.createElement( 'table' );
      * const range = model.createRangeOn( model.document.getRoot().getChild( 1 ) );
       *
      * model.insertObject( tableElement, range );
      * ```
      *
      * @param element An object to be inserted into the model document.
      * @param selectable A selectable where the content should be inserted. If not specified, the current
      * {@link module:engine/model/document~Document#selection document selection} will be used instead.
      * @param placeOrOffset Specifies the exact place or offset for the insertion to take place, relative to `selectable`.
      * @param options Additional options.
      * @param options.findOptimalPosition An option that, when set, adjusts the insertion position (relative to
      * `selectable` and `placeOrOffset`) so that the content of `selectable` is not split upon insertion (a.k.a. non-destructive insertion).
      * * When `'auto'`, the algorithm will decide whether to insert the object before or after `selectable` to avoid content splitting.
      * * When `'before'`, the closest position before `selectable` will be used that will not result in content splitting.
      * * When `'after'`, the closest position after `selectable` will be used that will not result in content splitting.
      *
      * Note that this option only works for block objects. Inline objects are inserted into text and do not split blocks.
      * @param options.setSelection An option that, when set, moves the
      * {@link module:engine/model/document~Document#selection document selection} after inserting the object.
      * * When `'on'`, the document selection will be set on the inserted object.
      * * When `'after'`, the document selection will move to the closest text node after the inserted object. If there is no
      * such text node, a paragraph will be created and the document selection will be moved inside it.
      * at the insertion position.
      */
      insertObject(element, selectable, placeOrOffset, options, ...rest2) {
        const selection = normalizeSelectable(selectable, placeOrOffset);
        return this.fire("insertObject", [
          element,
          selection,
          options,
          options,
          ...rest2
        ]);
      }
      /**
      * Deletes content of the selection and merge siblings. The resulting selection is always collapsed.
      *
      * **Note:** For the sake of predictability, the resulting selection should always be collapsed.
      * In cases where a feature wants to modify deleting behavior so selection isn't collapsed
      * (e.g. a table feature may want to keep row selection after pressing <kbd>Backspace</kbd>),
      * then that behavior should be implemented in the view's listener. At the same time, the table feature
      * will need to modify this method's behavior too, e.g. to "delete contents and then collapse
      * the selection inside the last selected cell" or "delete the row and collapse selection somewhere near".
      * That needs to be done in order to ensure that other features which use `deleteContent()` will work well with tables.
      *
      * @fires deleteContent
      * @param selection Selection of which the content should be deleted.
      * @param options.leaveUnmerged Whether to merge elements after removing the content of the selection.
      *
      * For example `<heading1>x[x</heading1><paragraph>y]y</paragraph>` will become:
      *
      * * `<heading1>x^y</heading1>` with the option disabled (`leaveUnmerged == false`)
      * * `<heading1>x^</heading1><paragraph>y</paragraph>` with enabled (`leaveUnmerged == true`).
      *
      * Note: {@link module:engine/model/schema~Schema#isObject object} and {@link module:engine/model/schema~Schema#isLimit limit}
      * elements will not be merged.
      *
      * @param options.doNotResetEntireContent Whether to skip replacing the entire content with a
      * paragraph when the entire content was selected.
      *
      * For example `<heading1>[x</heading1><paragraph>y]</paragraph>` will become:
      *
      * * `<paragraph>^</paragraph>` with the option disabled (`doNotResetEntireContent == false`)
      * * `<heading1>^</heading1>` with enabled (`doNotResetEntireContent == true`)
      *
      * @param options.doNotAutoparagraph Whether to create a paragraph if after content deletion selection is moved
      * to a place where text cannot be inserted.
      *
      * For example `<paragraph>x</paragraph>[<imageBlock src="foo.jpg"></imageBlock>]` will become:
      *
      * * `<paragraph>x</paragraph><paragraph>[]</paragraph>` with the option disabled (`doNotAutoparagraph == false`)
      * * `<paragraph>x[]</paragraph>` with the option enabled (`doNotAutoparagraph == true`).
      *
      * **Note:** if there is no valid position for the selection, the paragraph will always be created:
      *
      * `[<imageBlock src="foo.jpg"></imageBlock>]` -> `<paragraph>[]</paragraph>`.
      *
      * @param options.direction The direction in which the content is being consumed.
      * Deleting backward corresponds to using the <kbd>Backspace</kbd> key, while deleting content forward corresponds to
      * the <kbd>Shift</kbd>+<kbd>Backspace</kbd> keystroke.
      */
      deleteContent(selection, options) {
        deleteContent(this, selection, options);
      }
      /**
      * Modifies the selection. Currently, the supported modifications are:
      *
      * * Extending. The selection focus is moved in the specified `options.direction` with a step specified in `options.unit`.
      * Possible values for `unit` are:
      *  * `'character'` (default) - moves selection by one user-perceived character. In most cases this means moving by one
      *  character in `String` sense. However, unicode also defines "combing marks". These are special symbols, that combines
      *  with a symbol before it ("base character") to create one user-perceived character. For example, `q` is a normal
      *  letter `q` with two "combining marks": upper dot (`Ux0307`) and lower dot (`Ux0323`). For most actions, i.e. extending
      *  selection by one position, it is correct to include both "base character" and all of it's "combining marks". That is
      *  why `'character'` value is most natural and common method of modifying selection.
      *  * `'codePoint'` - moves selection by one unicode code point. In contrary to, `'character'` unit, this will insert
      *  selection between "base character" and "combining mark", because "combining marks" have their own unicode code points.
      *  However, for technical reasons, unicode code points with values above `UxFFFF` are represented in native `String` by
      *  two characters, called "surrogate pairs". Halves of "surrogate pairs" have a meaning only when placed next to each other.
      *  For example `` is represented in `String` by `\uD862\uDF4E`. Both `\uD862` and `\uDF4E` do not have any meaning
      *  outside the pair (are rendered as ? when alone). Position between them would be incorrect. In this case, selection
      *  extension will include whole "surrogate pair".
      *  * `'word'` - moves selection by a whole word.
      *
      * **Note:** if you extend a forward selection in a backward direction you will in fact shrink it.
      *
      * @fires modifySelection
      * @param selection The selection to modify.
      * @param options.direction The direction in which the selection should be modified.
      * @param options.unit The unit by which selection should be modified.
      * @param options.treatEmojiAsSingleUnit Whether multi-characer emoji sequences should be handled as single unit.
      */
      modifySelection(selection, options) {
        modifySelection(this, selection, options);
      }
      /**
      * Gets a clone of the selected content.
      *
      * For example, for the following selection:
      *
      * ```html
      * <paragraph>x</paragraph>
      * <blockQuote>
      * 	<paragraph>y</paragraph>
      * 	<heading1>fir[st</heading1>
      * </blockQuote>
      * <paragraph>se]cond</paragraph>
      * <paragraph>z</paragraph>
      * ```
      *
      * It will return a document fragment with such a content:
      *
      * ```html
      * <blockQuote>
      * 	<heading1>st</heading1>
      * </blockQuote>
      * <paragraph>se</paragraph>
      * ```
      *
      * @fires getSelectedContent
      * @param selection The selection of which content will be returned.
      */
      getSelectedContent(selection) {
        return getSelectedContent(this, selection);
      }
      /**
      * Checks whether the given {@link module:engine/model/range~Range range} or
      * {@link module:engine/model/element~Element element} has any meaningful content.
      *
      * Meaningful content is:
      *
      * * any text node (`options.ignoreWhitespaces` allows controlling whether this text node must also contain
      * any non-whitespace characters),
      * * or any {@link module:engine/model/schema~Schema#isContent content element},
      * * or any {@link module:engine/model/markercollection~Marker marker} which
      * {@link module:engine/model/markercollection~Marker#_affectsData affects data}.
      *
      * This means that a range containing an empty `<paragraph></paragraph>` is not considered to have a meaningful content.
      * However, a range containing an `<imageBlock></imageBlock>` (which would normally be marked in the schema as an object element)
      * is considered non-empty.
      *
      * @param rangeOrElement Range or element to check.
      * @param options.ignoreWhitespaces Whether text node with whitespaces only should be considered empty.
      * @param options.ignoreMarkers Whether markers should be ignored.
      */
      hasContent(rangeOrElement, options = {}) {
        const range2 = rangeOrElement instanceof Range ? rangeOrElement : Range._createIn(rangeOrElement);
        if (range2.isCollapsed) {
          return false;
        }
        const { ignoreWhitespaces = false, ignoreMarkers = false } = options;
        if (!ignoreMarkers) {
          for (const intersectingMarker of this.markers.getMarkersIntersectingRange(range2)) {
            if (intersectingMarker.affectsData) {
              return true;
            }
          }
        }
        for (const item of range2.getItems()) {
          if (this.schema.isContent(item)) {
            if (item.is("$textProxy")) {
              if (!ignoreWhitespaces) {
                return true;
              } else if (item.data.search(/\S/) !== -1) {
                return true;
              }
            } else {
              return true;
            }
          }
        }
        return false;
      }
      /**
      * Check whether given selectable is at a place in the model where it can be edited (returns `true`) or not (returns `false`).
      *
      * Should be used instead of {@link module:core/editor/editor~Editor#isReadOnly} to check whether a user action can happen at
      * given selectable. It may be decorated and used differently in different environment (e.g. multi-root editor can disable
      * a particular root).
      *
      * This method is decorated. Although this method accepts any parameter of `Selectable` type, the
      * {@link ~Model#event:canEditAt `canEditAt` event} is fired with `selectable` normalized to an instance of
      * {@link module:engine/model/selection~Selection} or {@link module:engine/model/documentselection~DocumentSelection}
      *
      * @fires canEditAt
      */
      canEditAt(selectable) {
        const selection = normalizeSelectable(selectable);
        return this.fire("canEditAt", [
          selection
        ]);
      }
      /**
      * Creates a position from the given root and path in that root.
      *
      * Note: This method is also available as
      * {@link module:engine/model/writer~Writer#createPositionFromPath `Writer#createPositionFromPath()`}.
      *
      * @param root Root of the position.
      * @param path Position path. See {@link module:engine/model/position~Position#path}.
      * @param stickiness Position stickiness. See {@link module:engine/model/position~PositionStickiness}.
      */
      createPositionFromPath(root2, path, stickiness) {
        return new Position(root2, path, stickiness);
      }
      /**
      * Creates position at the given location. The location can be specified as:
      *
      * * a {@link module:engine/model/position~Position position},
      * * a parent element and offset in that element,
      * * a parent element and `'end'` (the position will be set at the end of that element),
      * * a {@link module:engine/model/item~Item model item} and `'before'` or `'after'`
      * (the position will be set before or after the given model item).
      *
      * This method is a shortcut to other factory methods such as:
      *
      * * {@link module:engine/model/model~Model#createPositionBefore `createPositionBefore()`},
      * * {@link module:engine/model/model~Model#createPositionAfter `createPositionAfter()`}.
      *
      * Note: This method is also available as
      * {@link module:engine/model/writer~Writer#createPositionAt `Writer#createPositionAt()`},
      *
      * @param itemOrPosition
      * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/model/item~Item model item}.
      */
      createPositionAt(itemOrPosition, offset2) {
        return Position._createAt(itemOrPosition, offset2);
      }
      /**
      * Creates a new position after the given {@link module:engine/model/item~Item model item}.
      *
      * Note: This method is also available as
      * {@link module:engine/model/writer~Writer#createPositionAfter `Writer#createPositionAfter()`}.
      *
      * @param item Item after which the position should be placed.
      */
      createPositionAfter(item) {
        return Position._createAfter(item);
      }
      /**
      * Creates a new position before the given {@link module:engine/model/item~Item model item}.
      *
      * Note: This method is also available as
      * {@link module:engine/model/writer~Writer#createPositionBefore `Writer#createPositionBefore()`}.
      *
      * @param item Item before which the position should be placed.
      */
      createPositionBefore(item) {
        return Position._createBefore(item);
      }
      /**
      * Creates a range spanning from the `start` position to the `end` position.
      *
      * Note: This method is also available as
      * {@link module:engine/model/writer~Writer#createRange `Writer#createRange()`}:
      *
      * ```ts
      * model.change( writer => {
      * 	const range = writer.createRange( start, end );
      * } );
      * ```
      *
      * @param start Start position.
      * @param end End position. If not set, the range will be collapsed to the `start` position.
      */
      createRange(start2, end2) {
        return new Range(start2, end2);
      }
      /**
      * Creates a range inside the given element which starts before the first child of
      * that element and ends after the last child of that element.
      *
      * Note: This method is also available as
      * {@link module:engine/model/writer~Writer#createRangeIn `Writer#createRangeIn()`}:
      *
      * ```ts
      * model.change( writer => {
      * 	const range = writer.createRangeIn( paragraph );
      * } );
      * ```
      *
      * @param element Element which is a parent for the range.
      */
      createRangeIn(element) {
        return Range._createIn(element);
      }
      /**
      * Creates a range that starts before the given {@link module:engine/model/item~Item model item} and ends after it.
      *
      * Note: This method is also available on `writer` instance as
      * {@link module:engine/model/writer~Writer#createRangeOn `Writer.createRangeOn()`}:
      *
      * ```ts
      * model.change( writer => {
      * 	const range = writer.createRangeOn( paragraph );
      * } );
      * ```
      *
      * @param item
      */
      createRangeOn(item) {
        return Range._createOn(item);
      }
      createSelection(...args) {
        return new Selection(...args);
      }
      /**
      * Creates a {@link module:engine/model/batch~Batch} instance.
      *
      * **Note:** In most cases creating a batch instance is not necessary as they are created when using:
      *
      * * {@link #change `change()`},
      * * {@link #enqueueChange `enqueueChange()`}.
      *
      * @param type {@link module:engine/model/batch~Batch#constructor The type} of the batch.
      */
      createBatch(type) {
        return new Batch(type);
      }
      /**
      * Creates an operation instance from a JSON object (parsed JSON string).
      *
      * This is an alias for {@link module:engine/model/operation/operationfactory~OperationFactory.fromJSON `OperationFactory.fromJSON()`}.
      *
      * @param json Deserialized JSON object.
      */
      createOperationFromJSON(json) {
        return OperationFactory.fromJSON(json, this.document);
      }
      /**
      * Removes all events listeners set by model instance and destroys {@link module:engine/model/document~Document}.
      */
      destroy() {
        this.document.destroy();
        this.stopListening();
      }
      /**
      * Common part of {@link module:engine/model/model~Model#change} and {@link module:engine/model/model~Model#enqueueChange}
      * which calls callbacks and returns array of values returned by these callbacks.
      */
      _runPendingChanges() {
        const ret = [];
        this.fire("_beforeChanges");
        try {
          while (this._pendingChanges.length) {
            const currentBatch = this._pendingChanges[0].batch;
            this._currentWriter = new Writer(this, currentBatch);
            const callbackReturnValue = this._pendingChanges[0].callback(this._currentWriter);
            ret.push(callbackReturnValue);
            this.document._handleChangeBlock(this._currentWriter);
            this._pendingChanges.shift();
            this._currentWriter = null;
          }
        } finally {
          this._pendingChanges.length = 0;
          this._currentWriter = null;
          this.fire("_afterChanges");
        }
        return ret;
      }
    };
    function normalizeSelectable(selectable, placeOrOffset) {
      if (!selectable) {
        return;
      }
      if (selectable instanceof Selection || selectable instanceof DocumentSelection) {
        return selectable;
      }
      if (selectable instanceof Node$1) {
        if (placeOrOffset || placeOrOffset === 0) {
          return new Selection(selectable, placeOrOffset);
        } else if (selectable.is("rootElement")) {
          return new Selection(selectable, "in");
        } else {
          return new Selection(selectable, "on");
        }
      }
      return new Selection(selectable);
    }
    class ClickObserver extends DomEventObserver {
      constructor() {
        super(...arguments);
        /**
        * @inheritDoc
        */
        __publicField(this, "domEventType", "click");
      }
      /**
      * @inheritDoc
      */
      onDomEvent(domEvent) {
        this.fire(domEvent.type, domEvent);
      }
    }
    class MouseObserver extends DomEventObserver {
      constructor() {
        super(...arguments);
        /**
        * @inheritDoc
        */
        __publicField(this, "domEventType", [
          "mousedown",
          "mouseup",
          "mouseover",
          "mouseout"
        ]);
      }
      /**
      * @inheritDoc
      */
      onDomEvent(domEvent) {
        this.fire(domEvent.type, domEvent);
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class Watchdog {
      /**
      * @param {module:watchdog/watchdog~WatchdogConfig} config The watchdog plugin configuration.
      */
      constructor(config2) {
        /**
        * An array of crashes saved as an object with the following properties:
        *
        * * `message`: `String`,
        * * `stack`: `String`,
        * * `date`: `Number`,
        * * `filename`: `String | undefined`,
        * * `lineno`: `Number | undefined`,
        * * `colno`: `Number | undefined`,
        */
        __publicField(this, "crashes", []);
        /**
        * Specifies the state of the item watched by the watchdog. The state can be one of the following values:
        *
        * * `initializing` &ndash; Before the first initialization, and after crashes, before the item is ready.
        * * `ready` &ndash; A state when the user can interact with the item.
        * * `crashed` &ndash; A state when an error occurs. It quickly changes to `initializing` or `crashedPermanently`
        * depending on how many and how frequent errors have been caught recently.
        * * `crashedPermanently` &ndash; A state when the watchdog stops reacting to errors and keeps the item it is watching crashed,
        * * `destroyed` &ndash; A state when the item is manually destroyed by the user after calling `watchdog.destroy()`.
        */
        __publicField(this, "state", "initializing");
        /**
        * @see module:watchdog/watchdog~WatchdogConfig
        */
        __publicField(this, "_crashNumberLimit");
        /**
        * Returns the result of the `Date.now()` call. It can be overridden in tests to mock time as some popular
        * approaches like `sinon.useFakeTimers()` do not work well with error handling.
        */
        __publicField(this, "_now", Date.now);
        /**
        * @see module:watchdog/watchdog~WatchdogConfig
        */
        __publicField(this, "_minimumNonErrorTimePeriod");
        /**
        * Checks if the event error comes from the underlying item and restarts the item.
        */
        __publicField(this, "_boundErrorHandler");
        /**
        * A dictionary of event emitter listeners.
        */
        __publicField(this, "_listeners");
        this.crashes = [];
        this._crashNumberLimit = typeof config2.crashNumberLimit === "number" ? config2.crashNumberLimit : 3;
        this._minimumNonErrorTimePeriod = typeof config2.minimumNonErrorTimePeriod === "number" ? config2.minimumNonErrorTimePeriod : 5e3;
        this._boundErrorHandler = (evt) => {
          const error = "error" in evt ? evt.error : evt.reason;
          if (error instanceof Error) {
            this._handleError(error, evt);
          }
        };
        this._listeners = {};
        if (!this._restart) {
          throw new Error("The Watchdog class was split into the abstract `Watchdog` class and the `EditorWatchdog` class. Please, use `EditorWatchdog` if you have used the `Watchdog` class previously.");
        }
      }
      /**
      * Destroys the watchdog and releases the resources.
      */
      destroy() {
        this._stopErrorHandling();
        this._listeners = {};
      }
      /**
      * Starts listening to a specific event name by registering a callback that will be executed
      * whenever an event with a given name fires.
      *
      * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.
      *
      * @param eventName The event name.
      * @param callback A callback which will be added to event listeners.
      */
      on(eventName, callback) {
        if (!this._listeners[eventName]) {
          this._listeners[eventName] = [];
        }
        this._listeners[eventName].push(callback);
      }
      /**
      * Stops listening to the specified event name by removing the callback from event listeners.
      *
      * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.
      *
      * @param eventName The event name.
      * @param callback A callback which will be removed from event listeners.
      */
      off(eventName, callback) {
        this._listeners[eventName] = this._listeners[eventName].filter((cb) => cb !== callback);
      }
      /**
      * Fires an event with a given event name and arguments.
      *
      * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.
      */
      _fire(eventName, ...args) {
        const callbacks = this._listeners[eventName] || [];
        for (const callback of callbacks) {
          callback.apply(this, [
            null,
            ...args
          ]);
        }
      }
      /**
      * Starts error handling by attaching global error handlers.
      */
      _startErrorHandling() {
        window.addEventListener("error", this._boundErrorHandler);
        window.addEventListener("unhandledrejection", this._boundErrorHandler);
      }
      /**
      * Stops error handling by detaching global error handlers.
      */
      _stopErrorHandling() {
        window.removeEventListener("error", this._boundErrorHandler);
        window.removeEventListener("unhandledrejection", this._boundErrorHandler);
      }
      /**
      * Checks if an error comes from the watched item and restarts it.
      * It reacts to {@link module:utils/ckeditorerror~CKEditorError `CKEditorError` errors} only.
      *
      * @fires error
      * @param error Error.
      * @param evt An error event.
      */
      _handleError(error, evt) {
        if (this._shouldReactToError(error)) {
          this.crashes.push({
            message: error.message,
            stack: error.stack,
            // `evt.filename`, `evt.lineno` and `evt.colno` are available only in ErrorEvent events
            filename: evt instanceof ErrorEvent ? evt.filename : void 0,
            lineno: evt instanceof ErrorEvent ? evt.lineno : void 0,
            colno: evt instanceof ErrorEvent ? evt.colno : void 0,
            date: this._now()
          });
          const causesRestart = this._shouldRestart();
          this.state = "crashed";
          this._fire("stateChange");
          this._fire("error", {
            error,
            causesRestart
          });
          if (causesRestart) {
            this._restart();
          } else {
            this.state = "crashedPermanently";
            this._fire("stateChange");
          }
        }
      }
      /**
      * Checks whether an error should be handled by the watchdog.
      *
      * @param error An error that was caught by the error handling process.
      */
      _shouldReactToError(error) {
        return error.is && error.is("CKEditorError") && error.context !== void 0 && // In some cases the watched item should not be restarted - e.g. during the item initialization.
        // That's why the `null` was introduced as a correct error context which does cause restarting.
        error.context !== null && // Do not react to errors if the watchdog is in states other than `ready`.
        this.state === "ready" && this._isErrorComingFromThisItem(error);
      }
      /**
      * Checks if the watchdog should restart the underlying item.
      */
      _shouldRestart() {
        if (this.crashes.length <= this._crashNumberLimit) {
          return true;
        }
        const lastErrorTime = this.crashes[this.crashes.length - 1].date;
        const firstMeaningfulErrorTime = this.crashes[this.crashes.length - 1 - this._crashNumberLimit].date;
        const averageNonErrorTimePeriod = (lastErrorTime - firstMeaningfulErrorTime) / this._crashNumberLimit;
        return averageNonErrorTimePeriod > this._minimumNonErrorTimePeriod;
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function getSubNodes(head2, excludedProperties = /* @__PURE__ */ new Set()) {
      const nodes = [
        head2
      ];
      const subNodes = /* @__PURE__ */ new Set();
      let nodeIndex = 0;
      while (nodes.length > nodeIndex) {
        const node = nodes[nodeIndex++];
        if (subNodes.has(node) || !shouldNodeBeIncluded(node) || excludedProperties.has(node)) {
          continue;
        }
        subNodes.add(node);
        if (Symbol.iterator in node) {
          try {
            for (const n2 of node) {
              nodes.push(n2);
            }
          } catch (err) {
          }
        } else {
          for (const key in node) {
            if (key === "defaultValue") {
              continue;
            }
            nodes.push(node[key]);
          }
        }
      }
      return subNodes;
    }
    function shouldNodeBeIncluded(node) {
      const type = Object.prototype.toString.call(node);
      const typeOfNode = typeof node;
      return !(typeOfNode === "number" || typeOfNode === "boolean" || typeOfNode === "string" || typeOfNode === "symbol" || typeOfNode === "function" || type === "[object Date]" || type === "[object RegExp]" || type === "[object Module]" || node === void 0 || node === null || // This flag is meant to exclude singletons shared across editor instances. So when an error is thrown in one editor,
      // the other editors connected through the reference to the same singleton are not restarted. This is a temporary workaround
      // until a better solution is found.
      // More in https://github.com/ckeditor/ckeditor5/issues/12292.
      node._watchdogExcluded || // Skip native DOM objects, e.g. Window, nodes, events, etc.
      node instanceof EventTarget || node instanceof Event);
    }
    function areConnectedThroughProperties(target1, target2, excludedNodes = /* @__PURE__ */ new Set()) {
      if (target1 === target2 && isObject$2(target1)) {
        return true;
      }
      const subNodes1 = getSubNodes(target1, excludedNodes);
      const subNodes2 = getSubNodes(target2, excludedNodes);
      for (const node of subNodes1) {
        if (subNodes2.has(node)) {
          return true;
        }
      }
      return false;
    }
    function isObject$2(structure) {
      return typeof structure === "object" && structure !== null;
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class EditorWatchdog extends Watchdog {
      /**
      * @param Editor The editor class.
      * @param watchdogConfig The watchdog plugin configuration.
      */
      constructor(Editor2, watchdogConfig = {}) {
        super(watchdogConfig);
        /**
        * The current editor instance.
        */
        __publicField(this, "_editor", null);
        /**
        * A promise associated with the life cycle of the editor (creation or destruction processes).
        *
        * It is used to prevent the initialization of the editor if the previous instance has not been destroyed yet,
        * and conversely, to prevent the destruction of the editor if it has not been initialized.
        */
        __publicField(this, "_lifecyclePromise", null);
        /**
        * Throttled save method. The `save()` method is called the specified `saveInterval` after `throttledSave()` is called,
        * unless a new action happens in the meantime.
        */
        __publicField(this, "_throttledSave");
        /**
        * The latest saved editor data represented as a root name -> root data object.
        */
        __publicField(this, "_data");
        /**
        * The last document version.
        */
        __publicField(this, "_lastDocumentVersion");
        /**
        * The editor source element or data.
        */
        __publicField(this, "_elementOrData");
        /**
        * Specifies whether the editor was initialized using document data (`true`) or HTML elements (`false`).
        */
        __publicField(this, "_initUsingData", true);
        /**
        * The latest record of the editor editable elements. Used to restart the editor.
        */
        __publicField(this, "_editables", {});
        /**
        * The editor configuration.
        */
        __publicField(this, "_config");
        __publicField(this, "_excludedProps");
        this._throttledSave = throttle(this._save.bind(this), typeof watchdogConfig.saveInterval === "number" ? watchdogConfig.saveInterval : 5e3);
        if (Editor2) {
          this._creator = (elementOrData, config2) => Editor2.create(elementOrData, config2);
        }
        this._destructor = (editor2) => editor2.destroy();
      }
      /**
      * The current editor instance.
      */
      get editor() {
        return this._editor;
      }
      /**
      * @internal
      */
      get _item() {
        return this._editor;
      }
      /**
      * Sets the function that is responsible for the editor creation.
      * It expects a function that should return a promise.
      *
      * ```ts
      * watchdog.setCreator( ( element, config ) => ClassicEditor.create( element, config ) );
      * ```
      */
      setCreator(creator) {
        this._creator = creator;
      }
      /**
      * Sets the function that is responsible for the editor destruction.
      * Overrides the default destruction function, which destroys only the editor instance.
      * It expects a function that should return a promise or `undefined`.
      *
      * ```ts
      * watchdog.setDestructor( editor => {
      * 	// Do something before the editor is destroyed.
      *
      * 	return editor
      * 		.destroy()
      * 		.then( () => {
      * 			// Do something after the editor is destroyed.
      * 		} );
      * } );
      * ```
      */
      setDestructor(destructor) {
        this._destructor = destructor;
      }
      /**
      * Restarts the editor instance. This method is called whenever an editor error occurs. It fires the `restart` event and changes
      * the state to `initializing`.
      *
      * @fires restart
      */
      _restart() {
        return Promise.resolve().then(() => {
          this.state = "initializing";
          this._fire("stateChange");
          return this._destroy();
        }).catch((err) => {
          console.error("An error happened during the editor destroying.", err);
        }).then(() => {
          const existingRoots = {};
          const lazyRoots = [];
          const oldRootsAttributes = this._config.rootsAttributes || {};
          const rootsAttributes = {};
          for (const [rootName, rootData] of Object.entries(this._data.roots)) {
            if (rootData.isLoaded) {
              existingRoots[rootName] = "";
              rootsAttributes[rootName] = oldRootsAttributes[rootName] || {};
            } else {
              lazyRoots.push(rootName);
            }
          }
          const updatedConfig = {
            ...this._config,
            extraPlugins: this._config.extraPlugins || [],
            lazyRoots,
            rootsAttributes,
            _watchdogInitialData: this._data
          };
          delete updatedConfig.initialData;
          updatedConfig.extraPlugins.push(EditorWatchdogInitPlugin);
          if (this._initUsingData) {
            return this.create(existingRoots, updatedConfig, updatedConfig.context);
          } else {
            if (isElement$3(this._elementOrData)) {
              return this.create(this._elementOrData, updatedConfig, updatedConfig.context);
            } else {
              return this.create(this._editables, updatedConfig, updatedConfig.context);
            }
          }
        }).then(() => {
          this._fire("restart");
        });
      }
      /**
      * Creates the editor instance and keeps it running, using the defined creator and destructor.
      *
      * @param elementOrData The editor source element or the editor data.
      * @param config The editor configuration.
      * @param context A context for the editor.
      */
      create(elementOrData = this._elementOrData, config2 = this._config, context) {
        this._lifecyclePromise = Promise.resolve(this._lifecyclePromise).then(() => {
          super._startErrorHandling();
          this._elementOrData = elementOrData;
          this._initUsingData = typeof elementOrData == "string" || Object.keys(elementOrData).length > 0 && typeof Object.values(elementOrData)[0] == "string";
          this._config = this._cloneEditorConfiguration(config2) || {};
          this._config.context = context;
          return this._creator(elementOrData, this._config);
        }).then((editor2) => {
          this._editor = editor2;
          editor2.model.document.on("change:data", this._throttledSave);
          this._lastDocumentVersion = editor2.model.document.version;
          this._data = this._getData();
          if (!this._initUsingData) {
            this._editables = this._getEditables();
          }
          this.state = "ready";
          this._fire("stateChange");
        }).finally(() => {
          this._lifecyclePromise = null;
        });
        return this._lifecyclePromise;
      }
      /**
      * Destroys the watchdog and the current editor instance. It fires the callback
      * registered in {@link #setDestructor `setDestructor()`} and uses it to destroy the editor instance.
      * It also sets the state to `destroyed`.
      */
      destroy() {
        this._lifecyclePromise = Promise.resolve(this._lifecyclePromise).then(() => {
          this.state = "destroyed";
          this._fire("stateChange");
          super.destroy();
          return this._destroy();
        }).finally(() => {
          this._lifecyclePromise = null;
        });
        return this._lifecyclePromise;
      }
      _destroy() {
        return Promise.resolve().then(() => {
          this._stopErrorHandling();
          this._throttledSave.cancel();
          const editor2 = this._editor;
          this._editor = null;
          editor2.model.document.off("change:data", this._throttledSave);
          return this._destructor(editor2);
        });
      }
      /**
      * Saves the editor data, so it can be restored after the crash even if the data cannot be fetched at
      * the moment of the crash.
      */
      _save() {
        const version2 = this._editor.model.document.version;
        try {
          this._data = this._getData();
          if (!this._initUsingData) {
            this._editables = this._getEditables();
          }
          this._lastDocumentVersion = version2;
        } catch (err) {
          console.error(err, "An error happened during restoring editor data. Editor will be restored from the previously saved data.");
        }
      }
      /**
      * @internal
      */
      _setExcludedProperties(props) {
        this._excludedProps = props;
      }
      /**
      * Gets all data that is required to reinitialize editor instance.
      */
      _getData() {
        const editor2 = this._editor;
        const roots = editor2.model.document.roots.filter((root2) => root2.isAttached() && root2.rootName != "$graveyard");
        const { plugins } = editor2;
        const commentsRepository = plugins.has("CommentsRepository") && plugins.get("CommentsRepository");
        const trackChanges = plugins.has("TrackChanges") && plugins.get("TrackChanges");
        const data = {
          roots: {},
          markers: {},
          commentThreads: JSON.stringify([]),
          suggestions: JSON.stringify([])
        };
        roots.forEach((root2) => {
          data.roots[root2.rootName] = {
            content: JSON.stringify(Array.from(root2.getChildren())),
            attributes: JSON.stringify(Array.from(root2.getAttributes())),
            isLoaded: root2._isLoaded
          };
        });
        for (const marker of editor2.model.markers) {
          if (!marker._affectsData) {
            continue;
          }
          data.markers[marker.name] = {
            rangeJSON: marker.getRange().toJSON(),
            usingOperation: marker._managedUsingOperations,
            affectsData: marker._affectsData
          };
        }
        if (commentsRepository) {
          data.commentThreads = JSON.stringify(commentsRepository.getCommentThreads({
            toJSON: true,
            skipNotAttached: true
          }));
        }
        if (trackChanges) {
          data.suggestions = JSON.stringify(trackChanges.getSuggestions({
            toJSON: true,
            skipNotAttached: true
          }));
        }
        return data;
      }
      /**
      * For each attached model root, returns its HTML editable element (if available).
      */
      _getEditables() {
        const editables = {};
        for (const rootName of this.editor.model.document.getRootNames()) {
          const editable = this.editor.ui.getEditableElement(rootName);
          if (editable) {
            editables[rootName] = editable;
          }
        }
        return editables;
      }
      /**
      * Traverses the error context and the current editor to find out whether these structures are connected
      * to each other via properties.
      *
      * @internal
      */
      _isErrorComingFromThisItem(error) {
        return areConnectedThroughProperties(this._editor, error.context, this._excludedProps);
      }
      /**
      * Clones the editor configuration.
      */
      _cloneEditorConfiguration(config2) {
        return cloneDeepWith(config2, (value, key) => {
          if (isElement$3(value)) {
            return value;
          }
          if (key === "context") {
            return value;
          }
        });
      }
    }
    class EditorWatchdogInitPlugin {
      constructor(editor2) {
        __publicField(this, "editor");
        __publicField(this, "_data");
        this.editor = editor2;
        this._data = editor2.config.get("_watchdogInitialData");
      }
      /**
      * @inheritDoc
      */
      init() {
        this.editor.data.on("init", (evt) => {
          evt.stop();
          this.editor.model.enqueueChange({
            isUndoable: false
          }, (writer) => {
            this._restoreCollaborationData();
            this._restoreEditorData(writer);
          });
          this.editor.data.fire("ready");
        }, {
          priority: 1e3 - 1
        });
      }
      /**
      * Creates a model node (element or text) based on provided JSON.
      */
      _createNode(writer, jsonNode) {
        if ("name" in jsonNode) {
          const element = writer.createElement(jsonNode.name, jsonNode.attributes);
          if (jsonNode.children) {
            for (const child of jsonNode.children) {
              element._appendChild(this._createNode(writer, child));
            }
          }
          return element;
        } else {
          return writer.createText(jsonNode.data, jsonNode.attributes);
        }
      }
      /**
      * Restores the editor by setting the document data, roots attributes and markers.
      */
      _restoreEditorData(writer) {
        const editor2 = this.editor;
        Object.entries(this._data.roots).forEach(([rootName, { content, attributes }]) => {
          const parsedNodes = JSON.parse(content);
          const parsedAttributes = JSON.parse(attributes);
          const rootElement = editor2.model.document.getRoot(rootName);
          for (const [key, value] of parsedAttributes) {
            writer.setAttribute(key, value, rootElement);
          }
          for (const child of parsedNodes) {
            const node = this._createNode(writer, child);
            writer.insert(node, rootElement, "end");
          }
        });
        Object.entries(this._data.markers).forEach(([markerName, markerOptions]) => {
          const { document: document2 } = editor2.model;
          const { rangeJSON: { start: start2, end: end2 }, ...options } = markerOptions;
          const root2 = document2.getRoot(start2.root);
          const startPosition = writer.createPositionFromPath(root2, start2.path, start2.stickiness);
          const endPosition = writer.createPositionFromPath(root2, end2.path, end2.stickiness);
          const range2 = writer.createRange(startPosition, endPosition);
          writer.addMarker(markerName, {
            range: range2,
            ...options
          });
        });
      }
      /**
      * Restores the editor collaboration data - comment threads and suggestions.
      */
      _restoreCollaborationData() {
        const parsedCommentThreads = JSON.parse(this._data.commentThreads);
        const parsedSuggestions = JSON.parse(this._data.suggestions);
        parsedCommentThreads.forEach((commentThreadData) => {
          const channelId = this.editor.config.get("collaboration.channelId");
          const commentsRepository = this.editor.plugins.get("CommentsRepository");
          if (commentsRepository.hasCommentThread(commentThreadData.threadId)) {
            const commentThread = commentsRepository.getCommentThread(commentThreadData.threadId);
            commentThread.remove();
          }
          commentsRepository.addCommentThread({
            channelId,
            ...commentThreadData
          });
        });
        parsedSuggestions.forEach((suggestionData) => {
          const trackChangesEditing = this.editor.plugins.get("TrackChangesEditing");
          if (trackChangesEditing.hasSuggestion(suggestionData.id)) {
            const suggestion = trackChangesEditing.getSuggestion(suggestionData.id);
            suggestion.attributes = suggestionData.attributes;
          } else {
            trackChangesEditing.addSuggestionData(suggestionData);
          }
        });
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    const mainQueueId = Symbol("MainQueueId");
    class ContextWatchdog extends Watchdog {
      /**
      * The context watchdog class constructor.
      *
      * ```ts
      * const watchdog = new ContextWatchdog( Context );
      *
      * await watchdog.create( contextConfiguration );
      *
      * await watchdog.add( item );
      * ```
      *
      * See the {@glink features/watchdog Watchdog feature guide} to learn more how to use this feature.
      *
      * @param Context The {@link module:core/context~Context} class.
      * @param watchdogConfig The watchdog configuration.
      */
      constructor(Context2, watchdogConfig = {}) {
        super(watchdogConfig);
        /**
        * A map of internal watchdogs for added items.
        */
        __publicField(this, "_watchdogs", /* @__PURE__ */ new Map());
        /**
        * The watchdog configuration.
        */
        __publicField(this, "_watchdogConfig");
        /**
        * The current context instance.
        */
        __publicField(this, "_context", null);
        /**
        * Context properties (nodes/references) that are gathered during the initial context creation
        * and are used to distinguish the origin of an error.
        */
        __publicField(this, "_contextProps", /* @__PURE__ */ new Set());
        /**
        * An action queue, which is used to handle async functions queuing.
        */
        __publicField(this, "_actionQueues", new ActionQueues());
        /**
        * The configuration for the {@link module:core/context~Context}.
        */
        __publicField(this, "_contextConfig");
        /**
        * The watched item.
        */
        __publicField(this, "_item");
        this._watchdogConfig = watchdogConfig;
        this._creator = (contextConfig) => Context2.create(contextConfig);
        this._destructor = (context) => context.destroy();
        this._actionQueues.onEmpty(() => {
          if (this.state === "initializing") {
            this.state = "ready";
            this._fire("stateChange");
          }
        });
      }
      /**
      * Sets the function that is responsible for the context creation.
      * It expects a function that should return a promise (or `undefined`).
      *
      * ```ts
      * watchdog.setCreator( config => Context.create( config ) );
      * ```
      */
      setCreator(creator) {
        this._creator = creator;
      }
      /**
      * Sets the function that is responsible for the context destruction.
      * Overrides the default destruction function, which destroys only the context instance.
      * It expects a function that should return a promise (or `undefined`).
      *
      * ```ts
      * watchdog.setDestructor( context => {
      * 	// Do something before the context is destroyed.
      *
      * 	return context
      * 		.destroy()
      * 		.then( () => {
      * 			// Do something after the context is destroyed.
      * 		} );
      * } );
      * ```
      */
      setDestructor(destructor) {
        this._destructor = destructor;
      }
      /**
      * The context instance. Keep in mind that this property might be changed when the context watchdog restarts,
      * so do not keep this instance internally. Always operate on the `ContextWatchdog#context` property.
      */
      get context() {
        return this._context;
      }
      /**
      * Initializes the context watchdog. Once it is created, the watchdog takes care about
      * recreating the context and the provided items, and starts the error handling mechanism.
      *
      * ```ts
      * await watchdog.create( {
      * 	plugins: []
      * } );
      * ```
      *
      * @param contextConfig The context configuration. See {@link module:core/context~Context}.
      */
      create(contextConfig = {}) {
        return this._actionQueues.enqueue(mainQueueId, () => {
          this._contextConfig = contextConfig;
          return this._create();
        });
      }
      /**
      * Returns an item instance with the given `itemId`.
      *
      * ```ts
      * const editor1 = watchdog.getItem( 'editor1' );
      * ```
      *
      * @param itemId The item ID.
      * @returns The item instance or `undefined` if an item with a given ID has not been found.
      */
      getItem(itemId) {
        const watchdog = this._getWatchdog(itemId);
        return watchdog._item;
      }
      /**
      * Gets the state of the given item. See {@link #state} for a list of available states.
      *
      * ```ts
      * const editor1State = watchdog.getItemState( 'editor1' );
      * ```
      *
      * @param itemId Item ID.
      * @returns The state of the item.
      */
      getItemState(itemId) {
        const watchdog = this._getWatchdog(itemId);
        return watchdog.state;
      }
      /**
      * Adds items to the watchdog. Once created, instances of these items will be available using the {@link #getItem} method.
      *
      * Items can be passed together as an array of objects:
      *
      * ```ts
      * await watchdog.add( [ {
      * 	id: 'editor1',
      * 	type: 'editor',
      * 	sourceElementOrData: document.querySelector( '#editor' ),
      * 	config: {
      * 		plugins: [ Essentials, Paragraph, Bold, Italic ],
      * 		toolbar: [ 'bold', 'italic', 'alignment' ]
      * 	},
      * 	creator: ( element, config ) => ClassicEditor.create( element, config )
      * } ] );
      * ```
      *
      * Or one by one as objects:
      *
      * ```ts
      * await watchdog.add( {
      * 	id: 'editor1',
      * 	type: 'editor',
      * 	sourceElementOrData: document.querySelector( '#editor' ),
      * 	config: {
      * 		plugins: [ Essentials, Paragraph, Bold, Italic ],
      * 		toolbar: [ 'bold', 'italic', 'alignment' ]
      * 	},
      * 	creator: ( element, config ) => ClassicEditor.create( element, config )
      * ] );
      * ```
      *
      * Then an instance can be retrieved using the {@link #getItem} method:
      *
      * ```ts
      * const editor1 = watchdog.getItem( 'editor1' );
      * ```
      *
      * Note that this method can be called multiple times, but for performance reasons it is better
      * to pass all items together.
      *
      * @param itemConfigurationOrItemConfigurations An item configuration object or an array of item configurations.
      */
      add(itemConfigurationOrItemConfigurations) {
        const itemConfigurations = toArray$1(itemConfigurationOrItemConfigurations);
        return Promise.all(itemConfigurations.map((item) => {
          return this._actionQueues.enqueue(item.id, () => {
            if (this.state === "destroyed") {
              throw new Error("Cannot add items to destroyed watchdog.");
            }
            if (!this._context) {
              throw new Error("Context was not created yet. You should call the `ContextWatchdog#create()` method first.");
            }
            let watchdog;
            if (this._watchdogs.has(item.id)) {
              throw new Error(`Item with the given id is already added: '${item.id}'.`);
            }
            if (item.type === "editor") {
              watchdog = new EditorWatchdog(null, this._watchdogConfig);
              watchdog.setCreator(item.creator);
              watchdog._setExcludedProperties(this._contextProps);
              if (item.destructor) {
                watchdog.setDestructor(item.destructor);
              }
              this._watchdogs.set(item.id, watchdog);
              watchdog.on("error", (evt, { error, causesRestart }) => {
                this._fire("itemError", {
                  itemId: item.id,
                  error
                });
                if (!causesRestart) {
                  return;
                }
                this._actionQueues.enqueue(item.id, () => new Promise((res) => {
                  const rethrowRestartEventOnce = () => {
                    watchdog.off("restart", rethrowRestartEventOnce);
                    this._fire("itemRestart", {
                      itemId: item.id
                    });
                    res();
                  };
                  watchdog.on("restart", rethrowRestartEventOnce);
                }));
              });
              return watchdog.create(item.sourceElementOrData, item.config, this._context);
            } else {
              throw new Error(`Not supported item type: '${item.type}'.`);
            }
          });
        }));
      }
      /**
      * Removes and destroys item(s) with given ID(s).
      *
      * ```ts
      * await watchdog.remove( 'editor1' );
      * ```
      *
      * Or
      *
      * ```ts
      * await watchdog.remove( [ 'editor1', 'editor2' ] );
      * ```
      *
      * @param itemIdOrItemIds Item ID or an array of item IDs.
      */
      remove(itemIdOrItemIds) {
        const itemIds = toArray$1(itemIdOrItemIds);
        return Promise.all(itemIds.map((itemId) => {
          return this._actionQueues.enqueue(itemId, () => {
            const watchdog = this._getWatchdog(itemId);
            this._watchdogs.delete(itemId);
            return watchdog.destroy();
          });
        }));
      }
      /**
      * Destroys the context watchdog and all added items.
      * Once the context watchdog is destroyed, new items cannot be added.
      *
      * ```ts
      * await watchdog.destroy();
      * ```
      */
      destroy() {
        return this._actionQueues.enqueue(mainQueueId, () => {
          this.state = "destroyed";
          this._fire("stateChange");
          super.destroy();
          return this._destroy();
        });
      }
      /**
      * Restarts the context watchdog.
      */
      _restart() {
        return this._actionQueues.enqueue(mainQueueId, () => {
          this.state = "initializing";
          this._fire("stateChange");
          return this._destroy().catch((err) => {
            console.error("An error happened during destroying the context or items.", err);
          }).then(() => this._create()).then(() => this._fire("restart"));
        });
      }
      /**
      * Initializes the context watchdog.
      */
      _create() {
        return Promise.resolve().then(() => {
          this._startErrorHandling();
          return this._creator(this._contextConfig);
        }).then((context) => {
          this._context = context;
          this._contextProps = getSubNodes(this._context);
          return Promise.all(Array.from(this._watchdogs.values()).map((watchdog) => {
            watchdog._setExcludedProperties(this._contextProps);
            return watchdog.create(void 0, void 0, this._context);
          }));
        });
      }
      /**
      * Destroys the context instance and all added items.
      */
      _destroy() {
        return Promise.resolve().then(() => {
          this._stopErrorHandling();
          const context = this._context;
          this._context = null;
          this._contextProps = /* @__PURE__ */ new Set();
          return Promise.all(Array.from(this._watchdogs.values()).map((watchdog) => watchdog.destroy())).then(() => this._destructor(context));
        });
      }
      /**
      * Returns the watchdog for a given item ID.
      *
      * @param itemId Item ID.
      */
      _getWatchdog(itemId) {
        const watchdog = this._watchdogs.get(itemId);
        if (!watchdog) {
          throw new Error(`Item with the given id was not registered: ${itemId}.`);
        }
        return watchdog;
      }
      /**
      * Checks whether an error comes from the context instance and not from the item instances.
      *
      * @internal
      */
      _isErrorComingFromThisItem(error) {
        for (const watchdog of this._watchdogs.values()) {
          if (watchdog._isErrorComingFromThisItem(error)) {
            return false;
          }
        }
        return areConnectedThroughProperties(this._context, error.context);
      }
    }
    class ActionQueues {
      constructor() {
        __publicField(this, "_onEmptyCallbacks", []);
        __publicField(this, "_queues", /* @__PURE__ */ new Map());
        __publicField(this, "_activeActions", 0);
      }
      /**
      * Used to register callbacks that will be run when the queue becomes empty.
      *
      * @param onEmptyCallback A callback that will be run whenever the queue becomes empty.
      */
      onEmpty(onEmptyCallback) {
        this._onEmptyCallbacks.push(onEmptyCallback);
      }
      /**
      * It adds asynchronous actions (functions) to the proper queue and runs them one by one.
      *
      * @param queueId The action queue ID.
      * @param action A function that should be enqueued.
      */
      enqueue(queueId, action) {
        const isMainAction = queueId === mainQueueId;
        this._activeActions++;
        if (!this._queues.get(queueId)) {
          this._queues.set(queueId, Promise.resolve());
        }
        const awaitedActions = isMainAction ? Promise.all(this._queues.values()) : Promise.all([
          this._queues.get(mainQueueId),
          this._queues.get(queueId)
        ]);
        const queueWithAction = awaitedActions.then(action);
        const nonErrorQueue = queueWithAction.catch(() => {
        });
        this._queues.set(queueId, nonErrorQueue);
        return queueWithAction.finally(() => {
          this._activeActions--;
          if (this._queues.get(queueId) === nonErrorQueue && this._activeActions === 0) {
            this._onEmptyCallbacks.forEach((cb) => cb());
          }
        });
      }
    }
    function toArray$1(elementOrArray) {
      return Array.isArray(elementOrArray) ? elementOrArray : [
        elementOrArray
      ];
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class Plugin extends (/* @__PURE__ */ ObservableMixin()) {
      /**
      * @inheritDoc
      */
      constructor(editor2) {
        super();
        /**
        * The editor instance.
        *
        * Note that most editors implement the {@link module:core/editor/editor~Editor#ui} property.
        * However, editors with an external UI (i.e. Bootstrap-based) or a headless editor may not have this property or
        * throw an error when accessing it.
        *
        * Because of above, to make plugins more universal, it is recommended to split features into:
        *  - The "editing" part that uses the {@link module:core/editor/editor~Editor} class without `ui` property.
        *  - The "UI" part that uses the {@link module:core/editor/editor~Editor} class and accesses `ui` property.
        */
        __publicField(this, "editor");
        /**
        * Holds identifiers for {@link #forceDisabled} mechanism.
        */
        __publicField(this, "_disableStack", /* @__PURE__ */ new Set());
        this.editor = editor2;
        this.set("isEnabled", true);
      }
      /**
      * Disables the plugin.
      *
      * Plugin may be disabled by multiple features or algorithms (at once). When disabling a plugin, unique id should be passed
      * (e.g. feature name). The same identifier should be used when {@link #clearForceDisabled enabling back} the plugin.
      * The plugin becomes enabled only after all features {@link #clearForceDisabled enabled it back}.
      *
      * Disabling and enabling a plugin:
      *
      * ```ts
      * plugin.isEnabled; // -> true
      * plugin.forceDisabled( 'MyFeature' );
      * plugin.isEnabled; // -> false
      * plugin.clearForceDisabled( 'MyFeature' );
      * plugin.isEnabled; // -> true
      * ```
      *
      * Plugin disabled by multiple features:
      *
      * ```ts
      * plugin.forceDisabled( 'MyFeature' );
      * plugin.forceDisabled( 'OtherFeature' );
      * plugin.clearForceDisabled( 'MyFeature' );
      * plugin.isEnabled; // -> false
      * plugin.clearForceDisabled( 'OtherFeature' );
      * plugin.isEnabled; // -> true
      * ```
      *
      * Multiple disabling with the same identifier is redundant:
      *
      * ```ts
      * plugin.forceDisabled( 'MyFeature' );
      * plugin.forceDisabled( 'MyFeature' );
      * plugin.clearForceDisabled( 'MyFeature' );
      * plugin.isEnabled; // -> true
      * ```
      *
      * **Note:** some plugins or algorithms may have more complex logic when it comes to enabling or disabling certain plugins,
      * so the plugin might be still disabled after {@link #clearForceDisabled} was used.
      *
      * @param id Unique identifier for disabling. Use the same id when {@link #clearForceDisabled enabling back} the plugin.
      */
      forceDisabled(id) {
        this._disableStack.add(id);
        if (this._disableStack.size == 1) {
          this.on("set:isEnabled", forceDisable$1, {
            priority: "highest"
          });
          this.isEnabled = false;
        }
      }
      /**
      * Clears forced disable previously set through {@link #forceDisabled}. See {@link #forceDisabled}.
      *
      * @param id Unique identifier, equal to the one passed in {@link #forceDisabled} call.
      */
      clearForceDisabled(id) {
        this._disableStack.delete(id);
        if (this._disableStack.size == 0) {
          this.off("set:isEnabled", forceDisable$1);
          this.isEnabled = true;
        }
      }
      /**
      * @inheritDoc
      */
      destroy() {
        this.stopListening();
      }
      /**
      * @inheritDoc
      */
      static get isContextPlugin() {
        return false;
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return false;
      }
      /**
      * @inheritDoc
      */
      static get isPremiumPlugin() {
        return false;
      }
    }
    function forceDisable$1(evt) {
      evt.return = false;
      evt.stop();
    }
    class Command extends (/* @__PURE__ */ ObservableMixin()) {
      /**
      * Creates a new `Command` instance.
      *
      * @param editor The editor on which this command will be used.
      */
      constructor(editor2) {
        super();
        /**
        * The editor on which this command will be used.
        */
        __publicField(this, "editor");
        /**
        * A flag indicating whether a command's `isEnabled` state should be changed depending on where the document
        * selection is placed.
        *
        * By default, it is set to `true`. If the document selection is placed in a
        * {@link module:engine/model/model~Model#canEditAt non-editable} place (such as non-editable root), the command becomes disabled.
        *
        * The flag should be changed to `false` in a concrete command's constructor if the command should not change its `isEnabled`
        * accordingly to the document selection.
        */
        __publicField(this, "_isEnabledBasedOnSelection");
        /**
        * A flag indicating whether a command execution changes the editor data or not.
        *
        * @see #affectsData
        */
        __publicField(this, "_affectsData");
        /**
        * Holds identifiers for {@link #forceDisabled} mechanism.
        */
        __publicField(this, "_disableStack");
        this.editor = editor2;
        this.set("value", void 0);
        this.set("isEnabled", false);
        this._affectsData = true;
        this._isEnabledBasedOnSelection = true;
        this._disableStack = /* @__PURE__ */ new Set();
        this.decorate("execute");
        this.listenTo(this.editor.model.document, "change", () => {
          this.refresh();
        });
        this.listenTo(editor2, "change:isReadOnly", () => {
          this.refresh();
        });
        this.on("set:isEnabled", (evt) => {
          if (!this.affectsData) {
            return;
          }
          const selection = editor2.model.document.selection;
          const selectionInGraveyard = selection.getFirstPosition().root.rootName == "$graveyard";
          const canEditAtSelection = !selectionInGraveyard && editor2.model.canEditAt(selection);
          if (editor2.isReadOnly || this._isEnabledBasedOnSelection && !canEditAtSelection) {
            evt.return = false;
            evt.stop();
          }
        }, {
          priority: "highest"
        });
        this.on("execute", (evt) => {
          if (!this.isEnabled) {
            evt.stop();
          }
        }, {
          priority: "high"
        });
      }
      /**
      * A flag indicating whether a command execution changes the editor data or not.
      *
      * Commands with `affectsData` set to `false` will not be automatically disabled in
      * the {@link module:core/editor/editor~Editor#isReadOnly read-only mode} and
      * {@glink features/read-only#related-features other editor modes} with restricted user write permissions.
      *
      * **Note:** You do not have to set it for your every command. It is `true` by default.
      *
      * @default true
      */
      get affectsData() {
        return this._affectsData;
      }
      set affectsData(affectsData) {
        this._affectsData = affectsData;
      }
      /**
      * Refreshes the command. The command should update its {@link #isEnabled} and {@link #value} properties
      * in this method.
      *
      * This method is automatically called when
      * {@link module:engine/model/document~Document#event:change any changes are applied to the document}.
      */
      refresh() {
        this.isEnabled = true;
      }
      /**
      * Disables the command.
      *
      * Command may be disabled by multiple features or algorithms (at once). When disabling a command, unique id should be passed
      * (e.g. the feature name). The same identifier should be used when {@link #clearForceDisabled enabling back} the command.
      * The command becomes enabled only after all features {@link #clearForceDisabled enabled it back}.
      *
      * Disabling and enabling a command:
      *
      * ```ts
      * command.isEnabled; // -> true
      * command.forceDisabled( 'MyFeature' );
      * command.isEnabled; // -> false
      * command.clearForceDisabled( 'MyFeature' );
      * command.isEnabled; // -> true
      * ```
      *
      * Command disabled by multiple features:
      *
      * ```ts
      * command.forceDisabled( 'MyFeature' );
      * command.forceDisabled( 'OtherFeature' );
      * command.clearForceDisabled( 'MyFeature' );
      * command.isEnabled; // -> false
      * command.clearForceDisabled( 'OtherFeature' );
      * command.isEnabled; // -> true
      * ```
      *
      * Multiple disabling with the same identifier is redundant:
      *
      * ```ts
      * command.forceDisabled( 'MyFeature' );
      * command.forceDisabled( 'MyFeature' );
      * command.clearForceDisabled( 'MyFeature' );
      * command.isEnabled; // -> true
      * ```
      *
      * **Note:** some commands or algorithms may have more complex logic when it comes to enabling or disabling certain commands,
      * so the command might be still disabled after {@link #clearForceDisabled} was used.
      *
      * @param id Unique identifier for disabling. Use the same id when {@link #clearForceDisabled enabling back} the command.
      */
      forceDisabled(id) {
        this._disableStack.add(id);
        if (this._disableStack.size == 1) {
          this.on("set:isEnabled", forceDisable, {
            priority: "highest"
          });
          this.isEnabled = false;
        }
      }
      /**
      * Clears forced disable previously set through {@link #forceDisabled}. See {@link #forceDisabled}.
      *
      * @param id Unique identifier, equal to the one passed in {@link #forceDisabled} call.
      */
      clearForceDisabled(id) {
        this._disableStack.delete(id);
        if (this._disableStack.size == 0) {
          this.off("set:isEnabled", forceDisable);
          this.refresh();
        }
      }
      /**
      * Executes the command.
      *
      * A command may accept parameters. They will be passed from {@link module:core/editor/editor~Editor#execute `editor.execute()`}
      * to the command.
      *
      * The `execute()` method will automatically abort when the command is disabled ({@link #isEnabled} is `false`).
      * This behavior is implemented by a high priority listener to the {@link #event:execute} event.
      *
      * In order to see how to disable a command from "outside" see the {@link #isEnabled} documentation.
      *
      * This method may return a value, which would be forwarded all the way down to the
      * {@link module:core/editor/editor~Editor#execute `editor.execute()`}.
      *
      * @fires execute
      */
      execute(...args) {
        return void 0;
      }
      /**
      * Destroys the command.
      */
      destroy() {
        this.stopListening();
      }
    }
    function forceDisable(evt) {
      evt.return = false;
      evt.stop();
    }
    class PluginCollection extends (/* @__PURE__ */ EmitterMixin()) {
      /**
      * Creates an instance of the plugin collection class.
      * Allows loading and initializing plugins and their dependencies.
      * Allows providing a list of already loaded plugins. These plugins will not be destroyed along with this collection.
      *
      * @param availablePlugins Plugins (constructors) which the collection will be able to use
      * when {@link module:core/plugincollection~PluginCollection#init} is used with the plugin names (strings, instead of constructors).
      * Usually, the editor will pass its built-in plugins to the collection so they can later be
      * used in `config.plugins` or `config.removePlugins` by names.
      * @param contextPlugins A list of already initialized plugins represented by a `[ PluginConstructor, pluginInstance ]` pair.
      */
      constructor(context, availablePlugins = [], contextPlugins = []) {
        super();
        __publicField(this, "_context");
        __publicField(this, "_plugins", /* @__PURE__ */ new Map());
        /**
        * A map of plugin constructors that can be retrieved by their names.
        */
        __publicField(this, "_availablePlugins");
        /**
        * Map of {@link module:core/contextplugin~ContextPlugin context plugins} which can be retrieved by their constructors or instances.
        */
        __publicField(this, "_contextPlugins");
        this._context = context;
        this._availablePlugins = /* @__PURE__ */ new Map();
        for (const PluginConstructor of availablePlugins) {
          if (PluginConstructor.pluginName) {
            this._availablePlugins.set(PluginConstructor.pluginName, PluginConstructor);
          }
        }
        this._contextPlugins = /* @__PURE__ */ new Map();
        for (const [PluginConstructor, pluginInstance] of contextPlugins) {
          this._contextPlugins.set(PluginConstructor, pluginInstance);
          this._contextPlugins.set(pluginInstance, PluginConstructor);
          if (PluginConstructor.pluginName) {
            this._availablePlugins.set(PluginConstructor.pluginName, PluginConstructor);
          }
        }
      }
      /**
      * Iterable interface.
      *
      * Returns `[ PluginConstructor, pluginInstance ]` pairs.
      */
      *[Symbol.iterator]() {
        for (const entry of this._plugins) {
          if (typeof entry[0] == "function") {
            yield entry;
          }
        }
      }
      /**
      * Gets the plugin instance by its constructor or name.
      *
      * ```ts
      * // Check if 'Clipboard' plugin was loaded.
      * if ( editor.plugins.has( 'ClipboardPipeline' ) ) {
      * 	// Get clipboard plugin instance
      * 	const clipboard = editor.plugins.get( 'ClipboardPipeline' );
      *
      * 	this.listenTo( clipboard, 'inputTransformation', ( evt, data ) => {
      * 		// Do something on clipboard input.
      * 	} );
      * }
      * ```
      *
      * **Note**: This method will throw an error if a plugin is not loaded. Use `{@link #has editor.plugins.has()}`
      * to check if a plugin is available.
      *
      * @param key The plugin constructor or {@link module:core/plugin~PluginStaticMembers#pluginName name}.
      */
      get(key) {
        const plugin = this._plugins.get(key);
        if (!plugin) {
          let pluginName = key;
          if (typeof key == "function") {
            pluginName = key.pluginName || key.name;
          }
          throw new CKEditorError("plugincollection-plugin-not-loaded", this._context, {
            plugin: pluginName
          });
        }
        return plugin;
      }
      /**
      * Checks if a plugin is loaded.
      *
      * ```ts
      * // Check if the 'Clipboard' plugin was loaded.
      * if ( editor.plugins.has( 'ClipboardPipeline' ) ) {
      * 	// Now use the clipboard plugin instance:
      * 	const clipboard = editor.plugins.get( 'ClipboardPipeline' );
      *
      * 	// ...
      * }
      * ```
      *
      * @param key The plugin constructor or {@link module:core/plugin~PluginStaticMembers#pluginName name}.
      */
      has(key) {
        return this._plugins.has(key);
      }
      /**
      * Initializes a set of plugins and adds them to the collection.
      *
      * @param plugins An array of {@link module:core/plugin~PluginInterface plugin constructors}
      * or {@link module:core/plugin~PluginStaticMembers#pluginName plugin names}.
      * @param pluginsToRemove Names of the plugins or plugin constructors
      * that should not be loaded (despite being specified in the `plugins` array).
      * @param pluginsSubstitutions An array of {@link module:core/plugin~PluginInterface plugin constructors}
      * that will be used to replace plugins of the same names that were passed in `plugins` or that are in their dependency tree.
      * A useful option for replacing built-in plugins while creating tests (for mocking their APIs). Plugins that will be replaced
      * must follow these rules:
      *   * The new plugin must be a class.
      *   * The new plugin must be named.
      *   * Both plugins must not depend on other plugins.
      * @returns A promise which gets resolved once all plugins are loaded and available in the collection.
      */
      init(plugins, pluginsToRemove = [], pluginsSubstitutions = []) {
        const that = this;
        const context = this._context;
        findAvailablePluginConstructors(plugins);
        validatePlugins(plugins);
        const pluginsToLoad = plugins.filter((plugin) => !isPluginRemoved(plugin, pluginsToRemove));
        const pluginConstructors = [
          ...getPluginConstructors(pluginsToLoad)
        ];
        substitutePlugins(pluginConstructors, pluginsSubstitutions);
        const pluginInstances = loadPlugins(pluginConstructors);
        return initPlugins(pluginInstances, "init").then(() => initPlugins(pluginInstances, "afterInit")).then(() => pluginInstances);
        function isPluginConstructor(plugin) {
          return typeof plugin === "function";
        }
        function isContextPlugin(plugin) {
          return isPluginConstructor(plugin) && !!plugin.isContextPlugin;
        }
        function isPluginRemoved(plugin, pluginsToRemove2) {
          return pluginsToRemove2.some((removedPlugin) => {
            if (removedPlugin === plugin) {
              return true;
            }
            if (getPluginName(plugin) === removedPlugin) {
              return true;
            }
            if (getPluginName(removedPlugin) === plugin) {
              return true;
            }
            return false;
          });
        }
        function getPluginName(plugin) {
          return isPluginConstructor(plugin) ? plugin.pluginName || plugin.name : plugin;
        }
        function findAvailablePluginConstructors(plugins2, processed = /* @__PURE__ */ new Set()) {
          plugins2.forEach((plugin) => {
            if (!isPluginConstructor(plugin)) {
              return;
            }
            if (processed.has(plugin)) {
              return;
            }
            processed.add(plugin);
            if (plugin.pluginName && !that._availablePlugins.has(plugin.pluginName)) {
              that._availablePlugins.set(plugin.pluginName, plugin);
            }
            if (plugin.requires) {
              findAvailablePluginConstructors(plugin.requires, processed);
            }
          });
        }
        function getPluginConstructors(plugins2, processed = /* @__PURE__ */ new Set()) {
          return plugins2.map((plugin) => {
            return isPluginConstructor(plugin) ? plugin : that._availablePlugins.get(plugin);
          }).reduce((result2, plugin) => {
            if (processed.has(plugin)) {
              return result2;
            }
            processed.add(plugin);
            if (plugin.requires) {
              validatePlugins(plugin.requires, plugin);
              getPluginConstructors(plugin.requires, processed).forEach((plugin2) => result2.add(plugin2));
            }
            return result2.add(plugin);
          }, /* @__PURE__ */ new Set());
        }
        function validatePlugins(plugins2, parentPluginConstructor = null) {
          plugins2.map((plugin) => {
            return isPluginConstructor(plugin) ? plugin : that._availablePlugins.get(plugin) || plugin;
          }).forEach((plugin) => {
            checkMissingPlugin(plugin, parentPluginConstructor);
            checkContextPlugin(plugin, parentPluginConstructor);
            checkRemovedPlugin(plugin, parentPluginConstructor);
          });
        }
        function checkMissingPlugin(plugin, parentPluginConstructor) {
          if (isPluginConstructor(plugin)) {
            return;
          }
          if (parentPluginConstructor) {
            throw new CKEditorError("plugincollection-soft-required", context, {
              missingPlugin: plugin,
              requiredBy: getPluginName(parentPluginConstructor)
            });
          }
          throw new CKEditorError("plugincollection-plugin-not-found", context, {
            plugin
          });
        }
        function checkContextPlugin(plugin, parentPluginConstructor) {
          if (!isContextPlugin(parentPluginConstructor)) {
            return;
          }
          if (isContextPlugin(plugin)) {
            return;
          }
          throw new CKEditorError("plugincollection-context-required", context, {
            plugin: getPluginName(plugin),
            requiredBy: getPluginName(parentPluginConstructor)
          });
        }
        function checkRemovedPlugin(plugin, parentPluginConstructor) {
          if (!parentPluginConstructor) {
            return;
          }
          if (!isPluginRemoved(plugin, pluginsToRemove)) {
            return;
          }
          throw new CKEditorError("plugincollection-required", context, {
            plugin: getPluginName(plugin),
            requiredBy: getPluginName(parentPluginConstructor)
          });
        }
        function loadPlugins(pluginConstructors2) {
          return pluginConstructors2.map((PluginConstructor) => {
            let pluginInstance = that._contextPlugins.get(PluginConstructor);
            pluginInstance = pluginInstance || new PluginConstructor(context);
            that._add(PluginConstructor, pluginInstance);
            return pluginInstance;
          });
        }
        function initPlugins(pluginInstances2, method2) {
          return pluginInstances2.reduce((promise, plugin) => {
            if (!plugin[method2]) {
              return promise;
            }
            if (that._contextPlugins.has(plugin)) {
              return promise;
            }
            return promise.then(plugin[method2].bind(plugin));
          }, Promise.resolve());
        }
        function substitutePlugins(pluginConstructors2, pluginsSubstitutions2) {
          for (const pluginItem of pluginsSubstitutions2) {
            if (typeof pluginItem != "function") {
              throw new CKEditorError("plugincollection-replace-plugin-invalid-type", null, {
                pluginItem
              });
            }
            const pluginName = pluginItem.pluginName;
            if (!pluginName) {
              throw new CKEditorError("plugincollection-replace-plugin-missing-name", null, {
                pluginItem
              });
            }
            if (pluginItem.requires && pluginItem.requires.length) {
              throw new CKEditorError("plugincollection-plugin-for-replacing-cannot-have-dependencies", null, {
                pluginName
              });
            }
            const pluginToReplace = that._availablePlugins.get(pluginName);
            if (!pluginToReplace) {
              throw new CKEditorError("plugincollection-plugin-for-replacing-not-exist", null, {
                pluginName
              });
            }
            const indexInPluginConstructors = pluginConstructors2.indexOf(pluginToReplace);
            if (indexInPluginConstructors === -1) {
              if (that._contextPlugins.has(pluginToReplace)) {
                return;
              }
              throw new CKEditorError("plugincollection-plugin-for-replacing-not-loaded", null, {
                pluginName
              });
            }
            if (pluginToReplace.requires && pluginToReplace.requires.length) {
              throw new CKEditorError("plugincollection-replaced-plugin-cannot-have-dependencies", null, {
                pluginName
              });
            }
            pluginConstructors2.splice(indexInPluginConstructors, 1, pluginItem);
            that._availablePlugins.set(pluginName, pluginItem);
          }
        }
      }
      /**
      * Destroys all loaded plugins.
      */
      destroy() {
        const promises = [];
        for (const [, pluginInstance] of this) {
          if (typeof pluginInstance.destroy == "function" && !this._contextPlugins.has(pluginInstance)) {
            promises.push(pluginInstance.destroy());
          }
        }
        return Promise.all(promises);
      }
      /**
      * Adds the plugin to the collection. Exposed mainly for testing purposes.
      *
      * @param PluginConstructor The plugin constructor.
      * @param plugin The instance of the plugin.
      */
      _add(PluginConstructor, plugin) {
        this._plugins.set(PluginConstructor, plugin);
        const pluginName = PluginConstructor.pluginName;
        if (!pluginName) {
          return;
        }
        if (this._plugins.has(pluginName)) {
          throw new CKEditorError("plugincollection-plugin-name-conflict", null, {
            pluginName,
            plugin1: this._plugins.get(pluginName).constructor,
            plugin2: PluginConstructor
          });
        }
        this._plugins.set(pluginName, plugin);
      }
    }
    class Context {
      /**
      * Creates a context instance with a given configuration.
      *
      * Usually not to be used directly. See the static {@link module:core/context~Context.create `create()`} method.
      *
      * @param config The context configuration.
      */
      constructor(config2) {
        /**
        * Stores all the configurations specific to this context instance.
        */
        __publicField(this, "config");
        /**
        * The plugins loaded and in use by this context instance.
        */
        __publicField(this, "plugins");
        __publicField(this, "locale");
        /**
        * Shorthand for {@link module:utils/locale~Locale#t}.
        */
        __publicField(this, "t");
        /**
        * A list of editors that this context instance is injected to.
        */
        __publicField(this, "editors");
        /**
        * Reference to the editor which created the context.
        * Null when the context was created outside of the editor.
        *
        * It is used to destroy the context when removing the editor that has created the context.
        */
        __publicField(this, "_contextOwner", null);
        const { translations, ...rest2 } = config2 || {};
        this.config = new Config(rest2, this.constructor.defaultConfig);
        const availablePlugins = this.constructor.builtinPlugins;
        this.config.define("plugins", availablePlugins);
        this.plugins = new PluginCollection(this, availablePlugins);
        const languageConfig = this.config.get("language") || {};
        this.locale = new Locale({
          uiLanguage: typeof languageConfig === "string" ? languageConfig : languageConfig.ui,
          contentLanguage: this.config.get("language.content"),
          translations
        });
        this.t = this.locale.t;
        this.editors = new Collection();
      }
      /**
      * Loads and initializes plugins specified in the configuration.
      *
      * @returns A promise which resolves once the initialization is completed, providing an array of loaded plugins.
      */
      initPlugins() {
        const plugins = this.config.get("plugins") || [];
        const substitutePlugins = this.config.get("substitutePlugins") || [];
        for (const Plugin2 of plugins.concat(substitutePlugins)) {
          if (typeof Plugin2 != "function") {
            throw new CKEditorError("context-initplugins-constructor-only", null, {
              Plugin: Plugin2
            });
          }
          if (Plugin2.isContextPlugin !== true) {
            throw new CKEditorError("context-initplugins-invalid-plugin", null, {
              Plugin: Plugin2
            });
          }
        }
        return this.plugins.init(plugins, [], substitutePlugins);
      }
      /**
      * Destroys the context instance and all editors used with the context,
      * releasing all resources used by the context.
      *
      * @returns A promise that resolves once the context instance is fully destroyed.
      */
      destroy() {
        return Promise.all(Array.from(this.editors, (editor2) => editor2.destroy())).then(() => this.plugins.destroy());
      }
      /**
      * Adds a reference to the editor which is used with this context.
      *
      * When the given editor has created the context, the reference to this editor will be stored
      * as a {@link ~Context#_contextOwner}.
      *
      * This method should only be used by the editor.
      *
      * @internal
      * @param isContextOwner Stores the given editor as a context owner.
      */
      _addEditor(editor2, isContextOwner) {
        if (this._contextOwner) {
          throw new CKEditorError("context-addeditor-private-context");
        }
        this.editors.add(editor2);
        if (isContextOwner) {
          this._contextOwner = editor2;
        }
      }
      /**
      * Removes a reference to the editor which was used with this context.
      * When the context was created by the given editor, the context will be destroyed.
      *
      * This method should only be used by the editor.
      *
      * @internal
      * @return A promise that resolves once the editor is removed from the context or when the context was destroyed.
      */
      _removeEditor(editor2) {
        if (this.editors.has(editor2)) {
          this.editors.remove(editor2);
        }
        if (this._contextOwner === editor2) {
          return this.destroy();
        }
        return Promise.resolve();
      }
      /**
      * Returns the context configuration which will be copied to the editors created using this context.
      *
      * The configuration returned by this method has the plugins configuration removed &ndash; plugins are shared with all editors
      * through another mechanism.
      *
      * This method should only be used by the editor.
      *
      * @internal
      * @returns Configuration as a plain object.
      */
      _getEditorConfig() {
        const result2 = {};
        for (const name of this.config.names()) {
          if (![
            "plugins",
            "removePlugins",
            "extraPlugins"
          ].includes(name)) {
            result2[name] = this.config.get(name);
          }
        }
        return result2;
      }
      /**
      * Creates and initializes a new context instance.
      *
      * ```ts
      * const commonConfig = { ... }; // Configuration for all the plugins and editors.
      * const editorPlugins = [ ... ]; // Regular plugins here.
      *
      * Context
      * 	.create( {
      * 		// Only context plugins here.
      * 		plugins: [ ... ],
      *
      * 		// Configure the language for all the editors (it cannot be overwritten).
      * 		language: { ... },
      *
      * 		// Configuration for context plugins.
      * 		comments: { ... },
      * 		...
      *
      * 		// Default configuration for editor plugins.
      * 		toolbar: { ... },
      * 		image: { ... },
      * 		...
      * 	} )
      * 	.then( context => {
      * 		const promises = [];
      *
      * 		promises.push( ClassicEditor.create(
      * 			document.getElementById( 'editor1' ),
      * 			{
      * 				editorPlugins,
      * 				context
      * 			}
      * 		) );
      *
      * 		promises.push( ClassicEditor.create(
      * 			document.getElementById( 'editor2' ),
      * 			{
      * 				editorPlugins,
      * 				context,
      * 				toolbar: { ... } // You can overwrite the configuration of the context.
      * 			}
      * 		) );
      *
      * 		return Promise.all( promises );
      * 	} );
      * ```
      *
      * @param config The context configuration.
      * @returns A promise resolved once the context is ready. The promise resolves with the created context instance.
      */
      static create(config2) {
        return new Promise((resolve) => {
          const context = new this(config2);
          resolve(context.initPlugins().then(() => context));
        });
      }
    }
    /**
    * The default configuration which is built into the `Context` class.
    *
    * It is used in CKEditor 5 builds featuring `Context` to provide the default configuration options which are later used during the
    * context initialization.
    *
    * ```ts
    * Context.defaultConfig = {
    * 	foo: 1,
    * 	bar: 2
    * };
    *
    * Context
    * 	.create()
    * 	.then( context => {
    * 		context.config.get( 'foo' ); // -> 1
    * 		context.config.get( 'bar' ); // -> 2
    * 	} );
    *
    * // The default options can be overridden by the configuration passed to create().
    * Context
    * 	.create( { bar: 3 } )
    * 	.then( context => {
    * 		context.config.get( 'foo' ); // -> 1
    * 		context.config.get( 'bar' ); // -> 3
    * 	} );
    * ```
    *
    * See also {@link module:core/context~Context.builtinPlugins `Context.builtinPlugins`}
    * and {@link module:core/editor/editor~Editor.defaultConfig `Editor.defaultConfig`}.
    */
    __publicField(Context, "defaultConfig");
    /**
    * An array of plugins built into the `Context` class.
    *
    * It is used in CKEditor 5 builds featuring `Context` to provide a list of context plugins which are later automatically initialized
    * during the context initialization.
    *
    * They will be automatically initialized by `Context` unless `config.plugins` is passed.
    *
    * ```ts
    * // Build some context plugins into the Context class first.
    * Context.builtinPlugins = [ FooPlugin, BarPlugin ];
    *
    * // Normally, you need to define config.plugins, but since Context.builtinPlugins was
    * // defined, now you can call create() without any configuration.
    * Context
    * 	.create()
    * 	.then( context => {
    * 		context.plugins.get( FooPlugin ); // -> An instance of the Foo plugin.
    * 		context.plugins.get( BarPlugin ); // -> An instance of the Bar plugin.
    * 	} );
    * ```
    *
    * See also {@link module:core/context~Context.defaultConfig `Context.defaultConfig`}
    * and {@link module:core/editor/editor~Editor.builtinPlugins `Editor.builtinPlugins`}.
    */
    __publicField(Context, "builtinPlugins");
    class CommandCollection {
      /**
      * Creates collection instance.
      */
      constructor() {
        /**
        * Command map.
        */
        __publicField(this, "_commands");
        this._commands = /* @__PURE__ */ new Map();
      }
      /**
      * Registers a new command.
      *
      * @param commandName The name of the command.
      */
      add(commandName, command) {
        this._commands.set(commandName, command);
      }
      /**
      * Retrieves a command from the collection.
      *
      * @param commandName The name of the command.
      */
      get(commandName) {
        return this._commands.get(commandName);
      }
      /**
      * Executes a command.
      *
      * @param commandName The name of the command.
      * @param commandParams Command parameters.
      * @returns The value returned by the {@link module:core/command~Command#execute `command.execute()`}.
      */
      execute(commandName, ...commandParams) {
        const command = this.get(commandName);
        if (!command) {
          throw new CKEditorError("commandcollection-command-not-found", this, {
            commandName
          });
        }
        return command.execute(...commandParams);
      }
      /**
      * Returns iterator of command names.
      */
      *names() {
        yield* this._commands.keys();
      }
      /**
      * Returns iterator of command instances.
      */
      *commands() {
        yield* this._commands.values();
      }
      /**
      * Iterable interface.
      *
      * Returns `[ commandName, commandInstance ]` pairs.
      */
      [Symbol.iterator]() {
        return this._commands[Symbol.iterator]();
      }
      /**
      * Destroys all collection commands.
      */
      destroy() {
        for (const command of this.commands()) {
          command.destroy();
        }
      }
    }
    class EditingKeystrokeHandler extends KeystrokeHandler {
      /**
      * Creates an instance of the keystroke handler.
      */
      constructor(editor2) {
        super();
        /**
        * The editor instance.
        */
        __publicField(this, "editor");
        this.editor = editor2;
      }
      /**
      * Registers a handler for the specified keystroke.
      *
      * The handler can be specified as a command name or a callback.
      *
      * @param keystroke Keystroke defined in a format accepted by
      * the {@link module:utils/keyboard~parseKeystroke} function.
      * @param callback If a string is passed, then the keystroke will
      * {@link module:core/editor/editor~Editor#execute execute a command}.
      * If a function, then it will be called with the
      * {@link module:engine/view/observer/keyobserver~KeyEventData key event data} object and
      * a `cancel()` helper to both `preventDefault()` and `stopPropagation()` of the event.
      * @param options Additional options.
      * @param options.priority The priority of the keystroke callback. The higher the priority value
      * the sooner the callback will be executed. Keystrokes having the same priority
      * are called in the order they were added.
      */
      set(keystroke, callback, options = {}) {
        if (typeof callback == "string") {
          const commandName = callback;
          callback = (evtData, cancel2) => {
            this.editor.execute(commandName);
            cancel2();
          };
        }
        super.set(keystroke, callback, options);
      }
    }
    const DEFAULT_CATEGORY_ID = "contentEditing";
    const DEFAULT_GROUP_ID = "common";
    class Accessibility {
      /**
      * @inheritDoc
      */
      constructor(editor2) {
        /**
        * Stores information about keystrokes brought by editor features for the users to interact with the editor, mainly
        * keystroke combinations and their accessible labels.
        *
        * This information is particularly useful for screen reader and other assistive technology users. It gets displayed
        * by the {@link module:ui/editorui/accessibilityhelp/accessibilityhelp~AccessibilityHelp Accessibility help} dialog.
        *
        * Keystrokes are organized in categories and groups. They can be added using ({@link #addKeystrokeInfoCategory},
        * {@link #addKeystrokeInfoGroup}, and {@link #addKeystrokeInfos}) methods.
        *
        * Please note that:
        * * two categories are always available:
        *   * `'contentEditing'` for keystrokes related to content creation,
        *   * `'navigation'` for keystrokes related to navigation in the UI and the content.
        * * unless specified otherwise, new keystrokes are added into the `'contentEditing'` category and the `'common'`
        * keystroke group within that category while using the {@link #addKeystrokeInfos} method.
        */
        __publicField(this, "keystrokeInfos", /* @__PURE__ */ new Map());
        /**
        * The editor instance.
        */
        __publicField(this, "_editor");
        this._editor = editor2;
        const isMenuBarVisible = editor2.config.get("menuBar.isVisible");
        const t2 = editor2.locale.t;
        this.addKeystrokeInfoCategory({
          id: DEFAULT_CATEGORY_ID,
          label: t2("Content editing keystrokes"),
          description: t2("These keyboard shortcuts allow for quick access to content editing features.")
        });
        const navigationKeystrokes = [
          {
            label: t2("Close contextual balloons, dropdowns, and dialogs"),
            keystroke: "Esc"
          },
          {
            label: t2("Open the accessibility help dialog"),
            keystroke: "Alt+0"
          },
          {
            label: t2("Move focus between form fields (inputs, buttons, etc.)"),
            keystroke: [
              [
                "Tab"
              ],
              [
                "Shift+Tab"
              ]
            ]
          },
          {
            label: t2("Move focus to the toolbar, navigate between toolbars"),
            keystroke: "Alt+F10",
            mayRequireFn: true
          },
          {
            label: t2("Navigate through the toolbar or menu bar"),
            keystroke: [
              [
                "arrowup"
              ],
              [
                "arrowright"
              ],
              [
                "arrowdown"
              ],
              [
                "arrowleft"
              ]
            ]
          },
          {
            // eslint-disable-next-line max-len
            label: t2("Execute the currently focused button. Executing buttons that interact with the editor content moves the focus back to the content."),
            keystroke: [
              [
                "Enter"
              ],
              [
                "Space"
              ]
            ]
          }
        ];
        if (isMenuBarVisible) {
          navigationKeystrokes.push({
            label: t2("Move focus to the menu bar, navigate between menu bars"),
            keystroke: "Alt+F9",
            mayRequireFn: true
          });
        }
        this.addKeystrokeInfoCategory({
          id: "navigation",
          label: t2("User interface and content navigation keystrokes"),
          description: t2("Use the following keystrokes for more efficient navigation in the CKEditor 5 user interface."),
          groups: [
            {
              id: "common",
              keystrokes: navigationKeystrokes
            }
          ]
        });
      }
      /**
      * Adds a top-level category in the {@link #keystrokeInfos keystroke information database} with a label and optional description.
      *
      * Categories organize keystrokes and help users to find the right keystroke. Each category can have multiple groups
      * of keystrokes that narrow down the context in which the keystrokes are available. Every keystroke category comes
      * with a `'common'` group by default.
      *
      * By default, two categories are available:
      * * `'contentEditing'` for keystrokes related to content creation,
      * * `'navigation'` for keystrokes related to navigation in the UI and the content.
      *
      * To create a new keystroke category with new groups, use the following code:
      *
      * ```js
      * class MyPlugin extends Plugin {
      * 	// ...
      * 	init() {
      * 		const editor = this.editor;
      * 		const t = editor.t;
      *
      * 		// ...
      *
      * 		editor.accessibility.addKeystrokeInfoCategory( {
      * 			id: 'myCategory',
      * 			label: t( 'My category' ),
      * 			description: t( 'My category description.' ),
      * 			groups: [
      * 				{
      * 					id: 'myGroup',
      * 					label: t( 'My keystroke group' ),
      * 					keystrokes: [
      * 						{
      * 							label: t( 'Keystroke label 1' ),
      * 							keystroke: 'Ctrl+Shift+N'
      * 						},
      * 						{
      * 							label: t( 'Keystroke label 2' ),
      * 							keystroke: 'Ctrl+Shift+M'
      * 						}
      * 					]
      * 				}
      * 			]
      * 		};
      * 	}
      * }
      * ```
      *
      * See {@link #keystrokeInfos}, {@link #addKeystrokeInfoGroup}, and {@link #addKeystrokeInfos}.
      */
      addKeystrokeInfoCategory({ id, label, description, groups }) {
        this.keystrokeInfos.set(id, {
          id,
          label,
          description,
          groups: /* @__PURE__ */ new Map()
        });
        this.addKeystrokeInfoGroup({
          categoryId: id,
          id: DEFAULT_GROUP_ID
        });
        if (groups) {
          groups.forEach((group) => {
            this.addKeystrokeInfoGroup({
              categoryId: id,
              ...group
            });
          });
        }
      }
      /**
      * Adds a group of keystrokes in a specific category to the {@link #keystrokeInfos keystroke information database}.
      *
      * Groups narrow down the context in which the keystrokes are available. When `categoryId` is not specified,
      * the group goes to the `'contentEditing'` category (default).
      *
      * To create a new group within an existing category, use the following code:
      *
      * ```js
      * class MyPlugin extends Plugin {
      * 	// ...
      * 	init() {
      * 		const editor = this.editor;
      * 		const t = editor.t;
      *
      * 		// ...
      *
      * 		editor.accessibility.addKeystrokeInfoGroup( {
      * 			id: 'myGroup',
      * 			categoryId: 'navigation',
      * 			label: t( 'My keystroke group' ),
      * 			keystrokes: [
      * 				{
      * 					label: t( 'Keystroke label 1' ),
      * 					keystroke: 'Ctrl+Shift+N'
      * 				},
      * 				{
      * 					label: t( 'Keystroke label 2' ),
      * 					keystroke: 'Ctrl+Shift+M'
      * 				}
      * 			]
      * 		} );
      * 	}
      * }
      * ```
      *
      * See {@link #keystrokeInfos}, {@link #addKeystrokeInfoCategory}, and {@link #addKeystrokeInfos}.
      */
      addKeystrokeInfoGroup({ categoryId = DEFAULT_CATEGORY_ID, id, label, keystrokes }) {
        const category = this.keystrokeInfos.get(categoryId);
        if (!category) {
          throw new CKEditorError("accessibility-unknown-keystroke-info-category", this._editor, {
            groupId: id,
            categoryId
          });
        }
        category.groups.set(id, {
          id,
          label,
          keystrokes: keystrokes || []
        });
      }
      /**
      * Adds information about keystrokes to the {@link #keystrokeInfos keystroke information database}.
      *
      * Keystrokes without specified `groupId` or `categoryId` go to the `'common'` group in the `'contentEditing'` category (default).
      *
      * To add a keystroke brought by your plugin (using default group and category), use the following code:
      *
      * ```js
      * class MyPlugin extends Plugin {
      * 	// ...
      * 	init() {
      * 		const editor = this.editor;
      * 		const t = editor.t;
      *
      * 		// ...
      *
      * 		editor.accessibility.addKeystrokeInfos( {
      * 			keystrokes: [
      * 				{
      * 					label: t( 'Keystroke label' ),
      * 					keystroke: 'CTRL+B'
      * 				}
      * 			]
      * 		} );
      * 	}
      * }
      * ```
      * To add a keystroke in a specific existing `'widget'` group in the default `'contentEditing'` category:
      *
      * ```js
      * class MyPlugin extends Plugin {
      * 	// ...
      * 	init() {
      * 		const editor = this.editor;
      * 		const t = editor.t;
      *
      * 		// ...
      *
      * 		editor.accessibility.addKeystrokeInfos( {
      * 			// Add a keystroke to the existing "widget" group.
      * 			groupId: 'widget',
      * 			keystrokes: [
      * 				{
      * 					label: t( 'A an action on a selected widget' ),
      * 					keystroke: 'Ctrl+D',
      * 				}
      * 			]
      * 		} );
      * 	}
      * }
      * ```
      *
      * To add a keystroke to another existing category (using default group):
      *
      * ```js
      * class MyPlugin extends Plugin {
      * 	// ...
      * 	init() {
      * 		const editor = this.editor;
      * 		const t = editor.t;
      *
      * 		// ...
      *
      * 		editor.accessibility.addKeystrokeInfos( {
      * 			// Add keystrokes to the "navigation" category (one of defaults).
      * 			categoryId: 'navigation',
      * 			keystrokes: [
      * 				{
      * 					label: t( 'Keystroke label' ),
      * 					keystroke: 'CTRL+B'
      * 				}
      * 			]
      * 		} );
      * 	}
      * }
      * ```
      *
      * See {@link #keystrokeInfos}, {@link #addKeystrokeInfoGroup}, and {@link #addKeystrokeInfoCategory}.
      */
      addKeystrokeInfos({ categoryId = DEFAULT_CATEGORY_ID, groupId = DEFAULT_GROUP_ID, keystrokes }) {
        if (!this.keystrokeInfos.has(categoryId)) {
          throw new CKEditorError("accessibility-unknown-keystroke-info-category", this._editor, {
            categoryId,
            keystrokes
          });
        }
        const category = this.keystrokeInfos.get(categoryId);
        if (!category.groups.has(groupId)) {
          throw new CKEditorError("accessibility-unknown-keystroke-info-group", this._editor, {
            groupId,
            categoryId,
            keystrokes
          });
        }
        category.groups.get(groupId).keystrokes.push(...keystrokes);
      }
    }
    class Editor extends (/* @__PURE__ */ ObservableMixin()) {
      /**
      * Creates a new instance of the editor class.
      *
      * Usually, not to be used directly. See the static {@link module:core/editor/editor~Editor.create `create()`} method.
      *
      * @param config The editor configuration.
      */
      constructor(config2 = {}) {
        super();
        /**
        * A namespace for the accessibility features of the editor.
        */
        __publicField(this, "accessibility");
        /**
        * Commands registered to the editor.
        *
        * Use the shorthand {@link #execute `editor.execute()`} method to execute commands:
        *
        * ```ts
        * // Execute the bold command:
        * editor.execute( 'bold' );
        *
        * // Check the state of the bold command:
        * editor.commands.get( 'bold' ).value;
        * ```
        */
        __publicField(this, "commands");
        /**
        * Stores all configurations specific to this editor instance.
        *
        * ```ts
        * editor.config.get( 'image.toolbar' );
        * // -> [ 'imageStyle:block', 'imageStyle:side', '|', 'toggleImageCaption', 'imageTextAlternative' ]
        * ```
        */
        __publicField(this, "config");
        /**
        * Conversion manager through which you can register model-to-view and view-to-model converters.
        *
        * See the {@link module:engine/conversion/conversion~Conversion} documentation to learn how to add converters.
        */
        __publicField(this, "conversion");
        /**
        * The {@link module:engine/controller/datacontroller~DataController data controller}.
        * Used e.g. for setting and retrieving the editor data.
        */
        __publicField(this, "data");
        /**
        * The {@link module:engine/controller/editingcontroller~EditingController editing controller}.
        * Controls user input and rendering the content for editing.
        */
        __publicField(this, "editing");
        /**
        * The locale instance.
        */
        __publicField(this, "locale");
        /**
        * The editor's model.
        *
        * The central point of the editor's abstract data model.
        */
        __publicField(this, "model");
        /**
        * The plugins loaded and in use by this editor instance.
        *
        * ```ts
        * editor.plugins.get( 'ClipboardPipeline' ); // -> An instance of the clipboard pipeline plugin.
        * ```
        */
        __publicField(this, "plugins");
        /**
        * An instance of the {@link module:core/editingkeystrokehandler~EditingKeystrokeHandler}.
        *
        * It allows setting simple keystrokes:
        *
        * ```ts
        * // Execute the bold command on Ctrl+E:
        * editor.keystrokes.set( 'Ctrl+E', 'bold' );
        *
        * // Execute your own callback:
        * editor.keystrokes.set( 'Ctrl+E', ( data, cancel ) => {
        * 	console.log( data.keyCode );
        *
        * 	// Prevent the default (native) action and stop the underlying keydown event
        * 	// so no other editor feature will interfere.
        * 	cancel();
        * } );
        * ```
        *
        * Note: Certain typing-oriented keystrokes (like <kbd>Backspace</kbd> or <kbd>Enter</kbd>) are handled
        * by a low-level mechanism and trying to listen to them via the keystroke handler will not work reliably.
        * To handle these specific keystrokes, see the events fired by the
        * {@link module:engine/view/document~Document editing view document} (`editor.editing.view.document`).
        */
        __publicField(this, "keystrokes");
        /**
        * Shorthand for {@link module:utils/locale~Locale#t}.
        *
        * @see module:utils/locale~Locale#t
        */
        __publicField(this, "t");
        /**
        * The editor context.
        * When it is not provided through the configuration, the editor creates it.
        */
        __publicField(this, "_context");
        /**
        * A set of lock IDs for the {@link #isReadOnly} getter.
        */
        __publicField(this, "_readOnlyLocks");
        if ("sanitizeHtml" in config2) {
          throw new CKEditorError("editor-config-sanitizehtml-not-supported");
        }
        const constructor = this.constructor;
        const { translations: defaultTranslations, ...defaultConfig } = constructor.defaultConfig || {};
        const { translations = defaultTranslations, ...rest2 } = config2;
        const language = config2.language || defaultConfig.language;
        this._context = config2.context || new Context({
          language,
          translations
        });
        this._context._addEditor(this, !config2.context);
        const availablePlugins = Array.from(constructor.builtinPlugins || []);
        this.config = new Config(rest2, defaultConfig);
        this.config.define("plugins", availablePlugins);
        this.config.define(this._context._getEditorConfig());
        this.plugins = new PluginCollection(this, availablePlugins, this._context.plugins);
        this.locale = this._context.locale;
        this.t = this.locale.t;
        this._readOnlyLocks = /* @__PURE__ */ new Set();
        this.commands = new CommandCollection();
        this.set("state", "initializing");
        this.once("ready", () => this.state = "ready", {
          priority: "high"
        });
        this.once("destroy", () => this.state = "destroyed", {
          priority: "high"
        });
        this.model = new Model$1();
        this.on("change:isReadOnly", () => {
          this.model.document.isReadOnly = this.isReadOnly;
        });
        const stylesProcessor = new StylesProcessor();
        this.data = new DataController(this.model, stylesProcessor);
        this.editing = new EditingController(this.model, stylesProcessor);
        this.editing.view.document.bind("isReadOnly").to(this);
        this.conversion = new Conversion([
          this.editing.downcastDispatcher,
          this.data.downcastDispatcher
        ], this.data.upcastDispatcher);
        this.conversion.addAlias("dataDowncast", this.data.downcastDispatcher);
        this.conversion.addAlias("editingDowncast", this.editing.downcastDispatcher);
        this.keystrokes = new EditingKeystrokeHandler(this);
        this.keystrokes.listenTo(this.editing.view.document);
        this.accessibility = new Accessibility(this);
      }
      /**
      * Defines whether the editor is in the read-only mode.
      *
      * In read-only mode the editor {@link #commands commands} are disabled so it is not possible
      * to modify the document by using them. Also, the editable element(s) become non-editable.
      *
      * In order to make the editor read-only, you need to call the {@link #enableReadOnlyMode} method:
      *
      * ```ts
      * editor.enableReadOnlyMode( 'feature-id' );
      * ```
      *
         * Later, to turn off the read-only mode, call {@link #disableReadOnlyMode}:
      *
      * ```ts
      * editor.disableReadOnlyMode( 'feature-id' );
      * ```
      *
      * @readonly
      * @observable
      */
      get isReadOnly() {
        return this._readOnlyLocks.size > 0;
      }
      set isReadOnly(value) {
        throw new CKEditorError("editor-isreadonly-has-no-setter");
      }
      /**
      * Turns on the read-only mode in the editor.
      *
      * Editor can be switched to or out of the read-only mode by many features, under various circumstances. The editor supports locking
      * mechanism for the read-only mode. It enables easy control over the read-only mode when many features wants to turn it on or off at
      * the same time, without conflicting with each other. It guarantees that you will not make the editor editable accidentally (which
      * could lead to errors).
      *
      * Each read-only mode request is identified by a unique id (also called "lock"). If multiple plugins requested to turn on the
      * read-only mode, then, the editor will become editable only after all these plugins turn the read-only mode off (using the same ids).
      *
      * Note, that you cannot force the editor to disable the read-only mode if other plugins set it.
      *
      * After the first `enableReadOnlyMode()` call, the {@link #isReadOnly `isReadOnly` property} will be set to `true`:
      *
      * ```ts
      * editor.isReadOnly; // `false`.
      * editor.enableReadOnlyMode( 'my-feature-id' );
      * editor.isReadOnly; // `true`.
      * ```
      *
      * You can turn off the read-only mode ("clear the lock") using the {@link #disableReadOnlyMode `disableReadOnlyMode()`} method:
      *
      * ```ts
      * editor.enableReadOnlyMode( 'my-feature-id' );
      * // ...
      * editor.disableReadOnlyMode( 'my-feature-id' );
      * editor.isReadOnly; // `false`.
      * ```
      *
      * All "locks" need to be removed to enable editing:
      *
      * ```ts
      * editor.enableReadOnlyMode( 'my-feature-id' );
      * editor.enableReadOnlyMode( 'my-other-feature-id' );
      * // ...
      * editor.disableReadOnlyMode( 'my-feature-id' );
      * editor.isReadOnly; // `true`.
      * editor.disableReadOnlyMode( 'my-other-feature-id' );
      * editor.isReadOnly; // `false`.
      * ```
      *
      * @param lockId A unique ID for setting the editor to the read-only state.
      */
      enableReadOnlyMode(lockId) {
        if (typeof lockId !== "string" && typeof lockId !== "symbol") {
          throw new CKEditorError("editor-read-only-lock-id-invalid", null, {
            lockId
          });
        }
        if (this._readOnlyLocks.has(lockId)) {
          return;
        }
        this._readOnlyLocks.add(lockId);
        if (this._readOnlyLocks.size === 1) {
          this.fire("change:isReadOnly", "isReadOnly", true, false);
        }
      }
      /**
      * Removes the read-only lock from the editor with given lock ID.
      *
      * When no lock is present on the editor anymore, then the {@link #isReadOnly `isReadOnly` property} will be set to `false`.
      *
      * @param lockId The lock ID for setting the editor to the read-only state.
      */
      disableReadOnlyMode(lockId) {
        if (typeof lockId !== "string" && typeof lockId !== "symbol") {
          throw new CKEditorError("editor-read-only-lock-id-invalid", null, {
            lockId
          });
        }
        if (!this._readOnlyLocks.has(lockId)) {
          return;
        }
        this._readOnlyLocks.delete(lockId);
        if (this._readOnlyLocks.size === 0) {
          this.fire("change:isReadOnly", "isReadOnly", false, true);
        }
      }
      /**
      * Sets the data in the editor.
      *
      * ```ts
      * editor.setData( '<p>This is editor!</p>' );
      * ```
      *
      * If your editor implementation uses multiple roots, you should pass an object with keys corresponding
      * to the editor root names and values equal to the data that should be set in each root:
      *
      * ```ts
      * editor.setData( {
      *     header: '<p>Content for header part.</p>',
      *     content: '<p>Content for main part.</p>',
      *     footer: '<p>Content for footer part.</p>'
      * } );
      * ```
      *
      * By default the editor accepts HTML. This can be controlled by injecting a different data processor.
      * See the {@glink features/markdown Markdown output} guide for more details.
      *
      * @param data Input data.
      */
      setData(data) {
        this.data.set(data);
      }
      /**
      * Gets the data from the editor.
      *
      * ```ts
      * editor.getData(); // -> '<p>This is editor!</p>'
      * ```
      *
      * If your editor implementation uses multiple roots, you should pass root name as one of the options:
      *
      * ```ts
      * editor.getData( { rootName: 'header' } ); // -> '<p>Content for header part.</p>'
      * ```
      *
      * By default, the editor outputs HTML. This can be controlled by injecting a different data processor.
      * See the {@glink features/markdown Markdown output} guide for more details.
      *
      * A warning is logged when you try to retrieve data for a detached root, as most probably this is a mistake. A detached root should
      * be treated like it is removed, and you should not save its data. Note, that the detached root data is always an empty string.
      *
      * @param options Additional configuration for the retrieved data.
      * Editor features may introduce more configuration options that can be set through this parameter.
      * @param options.rootName Root name. Defaults to `'main'`.
      * @param options.trim Whether returned data should be trimmed. This option is set to `'empty'` by default,
      * which means that whenever editor content is considered empty, an empty string is returned. To turn off trimming
      * use `'none'`. In such cases exact content will be returned (for example `'<p>&nbsp;</p>'` for an empty editor).
      * @returns Output data.
      */
      getData(options) {
        return this.data.get(options);
      }
      /**
      * Loads and initializes plugins specified in the configuration.
      *
      * @returns A promise which resolves once the initialization is completed, providing an array of loaded plugins.
      */
      initPlugins() {
        const config2 = this.config;
        const plugins = config2.get("plugins");
        const removePlugins = config2.get("removePlugins") || [];
        const extraPlugins = config2.get("extraPlugins") || [];
        const substitutePlugins = config2.get("substitutePlugins") || [];
        return this.plugins.init(plugins.concat(extraPlugins), removePlugins, substitutePlugins);
      }
      /**
      * Destroys the editor instance, releasing all resources used by it.
      *
      * **Note** The editor cannot be destroyed during the initialization phase so if it is called
      * while the editor {@link #state is being initialized}, it will wait for the editor initialization before destroying it.
      *
      * @fires destroy
      * @returns A promise that resolves once the editor instance is fully destroyed.
      */
      destroy() {
        let readyPromise = Promise.resolve();
        if (this.state == "initializing") {
          readyPromise = new Promise((resolve) => this.once("ready", resolve));
        }
        return readyPromise.then(() => {
          this.fire("destroy");
          this.stopListening();
          this.commands.destroy();
        }).then(() => this.plugins.destroy()).then(() => {
          this.model.destroy();
          this.data.destroy();
          this.editing.destroy();
          this.keystrokes.destroy();
        }).then(() => this._context._removeEditor(this));
      }
      /**
      * Executes the specified command with given parameters.
      *
      * Shorthand for:
      *
      * ```ts
      * editor.commands.get( commandName ).execute( ... );
      * ```
      *
      * @param commandName The name of the command to execute.
      * @param commandParams Command parameters.
      * @returns The value returned by the {@link module:core/commandcollection~CommandCollection#execute `commands.execute()`}.
      */
      execute(commandName, ...commandParams) {
        try {
          return this.commands.execute(commandName, ...commandParams);
        } catch (err) {
          /* istanbul ignore next -- @preserve */
          CKEditorError.rethrowUnexpectedError(err, this);
        }
      }
      /**
      * Focuses the editor.
      *
      * **Note** To explicitly focus the editing area of the editor, use the
      * {@link module:engine/view/view~View#focus `editor.editing.view.focus()`} method of the editing view.
      *
      * Check out the {@glink framework/deep-dive/ui/focus-tracking#focus-in-the-editor-ui Focus in the editor UI} section
      * of the {@glink framework/deep-dive/ui/focus-tracking Deep dive into focus tracking} guide to learn more.
      */
      focus() {
        this.editing.view.focus();
      }
      /* istanbul ignore next -- @preserve */
      /**
      * Creates and initializes a new editor instance.
      *
      * This is an abstract method. Every editor type needs to implement its own initialization logic.
      *
      * See the `create()` methods of the existing editor types to learn how to use them:
      *
      * * {@link module:editor-classic/classiceditor~ClassicEditor.create `ClassicEditor.create()`}
      * * {@link module:editor-balloon/ballooneditor~BalloonEditor.create `BalloonEditor.create()`}
      * * {@link module:editor-decoupled/decouplededitor~DecoupledEditor.create `DecoupledEditor.create()`}
      * * {@link module:editor-inline/inlineeditor~InlineEditor.create `InlineEditor.create()`}
      */
      static create(...args) {
        throw new Error("This is an abstract method.");
      }
    }
    /**
    * The default configuration which is built into the editor class.
    *
    * It is used in CKEditor 5 builds to provide the default configuration options which are later used during the editor initialization.
    *
    * ```ts
    * ClassicEditor.defaultConfig = {
    * 	foo: 1,
    * 	bar: 2
    * };
    *
    * ClassicEditor
    * 	.create( sourceElement )
    * 	.then( editor => {
    * 		editor.config.get( 'foo' ); // -> 1
    * 		editor.config.get( 'bar' ); // -> 2
    * 	} );
    *
    * // The default options can be overridden by the configuration passed to create().
    * ClassicEditor
    * 	.create( sourceElement, { bar: 3 } )
    * 	.then( editor => {
    * 		editor.config.get( 'foo' ); // -> 1
    * 		editor.config.get( 'bar' ); // -> 3
    * 	} );
    * ```
    *
    * See also {@link module:core/editor/editor~Editor.builtinPlugins}.
    */
    __publicField(Editor, "defaultConfig");
    /**
    * An array of plugins built into this editor class.
    *
    * It is used in CKEditor 5 builds to provide a list of plugins which are later automatically initialized
    * during the editor initialization.
    *
    * They will be automatically initialized by the editor, unless listed in `config.removePlugins` and
    * unless `config.plugins` is passed.
    *
    * ```ts
    * // Build some plugins into the editor class first.
    * ClassicEditor.builtinPlugins = [ FooPlugin, BarPlugin ];
    *
    * // Normally, you need to define config.plugins, but since ClassicEditor.builtinPlugins was
    * // defined, now you can call create() without any configuration.
    * ClassicEditor
    * 	.create( sourceElement )
    * 	.then( editor => {
    * 		editor.plugins.get( FooPlugin ); // -> An instance of the Foo plugin.
    * 		editor.plugins.get( BarPlugin ); // -> An instance of the Bar plugin.
    * 	} );
    *
    * ClassicEditor
    * 	.create( sourceElement, {
    * 		// Do not initialize these plugins (note: it is defined by a string):
    * 		removePlugins: [ 'Foo' ]
    * 	} )
    * 	.then( editor => {
    * 		editor.plugins.get( FooPlugin ); // -> Undefined.
    * 		editor.config.get( BarPlugin ); // -> An instance of the Bar plugin.
    * 	} );
    *
    * ClassicEditor
    * 	.create( sourceElement, {
    * 		// Load only this plugin. It can also be defined by a string if
    * 		// this plugin was built into the editor class.
    * 		plugins: [ FooPlugin ]
    * 	} )
    * 	.then( editor => {
    * 		editor.plugins.get( FooPlugin ); // -> An instance of the Foo plugin.
    * 		editor.config.get( BarPlugin ); // -> Undefined.
    * 	} );
    * ```
    *
    * See also {@link module:core/editor/editor~Editor.defaultConfig}.
    */
    __publicField(Editor, "builtinPlugins");
    /**
    * The {@link module:core/context~Context} class.
    *
    * Exposed as static editor field for easier access in editor builds.
    */
    __publicField(Editor, "Context", Context);
    /**
    * The {@link module:watchdog/editorwatchdog~EditorWatchdog} class.
    *
    * Exposed as static editor field for easier access in editor builds.
    */
    __publicField(Editor, "EditorWatchdog", EditorWatchdog);
    /**
    * The {@link module:watchdog/contextwatchdog~ContextWatchdog} class.
    *
    * Exposed as static editor field for easier access in editor builds.
    */
    __publicField(Editor, "ContextWatchdog", ContextWatchdog);
    function attachToForm(editor2) {
      if (!isFunction(editor2.updateSourceElement)) {
        throw new CKEditorError("attachtoform-missing-elementapi-interface", editor2);
      }
      const sourceElement = editor2.sourceElement;
      if (isTextArea(sourceElement) && sourceElement.form) {
        let originalSubmit;
        const form = sourceElement.form;
        const onSubmit = () => editor2.updateSourceElement();
        if (isFunction(form.submit)) {
          originalSubmit = form.submit;
          form.submit = () => {
            onSubmit();
            originalSubmit.apply(form);
          };
        }
        form.addEventListener("submit", onSubmit);
        editor2.on("destroy", () => {
          form.removeEventListener("submit", onSubmit);
          if (originalSubmit) {
            form.submit = originalSubmit;
          }
        });
      }
    }
    function isTextArea(sourceElement) {
      return !!sourceElement && sourceElement.tagName.toLowerCase() === "textarea";
    }
    function ElementApiMixin(base) {
      class Mixin extends base {
        constructor() {
          super(...arguments);
          __publicField(this, "sourceElement");
        }
        updateSourceElement(data) {
          if (!this.sourceElement) {
            throw new CKEditorError("editor-missing-sourceelement", this);
          }
          const shouldUpdateSourceElement = this.config.get("updateSourceElementOnDestroy");
          const isSourceElementTextArea = this.sourceElement instanceof HTMLTextAreaElement;
          if (!shouldUpdateSourceElement && !isSourceElementTextArea) {
            setDataInElement(this.sourceElement, "");
            return;
          }
          const dataToSet = typeof data === "string" ? data : this.data.get();
          setDataInElement(this.sourceElement, dataToSet);
        }
      }
      return Mixin;
    }
    ElementApiMixin.updateSourceElement = ElementApiMixin(Object).prototype.updateSourceElement;
    var cancel = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.591 10.177 4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z"/></svg>';
    var caption = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 16h9a1 1 0 0 1 0 2H2a1 1 0 0 1 0-2z"/><path d="M17 1a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14zm0 1.5H3a.5.5 0 0 0-.492.41L2.5 3v9a.5.5 0 0 0 .41.492L3 12.5h14a.5.5 0 0 0 .492-.41L17.5 12V3a.5.5 0 0 0-.41-.492L17 2.5z" fill-opacity=".6"/></svg>';
    var check = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z"/></svg>';
    var cog = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.333 2 .19 2.263a5.899 5.899 0 0 1 1.458.604L14.714 3.4 16.6 5.286l-1.467 1.733c.263.452.468.942.605 1.46L18 8.666v2.666l-2.263.19a5.899 5.899 0 0 1-.604 1.458l1.467 1.733-1.886 1.886-1.733-1.467a5.899 5.899 0 0 1-1.46.605L11.334 18H8.667l-.19-2.263a5.899 5.899 0 0 1-1.458-.604L5.286 16.6 3.4 14.714l1.467-1.733a5.899 5.899 0 0 1-.604-1.458L2 11.333V8.667l2.262-.189a5.899 5.899 0 0 1 .605-1.459L3.4 5.286 5.286 3.4l1.733 1.467a5.899 5.899 0 0 1 1.46-.605L8.666 2h2.666zM10 6.267a3.733 3.733 0 1 0 0 7.466 3.733 3.733 0 0 0 0-7.466z"/></svg>';
    var colorPalette = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.209 18.717A8.5 8.5 0 1 1 18.686 9.6h-.008l.002.12a3 3 0 0 1-2.866 2.997h-.268l-.046-.002v.002h-4.791a2 2 0 1 0 0 4 1 1 0 1 1-.128 1.992 8.665 8.665 0 0 1-.372.008Zm-3.918-7.01a1.25 1.25 0 1 0-2.415-.648 1.25 1.25 0 0 0 2.415.647ZM5.723 8.18a1.25 1.25 0 1 0 .647-2.414 1.25 1.25 0 0 0-.647 2.414ZM9.76 6.155a1.25 1.25 0 1 0 .647-2.415 1.25 1.25 0 0 0-.647 2.415Zm4.028 1.759a1.25 1.25 0 1 0 .647-2.415 1.25 1.25 0 0 0-.647 2.415Z"/></svg>';
    var eraser = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m8.636 9.531-2.758 3.94a.5.5 0 0 0 .122.696l3.224 2.284h1.314l2.636-3.736L8.636 9.53zm.288 8.451L5.14 15.396a2 2 0 0 1-.491-2.786l6.673-9.53a2 2 0 0 1 2.785-.49l3.742 2.62a2 2 0 0 1 .491 2.785l-7.269 10.053-2.147-.066z"/><path d="M4 18h5.523v-1H4zm-2 0h1v-1H2z"/></svg>';
    var history = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11 1a9 9 0 1 1-8.027 13.075l1.128-1.129A7.502 7.502 0 0 0 18.5 10a7.5 7.5 0 1 0-14.962.759l-.745-.746-.76.76A9 9 0 0 1 11 1z"/><path d="M.475 8.17a.75.75 0 0 1 .978.047l.075.082 1.284 1.643 1.681-1.284a.75.75 0 0 1 .978.057l.073.083a.75.75 0 0 1-.057.978l-.083.073-2.27 1.737a.75.75 0 0 1-.973-.052l-.074-.082-1.741-2.23a.75.75 0 0 1 .13-1.052z"/><path d="M11.5 5v4.999l3.196 3.196-1.06 1.06L10.1 10.72l-.1-.113V5z"/></svg>';
    var lowVision = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.085 6.22 2.943 4.078a.75.75 0 1 1 1.06-1.06l2.592 2.59A11.094 11.094 0 0 1 10 5.068c4.738 0 8.578 3.101 8.578 5.083 0 1.197-1.401 2.803-3.555 3.887l1.714 1.713a.75.75 0 0 1-.09 1.138.488.488 0 0 1-.15.084.75.75 0 0 1-.821-.16L6.17 7.304c-.258.11-.51.233-.757.365l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.55 8.197a7.2 7.2 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 0 0-.124.2c-.043.077-.08.158-.108.241a.534.534 0 0 0-.028.133.29.29 0 0 0 .008.072.927.927 0 0 0 .082.226c.067.133.145.26.234.379l3.242 3.365.025.01.59.623c-3.265-.918-5.59-3.155-5.59-4.668 0-1.194 1.448-2.838 3.663-3.93zm7.07.531a4.632 4.632 0 0 1 1.108 5.992l.345.344.046-.018a9.313 9.313 0 0 0 2-1.112c.256-.187.5-.392.727-.613.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286.057-.093.107-.19.148-.292a.72.72 0 0 0 .036-.12.29.29 0 0 0 .008-.072.492.492 0 0 0-.028-.133.999.999 0 0 0-.036-.096 2.165 2.165 0 0 0-.071-.145 2.917 2.917 0 0 0-.125-.2 3.592 3.592 0 0 0-.263-.335 5.444 5.444 0 0 0-.53-.523 7.955 7.955 0 0 0-1.054-.768 9.766 9.766 0 0 0-1.879-.891c-.337-.118-.68-.219-1.027-.301zm-2.85.21-.069.002a.508.508 0 0 0-.254.097.496.496 0 0 0-.104.679.498.498 0 0 0 .326.199l.045.005c.091.003.181.003.272.012a2.45 2.45 0 0 1 2.017 1.513c.024.061.043.125.069.185a.494.494 0 0 0 .45.287h.008a.496.496 0 0 0 .35-.158.482.482 0 0 0 .13-.335.638.638 0 0 0-.048-.219 3.379 3.379 0 0 0-.36-.723 3.438 3.438 0 0 0-2.791-1.543l-.028-.001h-.013z"/></svg>';
    var textAlternative = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3.035 1C2.446 1 2 1.54 2 2.098V10.5h1.5v-8h13v8H18V2.098C18 1.539 17.48 1 16.9 1H3.035Zm10.453 2.61a1.885 1.885 0 0 0-1.442.736 1.89 1.89 0 0 0 1.011 2.976 1.903 1.903 0 0 0 2.253-1.114 1.887 1.887 0 0 0-1.822-2.598ZM7.463 8.163a.611.611 0 0 0-.432.154L5.071 10.5h5.119L7.88 8.348a.628.628 0 0 0-.417-.185Zm6.236 1.059a.62.62 0 0 0-.42.164L12.07 10.5h2.969l-.92-1.113a.618.618 0 0 0-.42-.165ZM.91 11.5a.91.91 0 0 0-.91.912v6.877c0 .505.405.91.91.91h18.178a.91.91 0 0 0 .912-.91v-6.877a.908.908 0 0 0-.912-.912H.91ZM3.668 13h1.947l2.135 5.7H5.898l-.28-.946H3.601l-.278.945H1.516L3.668 13Zm4.947 0h1.801v4.3h2.7v1.4h-4.5V13h-.001Zm4.5 0h5.4v1.4h-1.798v4.3h-1.701v-4.3h-1.9V13h-.001Zm-8.517 1.457-.614 2.059h1.262l-.648-2.059Z"/></svg>';
    var loupe = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.68 13.74h-.001l4.209 4.208a1 1 0 1 0 1.414-1.414l-4.267-4.268a6 6 0 1 0-1.355 1.474ZM13 9a4 4 0 1 1-8 0 4 4 0 0 1 8 0Z"/></svg>';
    var previousArrow = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.463 5.187a.888.888 0 1 1 1.254 1.255L9.16 10l3.557 3.557a.888.888 0 1 1-1.254 1.255L7.26 10.61a.888.888 0 0 1 .16-1.382l4.043-4.042z"/></svg>';
    var nextArrow = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.537 14.813a.888.888 0 1 1-1.254-1.255L10.84 10 7.283 6.442a.888.888 0 1 1 1.254-1.255L12.74 9.39a.888.888 0 0 1-.16 1.382l-4.043 4.042z"/></svg>';
    var image = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.66 9.118a.693.693 0 0 1 .956.032l3.65 3.411 2.422-2.238a.695.695 0 0 1 .945 0L17.5 13.6V2.5h-15v11.1l4.16-4.482ZM17.8 1c.652 0 1.2.47 1.2 1.1v14.362c0 .64-.532 1.038-1.184 1.038H2.184C1.532 17.5 1 17.103 1 16.462V2.1C1 1.47 1.537 1 2.2 1h15.6Zm-5.655 6a2.128 2.128 0 0 1 .157-2.364A2.133 2.133 0 1 1 12.145 7Z"/></svg>';
    var imageUpload = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M1.201 1C.538 1 0 1.47 0 2.1v14.363c0 .64.534 1.037 1.186 1.037h9.494a2.97 2.97 0 0 1-.414-.287 2.998 2.998 0 0 1-1.055-2.03 3.003 3.003 0 0 1 .693-2.185l.383-.455-.02.018-3.65-3.41a.695.695 0 0 0-.957-.034L1.5 13.6V2.5h15v5.535a2.97 2.97 0 0 1 1.412.932l.088.105V2.1c0-.63-.547-1.1-1.2-1.1H1.202Zm11.713 2.803a2.146 2.146 0 0 0-2.049 1.992 2.14 2.14 0 0 0 1.28 2.096 2.13 2.13 0 0 0 2.644-3.11 2.134 2.134 0 0 0-1.875-.978Z"/><path d="M15.522 19.1a.79.79 0 0 0 .79-.79v-5.373l2.059 2.455a.79.79 0 1 0 1.211-1.015l-3.352-3.995a.79.79 0 0 0-.995-.179.784.784 0 0 0-.299.221l-3.35 3.99a.79.79 0 1 0 1.21 1.017l1.936-2.306v5.185c0 .436.353.79.79.79Z"/><path d="M15.522 19.1a.79.79 0 0 0 .79-.79v-5.373l2.059 2.455a.79.79 0 1 0 1.211-1.015l-3.352-3.995a.79.79 0 0 0-.995-.179.784.784 0 0 0-.299.221l-3.35 3.99a.79.79 0 1 0 1.21 1.017l1.936-2.306v5.185c0 .436.353.79.79.79Z"/></svg>';
    var imageAssetManager = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M1.201 1c-.662 0-1.2.47-1.2 1.1v14.248c0 .64.533 1.152 1.185 1.152h6.623v-7.236L6.617 9.15a.694.694 0 0 0-.957-.033L1.602 13.55V2.553l14.798.003V9.7H18V2.1c0-.63-.547-1.1-1.2-1.1H1.202Zm11.723 2.805a2.094 2.094 0 0 0-1.621.832 2.127 2.127 0 0 0 1.136 3.357 2.13 2.13 0 0 0 2.611-1.506 2.133 2.133 0 0 0-.76-2.244 2.13 2.13 0 0 0-1.366-.44Z"/><path clip-rule="evenodd" d="M19.898 12.369v6.187a.844.844 0 0 1-.844.844h-8.719a.844.844 0 0 1-.843-.844v-7.312a.844.844 0 0 1 .843-.844h2.531a.843.843 0 0 1 .597.248l.838.852h4.75c.223 0 .441.114.6.272a.844.844 0 0 1 .247.597Zm-1.52.654-4.377.02-1.1-1.143H11v6h7.4l-.023-4.877Z"/></svg>';
    var imageUrl = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M1.201 1C.538 1 0 1.47 0 2.1v14.363c0 .64.534 1.037 1.186 1.037h7.029a5.401 5.401 0 0 1 .615-4.338l.762-1.232-2.975-2.78a.696.696 0 0 0-.957-.033L1.5 13.6V2.5h15v6.023c.449.131.887.32 1.307.573l.058.033c.046.028.09.057.135.086V2.1c0-.63-.547-1.1-1.2-1.1H1.202Zm11.713 2.803a2.15 2.15 0 0 0-1.611.834 2.118 2.118 0 0 0-.438 1.158 2.14 2.14 0 0 0 1.277 2.096 2.132 2.132 0 0 0 2.645-3.11 2.13 2.13 0 0 0-1.873-.978Z"/><path d="M16.63 10.294a3.003 3.003 0 0 0-4.142.887l-.117.177a.647.647 0 0 0-.096.492.664.664 0 0 0 .278.418.7.7 0 0 0 .944-.234 1.741 1.741 0 0 1 2.478-.463 1.869 1.869 0 0 1 .476 2.55.637.637 0 0 0-.071.5.646.646 0 0 0 .309.396.627.627 0 0 0 .869-.19l.027-.041a3.226 3.226 0 0 0-.956-4.492Zm-6.061 3.78-.044.066a3.228 3.228 0 0 0 .82 4.403 3.005 3.005 0 0 0 4.275-.798l.13-.197a.626.626 0 0 0 .092-.475.638.638 0 0 0-.268-.402.713.713 0 0 0-.99.26l-.018.029a1.741 1.741 0 0 1-2.477.461 1.87 1.87 0 0 1-.475-2.55l.029-.047a.647.647 0 0 0 .086-.485.66.66 0 0 0-.275-.408l-.04-.027a.609.609 0 0 0-.845.17Z"/><path d="M15.312 13.925c.24-.36.154-.838-.19-1.067-.346-.23-.82-.124-1.059.236l-1.268 1.907c-.239.36-.153.838.192 1.067.345.23.818.123 1.057-.236l1.268-1.907Z"/></svg>';
    var alignBottom = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.239 13.938-2.88-1.663a.75.75 0 0 1 .75-1.3L9 12.067V4.75a.75.75 0 1 1 1.5 0v7.318l1.89-1.093a.75.75 0 0 1 .75 1.3l-2.879 1.663a.752.752 0 0 1-.511.187.752.752 0 0 1-.511-.187zM4.25 17a.75.75 0 1 1 0-1.5h10.5a.75.75 0 0 1 0 1.5H4.25z"/></svg>';
    var alignMiddle = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.75 11.875a.752.752 0 0 1 .508.184l2.883 1.666a.75.75 0 0 1-.659 1.344l-.091-.044-1.892-1.093.001 4.318a.75.75 0 1 1-1.5 0v-4.317l-1.89 1.092a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .51-.187zM15.25 9a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM9.75.375a.75.75 0 0 1 .75.75v4.318l1.89-1.093.092-.045a.75.75 0 0 1 .659 1.344l-2.883 1.667a.752.752 0 0 1-.508.184.752.752 0 0 1-.511-.187L6.359 5.65a.75.75 0 0 1 .75-1.299L9 5.442V1.125a.75.75 0 0 1 .75-.75z"/></svg>';
    var alignTop = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m10.261 7.062 2.88 1.663a.75.75 0 0 1-.75 1.3L10.5 8.933v7.317a.75.75 0 1 1-1.5 0V8.932l-1.89 1.093a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .511-.187.752.752 0 0 1 .511.187zM15.25 4a.75.75 0 1 1 0 1.5H4.75a.75.75 0 0 1 0-1.5h10.5z"/></svg>';
    var alignLeft = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>';
    var alignCenter = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm2.286 4c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75z"/></svg>';
    var alignRight = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.75a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 8a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 4a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75zm0-8a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75z"/></svg>';
    var alignJustify = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>';
    var objectBlockLeft = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>';
    var objectCenter = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M15.003 7v5.5a1 1 0 0 1-1 1H5.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H6.5V12h6.997V7.5z"/></svg>';
    var objectBlockRight = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>';
    var objectFullWidth = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18 7v5.5a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1zm-1.505.5H3.504V12h12.991V7.5z"/></svg>';
    var objectInline = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>';
    var objectLeft = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zm0-3H18v1.5h-4.5zm0-3H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>';
    var objectRight = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2zm0-9h5v1.5H2zm0 3h5v1.5H2zm0 3h5v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>';
    var objectSizeFull = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M18.095 2H1.905C.853 2 0 2.895 0 4v12c0 1.105.853 2 1.905 2h16.19C19.147 18 20 17.105 20 16V4c0-1.105-.853-2-1.905-2zm0 1.5c.263 0 .476.224.476.5v12c0 .276-.213.5-.476.5H1.905a.489.489 0 0 1-.476-.5V4c0-.276.213-.5.476-.5h16.19z"/></svg>';
    var objectSizeCustom = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:v="https://vecta.io/nano" viewBox="0 0 20 20"><path d="M.95 1.43a.95.95 0 0 0-.95.95v3.1a.95.95 0 0 0 .95.95h.75v6.3H.95a.95.95 0 0 0-.95.95v3.1a.95.95 0 0 0 .95.95h3.1a.95.95 0 0 0 .95-.95v-.65h1.932l1.539-1.5H5v-.95a.95.95 0 0 0-.95-.95H3.2v-6.3h.85A.95.95 0 0 0 5 5.48v-.55h10v.55a.95.95 0 0 0 .95.95h3.1a.95.95 0 0 0 .95-.95v-3.1a.95.95 0 0 0-.95-.95h-3.1a.95.95 0 0 0-.95.95v1.05H5V2.38a.95.95 0 0 0-.95-.95H.95zm.55 3.5v-2h2v2h-2zm0 9.3v2h2v-2h-2zm15-11.3v2h2v-2h-2z"/><path d="M8.139 20.004v-2.388l7.045-7.048 2.391 2.391-7.046 7.046h-2.39zm11.421-9.101a.64.64 0 0 1-.138.206l-1.165 1.168-2.391-2.391 1.167-1.163a.63.63 0 0 1 .206-.138.635.635 0 0 1 .243-.049.63.63 0 0 1 .449.187l1.491 1.488c.059.059.108.129.138.206s.049.16.049.243a.6.6 0 0 1-.049.243z"/></svg>';
    var objectSizeLarge = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 16.5v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1ZM1 15v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 13v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 11v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 9v1H0V9h1Zm19 0v1h-1V9h1ZM1 7v1H0V7h1Zm19 0v1h-1V7h1ZM1 5v1H0V5h1Zm19 0v1h-1V5h1Zm0-2v1h-1V3h1ZM1 3v1H0V3h1Zm13.5-1.5v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm-8 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm8 0v1h-1v-1h1Zm-10 0v1h-1v-1h1Z"/><path d="M13 5.5H2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2v-8a2 2 0 0 0-2-2ZM13 7a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-8A.5.5 0 0 1 2 7h11Z"/></svg>';
    var objectSizeSmall = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 16.5v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1ZM1 15v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 13v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 11v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 9v1H0V9h1Zm19 0v1h-1V9h1ZM1 7v1H0V7h1Zm19 0v1h-1V7h1ZM1 5v1H0V5h1Zm19 0v1h-1V5h1Zm0-2v1h-1V3h1ZM1 3v1H0V3h1Zm13.5-1.5v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm-8 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm8 0v1h-1v-1h1Zm-10 0v1h-1v-1h1Z"/><path d="M7 9.5H2a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h5a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2ZM7 11a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-4A.5.5 0 0 1 2 11h5Z"/></svg>';
    var objectSizeMedium = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 16.5v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1ZM1 15v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 13v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 11v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 9v1H0V9h1Zm19 0v1h-1V9h1ZM1 7v1H0V7h1Zm19 0v1h-1V7h1ZM1 5v1H0V5h1Zm19 0v1h-1V5h1Zm0-2v1h-1V3h1ZM1 3v1H0V3h1Zm13.5-1.5v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm-8 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm8 0v1h-1v-1h1Zm-10 0v1h-1v-1h1Z"/><path d="M10 7.5H2a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2ZM10 9a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-6A.5.5 0 0 1 2 9h8Z"/></svg>';
    var pencil = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.3 17.37-.061.088a1.518 1.518 0 0 1-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506 13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5 9.375 17H19v1.5H8z"/></svg>';
    var pilcrow = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.999 2H15a1 1 0 0 1 0 2h-1.004v13a1 1 0 1 1-2 0V4H8.999v13a1 1 0 1 1-2 0v-7A4 4 0 0 1 3 6a4 4 0 0 1 3.999-4z"/></svg>';
    var quote = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z"/></svg>';
    var threeVerticalDots = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>';
    var dragIndicator = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5 3.25a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M12 3.25a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M5 10a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M12 10a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M5 16.75a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M12 16.75a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/></svg>';
    var bold = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 0 1 .808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 0 1-2.296 3.504 6.1 6.1 0 0 1-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 0 0 .91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z"/></svg>';
    var paragraph = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.5 5.5H7v5h3.5a2.5 2.5 0 1 0 0-5zM5 3h6.5v.025a5 5 0 0 1 0 9.95V13H7v4a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z"/></svg>';
    var plus = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 0 0-1 1v6H3a1 1 0 1 0 0 2h6v6a1 1 0 1 0 2 0v-6h6a1 1 0 1 0 0-2h-6V3a1 1 0 0 0-1-1Z"/></svg>';
    var text = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.816 11.5 7.038 4.785 4.261 11.5h5.555Zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13Z"/><path d="m12.09 17-.534-1.292.848-1.971.545 1.319L12.113 17h-.023Zm1.142-5.187.545 1.319L15.5 9.13l1.858 4.316h-3.45l.398.965h3.467L18.887 17H20l-3.873-9h-1.254l-1.641 3.813Z"/></svg>';
    var importExport = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M19 4.5 14 0H3v12.673l.868-1.041c.185-.222.4-.402.632-.54V1.5h8v5h5v7.626a2.24 2.24 0 0 1 1.5.822V4.5ZM14 5V2l3.3 3H14Zm-3.692 12.5c.062.105.133.206.213.303L11.52 19H8v-.876a2.243 2.243 0 0 0 1.82-.624h.488Zm7.518-.657a.75.75 0 0 0-1.152-.96L15.5 17.29V12H14v5.29l-1.174-1.408a.75.75 0 0 0-1.152.96l2.346 2.816a.95.95 0 0 0 1.46 0l2.346-2.815Zm-15.056-.38a.75.75 0 0 1-.096-1.056l2.346-2.815a.95.95 0 0 1 1.46 0l2.346 2.815a.75.75 0 1 1-1.152.96L6.5 14.96V20H5v-5.04l-1.174 1.408a.75.75 0 0 1-1.056.096Z"/></svg>';
    var redo = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m14.958 9.367-2.189 1.837a.75.75 0 0 0 .965 1.149l3.788-3.18a.747.747 0 0 0 .21-.284.75.75 0 0 0-.17-.945L13.77 4.762a.75.75 0 1 0-.964 1.15l2.331 1.955H6.22A.75.75 0 0 0 6 7.9a4 4 0 1 0 1.477 7.718l-.344-1.489A2.5 2.5 0 1 1 6.039 9.4l-.008-.032h8.927z"/></svg>';
    var undo = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m5.042 9.367 2.189 1.837a.75.75 0 0 1-.965 1.149l-3.788-3.18a.747.747 0 0 1-.21-.284.75.75 0 0 1 .17-.945L6.23 4.762a.75.75 0 1 1 .964 1.15L4.863 7.866h8.917A.75.75 0 0 1 14 7.9a4 4 0 1 1-1.477 7.718l.344-1.489a2.5 2.5 0 1 0 1.094-4.73l.008-.032H5.042z"/></svg>';
    var bulletedList = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0C1 4.784 1.777 4 2.75 4c.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75C1.784 7.5 1 6.723 1 5.75zm6 9c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0c0-.966.777-1.75 1.75-1.75.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75-.966 0-1.75-.777-1.75-1.75z"/></svg>';
    var numberedList = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM3.5 3v5H2V3.7H1v-1h2.5V3zM.343 17.857l2.59-3.257H2.92a.6.6 0 1 0-1.04 0H.302a2 2 0 1 1 3.995 0h-.001c-.048.405-.16.734-.333.988-.175.254-.59.692-1.244 1.312H4.3v1h-4l.043-.043zM7 14.75a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>';
    var todoList = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m2.315 14.705 2.224-2.24a.689.689 0 0 1 .963 0 .664.664 0 0 1 0 .949L2.865 16.07a.682.682 0 0 1-.112.089.647.647 0 0 1-.852-.051L.688 14.886a.635.635 0 0 1 0-.903.647.647 0 0 1 .91 0l.717.722zm5.185.045a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75zM2.329 5.745l2.21-2.226a.689.689 0 0 1 .963 0 .664.664 0 0 1 0 .95L2.865 7.125a.685.685 0 0 1-.496.196.644.644 0 0 1-.468-.187L.688 5.912a.635.635 0 0 1 0-.903.647.647 0 0 1 .91 0l.73.736zM7.5 5.75A.75.75 0 0 1 8.25 5h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>';
    var codeBlock = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.87 12.61a.75.75 0 0 1-.089.976l-.085.07-3.154 2.254 3.412 2.414a.75.75 0 0 1 .237.95l-.057.095a.75.75 0 0 1-.95.237l-.096-.058-4.272-3.022-.003-1.223 4.01-2.867a.75.75 0 0 1 1.047.174zm2.795-.231.095.057 4.011 2.867-.003 1.223-4.272 3.022-.095.058a.75.75 0 0 1-.88-.151l-.07-.086-.058-.095a.75.75 0 0 1 .15-.88l.087-.07 3.412-2.414-3.154-2.253-.085-.071a.75.75 0 0 1 .862-1.207zM16 0a2 2 0 0 1 2 2v9.354l-.663-.492-.837-.001V2a.5.5 0 0 0-.5-.5H2a.5.5 0 0 0-.5.5v15a.5.5 0 0 0 .5.5h3.118L7.156 19H2a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h14zM5.009 15l.003 1H3v-1h2.009zm2.188-2-1.471 1H5v-1h2.197zM10 11v.095L8.668 12H7v-1h3zm4-2v1H7V9h7zm0-2v1H7V7h7zm-4-2v1H5V5h5zM6 3v1H3V3h3z"/></svg>';
    var browseFiles = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.627 16.5zm5.873-.196zm0-7.001V8h-13v8.5h4.341c.191.54.457 1.044.785 1.5H2a1.5 1.5 0 0 1-1.5-1.5v-13A1.5 1.5 0 0 1 2 2h4.5a1.5 1.5 0 0 1 1.06.44L9.122 4H16a1.5 1.5 0 0 1 1.5 1.5v1A1.5 1.5 0 0 1 19 8v2.531a6.027 6.027 0 0 0-1.5-1.228zM16 6.5v-1H8.5l-2-2H2v13h1V8a1.5 1.5 0 0 1 1.5-1.5H16z"/><path d="M14.5 19.5a5 5 0 1 1 0-10 5 5 0 0 1 0 10zM15 14v-2h-1v2h-2v1h2v2h1v-2h2v-1h-2z"/></svg>';
    var heading1 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M19 9v10h-2v-8h-2V9h4zM4 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1H10a1 1 0 0 1-1-1V11H4v4.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1H3a1 1 0 0 1 1 1v4.5z"/></svg>';
    var heading2 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1V11H3v4.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1H2a1 1 0 0 1 1 1v4.5zm16.076 8.343V18.5h-6.252c.067-.626.27-1.22.61-1.78.338-.561 1.006-1.305 2.005-2.232.804-.749 1.297-1.257 1.479-1.523.245-.368.368-.732.368-1.092 0-.398-.107-.703-.32-.917-.214-.214-.51-.32-.886-.32-.372 0-.669.111-.889.336-.22.224-.347.596-.38 1.117l-1.778-.178c.106-.982.438-1.686.997-2.114.558-.427 1.257-.64 2.095-.64.918 0 1.64.247 2.164.742.525.495.787 1.11.787 1.847 0 .419-.075.818-.225 1.197-.15.378-.388.775-.714 1.19-.216.275-.605.67-1.168 1.187-.563.516-.92.859-1.07 1.028a3.11 3.11 0 0 0-.365.495h3.542z"/></svg>';
    var heading3 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1V11H3v4.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1H2a1 1 0 0 1 1 1v4.5zm9.989 7.53 1.726-.209c.055.44.203.777.445 1.01.24.232.533.349.876.349.368 0 .678-.14.93-.42.251-.279.377-.655.377-1.13 0-.448-.12-.803-.362-1.066a1.153 1.153 0 0 0-.882-.393c-.228 0-.501.044-.819.133l.197-1.453c.482.012.85-.092 1.105-.315.253-.222.38-.517.38-.885 0-.313-.093-.563-.279-.75-.186-.185-.434-.278-.743-.278a1.07 1.07 0 0 0-.78.317c-.216.212-.347.52-.394.927l-1.644-.28c.114-.562.287-1.012.517-1.348.231-.337.553-.601.965-.794a3.24 3.24 0 0 1 1.387-.289c.876 0 1.579.28 2.108.838.436.457.653.973.653 1.549 0 .817-.446 1.468-1.339 1.955.533.114.96.37 1.28.768.319.398.478.878.478 1.441 0 .817-.298 1.513-.895 2.088-.596.576-1.339.864-2.228.864-.842 0-1.54-.243-2.094-.727-.555-.485-.876-1.118-.965-1.901z"/></svg>';
    var heading4 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3.5 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V11h-5v4.5a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v4.5zm13.55 10v-1.873h-3.81v-1.561l4.037-5.91h1.498v5.904h1.156v1.567h-1.156V18.5H17.05zm0-3.44v-3.18l-2.14 3.18h2.14z"/></svg>';
    var heading5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3.5 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V11h-5v4.5a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v4.5zm9.578 7.607 1.777-.184c.05.402.201.72.45.955a1.223 1.223 0 0 0 1.81-.101c.258-.303.387-.759.387-1.368 0-.572-.128-1-.384-1.286-.256-.285-.59-.428-1-.428-.512 0-.971.226-1.377.679l-1.448-.21.915-4.843h4.716v1.67H15.56l-.28 1.58a2.697 2.697 0 0 1 1.219-.298 2.68 2.68 0 0 1 2.012.863c.55.576.825 1.323.825 2.241a3.36 3.36 0 0 1-.666 2.05c-.605.821-1.445 1.232-2.52 1.232-.86 0-1.56-.23-2.101-.692-.542-.461-.866-1.081-.971-1.86z"/></svg>';
    var heading6 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3.5 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V11h-5v4.5a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v4.5zm15.595 2.973-1.726.19c-.043-.355-.153-.617-.33-.787-.178-.169-.409-.253-.692-.253-.377 0-.695.169-.956.507-.26.339-.424 1.043-.492 2.114.445-.525.997-.787 1.657-.787.745 0 1.383.284 1.914.85.531.568.797 1.3.797 2.197 0 .952-.28 1.716-.838 2.291-.559.576-1.276.864-2.152.864-.94 0-1.712-.365-2.317-1.095-.605-.73-.908-1.927-.908-3.59 0-1.705.316-2.935.946-3.688.63-.753 1.45-1.13 2.457-1.13.706 0 1.291.198 1.755.594.463.395.758.97.885 1.723zm-4.043 3.891c0 .58.133 1.028.4 1.343.266.315.57.473.914.473.33 0 .605-.13.825-.388.22-.258.33-.68.33-1.27 0-.604-.118-1.047-.355-1.329a1.115 1.115 0 0 0-.89-.422c-.342 0-.632.134-.869.403s-.355.666-.355 1.19z"/></svg>';
    var horizontalLine = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 9h16v2H2z"/></svg>';
    var html = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M17 0a2 2 0 0 1 2 2v7a1 1 0 0 1 1 1v5a1 1 0 0 1-.883.993l-.118.006L19 17a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2l-.001-1.001-.116-.006A1 1 0 0 1 0 15v-5a1 1 0 0 1 .999-1L1 2a2 2 0 0 1 2-2h14zm.499 15.999h-15L2.5 17a.5.5 0 0 0 .5.5h14a.5.5 0 0 0 .5-.5l-.001-1.001zm-3.478-6.013-.014.014H14v.007l-1.525 1.525-1.46-1.46-.015.013V10h-1v5h1v-3.53l1.428 1.43.048.043.131-.129L14 11.421V15h1v-5h-.965l-.014-.014zM2 10H1v5h1v-2h2v2h1v-5H4v2H2v-2zm7 0H6v1h1v4h1v-4h1v-1zm8 0h-1v5h3v-1h-2v-4zm0-8.5H3a.5.5 0 0 0-.5.5l-.001 6.999h15L17.5 2a.5.5 0 0 0-.5-.5zM10 7v1H4V7h6zm3-2v1H4V5h9zm-3-2v1H4V3h6z"/></svg>';
    var indent = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zM1.632 6.95 5.02 9.358a.4.4 0 0 1-.013.661l-3.39 2.207A.4.4 0 0 1 1 11.892V7.275a.4.4 0 0 1 .632-.326z"/></svg>';
    var outdent = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zm1.618-9.55L.98 9.358a.4.4 0 0 0 .013.661l3.39 2.207A.4.4 0 0 0 5 11.892V7.275a.4.4 0 0 0-.632-.326z"/></svg>';
    var table = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 5.5v3h4v-3H3Zm0 4v3h4v-3H3Zm0 4v3h4v-3H3Zm5 3h4v-3H8v3Zm5 0h4v-3h-4v3Zm4-4v-3h-4v3h4Zm0-4v-3h-4v3h4Zm1.5 8A1.5 1.5 0 0 1 17 18H3a1.5 1.5 0 0 1-1.5-1.5V3c.222-.863 1.068-1.5 2-1.5h13c.932 0 1.778.637 2 1.5v13.5Zm-6.5-4v-3H8v3h4Zm0-4v-3H8v3h4Z"/></svg>';
    const icons = {
      bold,
      cancel,
      caption,
      check,
      cog,
      colorPalette,
      eraser,
      history,
      image,
      imageUpload,
      imageAssetManager,
      imageUrl,
      lowVision,
      textAlternative,
      loupe,
      previousArrow,
      nextArrow,
      importExport,
      paragraph,
      plus,
      text,
      alignBottom,
      alignMiddle,
      alignTop,
      alignLeft,
      alignCenter,
      alignRight,
      alignJustify,
      objectLeft,
      objectCenter,
      objectRight,
      objectFullWidth,
      objectInline,
      objectBlockLeft,
      objectBlockRight,
      objectSizeCustom,
      objectSizeFull,
      objectSizeLarge,
      objectSizeSmall,
      objectSizeMedium,
      pencil,
      pilcrow,
      quote,
      threeVerticalDots,
      dragIndicator,
      redo,
      undo,
      bulletedList,
      numberedList,
      todoList,
      codeBlock,
      browseFiles,
      heading1,
      heading2,
      heading3,
      heading4,
      heading5,
      heading6,
      horizontalLine,
      html,
      indent,
      outdent,
      table
    };
    var colorName = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
    const cssKeywords = colorName;
    const reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    const convert$1 = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    var conversions$2 = convert$1;
    for (const model of Object.keys(convert$1)) {
      if (!("channels" in convert$1[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert$1[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert$1[model].labels.length !== convert$1[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert$1[model];
      delete convert$1[model].channels;
      delete convert$1[model].labels;
      Object.defineProperty(convert$1[model], "channels", { value: channels });
      Object.defineProperty(convert$1[model], "labels", { value: labels });
    }
    convert$1.rgb.hsl = function(rgb) {
      const r2 = rgb[0] / 255;
      const g2 = rgb[1] / 255;
      const b2 = rgb[2] / 255;
      const min2 = Math.min(r2, g2, b2);
      const max2 = Math.max(r2, g2, b2);
      const delta = max2 - min2;
      let h2;
      let s2;
      if (max2 === min2) {
        h2 = 0;
      } else if (r2 === max2) {
        h2 = (g2 - b2) / delta;
      } else if (g2 === max2) {
        h2 = 2 + (b2 - r2) / delta;
      } else if (b2 === max2) {
        h2 = 4 + (r2 - g2) / delta;
      }
      h2 = Math.min(h2 * 60, 360);
      if (h2 < 0) {
        h2 += 360;
      }
      const l2 = (min2 + max2) / 2;
      if (max2 === min2) {
        s2 = 0;
      } else if (l2 <= 0.5) {
        s2 = delta / (max2 + min2);
      } else {
        s2 = delta / (2 - max2 - min2);
      }
      return [h2, s2 * 100, l2 * 100];
    };
    convert$1.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h2;
      let s2;
      const r2 = rgb[0] / 255;
      const g2 = rgb[1] / 255;
      const b2 = rgb[2] / 255;
      const v2 = Math.max(r2, g2, b2);
      const diff2 = v2 - Math.min(r2, g2, b2);
      const diffc = function(c2) {
        return (v2 - c2) / 6 / diff2 + 1 / 2;
      };
      if (diff2 === 0) {
        h2 = 0;
        s2 = 0;
      } else {
        s2 = diff2 / v2;
        rdif = diffc(r2);
        gdif = diffc(g2);
        bdif = diffc(b2);
        if (r2 === v2) {
          h2 = bdif - gdif;
        } else if (g2 === v2) {
          h2 = 1 / 3 + rdif - bdif;
        } else if (b2 === v2) {
          h2 = 2 / 3 + gdif - rdif;
        }
        if (h2 < 0) {
          h2 += 1;
        } else if (h2 > 1) {
          h2 -= 1;
        }
      }
      return [
        h2 * 360,
        s2 * 100,
        v2 * 100
      ];
    };
    convert$1.rgb.hwb = function(rgb) {
      const r2 = rgb[0];
      const g2 = rgb[1];
      let b2 = rgb[2];
      const h2 = convert$1.rgb.hsl(rgb)[0];
      const w2 = 1 / 255 * Math.min(r2, Math.min(g2, b2));
      b2 = 1 - 1 / 255 * Math.max(r2, Math.max(g2, b2));
      return [h2, w2 * 100, b2 * 100];
    };
    convert$1.rgb.cmyk = function(rgb) {
      const r2 = rgb[0] / 255;
      const g2 = rgb[1] / 255;
      const b2 = rgb[2] / 255;
      const k2 = Math.min(1 - r2, 1 - g2, 1 - b2);
      const c2 = (1 - r2 - k2) / (1 - k2) || 0;
      const m2 = (1 - g2 - k2) / (1 - k2) || 0;
      const y2 = (1 - b2 - k2) / (1 - k2) || 0;
      return [c2 * 100, m2 * 100, y2 * 100, k2 * 100];
    };
    function comparativeDistance(x2, y2) {
      return (x2[0] - y2[0]) ** 2 + (x2[1] - y2[1]) ** 2 + (x2[2] - y2[2]) ** 2;
    }
    convert$1.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert$1.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert$1.rgb.xyz = function(rgb) {
      let r2 = rgb[0] / 255;
      let g2 = rgb[1] / 255;
      let b2 = rgb[2] / 255;
      r2 = r2 > 0.04045 ? ((r2 + 0.055) / 1.055) ** 2.4 : r2 / 12.92;
      g2 = g2 > 0.04045 ? ((g2 + 0.055) / 1.055) ** 2.4 : g2 / 12.92;
      b2 = b2 > 0.04045 ? ((b2 + 0.055) / 1.055) ** 2.4 : b2 / 12.92;
      const x2 = r2 * 0.4124 + g2 * 0.3576 + b2 * 0.1805;
      const y2 = r2 * 0.2126 + g2 * 0.7152 + b2 * 0.0722;
      const z2 = r2 * 0.0193 + g2 * 0.1192 + b2 * 0.9505;
      return [x2 * 100, y2 * 100, z2 * 100];
    };
    convert$1.rgb.lab = function(rgb) {
      const xyz = convert$1.rgb.xyz(rgb);
      let x2 = xyz[0];
      let y2 = xyz[1];
      let z2 = xyz[2];
      x2 /= 95.047;
      y2 /= 100;
      z2 /= 108.883;
      x2 = x2 > 8856e-6 ? x2 ** (1 / 3) : 7.787 * x2 + 16 / 116;
      y2 = y2 > 8856e-6 ? y2 ** (1 / 3) : 7.787 * y2 + 16 / 116;
      z2 = z2 > 8856e-6 ? z2 ** (1 / 3) : 7.787 * z2 + 16 / 116;
      const l2 = 116 * y2 - 16;
      const a2 = 500 * (x2 - y2);
      const b2 = 200 * (y2 - z2);
      return [l2, a2, b2];
    };
    convert$1.hsl.rgb = function(hsl) {
      const h2 = hsl[0] / 360;
      const s2 = hsl[1] / 100;
      const l2 = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s2 === 0) {
        val = l2 * 255;
        return [val, val, val];
      }
      if (l2 < 0.5) {
        t2 = l2 * (1 + s2);
      } else {
        t2 = l2 + s2 - l2 * s2;
      }
      const t1 = 2 * l2 - t2;
      const rgb = [0, 0, 0];
      for (let i2 = 0; i2 < 3; i2++) {
        t3 = h2 + 1 / 3 * -(i2 - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i2] = val * 255;
      }
      return rgb;
    };
    convert$1.hsl.hsv = function(hsl) {
      const h2 = hsl[0];
      let s2 = hsl[1] / 100;
      let l2 = hsl[2] / 100;
      let smin = s2;
      const lmin = Math.max(l2, 0.01);
      l2 *= 2;
      s2 *= l2 <= 1 ? l2 : 2 - l2;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v2 = (l2 + s2) / 2;
      const sv = l2 === 0 ? 2 * smin / (lmin + smin) : 2 * s2 / (l2 + s2);
      return [h2, sv * 100, v2 * 100];
    };
    convert$1.hsv.rgb = function(hsv) {
      const h2 = hsv[0] / 60;
      const s2 = hsv[1] / 100;
      let v2 = hsv[2] / 100;
      const hi = Math.floor(h2) % 6;
      const f2 = h2 - Math.floor(h2);
      const p2 = 255 * v2 * (1 - s2);
      const q2 = 255 * v2 * (1 - s2 * f2);
      const t2 = 255 * v2 * (1 - s2 * (1 - f2));
      v2 *= 255;
      switch (hi) {
        case 0:
          return [v2, t2, p2];
        case 1:
          return [q2, v2, p2];
        case 2:
          return [p2, v2, t2];
        case 3:
          return [p2, q2, v2];
        case 4:
          return [t2, p2, v2];
        case 5:
          return [v2, p2, q2];
      }
    };
    convert$1.hsv.hsl = function(hsv) {
      const h2 = hsv[0];
      const s2 = hsv[1] / 100;
      const v2 = hsv[2] / 100;
      const vmin = Math.max(v2, 0.01);
      let sl;
      let l2;
      l2 = (2 - s2) * v2;
      const lmin = (2 - s2) * vmin;
      sl = s2 * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l2 /= 2;
      return [h2, sl * 100, l2 * 100];
    };
    convert$1.hwb.rgb = function(hwb) {
      const h2 = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f2;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i2 = Math.floor(6 * h2);
      const v2 = 1 - bl;
      f2 = 6 * h2 - i2;
      if ((i2 & 1) !== 0) {
        f2 = 1 - f2;
      }
      const n2 = wh + f2 * (v2 - wh);
      let r2;
      let g2;
      let b2;
      switch (i2) {
        default:
        case 6:
        case 0:
          r2 = v2;
          g2 = n2;
          b2 = wh;
          break;
        case 1:
          r2 = n2;
          g2 = v2;
          b2 = wh;
          break;
        case 2:
          r2 = wh;
          g2 = v2;
          b2 = n2;
          break;
        case 3:
          r2 = wh;
          g2 = n2;
          b2 = v2;
          break;
        case 4:
          r2 = n2;
          g2 = wh;
          b2 = v2;
          break;
        case 5:
          r2 = v2;
          g2 = wh;
          b2 = n2;
          break;
      }
      return [r2 * 255, g2 * 255, b2 * 255];
    };
    convert$1.cmyk.rgb = function(cmyk) {
      const c2 = cmyk[0] / 100;
      const m2 = cmyk[1] / 100;
      const y2 = cmyk[2] / 100;
      const k2 = cmyk[3] / 100;
      const r2 = 1 - Math.min(1, c2 * (1 - k2) + k2);
      const g2 = 1 - Math.min(1, m2 * (1 - k2) + k2);
      const b2 = 1 - Math.min(1, y2 * (1 - k2) + k2);
      return [r2 * 255, g2 * 255, b2 * 255];
    };
    convert$1.xyz.rgb = function(xyz) {
      const x2 = xyz[0] / 100;
      const y2 = xyz[1] / 100;
      const z2 = xyz[2] / 100;
      let r2;
      let g2;
      let b2;
      r2 = x2 * 3.2406 + y2 * -1.5372 + z2 * -0.4986;
      g2 = x2 * -0.9689 + y2 * 1.8758 + z2 * 0.0415;
      b2 = x2 * 0.0557 + y2 * -0.204 + z2 * 1.057;
      r2 = r2 > 31308e-7 ? 1.055 * r2 ** (1 / 2.4) - 0.055 : r2 * 12.92;
      g2 = g2 > 31308e-7 ? 1.055 * g2 ** (1 / 2.4) - 0.055 : g2 * 12.92;
      b2 = b2 > 31308e-7 ? 1.055 * b2 ** (1 / 2.4) - 0.055 : b2 * 12.92;
      r2 = Math.min(Math.max(0, r2), 1);
      g2 = Math.min(Math.max(0, g2), 1);
      b2 = Math.min(Math.max(0, b2), 1);
      return [r2 * 255, g2 * 255, b2 * 255];
    };
    convert$1.xyz.lab = function(xyz) {
      let x2 = xyz[0];
      let y2 = xyz[1];
      let z2 = xyz[2];
      x2 /= 95.047;
      y2 /= 100;
      z2 /= 108.883;
      x2 = x2 > 8856e-6 ? x2 ** (1 / 3) : 7.787 * x2 + 16 / 116;
      y2 = y2 > 8856e-6 ? y2 ** (1 / 3) : 7.787 * y2 + 16 / 116;
      z2 = z2 > 8856e-6 ? z2 ** (1 / 3) : 7.787 * z2 + 16 / 116;
      const l2 = 116 * y2 - 16;
      const a2 = 500 * (x2 - y2);
      const b2 = 200 * (y2 - z2);
      return [l2, a2, b2];
    };
    convert$1.lab.xyz = function(lab) {
      const l2 = lab[0];
      const a2 = lab[1];
      const b2 = lab[2];
      let x2;
      let y2;
      let z2;
      y2 = (l2 + 16) / 116;
      x2 = a2 / 500 + y2;
      z2 = y2 - b2 / 200;
      const y22 = y2 ** 3;
      const x22 = x2 ** 3;
      const z22 = z2 ** 3;
      y2 = y22 > 8856e-6 ? y22 : (y2 - 16 / 116) / 7.787;
      x2 = x22 > 8856e-6 ? x22 : (x2 - 16 / 116) / 7.787;
      z2 = z22 > 8856e-6 ? z22 : (z2 - 16 / 116) / 7.787;
      x2 *= 95.047;
      y2 *= 100;
      z2 *= 108.883;
      return [x2, y2, z2];
    };
    convert$1.lab.lch = function(lab) {
      const l2 = lab[0];
      const a2 = lab[1];
      const b2 = lab[2];
      let h2;
      const hr2 = Math.atan2(b2, a2);
      h2 = hr2 * 360 / 2 / Math.PI;
      if (h2 < 0) {
        h2 += 360;
      }
      const c2 = Math.sqrt(a2 * a2 + b2 * b2);
      return [l2, c2, h2];
    };
    convert$1.lch.lab = function(lch) {
      const l2 = lch[0];
      const c2 = lch[1];
      const h2 = lch[2];
      const hr2 = h2 / 360 * 2 * Math.PI;
      const a2 = c2 * Math.cos(hr2);
      const b2 = c2 * Math.sin(hr2);
      return [l2, a2, b2];
    };
    convert$1.rgb.ansi16 = function(args, saturation = null) {
      const [r2, g2, b2] = args;
      let value = saturation === null ? convert$1.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b2 / 255) << 2 | Math.round(g2 / 255) << 1 | Math.round(r2 / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert$1.hsv.ansi16 = function(args) {
      return convert$1.rgb.ansi16(convert$1.hsv.rgb(args), args[2]);
    };
    convert$1.rgb.ansi256 = function(args) {
      const r2 = args[0];
      const g2 = args[1];
      const b2 = args[2];
      if (r2 === g2 && g2 === b2) {
        if (r2 < 8) {
          return 16;
        }
        if (r2 > 248) {
          return 231;
        }
        return Math.round((r2 - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r2 / 255 * 5) + 6 * Math.round(g2 / 255 * 5) + Math.round(b2 / 255 * 5);
      return ansi;
    };
    convert$1.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r2 = (color & 1) * mult * 255;
      const g2 = (color >> 1 & 1) * mult * 255;
      const b2 = (color >> 2 & 1) * mult * 255;
      return [r2, g2, b2];
    };
    convert$1.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c2 = (args - 232) * 10 + 8;
        return [c2, c2, c2];
      }
      args -= 16;
      let rem;
      const r2 = Math.floor(args / 36) / 5 * 255;
      const g2 = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b2 = rem % 6 / 5 * 255;
      return [r2, g2, b2];
    };
    convert$1.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string2 = integer.toString(16).toUpperCase();
      return "000000".substring(string2.length) + string2;
    };
    convert$1.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r2 = integer >> 16 & 255;
      const g2 = integer >> 8 & 255;
      const b2 = integer & 255;
      return [r2, g2, b2];
    };
    convert$1.rgb.hcg = function(rgb) {
      const r2 = rgb[0] / 255;
      const g2 = rgb[1] / 255;
      const b2 = rgb[2] / 255;
      const max2 = Math.max(Math.max(r2, g2), b2);
      const min2 = Math.min(Math.min(r2, g2), b2);
      const chroma = max2 - min2;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min2 / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max2 === r2) {
        hue = (g2 - b2) / chroma % 6;
      } else if (max2 === g2) {
        hue = 2 + (b2 - r2) / chroma;
      } else {
        hue = 4 + (r2 - g2) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert$1.hsl.hcg = function(hsl) {
      const s2 = hsl[1] / 100;
      const l2 = hsl[2] / 100;
      const c2 = l2 < 0.5 ? 2 * s2 * l2 : 2 * s2 * (1 - l2);
      let f2 = 0;
      if (c2 < 1) {
        f2 = (l2 - 0.5 * c2) / (1 - c2);
      }
      return [hsl[0], c2 * 100, f2 * 100];
    };
    convert$1.hsv.hcg = function(hsv) {
      const s2 = hsv[1] / 100;
      const v2 = hsv[2] / 100;
      const c2 = s2 * v2;
      let f2 = 0;
      if (c2 < 1) {
        f2 = (v2 - c2) / (1 - c2);
      }
      return [hsv[0], c2 * 100, f2 * 100];
    };
    convert$1.hcg.rgb = function(hcg) {
      const h2 = hcg[0] / 360;
      const c2 = hcg[1] / 100;
      const g2 = hcg[2] / 100;
      if (c2 === 0) {
        return [g2 * 255, g2 * 255, g2 * 255];
      }
      const pure = [0, 0, 0];
      const hi = h2 % 1 * 6;
      const v2 = hi % 1;
      const w2 = 1 - v2;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v2;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w2;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v2;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w2;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v2;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w2;
      }
      mg = (1 - c2) * g2;
      return [
        (c2 * pure[0] + mg) * 255,
        (c2 * pure[1] + mg) * 255,
        (c2 * pure[2] + mg) * 255
      ];
    };
    convert$1.hcg.hsv = function(hcg) {
      const c2 = hcg[1] / 100;
      const g2 = hcg[2] / 100;
      const v2 = c2 + g2 * (1 - c2);
      let f2 = 0;
      if (v2 > 0) {
        f2 = c2 / v2;
      }
      return [hcg[0], f2 * 100, v2 * 100];
    };
    convert$1.hcg.hsl = function(hcg) {
      const c2 = hcg[1] / 100;
      const g2 = hcg[2] / 100;
      const l2 = g2 * (1 - c2) + 0.5 * c2;
      let s2 = 0;
      if (l2 > 0 && l2 < 0.5) {
        s2 = c2 / (2 * l2);
      } else if (l2 >= 0.5 && l2 < 1) {
        s2 = c2 / (2 * (1 - l2));
      }
      return [hcg[0], s2 * 100, l2 * 100];
    };
    convert$1.hcg.hwb = function(hcg) {
      const c2 = hcg[1] / 100;
      const g2 = hcg[2] / 100;
      const v2 = c2 + g2 * (1 - c2);
      return [hcg[0], (v2 - c2) * 100, (1 - v2) * 100];
    };
    convert$1.hwb.hcg = function(hwb) {
      const w2 = hwb[1] / 100;
      const b2 = hwb[2] / 100;
      const v2 = 1 - b2;
      const c2 = v2 - w2;
      let g2 = 0;
      if (c2 < 1) {
        g2 = (v2 - c2) / (1 - c2);
      }
      return [hwb[0], c2 * 100, g2 * 100];
    };
    convert$1.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert$1.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert$1.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert$1.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert$1.gray.hsv = convert$1.gray.hsl;
    convert$1.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert$1.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert$1.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert$1.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string2 = integer.toString(16).toUpperCase();
      return "000000".substring(string2.length) + string2;
    };
    convert$1.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
    const conversions$1 = conversions$2;
    function buildGraph() {
      const graph = {};
      const models2 = Object.keys(conversions$1);
      for (let len = models2.length, i2 = 0; i2 < len; i2++) {
        graph[models2[i2]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions$1[current]);
        for (let len = adjacents.length, i2 = 0; i2 < len; i2++) {
          const adjacent = adjacents[i2];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to2) {
      return function(args) {
        return to2(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path = [graph[toModel].parent, toModel];
      let fn2 = conversions$1[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn2 = link(conversions$1[graph[cur].parent][cur], fn2);
        cur = graph[cur].parent;
      }
      fn2.conversion = path;
      return fn2;
    }
    var route$1 = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models2 = Object.keys(graph);
      for (let len = models2.length, i2 = 0; i2 < len; i2++) {
        const toModel = models2[i2];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
    const conversions = conversions$2;
    const route = route$1;
    const convert = {};
    const models = Object.keys(conversions);
    function wrapRaw(fn2) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn2(args);
      };
      if ("conversion" in fn2) {
        wrappedFn.conversion = fn2.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn2) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result2 = fn2(args);
        if (typeof result2 === "object") {
          for (let len = result2.length, i2 = 0; i2 < len; i2++) {
            result2[i2] = Math.round(result2[i2]);
          }
        }
        return result2;
      };
      if ("conversion" in fn2) {
        wrappedFn.conversion = fn2.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn2 = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn2);
        convert[fromModel][toModel].raw = wrapRaw(fn2);
      });
    });
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class ViewCollection extends Collection {
      /**
      * Creates a new instance of the {@link module:ui/viewcollection~ViewCollection}.
      *
      * @param initialItems The initial items of the collection.
      */
      constructor(initialItems = []) {
        super(initialItems, {
          // An #id Number attribute should be legal and not break the `ViewCollection` instance.
          // https://github.com/ckeditor/ckeditor5-ui/issues/93
          idProperty: "viewUid"
        });
        /**
        * A parent element within which child views are rendered and managed in DOM.
        */
        __publicField(this, "_parentElement");
        this.on("add", (evt, view, index) => {
          this._renderViewIntoCollectionParent(view, index);
        });
        this.on("remove", (evt, view) => {
          if (view.element && this._parentElement) {
            view.element.remove();
          }
        });
        this._parentElement = null;
      }
      /**
      * Destroys the view collection along with child views.
      * See the view {@link module:ui/view~View#destroy} method.
      */
      destroy() {
        this.map((view) => view.destroy());
      }
      /**
      * Sets the parent HTML element of this collection. When parent is set, {@link #add adding} and
      * {@link #remove removing} views in the collection synchronizes their
      * {@link module:ui/view~View#element elements} in the parent element.
      *
      * @param element A new parent element.
      */
      setParent(elementOrDocFragment) {
        this._parentElement = elementOrDocFragment;
        for (const view of this) {
          this._renderViewIntoCollectionParent(view);
        }
      }
      /**
      * Delegates selected events coming from within views in the collection to any
      * {@link module:utils/emittermixin~Emitter}.
      *
      * For the following views and collection:
      *
      * ```ts
      * const viewA = new View();
      * const viewB = new View();
      * const viewC = new View();
      *
      * const views = parentView.createCollection();
      *
      * views.delegate( 'eventX' ).to( viewB );
      * views.delegate( 'eventX', 'eventY' ).to( viewC );
      *
      * views.add( viewA );
      * ```
      *
      * the `eventX` is delegated (fired by) `viewB` and `viewC` along with `customData`:
      *
      * ```ts
      * viewA.fire( 'eventX', customData );
      * ```
      *
      * and `eventY` is delegated (fired by) `viewC` along with `customData`:
      *
      * ```ts
      * viewA.fire( 'eventY', customData );
      * ```
      *
      * See {@link module:utils/emittermixin~Emitter#delegate}.
      *
      * @param events {@link module:ui/view~View} event names to be delegated to another
      * {@link module:utils/emittermixin~Emitter}.
      * @returns Object with `to` property, a function which accepts the destination
      * of {@link module:utils/emittermixin~Emitter#delegate delegated} events.
      */
      delegate(...events) {
        if (!events.length || !isStringArray(events)) {
          throw new CKEditorError("ui-viewcollection-delegate-wrong-events", this);
        }
        return {
          to: (dest) => {
            for (const view of this) {
              for (const evtName of events) {
                view.delegate(evtName).to(dest);
              }
            }
            this.on("add", (evt, view) => {
              for (const evtName of events) {
                view.delegate(evtName).to(dest);
              }
            });
            this.on("remove", (evt, view) => {
              for (const evtName of events) {
                view.stopDelegating(evtName, dest);
              }
            });
          }
        };
      }
      /**
      * This method {@link module:ui/view~View#render renders} a new view added to the collection.
      *
      * If the {@link #_parentElement parent element} of the collection is set, this method also adds
      * the view's {@link module:ui/view~View#element} as a child of the parent in DOM at a specified index.
      *
      * **Note**: If index is not specified, the view's element is pushed as the last child
      * of the parent element.
      *
      * @param view A new view added to the collection.
      * @param index An index the view holds in the collection. When not specified,
      * the view is added at the end.
      */
      _renderViewIntoCollectionParent(view, index) {
        if (!view.isRendered) {
          view.render();
        }
        if (view.element && this._parentElement) {
          this._parentElement.insertBefore(view.element, this._parentElement.children[index]);
        }
      }
      /**
      * Removes a child view from the collection. If the {@link #setParent parent element} of the
      * collection has been set, the {@link module:ui/view~View#element element} of the view is also removed
      * in DOM, reflecting the order of the collection.
      *
      * See the {@link #add} method.
      *
      * @param subject The view to remove, its id or index in the collection.
      * @returns The removed view.
      */
      remove(subject) {
        return super.remove(subject);
      }
    }
    function isStringArray(arr) {
      return arr.every((a2) => typeof a2 == "string");
    }
    const xhtmlNs = "http://www.w3.org/1999/xhtml";
    class Template extends (/* @__PURE__ */ EmitterMixin()) {
      /**
      * Creates an instance of the {@link ~Template} class.
      *
      * @param def The definition of the template.
      */
      constructor(def) {
        super();
        __publicField(this, "ns");
        /**
        * The tag (`tagName`) of this template, e.g. `div`. It also indicates that the template
        * renders to an HTML element.
        */
        __publicField(this, "tag");
        /**
        * The text of the template. It also indicates that the template renders to a DOM text node.
        */
        __publicField(this, "text");
        /**
        * The attributes of the template, e.g. `{ id: [ 'ck-id' ] }`, corresponding with
        * the attributes of an HTML element.
        *
        * **Note**: This property only makes sense when {@link #tag} is defined.
        */
        __publicField(this, "attributes");
        /**
        * The children of the template. They can be either:
        * * independent instances of {@link ~Template} (subtemplates),
        * * native DOM Nodes.
        *
        * **Note**: This property only makes sense when {@link #tag} is defined.
        */
        __publicField(this, "children");
        /**
        * The DOM event listeners of the template.
        */
        __publicField(this, "eventListeners");
        /**
        * Indicates whether this particular Template instance has been
        * {@link #render rendered}.
        */
        __publicField(this, "_isRendered");
        /**
        * The data used by the {@link #revert} method to restore a node to its original state.
        *
        * See: {@link #apply}.
        */
        __publicField(this, "_revertData");
        Object.assign(this, normalize(clone(def)));
        this._isRendered = false;
        this._revertData = null;
      }
      /**
      * Renders a DOM Node (an HTML element or text) out of the template.
      *
      * ```ts
      * const domNode = new Template( { ... } ).render();
      * ```
      *
      * See: {@link #apply}.
      */
      render() {
        const node = this._renderNode({
          intoFragment: true
        });
        this._isRendered = true;
        return node;
      }
      /**
      * Applies the template to an existing DOM Node, either HTML element or text.
      *
      * **Note:** No new DOM nodes will be created. Applying extends:
      *
      * {@link module:ui/template~TemplateDefinition attributes},
      * {@link module:ui/template~TemplateDefinition event listeners}, and
      * `textContent` of {@link module:ui/template~TemplateDefinition children} only.
      *
      * **Note:** Existing `class` and `style` attributes are extended when a template
      * is applied to an HTML element, while other attributes and `textContent` are overridden.
      *
      * **Note:** The process of applying a template can be easily reverted using the
      * {@link module:ui/template~Template#revert} method.
      *
      * ```ts
      * const element = document.createElement( 'div' );
      * const observable = new Model( { divClass: 'my-div' } );
      * const emitter = Object.create( EmitterMixin );
      * const bind = Template.bind( observable, emitter );
      *
      * new Template( {
      * 	attributes: {
      * 		id: 'first-div',
      * 		class: bind.to( 'divClass' )
      * 	},
      * 	on: {
      * 		click: bind( 'elementClicked' ) // Will be fired by the observable.
      * 	},
      * 	children: [
      * 		'Div text.'
      * 	]
      * } ).apply( element );
      *
      * console.log( element.outerHTML ); // -> '<div id="first-div" class="my-div"></div>'
      * ```
      *
      * @see module:ui/template~Template#render
      * @see module:ui/template~Template#revert
      * @param node Root node for the template to apply.
      */
      apply(node) {
        this._revertData = getEmptyRevertData();
        this._renderNode({
          node,
          intoFragment: false,
          isApplying: true,
          revertData: this._revertData
        });
        return node;
      }
      /**
      * Reverts a template {@link module:ui/template~Template#apply applied} to a DOM node.
      *
      * @param node The root node for the template to revert. In most of the cases, it is the
      * same node used by {@link module:ui/template~Template#apply}.
      */
      revert(node) {
        if (!this._revertData) {
          throw new CKEditorError("ui-template-revert-not-applied", [
            this,
            node
          ]);
        }
        this._revertTemplateFromNode(node, this._revertData);
      }
      /**
      * Returns an iterator which traverses the template in search of {@link module:ui/view~View}
      * instances and returns them one by one.
      *
      * ```ts
      * const viewFoo = new View();
      * const viewBar = new View();
      * const viewBaz = new View();
      * const template = new Template( {
      * 	tag: 'div',
      * 	children: [
      * 		viewFoo,
      * 		{
      * 			tag: 'div',
      * 			children: [
      * 				viewBar
      * 			]
      * 		},
      * 		viewBaz
      * 	]
      * } );
      *
      * // Logs: viewFoo, viewBar, viewBaz
      * for ( const view of template.getViews() ) {
      * 	console.log( view );
      * }
      * ```
      */
      *getViews() {
        function* search(def) {
          if (def.children) {
            for (const child of def.children) {
              if (isView(child)) {
                yield child;
              } else if (isTemplate(child)) {
                yield* search(child);
              }
            }
          }
        }
        yield* search(this);
      }
      /**
      * An entry point to the interface which binds DOM nodes to
      * {@link module:utils/observablemixin~Observable observables}.
      * There are two types of bindings:
      *
      * * HTML element attributes or text `textContent` synchronized with attributes of an
      * {@link module:utils/observablemixin~Observable}. Learn more about {@link module:ui/template~BindChain#to}
      * and {@link module:ui/template~BindChain#if}.
      *
      * ```ts
      * const bind = Template.bind( observable, emitter );
      *
      * new Template( {
      * 	attributes: {
      * 		// Binds the element "class" attribute to observable#classAttribute.
      * 		class: bind.to( 'classAttribute' )
      * 	}
      * } ).render();
      * ```
      *
      * * DOM events fired on HTML element propagated through
      * {@link module:utils/observablemixin~Observable}. Learn more about {@link module:ui/template~BindChain#to}.
      *
      * ```ts
      * const bind = Template.bind( observable, emitter );
      *
      * new Template( {
      * 	on: {
      * 		// Will be fired by the observable.
      * 		click: bind( 'elementClicked' )
      * 	}
      * } ).render();
      * ```
      *
      * Also see {@link module:ui/view~View#bindTemplate}.
      *
      * @param observable An observable which provides boundable attributes.
      * @param emitter An emitter that listens to observable attribute
      * changes or DOM Events (depending on the kind of the binding). Usually, a {@link module:ui/view~View} instance.
      */
      static bind(observable, emitter) {
        return {
          to(eventNameOrFunctionOrAttribute, callback) {
            return new TemplateToBinding({
              eventNameOrFunction: eventNameOrFunctionOrAttribute,
              attribute: eventNameOrFunctionOrAttribute,
              observable,
              emitter,
              callback
            });
          },
          if(attribute, valueIfTrue, callback) {
            return new TemplateIfBinding({
              observable,
              emitter,
              attribute,
              valueIfTrue,
              callback
            });
          }
        };
      }
      /**
      * Extends an existing {@link module:ui/template~Template} instance with some additional content
      * from another {@link module:ui/template~TemplateDefinition}.
      *
      * ```ts
      * const bind = Template.bind( observable, emitter );
      *
      * const template = new Template( {
      * 	tag: 'p',
      * 	attributes: {
      * 		class: 'a',
      * 		data-x: bind.to( 'foo' )
      * 	},
      * 	children: [
      * 		{
      * 			tag: 'span',
      * 			attributes: {
      * 				class: 'b'
      * 			},
      * 			children: [
      * 				'Span'
      * 			]
      * 		}
      * 	]
      *  } );
      *
      * // Instance-level extension.
      * Template.extend( template, {
      * 	attributes: {
      * 		class: 'b',
      * 		data-x: bind.to( 'bar' )
      * 	},
      * 	children: [
      * 		{
      * 			attributes: {
      * 				class: 'c'
      * 			}
      * 		}
      * 	]
      * } );
      *
      * // Child extension.
      * Template.extend( template.children[ 0 ], {
      * 	attributes: {
      * 		class: 'd'
      * 	}
      * } );
      * ```
      *
      * the `outerHTML` of `template.render()` is:
      *
      * ```html
      * <p class="a b" data-x="{ observable.foo } { observable.bar }">
      * 	<span class="b c d">Span</span>
      * </p>
      * ```
      *
      * @param template An existing template instance to be extended.
      * @param def Additional definition to be applied to a template.
      */
      static extend(template2, def) {
        if (template2._isRendered) {
          throw new CKEditorError("template-extend-render", [
            this,
            template2
          ]);
        }
        extendTemplate(template2, normalize(clone(def)));
      }
      /**
      * Renders a DOM Node (either an HTML element or text) out of the template.
      *
      * @param data Rendering data.
      */
      _renderNode(data) {
        let isInvalid;
        if (data.node) {
          isInvalid = this.tag && this.text;
        } else {
          isInvalid = this.tag ? this.text : !this.text;
        }
        if (isInvalid) {
          throw new CKEditorError("ui-template-wrong-syntax", this);
        }
        if (this.text) {
          return this._renderText(data);
        } else {
          return this._renderElement(data);
        }
      }
      /**
      * Renders an HTML element out of the template.
      *
      * @param data Rendering data.
      */
      _renderElement(data) {
        let node = data.node;
        if (!node) {
          node = data.node = document.createElementNS(this.ns || xhtmlNs, this.tag);
        }
        this._renderAttributes(data);
        this._renderElementChildren(data);
        this._setUpListeners(data);
        return node;
      }
      /**
      * Renders a text node out of {@link module:ui/template~Template#text}.
      *
      * @param data Rendering data.
      */
      _renderText(data) {
        let node = data.node;
        if (node) {
          data.revertData.text = node.textContent;
        } else {
          node = data.node = document.createTextNode("");
        }
        if (hasTemplateBinding(this.text)) {
          this._bindToObservable({
            schema: this.text,
            updater: getTextUpdater(node),
            data
          });
        } else {
          node.textContent = this.text.join("");
        }
        return node;
      }
      /**
      * Renders HTML element attributes out of {@link module:ui/template~Template#attributes}.
      *
      * @param data Rendering data.
      */
      _renderAttributes(data) {
        if (!this.attributes) {
          return;
        }
        const node = data.node;
        const revertData = data.revertData;
        for (const attrName in this.attributes) {
          const domAttrValue = node.getAttribute(attrName);
          const attrValue = this.attributes[attrName];
          if (revertData) {
            revertData.attributes[attrName] = domAttrValue;
          }
          const attrNs = isNamespaced(attrValue) ? attrValue[0].ns : null;
          if (hasTemplateBinding(attrValue)) {
            const valueToBind = isNamespaced(attrValue) ? attrValue[0].value : attrValue;
            if (revertData && shouldExtend(attrName)) {
              valueToBind.unshift(domAttrValue);
            }
            this._bindToObservable({
              schema: valueToBind,
              updater: getAttributeUpdater(node, attrName, attrNs),
              data
            });
          } else if (attrName == "style" && typeof attrValue[0] !== "string") {
            this._renderStyleAttribute(attrValue[0], data);
          } else {
            if (revertData && domAttrValue && shouldExtend(attrName)) {
              attrValue.unshift(domAttrValue);
            }
            const value = attrValue.map((val) => val ? val.value || val : val).reduce((prev, next) => prev.concat(next), []).reduce(arrayValueReducer, "");
            if (!isFalsy(value)) {
              node.setAttributeNS(attrNs, attrName, value);
            }
          }
        }
      }
      /**
      * Renders the `style` attribute of an HTML element based on
      * {@link module:ui/template~Template#attributes}.
      *
      * A style attribute is an object with static values:
      *
      * ```ts
      * attributes: {
      * 	style: {
      * 		color: 'red'
      * 	}
      * }
      * ```
      *
      * or values bound to {@link module:ui/model~Model} properties:
      *
      * ```ts
      * attributes: {
      * 	style: {
      * 		color: bind.to( ... )
      * 	}
      * }
      * ```
      *
      * Note: The `style` attribute is rendered without setting the namespace. It does not seem to be
      * needed.
      *
      * @param styles Styles located in `attributes.style` of {@link module:ui/template~TemplateDefinition}.
      * @param data Rendering data.
      */
      _renderStyleAttribute(styles, data) {
        const node = data.node;
        for (const styleName in styles) {
          const styleValue = styles[styleName];
          if (hasTemplateBinding(styleValue)) {
            this._bindToObservable({
              schema: [
                styleValue
              ],
              updater: getStyleUpdater(node, styleName),
              data
            });
          } else {
            node.style[styleName] = styleValue;
          }
        }
      }
      /**
      * Recursively renders HTML element's children from {@link module:ui/template~Template#children}.
      *
      * @param data Rendering data.
      */
      _renderElementChildren(data) {
        const node = data.node;
        const container2 = data.intoFragment ? document.createDocumentFragment() : node;
        const isApplying = data.isApplying;
        let childIndex = 0;
        for (const child of this.children) {
          if (isViewCollection(child)) {
            if (!isApplying) {
              child.setParent(node);
              for (const view of child) {
                container2.appendChild(view.element);
              }
            }
          } else if (isView(child)) {
            if (!isApplying) {
              if (!child.isRendered) {
                child.render();
              }
              container2.appendChild(child.element);
            }
          } else if (isNode(child)) {
            container2.appendChild(child);
          } else {
            if (isApplying) {
              const revertData = data.revertData;
              const childRevertData = getEmptyRevertData();
              revertData.children.push(childRevertData);
              child._renderNode({
                intoFragment: false,
                node: container2.childNodes[childIndex++],
                isApplying: true,
                revertData: childRevertData
              });
            } else {
              container2.appendChild(child.render());
            }
          }
        }
        if (data.intoFragment) {
          node.appendChild(container2);
        }
      }
      /**
      * Activates `on` event listeners from the {@link module:ui/template~TemplateDefinition}
      * on an HTML element.
      *
      * @param data Rendering data.
      */
      _setUpListeners(data) {
        if (!this.eventListeners) {
          return;
        }
        for (const key in this.eventListeners) {
          const revertBindings = this.eventListeners[key].map((schemaItem) => {
            const [domEvtName, domSelector] = key.split("@");
            return schemaItem.activateDomEventListener(domEvtName, domSelector, data);
          });
          if (data.revertData) {
            data.revertData.bindings.push(revertBindings);
          }
        }
      }
      /**
      * For a given {@link module:ui/template~TemplateValueSchema} containing {@link module:ui/template~TemplateBinding}
      * activates the binding and sets its initial value.
      *
      * Note: {@link module:ui/template~TemplateValueSchema} can be for HTML element attributes or
      * text node `textContent`.
      *
      * @param options Binding options.
      * @param options.updater A function which updates the DOM (like attribute or text).
      * @param options.data Rendering data.
      */
      _bindToObservable({ schema, updater, data }) {
        const revertData = data.revertData;
        syncValueSchemaValue(schema, updater, data);
        const revertBindings = schema.filter((item) => !isFalsy(item)).filter((item) => item.observable).map((templateBinding) => templateBinding.activateAttributeListener(schema, updater, data));
        if (revertData) {
          revertData.bindings.push(revertBindings);
        }
      }
      /**
      * Reverts {@link module:ui/template~RenderData#revertData template data} from a node to
      * return it to the original state.
      *
      * @param node A node to be reverted.
      * @param revertData An object that stores information about what changes have been made by
      * {@link #apply} to the node. See {@link module:ui/template~RenderData#revertData} for more information.
      */
      _revertTemplateFromNode(node, revertData) {
        for (const binding of revertData.bindings) {
          for (const revertBinding of binding) {
            revertBinding();
          }
        }
        if (revertData.text) {
          node.textContent = revertData.text;
          return;
        }
        const element = node;
        for (const attrName in revertData.attributes) {
          const attrValue = revertData.attributes[attrName];
          if (attrValue === null) {
            element.removeAttribute(attrName);
          } else {
            element.setAttribute(attrName, attrValue);
          }
        }
        for (let i2 = 0; i2 < revertData.children.length; ++i2) {
          this._revertTemplateFromNode(element.childNodes[i2], revertData.children[i2]);
        }
      }
    }
    class TemplateBinding {
      /**
      * Creates an instance of the {@link module:ui/template~TemplateBinding} class.
      *
      * @param def The definition of the binding.
      */
      constructor(def) {
        /**
        * The name of the {@link module:ui/template~TemplateBinding#observable observed attribute}.
        */
        __publicField(this, "attribute");
        /**
        * An observable instance of the binding. It either:
        *
        * * provides the attribute with the value,
        * * or passes the event when a corresponding DOM event is fired.
        */
        __publicField(this, "observable");
        /**
        * An {@link module:utils/emittermixin~Emitter} used by the binding to:
        *
        * * listen to the attribute change in the {@link module:ui/template~TemplateBinding#observable},
        * * or listen to the event in the DOM.
        */
        __publicField(this, "emitter");
        /**
        * A custom function to process the value of the {@link module:ui/template~TemplateBinding#attribute}.
        */
        __publicField(this, "callback");
        this.attribute = def.attribute;
        this.observable = def.observable;
        this.emitter = def.emitter;
        this.callback = def.callback;
      }
      /**
      * Returns the value of the binding. It is the value of the {@link module:ui/template~TemplateBinding#attribute} in
      * {@link module:ui/template~TemplateBinding#observable}. The value may be processed by the
      * {@link module:ui/template~TemplateBinding#callback}, if such has been passed to the binding.
      *
      * @param node A native DOM node, passed to the custom {@link module:ui/template~TemplateBinding#callback}.
      * @returns The value of {@link module:ui/template~TemplateBinding#attribute} in
      * {@link module:ui/template~TemplateBinding#observable}.
      */
      getValue(node) {
        const value = this.observable[this.attribute];
        return this.callback ? this.callback(value, node) : value;
      }
      /**
      * Activates the listener which waits for changes of the {@link module:ui/template~TemplateBinding#attribute} in
      * {@link module:ui/template~TemplateBinding#observable}, then updates the DOM with the aggregated
      * value of {@link module:ui/template~TemplateValueSchema}.
      *
      * @param schema A full schema to generate an attribute or text in the DOM.
      * @param updater A DOM updater function used to update the native DOM attribute or text.
      * @param data Rendering data.
      * @returns A function to sever the listener binding.
      */
      activateAttributeListener(schema, updater, data) {
        const callback = () => syncValueSchemaValue(schema, updater, data);
        this.emitter.listenTo(this.observable, `change:${this.attribute}`, callback);
        return () => {
          this.emitter.stopListening(this.observable, `change:${this.attribute}`, callback);
        };
      }
    }
    class TemplateToBinding extends TemplateBinding {
      constructor(def) {
        super(def);
        __publicField(this, "eventNameOrFunction");
        this.eventNameOrFunction = def.eventNameOrFunction;
      }
      /**
      * Activates the listener for the native DOM event, which when fired, is propagated by
      * the {@link module:ui/template~TemplateBinding#emitter}.
      *
      * @param domEvtName The name of the native DOM event.
      * @param domSelector The selector in the DOM to filter delegated events.
      * @param data Rendering data.
      * @returns A function to sever the listener binding.
      */
      activateDomEventListener(domEvtName, domSelector, data) {
        const callback = (evt, domEvt) => {
          if (!domSelector || domEvt.target.matches(domSelector)) {
            if (typeof this.eventNameOrFunction == "function") {
              this.eventNameOrFunction(domEvt);
            } else {
              this.observable.fire(this.eventNameOrFunction, domEvt);
            }
          }
        };
        this.emitter.listenTo(data.node, domEvtName, callback);
        return () => {
          this.emitter.stopListening(data.node, domEvtName, callback);
        };
      }
    }
    class TemplateIfBinding extends TemplateBinding {
      constructor(def) {
        super(def);
        /**
        * The value of the DOM attribute or text to be set if the {@link module:ui/template~TemplateBinding#attribute} in
        * {@link module:ui/template~TemplateBinding#observable} is `true`.
        */
        __publicField(this, "valueIfTrue");
        this.valueIfTrue = def.valueIfTrue;
      }
      /**
      * @inheritDoc
      */
      getValue(node) {
        const value = super.getValue(node);
        return isFalsy(value) ? false : this.valueIfTrue || true;
      }
    }
    function hasTemplateBinding(schema) {
      if (!schema) {
        return false;
      }
      if (schema.value) {
        schema = schema.value;
      }
      if (Array.isArray(schema)) {
        return schema.some(hasTemplateBinding);
      } else if (schema instanceof TemplateBinding) {
        return true;
      }
      return false;
    }
    function getValueSchemaValue(schema, node) {
      return schema.map((schemaItem) => {
        if (schemaItem instanceof TemplateBinding) {
          return schemaItem.getValue(node);
        }
        return schemaItem;
      });
    }
    function syncValueSchemaValue(schema, updater, { node }) {
      const values2 = getValueSchemaValue(schema, node);
      let value;
      if (schema.length == 1 && schema[0] instanceof TemplateIfBinding) {
        value = values2[0];
      } else {
        value = values2.reduce(arrayValueReducer, "");
      }
      if (isFalsy(value)) {
        updater.remove();
      } else {
        updater.set(value);
      }
    }
    function getTextUpdater(node) {
      return {
        set(value) {
          node.textContent = value;
        },
        remove() {
          node.textContent = "";
        }
      };
    }
    function getAttributeUpdater(el, attrName, ns) {
      return {
        set(value) {
          el.setAttributeNS(ns, attrName, value);
        },
        remove() {
          el.removeAttributeNS(ns, attrName);
        }
      };
    }
    function getStyleUpdater(el, styleName) {
      return {
        set(value) {
          el.style[styleName] = value;
        },
        remove() {
          el.style[styleName] = null;
        }
      };
    }
    function clone(def) {
      const clone2 = cloneDeepWith(def, (value) => {
        if (value && (value instanceof TemplateBinding || isTemplate(value) || isView(value) || isViewCollection(value))) {
          return value;
        }
      });
      return clone2;
    }
    function normalize(def) {
      if (typeof def == "string") {
        def = normalizePlainTextDefinition(def);
      } else if (def.text) {
        normalizeTextDefinition(def);
      }
      if (def.on) {
        def.eventListeners = normalizeListeners(def.on);
        delete def.on;
      }
      if (!def.text) {
        if (def.attributes) {
          normalizeAttributes(def.attributes);
        }
        const children = [];
        if (def.children) {
          if (isViewCollection(def.children)) {
            children.push(def.children);
          } else {
            for (const child of def.children) {
              if (isTemplate(child) || isView(child) || isNode(child)) {
                children.push(child);
              } else {
                children.push(new Template(child));
              }
            }
          }
        }
        def.children = children;
      }
      return def;
    }
    function normalizeAttributes(attributes) {
      for (const a2 in attributes) {
        if (attributes[a2].value) {
          attributes[a2].value = toArray$2(attributes[a2].value);
        }
        arrayify(attributes, a2);
      }
    }
    function normalizeListeners(listeners) {
      for (const l2 in listeners) {
        arrayify(listeners, l2);
      }
      return listeners;
    }
    function normalizePlainTextDefinition(def) {
      return {
        text: [
          def
        ]
      };
    }
    function normalizeTextDefinition(def) {
      def.text = toArray$2(def.text);
    }
    function arrayify(obj, key) {
      obj[key] = toArray$2(obj[key]);
    }
    function arrayValueReducer(prev, cur) {
      if (isFalsy(cur)) {
        return prev;
      } else if (isFalsy(prev)) {
        return cur;
      } else {
        return `${prev} ${cur}`;
      }
    }
    function extendObjectValueArray(obj, ext) {
      for (const a2 in ext) {
        if (obj[a2]) {
          obj[a2].push(...ext[a2]);
        } else {
          obj[a2] = ext[a2];
        }
      }
    }
    function extendTemplate(template2, def) {
      if (def.attributes) {
        if (!template2.attributes) {
          template2.attributes = {};
        }
        extendObjectValueArray(template2.attributes, def.attributes);
      }
      if (def.eventListeners) {
        if (!template2.eventListeners) {
          template2.eventListeners = {};
        }
        extendObjectValueArray(template2.eventListeners, def.eventListeners);
      }
      if (def.text) {
        template2.text.push(...def.text);
      }
      if (def.children && def.children.length) {
        if (template2.children.length != def.children.length) {
          throw new CKEditorError("ui-template-extend-children-mismatch", template2);
        }
        let childIndex = 0;
        for (const childDef of def.children) {
          extendTemplate(template2.children[childIndex++], childDef);
        }
      }
    }
    function isFalsy(value) {
      return !value && value !== 0;
    }
    function isView(item) {
      return item instanceof View;
    }
    function isTemplate(item) {
      return item instanceof Template;
    }
    function isViewCollection(item) {
      return item instanceof ViewCollection;
    }
    function isNamespaced(attrValue) {
      return isObject$3(attrValue[0]) && attrValue[0].ns;
    }
    function getEmptyRevertData() {
      return {
        children: [],
        bindings: [],
        attributes: {}
      };
    }
    function shouldExtend(attrName) {
      return attrName == "class" || attrName == "style";
    }
    class View extends (/* @__PURE__ */ DomEmitterMixin(/* @__PURE__ */ ObservableMixin())) {
      /**
      * Creates an instance of the {@link module:ui/view~View} class.
      *
      * Also see {@link #render}.
      *
      * @param locale The localization services instance.
      */
      constructor(locale) {
        super();
        /**
        * An HTML element of the view. `null` until {@link #render rendered}
        * from the {@link #template}.
        *
        * ```ts
        * class SampleView extends View {
        * 	constructor() {
        * 		super();
        *
        * 		// A template instance the #element will be created from.
        * 		this.setTemplate( {
        * 			tag: 'p'
        *
        * 			// ...
        * 		} );
        * 	}
        * }
        *
        * const view = new SampleView();
        *
        * // Renders the #template.
        * view.render();
        *
        * // Append the HTML element of the view to <body>.
        * document.body.appendChild( view.element );
        * ```
        *
        * **Note**: The element of the view can also be assigned directly:
        *
        * ```ts
        * view.element = document.querySelector( '#my-container' );
        * ```
        */
        __publicField(this, "element");
        /**
        * Set `true` when the view has already been {@link module:ui/view~View#render rendered}.
        *
        * @readonly
        */
        __publicField(this, "isRendered");
        /**
        * A set of tools to localize the user interface.
        *
        * Also see {@link module:core/editor/editor~Editor#locale}.
        *
        * @readonly
        */
        __publicField(this, "locale");
        /**
        * Shorthand for {@link module:utils/locale~Locale#t}.
        *
        * Note: If {@link #locale} instance hasn't been passed to the view this method may not
        * be available.
        *
        * @see module:utils/locale~Locale#t
        */
        __publicField(this, "t");
        /**
        * Template of this view. It provides the {@link #element} representing
        * the view in DOM, which is {@link #render rendered}.
        */
        __publicField(this, "template");
        /**
        * Collections registered with {@link #createCollection}.
        */
        __publicField(this, "_viewCollections");
        /**
        * A collection of view instances, which have been added directly
        * into the {@link module:ui/template~Template#children}.
        */
        __publicField(this, "_unboundChildren");
        /**
        * Cached {@link module:ui/template~BindChain bind chain} object created by the
        * {@link #template}. See {@link #bindTemplate}.
        */
        __publicField(this, "_bindTemplate");
        this.element = null;
        this.isRendered = false;
        this.locale = locale;
        this.t = locale && locale.t;
        this._viewCollections = new Collection();
        this._unboundChildren = this.createCollection();
        this._viewCollections.on("add", (evt, collection2) => {
          collection2.locale = locale;
          collection2.t = locale && locale.t;
        });
        this.decorate("render");
      }
      /**
      * Shorthand for {@link module:ui/template~Template.bind}, a binding
      * {@link module:ui/template~BindChain interface} preconfigured for the view instance.
      *
      * It provides {@link module:ui/template~BindChain#to `to()`} and
      * {@link module:ui/template~BindChain#if `if()`} methods that initialize bindings with
      * observable attributes and attach DOM listeners.
      *
      * ```ts
      * class SampleView extends View {
      * 	constructor( locale ) {
      * 		super( locale );
      *
      * 		const bind = this.bindTemplate;
      *
      * 		// These {@link module:utils/observablemixin~Observable observable} attributes will control
      * 		// the state of the view in DOM.
      * 		this.set( {
      * 			elementClass: 'foo',
      * 		 	isEnabled: true
      * 		 } );
      *
      * 		this.setTemplate( {
      * 			tag: 'p',
      *
      * 			attributes: {
      * 				// The class HTML attribute will follow elementClass
      * 				// and isEnabled view attributes.
      * 				class: [
      * 					bind.to( 'elementClass' )
      * 					bind.if( 'isEnabled', 'present-when-enabled' )
      * 				]
      * 			},
      *
      * 			on: {
      * 				// The view will fire the "clicked" event upon clicking <p> in DOM.
      * 				click: bind.to( 'clicked' )
      * 			}
      * 		} );
      * 	}
      * }
      * ```
      */
      get bindTemplate() {
        if (this._bindTemplate) {
          return this._bindTemplate;
        }
        return this._bindTemplate = Template.bind(this, this);
      }
      /**
      * Creates a new collection of views, which can be used as
      * {@link module:ui/template~Template#children} of this view.
      *
      * ```ts
      * class SampleView extends View {
      * 	constructor( locale ) {
      * 		super( locale );
      *
      * 		const child = new ChildView( locale );
      * 		this.items = this.createCollection( [ child ] );
       *
      * 		this.setTemplate( {
      * 			tag: 'p',
      *
      * 			// `items` collection will render here.
      * 			children: this.items
      * 		} );
      * 	}
      * }
      *
      * const view = new SampleView( locale );
      * view.render();
      *
      * // It will append <p><child#element></p> to the <body>.
      * document.body.appendChild( view.element );
      * ```
      *
      * @param views Initial views of the collection.
      * @returns A new collection of view instances.
      */
      createCollection(views) {
        const collection2 = new ViewCollection(views);
        this._viewCollections.add(collection2);
        return collection2;
      }
      /**
      * Registers a new child view under the view instance. Once registered, a child
      * view is managed by its parent, including {@link #render rendering}
      * and {@link #destroy destruction}.
      *
      * To revert this, use {@link #deregisterChild}.
      *
      * ```ts
      * class SampleView extends View {
      * 	constructor( locale ) {
      * 		super( locale );
      *
      * 		this.childA = new SomeChildView( locale );
      * 		this.childB = new SomeChildView( locale );
      *
      * 		this.setTemplate( { tag: 'p' } );
      *
      * 		// Register the children.
      * 		this.registerChild( [ this.childA, this.childB ] );
      * 	}
      *
      * 	render() {
      * 		super.render();
      *
      * 		this.element.appendChild( this.childA.element );
      * 		this.element.appendChild( this.childB.element );
      * 	}
      * }
      *
      * const view = new SampleView( locale );
      *
      * view.render();
      *
      * // Will append <p><childA#element><b></b><childB#element></p>.
      * document.body.appendChild( view.element );
      * ```
      *
      * **Note**: There's no need to add child views if they're already referenced in the
      * {@link #template}:
      *
      * ```ts
      * class SampleView extends View {
      * 	constructor( locale ) {
      * 		super( locale );
      *
      * 		this.childA = new SomeChildView( locale );
      * 		this.childB = new SomeChildView( locale );
      *
      * 		this.setTemplate( {
      * 			tag: 'p',
      *
       * 			// These children will be added automatically. There's no
       * 			// need to call {@link #registerChild} for any of them.
      * 			children: [ this.childA, this.childB ]
      * 		} );
      * 	}
      *
      * 	// ...
      * }
      * ```
      *
      * @param children Children views to be registered.
      */
      registerChild(children) {
        if (!isIterable(children)) {
          children = [
            children
          ];
        }
        for (const child of children) {
          this._unboundChildren.add(child);
        }
      }
      /**
      * The opposite of {@link #registerChild}. Removes a child view from this view instance.
      * Once removed, the child is no longer managed by its parent, e.g. it can safely
      * become a child of another parent view.
      *
      * @see #registerChild
      * @param children Child views to be removed.
      */
      deregisterChild(children) {
        if (!isIterable(children)) {
          children = [
            children
          ];
        }
        for (const child of children) {
          this._unboundChildren.remove(child);
        }
      }
      /**
      * Sets the {@link #template} of the view with with given definition.
      *
      * A shorthand for:
      *
      * ```ts
      * view.setTemplate( definition );
      * ```
      *
      * @param definition Definition of view's template.
      */
      setTemplate(definition) {
        this.template = new Template(definition);
      }
      /**
      * {@link module:ui/template~Template.extend Extends} the {@link #template} of the view with
      * with given definition.
      *
      * A shorthand for:
      *
      * ```ts
      * Template.extend( view.template, definition );
      * ```
      *
      * **Note**: Is requires the {@link #template} to be already set. See {@link #setTemplate}.
      *
      * @param definition Definition which extends the {@link #template}.
      */
      extendTemplate(definition) {
        Template.extend(this.template, definition);
      }
      /**
      * Recursively renders the view.
      *
      * Once the view is rendered:
      * * the {@link #element} becomes an HTML element out of {@link #template},
      * * the {@link #isRendered} flag is set `true`.
      *
      * **Note**: The children of the view:
      * * defined directly in the {@link #template}
      * * residing in collections created by the {@link #createCollection} method,
      * * and added by {@link #registerChild}
      * are also rendered in the process.
      *
      * In general, `render()` method is the right place to keep the code which refers to the
      * {@link #element} and should be executed at the very beginning of the view's life cycle.
      *
      * It is possible to {@link module:ui/template~Template.extend} the {@link #template} before
      * the view is rendered. To allow an early customization of the view (e.g. by its parent),
      * such references should be done in `render()`.
      *
      * ```ts
      * class SampleView extends View {
      * 	constructor() {
      * 		this.setTemplate( {
      * 			// ...
      * 		} );
      * 	},
      *
      * 	render() {
      * 		// View#element becomes available.
      * 		super.render();
      *
      * 		// The "scroll" listener depends on #element.
      * 		this.listenTo( window, 'scroll', () => {
      * 			// A reference to #element would render the #template and make it non-extendable.
      * 			if ( window.scrollY > 0 ) {
      * 				this.element.scrollLeft = 100;
      * 			} else {
      * 				this.element.scrollLeft = 0;
      * 			}
      * 		} );
      * 	}
      * }
      *
      * const view = new SampleView();
      *
      * // Let's customize the view before it gets rendered.
      * view.extendTemplate( {
      * 	attributes: {
      * 		class: [
      * 			'additional-class'
      * 		]
      * 	}
      * } );
      *
      * // Late rendering allows customization of the view.
      * view.render();
      * ```
      */
      render() {
        if (this.isRendered) {
          throw new CKEditorError("ui-view-render-already-rendered", this);
        }
        if (this.template) {
          this.element = this.template.render();
          this.registerChild(this.template.getViews());
        }
        this.isRendered = true;
      }
      /**
      * Recursively destroys the view instance and child views added by {@link #registerChild} and
      * residing in collections created by the {@link #createCollection}.
      *
      * Destruction disables all event listeners:
      * * created on the view, e.g. `view.on( 'event', () => {} )`,
      * * defined in the {@link #template} for DOM events.
      */
      destroy() {
        this.stopListening();
        this._viewCollections.map((c2) => c2.destroy());
        if (this.template && this.template._revertData) {
          this.template.revert(this.element);
        }
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function clickOutsideHandler({ emitter, activator, callback, contextElements, listenerOptions }) {
      emitter.listenTo(document, "mousedown", (evt, domEvt) => {
        if (!activator()) {
          return;
        }
        const path = typeof domEvt.composedPath == "function" ? domEvt.composedPath() : [];
        const contextElementsList = typeof contextElements == "function" ? contextElements() : contextElements;
        for (const contextElement of contextElementsList) {
          if (contextElement.contains(domEvt.target) || path.includes(contextElement)) {
            return;
          }
        }
        callback();
      }, listenerOptions);
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function CssTransitionDisablerMixin(view) {
      class Mixin extends view {
        disableCssTransitions() {
          this._isCssTransitionsDisabled = true;
        }
        enableCssTransitions() {
          this._isCssTransitionsDisabled = false;
        }
        constructor(...args) {
          super(...args);
          this.set("_isCssTransitionsDisabled", false);
          this.initializeCssTransitionDisablerMixin();
        }
        initializeCssTransitionDisablerMixin() {
          this.extendTemplate({
            attributes: {
              class: [
                this.bindTemplate.if("_isCssTransitionsDisabled", "ck-transitions-disabled")
              ]
            }
          });
        }
      }
      return Mixin;
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function submitHandler({ view }) {
      view.listenTo(view.element, "submit", (evt, domEvt) => {
        domEvt.preventDefault();
        view.fire("submit");
      }, {
        useCapture: true
      });
    }
    const _IconView = class _IconView extends View {
      /**
      * @inheritDoc
      */
      constructor() {
        super();
        const bind2 = this.bindTemplate;
        this.set("content", "");
        this.set("viewBox", "0 0 20 20");
        this.set("fillColor", "");
        this.set("isColorInherited", true);
        this.set("isVisible", true);
        this.setTemplate({
          tag: "svg",
          ns: "http://www.w3.org/2000/svg",
          attributes: {
            class: [
              "ck",
              "ck-icon",
              bind2.if("isVisible", "ck-hidden", (value) => !value),
              // Exclude icon internals from the CSS reset to allow rich (non-monochromatic) icons
              // (https://github.com/ckeditor/ckeditor5/issues/12599).
              "ck-reset_all-excluded",
              // The class to remove the dynamic color inheritance is toggleable
              // (https://github.com/ckeditor/ckeditor5/issues/12599).
              bind2.if("isColorInherited", "ck-icon_inherit-color")
            ],
            viewBox: bind2.to("viewBox")
          }
        });
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        this._updateXMLContent();
        this._colorFillPaths();
        this.on("change:content", () => {
          this._updateXMLContent();
          this._colorFillPaths();
        });
        this.on("change:fillColor", () => {
          this._colorFillPaths();
        });
      }
      /**
      * Updates the {@link #element} with the value of {@link #content}.
      */
      _updateXMLContent() {
        if (this.content) {
          const parsed = new DOMParser().parseFromString(this.content.trim(), "image/svg+xml");
          const svg = parsed.querySelector("svg");
          const viewBox = svg.getAttribute("viewBox");
          if (viewBox) {
            this.viewBox = viewBox;
          }
          for (const { name, value } of Array.from(svg.attributes)) {
            if (_IconView.presentationalAttributeNames.includes(name)) {
              this.element.setAttribute(name, value);
            }
          }
          while (this.element.firstChild) {
            this.element.removeChild(this.element.firstChild);
          }
          while (svg.childNodes.length > 0) {
            this.element.appendChild(svg.childNodes[0]);
          }
        }
      }
      /**
      * Fills all child `path.ck-icon__fill` with the `#fillColor`.
      */
      _colorFillPaths() {
        if (this.fillColor) {
          this.element.querySelectorAll(".ck-icon__fill").forEach((path) => {
            path.style.fill = this.fillColor;
          });
        }
      }
    };
    /**
    * A list of presentational attributes that can be set on the `<svg>` element and should be preserved
    * when the icon {@link module:ui/icon/iconview~IconView#content content} is loaded.
    *
    * See the [specification](https://www.w3.org/TR/SVG/styling.html#TermPresentationAttribute) to learn more.
    */
    __publicField(_IconView, "presentationalAttributeNames", [
      "alignment-baseline",
      "baseline-shift",
      "clip-path",
      "clip-rule",
      "color",
      "color-interpolation",
      "color-interpolation-filters",
      "color-rendering",
      "cursor",
      "direction",
      "display",
      "dominant-baseline",
      "fill",
      "fill-opacity",
      "fill-rule",
      "filter",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "mask",
      "opacity",
      "overflow",
      "paint-order",
      "pointer-events",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "stroke",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-overflow",
      "text-rendering",
      "transform",
      "unicode-bidi",
      "vector-effect",
      "visibility",
      "white-space",
      "word-spacing",
      "writing-mode"
    ]);
    let IconView = _IconView;
    class ButtonLabelView extends View {
      /**
      * @inheritDoc
      */
      constructor() {
        super();
        this.set({
          style: void 0,
          text: void 0,
          id: void 0
        });
        const bind2 = this.bindTemplate;
        this.setTemplate({
          tag: "span",
          attributes: {
            class: [
              "ck",
              "ck-button__label"
            ],
            style: bind2.to("style"),
            id: bind2.to("id")
          },
          children: [
            {
              text: bind2.to("text")
            }
          ]
        });
      }
    }
    class ButtonView extends View {
      /**
      * Creates an instance of the button view class.
      *
      * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
      * @param labelView The instance of the button's label. If not provided, an instance of
      * {@link module:ui/button/buttonlabelview~ButtonLabelView} is used.
      */
      constructor(locale, labelView = new ButtonLabelView()) {
        super(locale);
        /**
        * Collection of the child views inside of the button {@link #element}.
        */
        __publicField(this, "children");
        /**
        * Label of the button view. Its text is configurable using the {@link #label label attribute}.
        *
        * If not configured otherwise in the `constructor()`, by default the label is an instance
        * of {@link module:ui/button/buttonlabelview~ButtonLabelView}.
        */
        __publicField(this, "labelView");
        /**
        * The icon view of the button. Will be added to {@link #children} when the
        * {@link #icon icon attribute} is defined.
        */
        __publicField(this, "iconView");
        /**
        * A view displaying the keystroke of the button next to the {@link #labelView label}.
        * Added to {@link #children} when the {@link #withKeystroke `withKeystroke` attribute}
        * is defined.
        */
        __publicField(this, "keystrokeView");
        /**
        * Delayed focus function for focus handling in Safari.
        */
        __publicField(this, "_focusDelayed", null);
        const bind2 = this.bindTemplate;
        const ariaLabelUid = uid();
        this.set("_ariaPressed", false);
        this.set("_ariaChecked", false);
        this.set("ariaLabel", void 0);
        this.set("ariaLabelledBy", `ck-editor__aria-label_${ariaLabelUid}`);
        this.set("class", void 0);
        this.set("labelStyle", void 0);
        this.set("icon", void 0);
        this.set("isEnabled", true);
        this.set("isOn", false);
        this.set("isVisible", true);
        this.set("isToggleable", false);
        this.set("keystroke", void 0);
        this.set("label", void 0);
        this.set("role", void 0);
        this.set("tabindex", -1);
        this.set("tooltip", false);
        this.set("tooltipPosition", "s");
        this.set("type", "button");
        this.set("withText", false);
        this.set("withKeystroke", false);
        this.children = this.createCollection();
        this.labelView = this._setupLabelView(labelView);
        this.iconView = new IconView();
        this.iconView.extendTemplate({
          attributes: {
            class: "ck-button__icon"
          }
        });
        this.keystrokeView = this._createKeystrokeView();
        this.bind("_tooltipString").to(this, "tooltip", this, "label", this, "keystroke", this._getTooltipString.bind(this));
        const template2 = {
          tag: "button",
          attributes: {
            class: [
              "ck",
              "ck-button",
              bind2.to("class"),
              bind2.if("isEnabled", "ck-disabled", (value) => !value),
              bind2.if("isVisible", "ck-hidden", (value) => !value),
              bind2.to("isOn", (value) => value ? "ck-on" : "ck-off"),
              bind2.if("withText", "ck-button_with-text"),
              bind2.if("withKeystroke", "ck-button_with-keystroke")
            ],
            role: bind2.to("role"),
            type: bind2.to("type", (value) => value ? value : "button"),
            tabindex: bind2.to("tabindex"),
            "aria-checked": bind2.to("_ariaChecked"),
            "aria-pressed": bind2.to("_ariaPressed"),
            "aria-label": bind2.to("ariaLabel"),
            "aria-labelledby": bind2.to("ariaLabelledBy"),
            "aria-disabled": bind2.if("isEnabled", true, (value) => !value),
            "data-cke-tooltip-text": bind2.to("_tooltipString"),
            "data-cke-tooltip-position": bind2.to("tooltipPosition")
          },
          children: this.children,
          on: {
            click: bind2.to((evt) => {
              if (this.isEnabled) {
                this.fire("execute");
              } else {
                evt.preventDefault();
              }
            })
          }
        };
        this.bind("_ariaPressed").to(this, "isOn", this, "isToggleable", this, "role", (isOn, isToggleable, role) => {
          if (!isToggleable || isCheckableRole(role)) {
            return false;
          }
          return String(!!isOn);
        });
        this.bind("_ariaChecked").to(this, "isOn", this, "isToggleable", this, "role", (isOn, isToggleable, role) => {
          if (!isToggleable || !isCheckableRole(role)) {
            return false;
          }
          return String(!!isOn);
        });
        if (env.isSafari) {
          if (!this._focusDelayed) {
            this._focusDelayed = delay(() => this.focus(), 0);
          }
          template2.on.mousedown = bind2.to(() => {
            this._focusDelayed();
          });
          template2.on.mouseup = bind2.to(() => {
            this._focusDelayed.cancel();
          });
        }
        this.setTemplate(template2);
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        if (this.icon) {
          this.iconView.bind("content").to(this, "icon");
          this.children.add(this.iconView);
        }
        this.children.add(this.labelView);
        if (this.withKeystroke && this.keystroke) {
          this.children.add(this.keystrokeView);
        }
      }
      /**
      * Focuses the {@link #element} of the button.
      */
      focus() {
        this.element.focus();
      }
      /**
      * @inheritDoc
      */
      destroy() {
        if (this._focusDelayed) {
          this._focusDelayed.cancel();
        }
        super.destroy();
      }
      /**
      * Binds the label view instance it with button attributes.
      */
      _setupLabelView(labelView) {
        labelView.bind("text", "style", "id").to(this, "label", "labelStyle", "ariaLabelledBy");
        return labelView;
      }
      /**
      * Creates a view that displays a keystroke next to a {@link #labelView label }
      * and binds it with button attributes.
      */
      _createKeystrokeView() {
        const keystrokeView = new View();
        keystrokeView.setTemplate({
          tag: "span",
          attributes: {
            class: [
              "ck",
              "ck-button__keystroke"
            ]
          },
          children: [
            {
              text: this.bindTemplate.to("keystroke", (text2) => getEnvKeystrokeText(text2))
            }
          ]
        });
        return keystrokeView;
      }
      /**
      * Gets the text for the tooltip from the combination of
      * {@link #tooltip}, {@link #label} and {@link #keystroke} attributes.
      *
      * @see #tooltip
      * @see #_tooltipString
      * @param tooltip Button tooltip.
      * @param label Button label.
      * @param keystroke Button keystroke.
      */
      _getTooltipString(tooltip2, label, keystroke) {
        if (tooltip2) {
          if (typeof tooltip2 == "string") {
            return tooltip2;
          } else {
            if (keystroke) {
              keystroke = getEnvKeystrokeText(keystroke);
            }
            if (tooltip2 instanceof Function) {
              return tooltip2(label, keystroke);
            } else {
              return `${label}${keystroke ? ` (${keystroke})` : ""}`;
            }
          }
        }
        return "";
      }
    }
    function isCheckableRole(role) {
      switch (role) {
        case "radio":
        case "checkbox":
        case "option":
        case "switch":
        case "menuitemcheckbox":
        case "menuitemradio":
          return true;
        default:
          return false;
      }
    }
    class FormHeaderView extends View {
      /**
      * Creates an instance of the form header class.
      *
      * @param locale The locale instance.
      * @param options.label A label.
      * @param options.class An additional class.
      */
      constructor(locale, options = {}) {
        super(locale);
        /**
        * A collection of header items.
        */
        __publicField(this, "children");
        /**
        * The icon view instance. Defined only if icon was passed in the constructor's options.
        */
        __publicField(this, "iconView");
        const bind2 = this.bindTemplate;
        this.set("label", options.label || "");
        this.set("class", options.class || null);
        this.children = this.createCollection();
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-form__header",
              bind2.to("class")
            ]
          },
          children: this.children
        });
        if (options.icon) {
          this.iconView = new IconView();
          this.iconView.content = options.icon;
          this.children.add(this.iconView);
        }
        const label = new View(locale);
        label.setTemplate({
          tag: "h2",
          attributes: {
            class: [
              "ck",
              "ck-form__header__label"
            ],
            role: "presentation"
          },
          children: [
            {
              text: bind2.to("label")
            }
          ]
        });
        this.children.add(label);
      }
    }
    class FocusCycler extends (/* @__PURE__ */ EmitterMixin()) {
      /**
      * Creates an instance of the focus cycler utility.
      *
      * @param options Configuration options.
      */
      constructor(options) {
        super();
        /**
        * A {@link module:ui/focuscycler~FocusableView focusable views} collection that the cycler operates on.
        */
        __publicField(this, "focusables");
        /**
        * A focus tracker instance that the cycler uses to determine the current focus
        * state in {@link #focusables}.
        */
        __publicField(this, "focusTracker");
        /**
        * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}
        * which can respond to certain keystrokes and cycle the focus.
        */
        __publicField(this, "keystrokeHandler");
        /**
        * Actions that the cycler can take when a keystroke is pressed. Requires
        * `options.keystrokeHandler` to be passed and working. When an action is
        * performed, `preventDefault` and `stopPropagation` will be called on the event
        * the keystroke fired in the DOM.
        *
        * ```ts
        * actions: {
        * 	// Will call #focusPrevious() when arrowleft or arrowup is pressed.
        * 	focusPrevious: [ 'arrowleft', 'arrowup' ],
        *
        * 	// Will call #focusNext() when arrowdown is pressed.
        * 	focusNext: 'arrowdown'
        * }
        * ```
        */
        __publicField(this, "actions");
        this.focusables = options.focusables;
        this.focusTracker = options.focusTracker;
        this.keystrokeHandler = options.keystrokeHandler;
        this.actions = options.actions;
        if (options.actions && options.keystrokeHandler) {
          for (const methodName in options.actions) {
            let actions = options.actions[methodName];
            if (typeof actions == "string") {
              actions = [
                actions
              ];
            }
            for (const keystroke of actions) {
              options.keystrokeHandler.set(keystroke, (data, cancel2) => {
                this[methodName]();
                cancel2();
              }, options.keystrokeHandlerOptions);
            }
          }
        }
        this.on("forwardCycle", () => this.focusFirst(), {
          priority: "low"
        });
        this.on("backwardCycle", () => this.focusLast(), {
          priority: "low"
        });
      }
      /**
      * Returns the first focusable view in {@link #focusables}.
      * Returns `null` if there is none.
      *
      * **Note**: Hidden views (e.g. with `display: none`) are ignored.
      */
      get first() {
        return this.focusables.find(isDomFocusable) || null;
      }
      /**
      * Returns the last focusable view in {@link #focusables}.
      * Returns `null` if there is none.
      *
      * **Note**: Hidden views (e.g. with `display: none`) are ignored.
      */
      get last() {
        return this.focusables.filter(isDomFocusable).slice(-1)[0] || null;
      }
      /**
      * Returns the next focusable view in {@link #focusables} based on {@link #current}.
      * Returns `null` if there is none.
      *
      * **Note**: Hidden views (e.g. with `display: none`) are ignored.
      */
      get next() {
        return this._getDomFocusableItem(1);
      }
      /**
      * Returns the previous focusable view in {@link #focusables} based on {@link #current}.
      * Returns `null` if there is none.
      *
      * **Note**: Hidden views (e.g. with `display: none`) are ignored.
      */
      get previous() {
        return this._getDomFocusableItem(-1);
      }
      /**
      * An index of the view in the {@link #focusables} which is focused according
      * to {@link #focusTracker}. Returns `null` when there is no such view.
      */
      get current() {
        let index = null;
        if (this.focusTracker.focusedElement === null) {
          return null;
        }
        this.focusables.find((view, viewIndex) => {
          const focused = view.element === this.focusTracker.focusedElement;
          if (focused) {
            index = viewIndex;
          }
          return focused;
        });
        return index;
      }
      /**
      * Focuses the {@link #first} item in {@link #focusables}.
      *
      * **Note**: Hidden views (e.g. with `display: none`) are ignored.
      */
      focusFirst() {
        this._focus(this.first, 1);
      }
      /**
      * Focuses the {@link #last} item in {@link #focusables}.
      *
      * **Note**: Hidden views (e.g. with `display: none`) are ignored.
      */
      focusLast() {
        this._focus(this.last, -1);
      }
      /**
      * Focuses the {@link #next} item in {@link #focusables}.
      *
      * **Note**: Hidden views (e.g. with `display: none`) are ignored.
      */
      focusNext() {
        const next = this.next;
        if (next && this.focusables.getIndex(next) === this.current) {
          this.fire("forwardCycle");
          return;
        }
        if (next === this.first) {
          this.fire("forwardCycle");
        } else {
          this._focus(next, 1);
        }
      }
      /**
      * Focuses the {@link #previous} item in {@link #focusables}.
      *
      * **Note**: Hidden views (e.g. with `display: none`) are ignored.
      */
      focusPrevious() {
        const previous = this.previous;
        if (previous && this.focusables.getIndex(previous) === this.current) {
          this.fire("backwardCycle");
          return;
        }
        if (previous === this.last) {
          this.fire("backwardCycle");
        } else {
          this._focus(previous, -1);
        }
      }
      /**
      * Allows for creating continuous focus cycling across multiple focus cyclers and their collections of {@link #focusables}.
      *
      * It starts listening to the {@link module:ui/focuscycler~FocusCyclerForwardCycleEvent} and
      * {@link module:ui/focuscycler~FocusCyclerBackwardCycleEvent} events of the chained focus cycler and engages,
      * whenever the user reaches the last (forwards navigation) or first (backwards navigation) focusable view
      * and would normally start over. Instead, the navigation continues on the higher level (flattens).
      *
      * For instance, for the following nested focus navigation structure, the focus would get stuck the moment
      * the AB gets focused and its focus cycler starts managing it:
      *
      *	         
      *	    AA             AB                                   AC         
      *	                                                                   
      *	                                              
      *	                    ABA  ABB  ABC                 
      *	                                         
      *	                                                                 
      *	                                                                 
      *	                                   
      *	                                                                   
      *	         
      *
      * Chaining a focus tracker that manages AA, AB, and AC with the focus tracker that manages ABA, ABB, and ABC
      * creates a seamless navigation experience instead:
      *
      *	         
      *	    AA             AB                                   AC         
      *	                                                                   
      *	                                              
      *	                    ABA  ABB  ABC                  
      *	                                
      *	                                                                    
      *	                                                                    
      *	                                                                    
      *	                                                                    
      *	          
      *	                                                                          
      *	                                                                          
      *	
      *
      * See {@link #unchain} to reverse the chaining.
      */
      chain(chainedFocusCycler) {
        const getCurrentFocusedView = () => {
          if (this.current === null) {
            return null;
          }
          return this.focusables.get(this.current);
        };
        this.listenTo(chainedFocusCycler, "forwardCycle", (evt) => {
          const oldCurrent = getCurrentFocusedView();
          this.focusNext();
          if (oldCurrent !== getCurrentFocusedView()) {
            evt.stop();
          }
        }, {
          priority: "low"
        });
        this.listenTo(chainedFocusCycler, "backwardCycle", (evt) => {
          const oldCurrent = getCurrentFocusedView();
          this.focusPrevious();
          if (oldCurrent !== getCurrentFocusedView()) {
            evt.stop();
          }
        }, {
          priority: "low"
        });
      }
      /**
      * Reverses a chaining made by {@link #chain}.
      */
      unchain(otherFocusCycler) {
        this.stopListening(otherFocusCycler);
      }
      /**
      * Focuses the given view if it exists.
      *
      * @param view The view to be focused
      * @param direction The direction of the focus if the view has focusable children.
      * @returns
      */
      _focus(view, direction) {
        if (view && this.focusTracker.focusedElement !== view.element) {
          view.focus(direction);
        }
      }
      /**
      * Returns the next or previous focusable view in {@link #focusables} with respect
      * to {@link #current}.
      *
      * @param step Either `1` for checking forward from {@link #current} or `-1` for checking backwards.
      */
      _getDomFocusableItem(step) {
        const collectionLength = this.focusables.length;
        if (!collectionLength) {
          return null;
        }
        const current = this.current;
        if (current === null) {
          return this[step === 1 ? "first" : "last"];
        }
        let focusableItem = this.focusables.get(current);
        let index = (current + collectionLength + step) % collectionLength;
        do {
          const focusableItemCandidate = this.focusables.get(index);
          if (isDomFocusable(focusableItemCandidate)) {
            focusableItem = focusableItemCandidate;
            break;
          }
          index = (index + collectionLength + step) % collectionLength;
        } while (index !== current);
        return focusableItem;
      }
    }
    function isDomFocusable(view) {
      return isFocusable(view) && isVisible(view.element);
    }
    function isFocusable(view) {
      return !!("focus" in view && typeof view.focus == "function");
    }
    function isViewWithFocusCycler(view) {
      return isFocusable(view) && "focusCycler" in view && view.focusCycler instanceof FocusCycler;
    }
    function DraggableViewMixin(view) {
      class DraggableMixin extends view {
        /**
        * @inheritDoc
        */
        constructor(...args) {
          super(...args);
          /**
          * A bound version of {@link #_onDrag}.
          */
          __publicField(this, "_onDragBound", this._onDrag.bind(this));
          /**
          * A bound version of {@link #_onDragEnd}.
          */
          __publicField(this, "_onDragEndBound", this._onDragEnd.bind(this));
          /**
          * The last coordinates of the view. It is updated on every mouse move.
          */
          __publicField(this, "_lastDraggingCoordinates", {
            x: 0,
            y: 0
          });
          this.on("render", () => {
            this._attachListeners();
          });
          this.set("isDragging", false);
        }
        /**
        * Attaches the listeners for the drag start.
        */
        _attachListeners() {
          this.listenTo(this.element, "mousedown", this._onDragStart.bind(this));
          this.listenTo(this.element, "touchstart", this._onDragStart.bind(this));
        }
        /**
        * Attaches the listeners for the dragging and drag end.
        */
        _attachDragListeners() {
          this.listenTo(global$1.document, "mouseup", this._onDragEndBound);
          this.listenTo(global$1.document, "touchend", this._onDragEndBound);
          this.listenTo(global$1.document, "mousemove", this._onDragBound);
          this.listenTo(global$1.document, "touchmove", this._onDragBound);
        }
        /**
        * Detaches the listeners after the drag end.
        */
        _detachDragListeners() {
          this.stopListening(global$1.document, "mouseup", this._onDragEndBound);
          this.stopListening(global$1.document, "touchend", this._onDragEndBound);
          this.stopListening(global$1.document, "mousemove", this._onDragBound);
          this.stopListening(global$1.document, "touchmove", this._onDragBound);
        }
        /**
        * Starts the dragging listeners and sets the initial view coordinates.
        */
        _onDragStart(evt, domEvt) {
          if (!this._isHandleElementPressed(domEvt)) {
            return;
          }
          this._attachDragListeners();
          let x2 = 0;
          let y2 = 0;
          if (domEvt instanceof MouseEvent) {
            x2 = domEvt.clientX;
            y2 = domEvt.clientY;
          } else {
            x2 = domEvt.touches[0].clientX;
            y2 = domEvt.touches[0].clientY;
          }
          this._lastDraggingCoordinates = {
            x: x2,
            y: y2
          };
          this.isDragging = true;
        }
        /**
        * Updates the view coordinates and fires the `drag` event.
        */
        _onDrag(evt, domEvt) {
          if (!this.isDragging) {
            this._detachDragListeners();
            return;
          }
          let newX = 0;
          let newY = 0;
          if (domEvt instanceof MouseEvent) {
            newX = domEvt.clientX;
            newY = domEvt.clientY;
          } else {
            newX = domEvt.touches[0].clientX;
            newY = domEvt.touches[0].clientY;
          }
          domEvt.preventDefault();
          this.fire("drag", {
            deltaX: Math.round(newX - this._lastDraggingCoordinates.x),
            deltaY: Math.round(newY - this._lastDraggingCoordinates.y)
          });
          this._lastDraggingCoordinates = {
            x: newX,
            y: newY
          };
        }
        /**
        * Stops the dragging and detaches the listeners.
        */
        _onDragEnd() {
          this._detachDragListeners();
          this.isDragging = false;
        }
        /**
        * Checks if the drag handle element was pressed.
        */
        _isHandleElementPressed(domEvt) {
          if (!this.dragHandleElement) {
            return false;
          }
          return this.dragHandleElement === domEvt.target || domEvt.target instanceof HTMLElement && this.dragHandleElement.contains(domEvt.target);
        }
      }
      return DraggableMixin;
    }
    class DialogActionsView extends View {
      /**
      * @inheritDoc
      */
      constructor(locale) {
        super(locale);
        /**
        * A collection of button views.
        */
        __publicField(this, "children");
        /**
        * A keystroke handler instance.
        */
        __publicField(this, "keystrokes");
        /**
        * A focus cycler instance.
        */
        __publicField(this, "focusCycler");
        /**
        * A focus tracker instance.
        */
        __publicField(this, "_focusTracker");
        /**
        * A collection of focusable views.
        */
        __publicField(this, "_focusables");
        this.children = this.createCollection();
        this.keystrokes = new KeystrokeHandler();
        this._focusTracker = new FocusTracker();
        this._focusables = new ViewCollection();
        this.focusCycler = new FocusCycler({
          focusables: this._focusables,
          focusTracker: this._focusTracker,
          keystrokeHandler: this.keystrokes,
          actions: {
            // Navigate form fields backwards using the Shift + Tab keystroke.
            focusPrevious: "shift + tab",
            // Navigate form fields forwards using the Tab key.
            focusNext: "tab"
          }
        });
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-dialog__actions"
            ]
          },
          children: this.children
        });
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        this.keystrokes.listenTo(this.element);
      }
      /**
      * Creates the button views based on the given definitions.
      * Then adds them to the {@link #children} collection and to the focus cycler.
      */
      setButtons(definitions) {
        for (const definition of definitions) {
          const button = new ButtonView(this.locale);
          let property2;
          button.on("execute", () => definition.onExecute());
          if (definition.onCreate) {
            definition.onCreate(button);
          }
          for (property2 in definition) {
            if (property2 != "onExecute" && property2 != "onCreate") {
              button.set(property2, definition[property2]);
            }
          }
          this.children.add(button);
        }
        this._updateFocusCyclableItems();
      }
      /**
      * @inheritDoc
      */
      focus(direction) {
        if (direction === -1) {
          this.focusCycler.focusLast();
        } else {
          this.focusCycler.focusFirst();
        }
      }
      /**
      * Adds all elements from the {@link #children} collection to the {@link #_focusables} collection
      * and to the {@link #_focusTracker} instance.
      */
      _updateFocusCyclableItems() {
        Array.from(this.children).forEach((v2) => {
          this._focusables.add(v2);
          this._focusTracker.add(v2.element);
        });
      }
    }
    class DialogContentView extends View {
      /**
      * @inheritDoc
      */
      constructor(locale) {
        super(locale);
        /**
        * A collection of content items.
        */
        __publicField(this, "children");
        this.children = this.createCollection();
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-dialog__content"
            ]
          },
          children: this.children
        });
      }
      /**
      * Removes all the child views.
      */
      reset() {
        while (this.children.length) {
          this.children.remove(0);
        }
      }
    }
    const DialogViewPosition = {
      SCREEN_CENTER: "screen-center",
      EDITOR_CENTER: "editor-center",
      EDITOR_TOP_SIDE: "editor-top-side",
      EDITOR_TOP_CENTER: "editor-top-center",
      EDITOR_BOTTOM_CENTER: "editor-bottom-center",
      EDITOR_ABOVE_CENTER: "editor-above-center",
      EDITOR_BELOW_CENTER: "editor-below-center"
    };
    const toPx$6 = /* @__PURE__ */ toUnit("px");
    const _DialogView = class _DialogView extends (/* @__PURE__ */ DraggableViewMixin(View)) {
      /**
      * @inheritDoc
      */
      constructor(locale, { getCurrentDomRoot, getViewportOffset }) {
        super(locale);
        /**
        * A collection of the child views inside of the dialog.
        * A dialog can have 3 optional parts: header, content, and actions.
        */
        __publicField(this, "parts");
        /**
        * A header view of the dialog. It is also a drag handle of the dialog.
        */
        __publicField(this, "headerView");
        /**
        * A close button view. It is automatically added to the header view if present.
        */
        __publicField(this, "closeButtonView");
        /**
        * A view with the action buttons available to the user.
        */
        __publicField(this, "actionsView");
        /**
        * A view with the dialog content.
        */
        __publicField(this, "contentView");
        /**
        * A keystroke handler instance.
        */
        __publicField(this, "keystrokes");
        /**
        * A focus tracker instance.
        */
        __publicField(this, "focusTracker");
        /**
        * A flag indicating if the dialog was moved manually. If so, its position
        * will not be updated automatically upon window resize or document scroll.
        */
        __publicField(this, "wasMoved", false);
        /**
        * A callback returning the DOM root that requested the dialog.
        */
        __publicField(this, "_getCurrentDomRoot");
        /**
        * A callback returning the configured editor viewport offset.
        */
        __publicField(this, "_getViewportOffset");
        /**
        * The list of the focusable elements inside the dialog view.
        */
        __publicField(this, "_focusables");
        /**
        * The focus cycler instance.
        */
        __publicField(this, "_focusCycler");
        const bind2 = this.bindTemplate;
        const t2 = locale.t;
        this.set("className", "");
        this.set("ariaLabel", t2("Editor dialog"));
        this.set("isModal", false);
        this.set("position", DialogViewPosition.SCREEN_CENTER);
        this.set("_isVisible", false);
        this.set("_isTransparent", false);
        this.set("_top", 0);
        this.set("_left", 0);
        this._getCurrentDomRoot = getCurrentDomRoot;
        this._getViewportOffset = getViewportOffset;
        this.decorate("moveTo");
        this.parts = this.createCollection();
        this.keystrokes = new KeystrokeHandler();
        this.focusTracker = new FocusTracker();
        this._focusables = new ViewCollection();
        this._focusCycler = new FocusCycler({
          focusables: this._focusables,
          focusTracker: this.focusTracker,
          keystrokeHandler: this.keystrokes,
          actions: {
            // Navigate form fields backwards using the Shift + Tab keystroke.
            focusPrevious: "shift + tab",
            // Navigate form fields forwards using the Tab key.
            focusNext: "tab"
          }
        });
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-dialog-overlay",
              bind2.if("isModal", "ck-dialog-overlay__transparent", (isModal) => !isModal),
              bind2.if("_isVisible", "ck-hidden", (value) => !value)
            ],
            // Prevent from editor losing focus when clicking on the modal overlay.
            tabindex: "-1"
          },
          children: [
            {
              tag: "div",
              attributes: {
                tabindex: "-1",
                class: [
                  "ck",
                  "ck-dialog",
                  bind2.if("isModal", "ck-dialog_modal"),
                  bind2.to("className")
                ],
                role: "dialog",
                "aria-label": bind2.to("ariaLabel"),
                style: {
                  top: bind2.to("_top", (top2) => toPx$6(top2)),
                  left: bind2.to("_left", (left2) => toPx$6(left2)),
                  visibility: bind2.if("_isTransparent", "hidden")
                }
              },
              children: this.parts
            }
          ]
        });
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        this.keystrokes.set("Esc", (data, cancel2) => {
          this.fire("close", {
            source: "escKeyPress"
          });
          cancel2();
        });
        this.on("drag", (evt, { deltaX, deltaY }) => {
          this.wasMoved = true;
          this.moveBy(deltaX, deltaY);
        });
        this.listenTo(global$1.window, "resize", () => {
          if (this._isVisible && !this.wasMoved) {
            this.updatePosition();
          }
        });
        this.listenTo(global$1.document, "scroll", () => {
          if (this._isVisible && !this.wasMoved) {
            this.updatePosition();
          }
        });
        this.on("change:_isVisible", (evt, name, isVisible2) => {
          if (isVisible2) {
            this._isTransparent = true;
            setTimeout(() => {
              this.updatePosition();
              this._isTransparent = false;
              this.focus();
            }, 10);
          }
        });
        this.keystrokes.listenTo(this.element);
      }
      /**
      * Returns the element that should be used as a drag handle.
      */
      get dragHandleElement() {
        if (this.headerView && !this.isModal) {
          return this.headerView.element;
        } else {
          return null;
        }
      }
      /**
      * Creates the dialog parts. Which of them are created depends on the arguments passed to the method.
      * There are no rules regarding the dialog construction, that is, no part is mandatory.
      * Each part can only be created once.
      *
      * @internal
      */
      setupParts({ icon, title, hasCloseButton = true, content, actionButtons }) {
        if (title) {
          this.headerView = new FormHeaderView(this.locale, {
            icon
          });
          if (hasCloseButton) {
            this.closeButtonView = this._createCloseButton();
            this.headerView.children.add(this.closeButtonView);
          }
          this.headerView.label = title;
          this.ariaLabel = title;
          this.parts.add(this.headerView, 0);
        }
        if (content) {
          if (content instanceof View) {
            content = [
              content
            ];
          }
          this.contentView = new DialogContentView(this.locale);
          this.contentView.children.addMany(content);
          this.parts.add(this.contentView);
        }
        if (actionButtons) {
          this.actionsView = new DialogActionsView(this.locale);
          this.actionsView.setButtons(actionButtons);
          this.parts.add(this.actionsView);
        }
        this._updateFocusCyclableItems();
      }
      /**
      * Focuses the first focusable element inside the dialog.
      */
      focus() {
        this._focusCycler.focusFirst();
      }
      /**
      * Normalizes the passed coordinates to make sure the dialog view
      * is displayed within the visible viewport and moves it there.
      *
      * @internal
      */
      moveTo(left2, top2) {
        const viewportRect = this._getViewportRect();
        const dialogRect = this._getDialogRect();
        if (left2 + dialogRect.width > viewportRect.right) {
          left2 = viewportRect.right - dialogRect.width;
        }
        if (left2 < viewportRect.left) {
          left2 = viewportRect.left;
        }
        if (top2 < viewportRect.top) {
          top2 = viewportRect.top;
        }
        this._moveTo(left2, top2);
      }
      /**
      * Moves the dialog to the specified coordinates.
      */
      _moveTo(left2, top2) {
        this._left = left2;
        this._top = top2;
      }
      /**
      * Moves the dialog by the specified offset.
      *
      * @internal
      */
      moveBy(left2, top2) {
        this.moveTo(this._left + left2, this._top + top2);
      }
      /**
      * Moves the dialog view to the off-screen position.
      * Used when there is no space to display the dialog.
      */
      _moveOffScreen() {
        this._moveTo(-9999, -9999);
      }
      /**
      * Recalculates the dialog according to the set position and viewport,
      * and moves it to the new position.
      */
      updatePosition() {
        if (!this.element || !this.element.parentNode) {
          return;
        }
        const viewportRect = this._getViewportRect();
        let configuredPosition = this.position;
        let domRootRect;
        if (!this._getCurrentDomRoot()) {
          configuredPosition = DialogViewPosition.SCREEN_CENTER;
        } else {
          domRootRect = this._getVisibleDomRootRect(viewportRect);
        }
        const defaultOffset = _DialogView.defaultOffset;
        const dialogRect = this._getDialogRect();
        switch (configuredPosition) {
          case DialogViewPosition.EDITOR_TOP_SIDE: {
            if (domRootRect) {
              const leftCoordinate = this.locale.contentLanguageDirection === "ltr" ? domRootRect.right - dialogRect.width - defaultOffset : domRootRect.left + defaultOffset;
              this.moveTo(leftCoordinate, domRootRect.top + defaultOffset);
            } else {
              this._moveOffScreen();
            }
            break;
          }
          case DialogViewPosition.EDITOR_CENTER: {
            if (domRootRect) {
              this.moveTo(Math.round(domRootRect.left + domRootRect.width / 2 - dialogRect.width / 2), Math.round(domRootRect.top + domRootRect.height / 2 - dialogRect.height / 2));
            } else {
              this._moveOffScreen();
            }
            break;
          }
          case DialogViewPosition.SCREEN_CENTER: {
            this.moveTo(Math.round((viewportRect.width - dialogRect.width) / 2), Math.round((viewportRect.height - dialogRect.height) / 2));
            break;
          }
          case DialogViewPosition.EDITOR_TOP_CENTER: {
            if (domRootRect) {
              this.moveTo(Math.round(domRootRect.left + domRootRect.width / 2 - dialogRect.width / 2), domRootRect.top + defaultOffset);
            } else {
              this._moveOffScreen();
            }
            break;
          }
          case DialogViewPosition.EDITOR_BOTTOM_CENTER: {
            if (domRootRect) {
              this.moveTo(Math.round(domRootRect.left + domRootRect.width / 2 - dialogRect.width / 2), domRootRect.bottom - dialogRect.height - defaultOffset);
            } else {
              this._moveOffScreen();
            }
            break;
          }
          case DialogViewPosition.EDITOR_ABOVE_CENTER: {
            if (domRootRect) {
              this.moveTo(Math.round(domRootRect.left + domRootRect.width / 2 - dialogRect.width / 2), domRootRect.top - dialogRect.height - defaultOffset);
            } else {
              this._moveOffScreen();
            }
            break;
          }
          case DialogViewPosition.EDITOR_BELOW_CENTER: {
            if (domRootRect) {
              this.moveTo(Math.round(domRootRect.left + domRootRect.width / 2 - dialogRect.width / 2), domRootRect.bottom + defaultOffset);
            } else {
              this._moveOffScreen();
            }
            break;
          }
        }
      }
      /**
      * Calculates the visible DOM root part.
      */
      _getVisibleDomRootRect(viewportRect) {
        let visibleDomRootRect = new Rect(this._getCurrentDomRoot()).getVisible();
        if (!visibleDomRootRect) {
          return null;
        } else {
          visibleDomRootRect = viewportRect.getIntersection(visibleDomRootRect);
          if (!visibleDomRootRect) {
            return null;
          }
        }
        return visibleDomRootRect;
      }
      /**
      * Calculates the dialog element rect.
      */
      _getDialogRect() {
        return new Rect(this.element.firstElementChild);
      }
      /**
      * Returns a viewport `Rect` shrunk by the viewport offset config from all sides.
      *
      * TODO: This is a duplicate from position.ts module. It should either be exported there or land somewhere in utils.
      */
      _getViewportRect() {
        const viewportRect = new Rect(global$1.window);
        if (this.isModal) {
          return viewportRect;
        }
        const viewportOffset = {
          top: 0,
          bottom: 0,
          left: 0,
          right: 0,
          ...this._getViewportOffset()
        };
        viewportRect.top += viewportOffset.top;
        viewportRect.height -= viewportOffset.top;
        viewportRect.bottom -= viewportOffset.bottom;
        viewportRect.height -= viewportOffset.bottom;
        viewportRect.left += viewportOffset.left;
        viewportRect.right -= viewportOffset.right;
        viewportRect.width -= viewportOffset.left + viewportOffset.right;
        return viewportRect;
      }
      /**
      * Collects all focusable elements inside the dialog parts
      * and adds them to the focus tracker and focus cycler.
      */
      _updateFocusCyclableItems() {
        const focusables = [];
        if (this.contentView) {
          for (const child of this.contentView.children) {
            if (isFocusable(child)) {
              focusables.push(child);
            }
          }
        }
        if (this.actionsView) {
          focusables.push(this.actionsView);
        }
        if (this.closeButtonView) {
          focusables.push(this.closeButtonView);
        }
        focusables.forEach((focusable) => {
          this._focusables.add(focusable);
          this.focusTracker.add(focusable.element);
          if (isViewWithFocusCycler(focusable)) {
            this._focusCycler.chain(focusable.focusCycler);
          }
        });
      }
      /**
      * Creates the close button view that is displayed in the header view corner.
      */
      _createCloseButton() {
        const buttonView = new ButtonView(this.locale);
        const t2 = this.locale.t;
        buttonView.set({
          label: t2("Close"),
          tooltip: true,
          icon: icons.cancel
        });
        buttonView.on("execute", () => this.fire("close", {
          source: "closeButton"
        }));
        return buttonView;
      }
    };
    /**
    * A default dialog element offset from the reference element (e.g. editor editable area).
    */
    __publicField(_DialogView, "defaultOffset", 15);
    let DialogView = _DialogView;
    const _Dialog = class _Dialog extends Plugin {
      /**
      * @inheritDoc
      */
      constructor(editor2) {
        super(editor2);
        /**
        * The currently visible dialog view instance.
        */
        __publicField(this, "view");
        /**
        * A configurable callback called when the dialog is hidden.
        */
        __publicField(this, "_onHide");
        const t2 = editor2.t;
        this._initShowHideListeners();
        this._initFocusToggler();
        this._initMultiRootIntegration();
        this.set({
          id: null,
          isOpen: false
        });
        editor2.accessibility.addKeystrokeInfos({
          categoryId: "navigation",
          keystrokes: [
            {
              label: t2("Move focus in and out of an active dialog window"),
              keystroke: "Ctrl+F6",
              mayRequireFn: true
            }
          ]
        });
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "Dialog";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        this._unlockBodyScroll();
      }
      /**
      * Initiates listeners for the `show` and `hide` events emitted by this plugin.
      *
      * We could not simply decorate the {@link #show} and {@link #hide} methods to fire events,
      * because they would be fired in the wrong order &ndash; first would be `show` and then `hide`
      * (because showing the dialog actually starts with hiding the previously visible one).
      * Hence, we added private methods {@link #_show} and {@link #_hide} which are called on events
      * in the desired sequence.
      */
      _initShowHideListeners() {
        this.on("show", (evt, args) => {
          this._show(args);
        });
        this.on("show", (evt, args) => {
          if (args.onShow) {
            args.onShow(this);
          }
        }, {
          priority: "low"
        });
        this.on("hide", () => {
          if (_Dialog._visibleDialogPlugin) {
            _Dialog._visibleDialogPlugin._hide();
          }
        });
        this.on("hide", () => {
          if (this._onHide) {
            this._onHide(this);
            this._onHide = void 0;
          }
        }, {
          priority: "low"
        });
      }
      /**
      * Initiates keystroke handler for toggling the focus between the editor and the dialog view.
      */
      _initFocusToggler() {
        const editor2 = this.editor;
        editor2.keystrokes.set("Ctrl+F6", (data, cancel2) => {
          if (!this.isOpen || this.view.isModal) {
            return;
          }
          if (this.view.focusTracker.isFocused) {
            editor2.editing.view.focus();
          } else {
            this.view.focus();
          }
          cancel2();
        });
      }
      /**
      * Provides an integration between the root attaching and detaching and positioning of the view.
      */
      _initMultiRootIntegration() {
        const model = this.editor.model;
        model.document.on("change:data", () => {
          if (!this.view) {
            return;
          }
          const changedRoots = model.document.differ.getChangedRoots();
          for (const changes of changedRoots) {
            if (changes.state) {
              this.view.updatePosition();
            }
          }
        });
      }
      /**
      * Displays a dialog window.
      *
      * This method requires a {@link ~DialogDefinition} that defines the dialog's content, title, icon, action buttons, etc.
      *
      * For example, the following definition will create a dialog with:
      * * A header consisting of an icon, a title, and a "Close" button (it is added by default).
      * * A content consisting of a view with a single paragraph.
      * * A footer consisting of two buttons: "Yes" and "No".
      *
      * ```js
      * // Create the view that will be used as the dialog's content.
      * const textView = new View( locale );
      *
      * textView.setTemplate( {
      * 	tag: 'div',
      * 	attributes: {
      * 		style: {
      * 			padding: 'var(--ck-spacing-large)',
      * 			whiteSpace: 'initial',
      * 			width: '100%',
      * 			maxWidth: '500px'
      * 		},
      * 		tabindex: -1
      * 	},
      * 	children: [
      * 		'Lorem ipsum dolor sit amet...'
      * 	]
      * } );
      *
      * // Show the dialog.
      * editor.plugins.get( 'Dialog' ).show( {
      *	id: 'myDialog',
      * 	icon: 'myIcon', // This should be an SVG string.
      * 	title: 'My dialog',
      * 	content: textView,
      * 	actionButtons: [
      *		{
      *			label: t( 'Yes' ),
      *			class: 'ck-button-action',
      *			withText: true,
      *			onExecute: () => dialog.hide()
      *		},
      *		{
      *			label: t( 'No' ),
      *			withText: true,
      *			onExecute: () => dialog.hide()
      *		}
      *	]
      * } );
      * ```
      *
      * By specifying the {@link ~DialogDefinition#onShow} and {@link ~DialogDefinition#onHide} callbacks
      * it is also possible to add callbacks that will be called when the dialog is shown or hidden.
      *
      * For example, the callbacks in the following definition:
      * * Disable the default behavior of the <kbd>Esc</kbd> key.
      * * Fire a custom event when the dialog gets hidden.
      *
      * ```js
      * editor.plugins.get( 'Dialog' ).show( {
      * 	// ...
      * 	onShow: dialog => {
      * 		dialog.view.on( 'close', ( evt, data ) => {
      * 			// Only prevent the event from the "Esc" key - do not affect the other ways of closing the dialog.
      * 			if ( data.source === 'escKeyPress' ) {
      * 				evt.stop();
      * 			}
      * 		} );
      * 	},
      * 	onHide: dialog => {
      * 		dialog.fire( 'dialogDestroyed' );
      * 	}
      * } );
      * ```
      *
      * Internally, calling this method:
      * 1. Hides the currently visible dialog (if any) calling the {@link #hide} method
      * (fires the {@link ~DialogHideEvent hide event}).
      * 2. Fires the {@link ~DialogShowEvent show event} which allows for adding callbacks that customize the
      * behavior of the dialog.
      * 3. Shows the dialog.
      */
      show(dialogDefinition) {
        this.hide();
        this.fire(`show:${dialogDefinition.id}`, dialogDefinition);
      }
      /**
      * Handles creating the {@link module:ui/dialog/dialogview~DialogView} instance and making it visible.
      */
      _show({ id, icon, title, hasCloseButton = true, content, actionButtons, className, isModal, position, onHide }) {
        const editor2 = this.editor;
        this.view = new DialogView(editor2.locale, {
          getCurrentDomRoot: () => {
            return editor2.editing.view.getDomRoot(editor2.model.document.selection.anchor.root.rootName);
          },
          getViewportOffset: () => {
            return editor2.ui.viewportOffset;
          }
        });
        const view = this.view;
        view.on("close", () => {
          this.hide();
        });
        editor2.ui.view.body.add(view);
        editor2.keystrokes.listenTo(view.element);
        if (!position) {
          position = isModal ? DialogViewPosition.SCREEN_CENTER : DialogViewPosition.EDITOR_CENTER;
        }
        if (isModal) {
          this._lockBodyScroll();
        }
        view.set({
          position,
          _isVisible: true,
          className,
          isModal
        });
        view.setupParts({
          icon,
          title,
          hasCloseButton,
          content,
          actionButtons
        });
        this.id = id;
        if (onHide) {
          this._onHide = onHide;
        }
        this.isOpen = true;
        _Dialog._visibleDialogPlugin = this;
      }
      /**
      * Hides the dialog. This method is decorated to enable interacting on the {@link ~DialogHideEvent hide event}.
      *
      * See {@link #show}.
      */
      hide() {
        if (_Dialog._visibleDialogPlugin) {
          _Dialog._visibleDialogPlugin.fire(`hide:${_Dialog._visibleDialogPlugin.id}`);
        }
      }
      /**
      * Destroys the {@link module:ui/dialog/dialogview~DialogView} and cleans up the stored dialog state.
      */
      _hide() {
        if (!this.view) {
          return;
        }
        const editor2 = this.editor;
        const view = this.view;
        if (view.isModal) {
          this._unlockBodyScroll();
        }
        if (view.contentView) {
          view.contentView.reset();
        }
        editor2.ui.view.body.remove(view);
        editor2.ui.focusTracker.remove(view.element);
        editor2.keystrokes.stopListening(view.element);
        view.destroy();
        editor2.editing.view.focus();
        this.id = null;
        this.isOpen = false;
        _Dialog._visibleDialogPlugin = null;
      }
      /**
      * Makes the <body> unscrollable (e.g. when the modal shows up).
      */
      _lockBodyScroll() {
        document.documentElement.classList.add("ck-dialog-scroll-locked");
      }
      /**
      * Makes the <body> scrollable again (e.g. once the modal hides).
      */
      _unlockBodyScroll() {
        document.documentElement.classList.remove("ck-dialog-scroll-locked");
      }
    };
    /**
    * The `Dialog` plugin instance which most recently showed the dialog.
    *
    * Only one dialog can be visible at once, even if there are many editor instances on the page.
    * If an editor wants to show a dialog, it should first hide the dialog that is already opened.
    * But only the `Dialog` instance that showed the dialog is able able to properly hide it.
    * This is why we need to store it in a globally available space (static property).
    * This way every `Dialog` plugin in every editor is able to correctly close any open dialog window.
    */
    __publicField(_Dialog, "_visibleDialogPlugin");
    let Dialog = _Dialog;
    class ListItemButtonView extends ButtonView {
      /**
      * @inheritDoc
      */
      constructor(locale, labelView = new ButtonLabelView()) {
        super(locale, labelView);
        /**
        * Holds the view for the check icon of a button list item.
        */
        __publicField(this, "_checkIconHolderView", new CheckIconHolderView());
        this.set({
          hasCheckSpace: false,
          _hasCheck: this.isToggleable
        });
        const bind2 = this.bindTemplate;
        this.extendTemplate({
          attributes: {
            class: [
              "ck-list-item-button",
              bind2.if("isToggleable", "ck-list-item-button_toggleable")
            ]
          }
        });
        this.bind("_hasCheck").to(this, "hasCheckSpace", this, "isToggleable", (hasCheckSpace, isToggleable) => hasCheckSpace || isToggleable);
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        if (this._hasCheck) {
          this.children.add(this._checkIconHolderView, 0);
        }
        this._watchCheckIconHolderMount();
      }
      /**
      * Renders the check icon if the button is toggleable.
      */
      _watchCheckIconHolderMount() {
        this._checkIconHolderView.bind("isOn").to(this, "isOn", (value) => this.isToggleable && value);
        this.on("change:_hasCheck", (evt, propertyName, hasCheck) => {
          const { children, _checkIconHolderView } = this;
          if (hasCheck) {
            children.add(_checkIconHolderView, 0);
          } else {
            children.remove(_checkIconHolderView);
          }
        });
      }
    }
    class CheckIconHolderView extends View {
      /**
      * @inheritDoc
      */
      constructor() {
        super();
        /**
        * Collection of child views.
        */
        __publicField(this, "children");
        /**
        * The view for the check icon of the button list item.
        */
        __publicField(this, "_checkIconView", this._createCheckIconView());
        const bind2 = this.bindTemplate;
        this.children = this.createCollection();
        this.set("isOn", false);
        this.setTemplate({
          tag: "span",
          children: this.children,
          attributes: {
            class: [
              "ck",
              "ck-list-item-button__check-holder",
              bind2.to("isOn", (isOn) => isOn ? "ck-on" : "ck-off")
            ]
          }
        });
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        if (this.isOn) {
          this.children.add(this._checkIconView, 0);
        }
        this._watchCheckIconMount();
      }
      /**
      * Renders the check icon if the button is toggleable.
      */
      _watchCheckIconMount() {
        this.on("change:isOn", (evt, propertyName, isOn) => {
          const { children, _checkIconView } = this;
          if (isOn && !children.has(_checkIconView)) {
            children.add(_checkIconView);
          } else if (!isOn && children.has(_checkIconView)) {
            children.remove(_checkIconView);
          }
        });
      }
      /**
      * Creates a check icon view.
      */
      _createCheckIconView() {
        const iconView = new IconView();
        iconView.content = icons.check;
        iconView.extendTemplate({
          attributes: {
            class: "ck-list-item-button__check-icon"
          }
        });
        return iconView;
      }
    }
    class MenuBarMenuListItemButtonView extends ListItemButtonView {
      /**
      * Creates an instance of the menu bar list button view.
      *
      * @param locale The localization services instance.
      */
      constructor(locale) {
        super(locale);
        this.set({
          withText: true,
          withKeystroke: true,
          tooltip: false,
          role: "menuitem"
        });
        this.extendTemplate({
          attributes: {
            class: [
              "ck-menu-bar__menu__item__button"
            ]
          }
        });
      }
    }
    class LabelView extends View {
      /**
      * @inheritDoc
      */
      constructor(locale) {
        super(locale);
        /**
        * An unique id of the label. It can be used by other UI components to reference
        * the label, for instance, using the `aria-describedby` DOM attribute.
        */
        __publicField(this, "id");
        this.set("text", void 0);
        this.set("for", void 0);
        this.id = `ck-editor__label_${uid()}`;
        const bind2 = this.bindTemplate;
        this.setTemplate({
          tag: "label",
          attributes: {
            class: [
              "ck",
              "ck-label"
            ],
            id: this.id,
            for: bind2.to("for")
          },
          children: [
            {
              text: bind2.to("text")
            }
          ]
        });
      }
    }
    class AccessibilityHelpContentView extends View {
      /**
      * @inheritDoc
      */
      constructor(locale, keystrokes) {
        super(locale);
        const t2 = locale.t;
        const helpLabel = new LabelView();
        helpLabel.text = t2("Help Contents. To close this dialog press ESC.");
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-accessibility-help-dialog__content"
            ],
            "aria-labelledby": helpLabel.id,
            role: "document",
            tabindex: -1
          },
          children: [
            createElement(document, "p", {}, t2("Below, you can find a list of keyboard shortcuts that can be used in the editor.")),
            ...this._createCategories(Array.from(keystrokes.values())),
            helpLabel
          ]
        });
      }
      /**
      * @inheritDoc
      */
      focus() {
        this.element.focus();
      }
      /**
      * Creates `<section><h3>Category label</h3>...</section>` elements for each category of keystrokes.
      */
      _createCategories(categories) {
        return categories.map((categoryDefinition) => {
          const elements2 = [
            // Category header.
            createElement(document, "h3", {}, categoryDefinition.label),
            // Category definitions (<dl>) and their optional headers (<h4>).
            ...Array.from(categoryDefinition.groups.values()).map((groupDefinition) => this._createGroup(groupDefinition)).flat()
          ];
          if (categoryDefinition.description) {
            elements2.splice(1, 0, createElement(document, "p", {}, categoryDefinition.description));
          }
          return createElement(document, "section", {}, elements2);
        });
      }
      /**
      * Creates `[<h4>Optional label</h4>]<dl>...</dl>` elements for each group of keystrokes in a category.
      */
      _createGroup(groupDefinition) {
        const definitionAndDescriptionElements = groupDefinition.keystrokes.sort((a2, b2) => a2.label.localeCompare(b2.label)).map((keystrokeDefinition) => this._createGroupRow(keystrokeDefinition)).flat();
        const elements2 = [
          createElement(document, "dl", {}, definitionAndDescriptionElements)
        ];
        if (groupDefinition.label) {
          elements2.unshift(createElement(document, "h4", {}, groupDefinition.label));
        }
        return elements2;
      }
      /**
      * Creates `<dt>Keystroke label</dt><dd>Keystroke definition</dd>` elements for each keystroke in a group.
      */
      _createGroupRow(keystrokeDefinition) {
        const t2 = this.locale.t;
        const dt2 = createElement(document, "dt");
        const dd = createElement(document, "dd");
        const normalizedKeystrokeDefinition = normalizeKeystrokeDefinition(keystrokeDefinition.keystroke);
        const keystrokeAlternativeHTMLs = [];
        for (const keystrokeAlternative of normalizedKeystrokeDefinition) {
          keystrokeAlternativeHTMLs.push(keystrokeAlternative.map(keystrokeToEnvKbd).join(""));
        }
        dt2.innerHTML = keystrokeDefinition.label;
        dd.innerHTML = keystrokeAlternativeHTMLs.join(", ") + (keystrokeDefinition.mayRequireFn && env.isMac ? ` ${t2("(may require <kbd>Fn</kbd>)")}` : "");
        return [
          dt2,
          dd
        ];
      }
    }
    function keystrokeToEnvKbd(keystroke) {
      return getEnvKeystrokeText(keystroke).split("+").map((part) => `<kbd>${part}</kbd>`).join("+");
    }
    function normalizeKeystrokeDefinition(definition) {
      if (typeof definition === "string") {
        return [
          [
            definition
          ]
        ];
      }
      if (typeof definition[0] === "string") {
        return [
          definition
        ];
      }
      return definition;
    }
    var accessibilityIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 6.628a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3Z"/><path d="M8.5 9.125a.3.3 0 0 0-.253-.296L5.11 8.327a.75.75 0 1 1 .388-1.449l4.04.716c.267.072.624.08.893.009l4.066-.724a.75.75 0 1 1 .388 1.45l-3.132.5a.3.3 0 0 0-.253.296v1.357a.3.3 0 0 0 .018.102l1.615 4.438a.75.75 0 0 1-1.41.513l-1.35-3.71a.3.3 0 0 0-.281-.197h-.209a.3.3 0 0 0-.282.198l-1.35 3.711a.75.75 0 0 1-1.41-.513l1.64-4.509a.3.3 0 0 0 .019-.103V9.125Z"/><path clip-rule="evenodd" d="M10 18.5a8.5 8.5 0 1 1 0-17 8.5 8.5 0 0 1 0 17Zm0 1.5c5.523 0 10-4.477 10-10S15.523 0 10 0 0 4.477 0 10s4.477 10 10 10Z"/></svg>';
    class AccessibilityHelp extends Plugin {
      constructor() {
        super(...arguments);
        /**
        * The view that displays the dialog content (list of keystrokes).
        * Created when the dialog is opened for the first time.
        */
        __publicField(this, "contentView", null);
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          Dialog
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "AccessibilityHelp";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor2 = this.editor;
        const t2 = editor2.locale.t;
        editor2.ui.componentFactory.add("accessibilityHelp", () => {
          const button = this._createButton(ButtonView);
          button.set({
            tooltip: true,
            withText: false,
            label: t2("Accessibility help")
          });
          return button;
        });
        editor2.ui.componentFactory.add("menuBar:accessibilityHelp", () => {
          const button = this._createButton(MenuBarMenuListItemButtonView);
          button.label = t2("Accessibility");
          return button;
        });
        editor2.keystrokes.set("Alt+0", (evt, cancel2) => {
          this._toggleDialog();
          cancel2();
        });
        this._setupRootLabels();
      }
      /**
      * Creates a button to show accessibility help dialog, for use either in toolbar or in menu bar.
      */
      _createButton(ButtonClass) {
        const editor2 = this.editor;
        const dialog = editor2.plugins.get("Dialog");
        const locale = editor2.locale;
        const view = new ButtonClass(locale);
        view.set({
          keystroke: "Alt+0",
          icon: accessibilityIcon,
          isToggleable: true
        });
        view.on("execute", () => this._toggleDialog());
        view.bind("isOn").to(dialog, "id", (id) => id === "accessibilityHelp");
        return view;
      }
      /**
      * Injects a help text into each editing root's `aria-label` attribute allowing assistive technology users
      * to discover the availability of the Accessibility help dialog.
      */
      _setupRootLabels() {
        const editor2 = this.editor;
        const editingView = editor2.editing.view;
        const t2 = editor2.t;
        editor2.ui.on("ready", () => {
          editingView.change((writer) => {
            for (const root2 of editingView.document.roots) {
              addAriaLabelTextToRoot(writer, root2);
            }
          });
          editor2.on("addRoot", (evt, modelRoot) => {
            const viewRoot = editor2.editing.view.document.getRoot(modelRoot.rootName);
            editingView.change((writer) => addAriaLabelTextToRoot(writer, viewRoot));
          }, {
            priority: "low"
          });
        });
        function addAriaLabelTextToRoot(writer, viewRoot) {
          const currentAriaLabel = viewRoot.getAttribute("aria-label");
          const newAriaLabel = [
            currentAriaLabel,
            t2("Press %0 for help.", [
              getEnvKeystrokeText("Alt+0")
            ])
          ].filter((segment) => segment).join(". ");
          writer.setAttribute("aria-label", newAriaLabel, viewRoot);
        }
      }
      /**
      * Shows the accessibility help dialog. Also, creates {@link #contentView} on demand.
      */
      _toggleDialog() {
        const editor2 = this.editor;
        const dialog = editor2.plugins.get("Dialog");
        const t2 = editor2.locale.t;
        if (!this.contentView) {
          this.contentView = new AccessibilityHelpContentView(editor2.locale, editor2.accessibility.keystrokeInfos);
        }
        if (dialog.id === "accessibilityHelp") {
          dialog.hide();
        } else {
          dialog.show({
            id: "accessibilityHelp",
            className: "ck-accessibility-help-dialog",
            title: t2("Accessibility help"),
            icon: accessibilityIcon,
            hasCloseButton: true,
            content: this.contentView
          });
        }
      }
    }
    class BodyCollection extends ViewCollection {
      /**
      * Creates a new instance of the {@link module:ui/editorui/bodycollection~BodyCollection}.
      *
      * @param locale The {@link module:core/editor/editor~Editor editor's locale} instance.
      * @param initialItems The initial items of the collection.
      */
      constructor(locale, initialItems = []) {
        super(initialItems);
        /**
        * The {@link module:core/editor/editor~Editor#locale editor's locale} instance.
        * See the view {@link module:ui/view~View#locale locale} property.
        */
        __publicField(this, "locale");
        /**
        * The element holding elements of the body region.
        */
        __publicField(this, "_bodyCollectionContainer");
        this.locale = locale;
      }
      /**
      * The element holding elements of the body region.
      */
      get bodyCollectionContainer() {
        return this._bodyCollectionContainer;
      }
      /**
      * Attaches the body collection to the DOM body element. You need to execute this method to render the content of
      * the body collection.
      */
      attachToDom() {
        this._bodyCollectionContainer = new Template({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-reset_all",
              "ck-body",
              "ck-rounded-corners"
            ],
            dir: this.locale.uiLanguageDirection,
            role: "application"
          },
          children: this
        }).render();
        let wrapper = document.querySelector(".ck-body-wrapper");
        if (!wrapper) {
          wrapper = createElement(document, "div", {
            class: "ck-body-wrapper"
          });
          document.body.appendChild(wrapper);
        }
        wrapper.appendChild(this._bodyCollectionContainer);
      }
      /**
      * Detaches the collection from the DOM structure. Use this method when you do not need to use the body collection
      * anymore to clean-up the DOM structure.
      */
      detachFromDom() {
        super.destroy();
        if (this._bodyCollectionContainer) {
          this._bodyCollectionContainer.remove();
        }
        const wrapper = document.querySelector(".ck-body-wrapper");
        if (wrapper && wrapper.childElementCount == 0) {
          wrapper.remove();
        }
      }
    }
    class SwitchButtonView extends ButtonView {
      /**
      * @inheritDoc
      */
      constructor(locale) {
        super(locale);
        /**
        * The toggle switch of the button.
        */
        __publicField(this, "toggleSwitchView");
        this.isToggleable = true;
        this.toggleSwitchView = this._createToggleView();
        this.extendTemplate({
          attributes: {
            class: "ck-switchbutton"
          }
        });
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        this.children.add(this.toggleSwitchView);
      }
      /**
      * Creates a toggle child view.
      */
      _createToggleView() {
        const toggleSwitchView = new View();
        toggleSwitchView.setTemplate({
          tag: "span",
          attributes: {
            class: [
              "ck",
              "ck-button__toggle"
            ]
          },
          children: [
            {
              tag: "span",
              attributes: {
                class: [
                  "ck",
                  "ck-button__toggle__inner"
                ]
              }
            }
          ]
        });
        return toggleSwitchView;
      }
    }
    class FileDialogListItemButtonView extends (/* @__PURE__ */ FileDialogViewMixin(ListItemButtonView)) {
    }
    function FileDialogViewMixin(view) {
      class FileDialogView extends view {
        /**
        * @inheritDoc
        */
        constructor(...args) {
          super(...args);
          /**
          * The button view of the component.
          *
          * @deprecated
          */
          __publicField(this, "buttonView");
          /**
          * A hidden `<input>` view used to execute file dialog.
          */
          __publicField(this, "_fileInputView");
          this.buttonView = this;
          this._fileInputView = new FileInputView(this.locale);
          this._fileInputView.bind("acceptedType").to(this);
          this._fileInputView.bind("allowMultipleFiles").to(this);
          this._fileInputView.delegate("done").to(this);
          this.on("execute", () => {
            this._fileInputView.open();
          });
          this.extendTemplate({
            attributes: {
              class: "ck-file-dialog-button"
            }
          });
        }
        /**
        * @inheritDoc
        */
        render() {
          super.render();
          this.children.add(this._fileInputView);
        }
      }
      return FileDialogView;
    }
    class FileInputView extends View {
      /**
      * @inheritDoc
      */
      constructor(locale) {
        super(locale);
        this.set("acceptedType", void 0);
        this.set("allowMultipleFiles", false);
        const bind2 = this.bindTemplate;
        this.setTemplate({
          tag: "input",
          attributes: {
            class: [
              "ck-hidden"
            ],
            type: "file",
            tabindex: "-1",
            accept: bind2.to("acceptedType"),
            multiple: bind2.to("allowMultipleFiles")
          },
          on: {
            // Removing from code coverage since we cannot programmatically set input element files.
            change: bind2.to(
              /* istanbul ignore next -- @preserve */
              () => {
                if (this.element && this.element.files && this.element.files.length) {
                  this.fire("done", this.element.files);
                }
                this.element.value = "";
              }
            )
          }
        });
      }
      /**
      * Opens file dialog.
      */
      open() {
        this.element.click();
      }
    }
    var dropdownArrowIcon = '<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z"/></svg>';
    class LabeledFieldView extends View {
      /**
      * Creates an instance of the labeled field view class using a provided creator function
      * that provides the view to be labeled.
      *
      * @param locale The locale instance.
      * @param viewCreator A function that returns a {@link module:ui/view~View}
      * that will be labeled. The following arguments are passed to the creator function:
      *
      * * an instance of the `LabeledFieldView` to allow binding observable properties,
      * * an UID string that connects the {@link #labelView label} and the labeled field view in DOM,
      * * an UID string that connects the {@link #statusView status} and the labeled field view in DOM.
      */
      constructor(locale, viewCreator) {
        super(locale);
        /**
        * The field view that gets labeled.
        */
        __publicField(this, "fieldView");
        /**
        * The label view instance that describes the entire view.
        */
        __publicField(this, "labelView");
        /**
        * The status view for the {@link #fieldView}. It displays {@link #errorText} and
        * {@link #infoText}.
        */
        __publicField(this, "statusView");
        /**
        * A collection of children of the internal wrapper element. Allows inserting additional DOM elements (views) next to
        * the {@link #fieldView} for easy styling (e.g. positioning).
        *
        * By default, the collection contains {@link #fieldView} and {@link #labelView}.
        */
        __publicField(this, "fieldWrapperChildren");
        const viewUid = `ck-labeled-field-view-${uid()}`;
        const statusUid = `ck-labeled-field-view-status-${uid()}`;
        this.fieldView = viewCreator(this, viewUid, statusUid);
        this.set("label", void 0);
        this.set("isEnabled", true);
        this.set("isEmpty", true);
        this.set("isFocused", false);
        this.set("errorText", null);
        this.set("infoText", null);
        this.set("class", void 0);
        this.set("placeholder", void 0);
        this.labelView = this._createLabelView(viewUid);
        this.statusView = this._createStatusView(statusUid);
        this.fieldWrapperChildren = this.createCollection([
          this.fieldView,
          this.labelView
        ]);
        this.bind("_statusText").to(this, "errorText", this, "infoText", (errorText, infoText) => errorText || infoText);
        const bind2 = this.bindTemplate;
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-labeled-field-view",
              bind2.to("class"),
              bind2.if("isEnabled", "ck-disabled", (value) => !value),
              bind2.if("isEmpty", "ck-labeled-field-view_empty"),
              bind2.if("isFocused", "ck-labeled-field-view_focused"),
              bind2.if("placeholder", "ck-labeled-field-view_placeholder"),
              bind2.if("errorText", "ck-error")
            ]
          },
          children: [
            {
              tag: "div",
              attributes: {
                class: [
                  "ck",
                  "ck-labeled-field-view__input-wrapper"
                ]
              },
              children: this.fieldWrapperChildren
            },
            this.statusView
          ]
        });
      }
      /**
      * Creates label view class instance and bind with view.
      *
      * @param id Unique id to set as labelView#for attribute.
      */
      _createLabelView(id) {
        const labelView = new LabelView(this.locale);
        labelView.for = id;
        labelView.bind("text").to(this, "label");
        return labelView;
      }
      /**
      * Creates the status view instance. It displays {@link #errorText} and {@link #infoText}
      * next to the {@link #fieldView}. See {@link #_statusText}.
      *
      * @param statusUid Unique id of the status, shared with the {@link #fieldView view's}
      * `aria-describedby` attribute.
      */
      _createStatusView(statusUid) {
        const statusView = new View(this.locale);
        const bind2 = this.bindTemplate;
        statusView.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-labeled-field-view__status",
              bind2.if("errorText", "ck-labeled-field-view__status_error"),
              bind2.if("_statusText", "ck-hidden", (value) => !value)
            ],
            id: statusUid,
            role: bind2.if("errorText", "alert")
          },
          children: [
            {
              text: bind2.to("_statusText")
            }
          ]
        });
        return statusView;
      }
      /**
      * Focuses the {@link #fieldView}.
      */
      focus(direction) {
        this.fieldView.focus(direction);
      }
    }
    class InputBase extends View {
      /**
      * @inheritDoc
      */
      constructor(locale) {
        super(locale);
        /**
        * Stores information about the editor UI focus and propagates it so various plugins and components
        * are unified as a focus group.
        */
        __publicField(this, "focusTracker");
        this.set("value", void 0);
        this.set("id", void 0);
        this.set("placeholder", void 0);
        this.set("tabIndex", void 0);
        this.set("isReadOnly", false);
        this.set("hasError", false);
        this.set("ariaDescribedById", void 0);
        this.set("ariaLabel", void 0);
        this.focusTracker = new FocusTracker();
        this.bind("isFocused").to(this.focusTracker);
        this.set("isEmpty", true);
        const bind2 = this.bindTemplate;
        this.setTemplate({
          tag: "input",
          attributes: {
            class: [
              "ck",
              "ck-input",
              bind2.if("isFocused", "ck-input_focused"),
              bind2.if("isEmpty", "ck-input-text_empty"),
              bind2.if("hasError", "ck-error")
            ],
            id: bind2.to("id"),
            placeholder: bind2.to("placeholder"),
            tabindex: bind2.to("tabIndex"),
            readonly: bind2.to("isReadOnly"),
            "aria-invalid": bind2.if("hasError", true),
            "aria-describedby": bind2.to("ariaDescribedById"),
            "aria-label": bind2.to("ariaLabel")
          },
          on: {
            input: bind2.to((...args) => {
              this.fire("input", ...args);
              this._updateIsEmpty();
            }),
            change: bind2.to(this._updateIsEmpty.bind(this))
          }
        });
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        this.focusTracker.add(this.element);
        this._setDomElementValue(this.value);
        this._updateIsEmpty();
        this.on("change:value", (evt, name, value) => {
          this._setDomElementValue(value);
          this._updateIsEmpty();
        });
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        this.focusTracker.destroy();
      }
      /**
      * Moves the focus to the input and selects the value.
      */
      select() {
        this.element.select();
      }
      /**
      * Focuses the input.
      */
      focus() {
        this.element.focus();
      }
      /**
      * Resets the value of the input
      */
      reset() {
        this.value = this.element.value = "";
        this._updateIsEmpty();
      }
      /**
      * Updates the {@link #isEmpty} property value on demand.
      */
      _updateIsEmpty() {
        this.isEmpty = isInputElementEmpty(this.element);
      }
      /**
      * Sets the `value` property of the {@link #element DOM element} on demand.
      */
      _setDomElementValue(value) {
        this.element.value = !value && value !== 0 ? "" : value;
      }
    }
    function isInputElementEmpty(domElement) {
      return !domElement.value;
    }
    class InputView extends InputBase {
      /**
      * @inheritDoc
      */
      constructor(locale) {
        super(locale);
        this.set("inputMode", "text");
        const bind2 = this.bindTemplate;
        this.extendTemplate({
          attributes: {
            inputmode: bind2.to("inputMode")
          }
        });
      }
    }
    class InputTextView extends InputView {
      /**
      * @inheritDoc
      */
      constructor(locale) {
        super(locale);
        this.extendTemplate({
          attributes: {
            type: "text",
            class: [
              "ck-input-text"
            ]
          }
        });
      }
    }
    class DropdownPanelView extends View {
      /**
      * @inheritDoc
      */
      constructor(locale) {
        super(locale);
        /**
        * Collection of the child views in this panel.
        *
        * A common child type is the {@link module:ui/list/listview~ListView} and {@link module:ui/toolbar/toolbarview~ToolbarView}.
        * See {@link module:ui/dropdown/utils~addListToDropdown} and
        * {@link module:ui/dropdown/utils~addToolbarToDropdown} to learn more about child views of dropdowns.
        */
        __publicField(this, "children");
        const bind2 = this.bindTemplate;
        this.set("isVisible", false);
        this.set("position", "se");
        this.children = this.createCollection();
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-reset",
              "ck-dropdown__panel",
              bind2.to("position", (value) => `ck-dropdown__panel_${value}`),
              bind2.if("isVisible", "ck-dropdown__panel-visible")
            ],
            tabindex: "-1"
          },
          children: this.children,
          on: {
            // Drag and drop in the panel should not break the selection in the editor.
            // https://github.com/ckeditor/ckeditor5-ui/issues/228
            selectstart: bind2.to((evt) => {
              if (evt.target.tagName.toLocaleLowerCase() === "input") {
                return;
              }
              evt.preventDefault();
            })
          }
        });
      }
      /**
      * Focuses the first view in the {@link #children} collection.
      *
      * See also {@link module:ui/dropdown/dropdownpanelfocusable~DropdownPanelFocusable}.
      */
      focus() {
        if (this.children.length) {
          const firstChild = this.children.first;
          if (typeof firstChild.focus === "function") {
            firstChild.focus();
          } else {
            logWarning("ui-dropdown-panel-focus-child-missing-focus", {
              childView: this.children.first,
              dropdownPanel: this
            });
          }
        }
      }
      /**
      * Focuses the view element or last item in view collection on opening dropdown's panel.
      *
      * See also {@link module:ui/dropdown/dropdownpanelfocusable~DropdownPanelFocusable}.
      */
      focusLast() {
        if (this.children.length) {
          const lastChild = this.children.last;
          if (typeof lastChild.focusLast === "function") {
            lastChild.focusLast();
          } else {
            lastChild.focus();
          }
        }
      }
    }
    const _DropdownView = class _DropdownView extends View {
      /**
      * Creates an instance of the dropdown.
      *
      * Also see {@link #render}.
      *
      * @param locale The localization services instance.
      */
      constructor(locale, buttonView, panelView) {
        super(locale);
        /**
        * Button of the dropdown view. Clicking the button opens the {@link #panelView}.
        */
        __publicField(this, "buttonView");
        /**
        * Panel of the dropdown. It opens when the {@link #buttonView} is
        * {@link module:ui/button/button~Button#event:execute executed} (i.e. clicked).
        *
        * Child views can be added to the panel's `children` collection:
        *
        * ```ts
        * dropdown.panelView.children.add( childView );
        * ```
        *
        * See {@link module:ui/dropdown/dropdownpanelview~DropdownPanelView#children} and
        * {@link module:ui/viewcollection~ViewCollection#add}.
        */
        __publicField(this, "panelView");
        /**
        * Tracks information about the DOM focus in the dropdown.
        */
        __publicField(this, "focusTracker");
        /**
        * Instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}. It manages
        * keystrokes of the dropdown:
        *
        * * <kbd></kbd> opens the dropdown,
        * * <kbd></kbd> and <kbd>Esc</kbd> closes the dropdown.
        */
        __publicField(this, "keystrokes");
        /**
        * A child {@link module:ui/list/listview~ListView list view} of the dropdown located
        * in its {@link module:ui/dropdown/dropdownview~DropdownView#panelView panel}.
        *
        * **Note**: Only supported when dropdown has list view added using {@link module:ui/dropdown/utils~addListToDropdown}.
        */
        __publicField(this, "listView");
        /**
        * A child toolbar of the dropdown located in the
        * {@link module:ui/dropdown/dropdownview~DropdownView#panelView panel}.
        *
        * **Note**: Only supported when dropdown has a toolbar added using {@link module:ui/dropdown/utils~addToolbarToDropdown}.
        */
        __publicField(this, "toolbarView");
        /**
        * A child menu component of the dropdown located
        * in its {@link module:ui/dropdown/dropdownview~DropdownView#panelView panel}.
        *
        * **Note**: Only supported when dropdown has a menu added using {@link module:ui/dropdown/utils~addMenuToDropdown}.
        */
        __publicField(this, "menuView");
        const bind2 = this.bindTemplate;
        this.buttonView = buttonView;
        this.panelView = panelView;
        this.set("isOpen", false);
        this.set("isEnabled", true);
        this.set("class", void 0);
        this.set("id", void 0);
        this.set("panelPosition", "auto");
        this.panelView.bind("isVisible").to(this, "isOpen");
        this.keystrokes = new KeystrokeHandler();
        this.focusTracker = new FocusTracker();
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-dropdown",
              bind2.to("class"),
              bind2.if("isEnabled", "ck-disabled", (value) => !value)
            ],
            id: bind2.to("id"),
            "aria-describedby": bind2.to("ariaDescribedById")
          },
          children: [
            buttonView,
            panelView
          ]
        });
        buttonView.extendTemplate({
          attributes: {
            class: [
              "ck-dropdown__button"
            ],
            "data-cke-tooltip-disabled": bind2.to("isOpen")
          }
        });
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        this.focusTracker.add(this.buttonView.element);
        this.focusTracker.add(this.panelView.element);
        this.listenTo(this.buttonView, "open", () => {
          this.isOpen = !this.isOpen;
        });
        this.on("change:isOpen", (evt, name, isOpen) => {
          if (!isOpen) {
            return;
          }
          if (this.panelPosition === "auto") {
            const optimalPanelPosition = _DropdownView._getOptimalPosition({
              element: this.panelView.element,
              target: this.buttonView.element,
              fitInViewport: true,
              positions: this._panelPositions
            });
            this.panelView.position = optimalPanelPosition ? optimalPanelPosition.name : this._panelPositions[0].name;
          } else {
            this.panelView.position = this.panelPosition;
          }
        });
        this.keystrokes.listenTo(this.element);
        const closeDropdown = (data, cancel2) => {
          if (this.isOpen) {
            this.isOpen = false;
            cancel2();
          }
        };
        this.keystrokes.set("arrowdown", (data, cancel2) => {
          if (this.buttonView.isEnabled && !this.isOpen) {
            this.isOpen = true;
            cancel2();
          }
        });
        this.keystrokes.set("arrowright", (data, cancel2) => {
          if (this.isOpen) {
            cancel2();
          }
        });
        this.keystrokes.set("arrowleft", closeDropdown);
        this.keystrokes.set("esc", closeDropdown);
      }
      /**
      * Focuses the {@link #buttonView}.
      */
      focus() {
        this.buttonView.focus();
      }
      /**
      * Returns {@link #panelView panel} positions to be used by the
      * {@link module:utils/dom/position~getOptimalPosition `getOptimalPosition()`}
      * utility considering the direction of the language the UI of the editor is displayed in.
      */
      get _panelPositions() {
        const { south, north, southEast, southWest, northEast, northWest, southMiddleEast, southMiddleWest, northMiddleEast, northMiddleWest } = _DropdownView.defaultPanelPositions;
        if (this.locale.uiLanguageDirection !== "rtl") {
          return [
            southEast,
            southWest,
            southMiddleEast,
            southMiddleWest,
            south,
            northEast,
            northWest,
            northMiddleEast,
            northMiddleWest,
            north
          ];
        } else {
          return [
            southWest,
            southEast,
            southMiddleWest,
            southMiddleEast,
            south,
            northWest,
            northEast,
            northMiddleWest,
            northMiddleEast,
            north
          ];
        }
      }
    };
    /**
    * A set of positioning functions used by the dropdown view to determine
    * the optimal position (i.e. fitting into the browser viewport) of its
    * {@link module:ui/dropdown/dropdownview~DropdownView#panelView panel} when
    * {@link module:ui/dropdown/dropdownview~DropdownView#panelPosition} is set to 'auto'`.
    *
    * The available positioning functions are as follow:
    *
    * **South**
    *
    * * `south`
    *
    * ```
    *			[ Button ]
    *		+-----------------+
    *		|      Panel      |
    *		+-----------------+
    * ```
    *
    * * `southEast`
    *
    * ```
    *		[ Button ]
    *		+-----------------+
    *		|      Panel      |
    *		+-----------------+
    * ```
    *
    * * `southWest`
    *
    * ```
    *		         [ Button ]
    *		+-----------------+
    *		|      Panel      |
    *		+-----------------+
    * ```
    *
    * * `southMiddleEast`
    *
    * ```
    *		  [ Button ]
    *		+-----------------+
    *		|      Panel      |
    *		+-----------------+
    * ```
    *
    * * `southMiddleWest`
    *
    * ```
    *		       [ Button ]
    *		+-----------------+
    *		|      Panel      |
    *		+-----------------+
    * ```
    *
    * **North**
    *
    * * `north`
    *
    * ```
    *		+-----------------+
    *		|      Panel      |
    *		+-----------------+
    *		    [ Button ]
    * ```
    *
    * * `northEast`
    *
    * ```
    *		+-----------------+
    *		|      Panel      |
    *		+-----------------+
    *		[ Button ]
    * ```
    *
    * * `northWest`
    *
    * ```
    *		+-----------------+
    *		|      Panel      |
    *		+-----------------+
    *		         [ Button ]
    * ```
    *
    * * `northMiddleEast`
    *
    * ```
    *		+-----------------+
    *		|      Panel      |
    *		+-----------------+
    *		  [ Button ]
    * ```
    *
    * * `northMiddleWest`
    *
    * ```
    *		+-----------------+
    *		|      Panel      |
    *		+-----------------+
    *		       [ Button ]
    * ```
    *
    * Positioning functions are compatible with {@link module:utils/dom/position~DomPoint}.
    *
    * The name that position function returns will be reflected in dropdown panel's class that
    * controls its placement. See {@link module:ui/dropdown/dropdownview~DropdownView#panelPosition}
    * to learn more.
    */
    __publicField(_DropdownView, "defaultPanelPositions", {
      south: (buttonRect, panelRect) => {
        return {
          top: buttonRect.bottom,
          left: buttonRect.left - (panelRect.width - buttonRect.width) / 2,
          name: "s"
        };
      },
      southEast: (buttonRect) => {
        return {
          top: buttonRect.bottom,
          left: buttonRect.left,
          name: "se"
        };
      },
      southWest: (buttonRect, panelRect) => {
        return {
          top: buttonRect.bottom,
          left: buttonRect.left - panelRect.width + buttonRect.width,
          name: "sw"
        };
      },
      southMiddleEast: (buttonRect, panelRect) => {
        return {
          top: buttonRect.bottom,
          left: buttonRect.left - (panelRect.width - buttonRect.width) / 4,
          name: "sme"
        };
      },
      southMiddleWest: (buttonRect, panelRect) => {
        return {
          top: buttonRect.bottom,
          left: buttonRect.left - (panelRect.width - buttonRect.width) * 3 / 4,
          name: "smw"
        };
      },
      north: (buttonRect, panelRect) => {
        return {
          top: buttonRect.top - panelRect.height,
          left: buttonRect.left - (panelRect.width - buttonRect.width) / 2,
          name: "n"
        };
      },
      northEast: (buttonRect, panelRect) => {
        return {
          top: buttonRect.top - panelRect.height,
          left: buttonRect.left,
          name: "ne"
        };
      },
      northWest: (buttonRect, panelRect) => {
        return {
          top: buttonRect.top - panelRect.height,
          left: buttonRect.left - panelRect.width + buttonRect.width,
          name: "nw"
        };
      },
      northMiddleEast: (buttonRect, panelRect) => {
        return {
          top: buttonRect.top - panelRect.height,
          left: buttonRect.left - (panelRect.width - buttonRect.width) / 4,
          name: "nme"
        };
      },
      northMiddleWest: (buttonRect, panelRect) => {
        return {
          top: buttonRect.top - panelRect.height,
          left: buttonRect.left - (panelRect.width - buttonRect.width) * 3 / 4,
          name: "nmw"
        };
      }
    });
    /**
    * A function used to calculate the optimal position for the dropdown panel.
    */
    __publicField(_DropdownView, "_getOptimalPosition", getOptimalPosition);
    let DropdownView = _DropdownView;
    class DropdownButtonView extends ButtonView {
      /**
      * @inheritDoc
      */
      constructor(locale) {
        super(locale);
        /**
        * An icon that displays arrow to indicate a dropdown button.
        */
        __publicField(this, "arrowView");
        this.arrowView = this._createArrowView();
        this.extendTemplate({
          attributes: {
            "aria-haspopup": true,
            "aria-expanded": this.bindTemplate.to("isOn", (value) => String(value))
          }
        });
        this.delegate("execute").to(this, "open");
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        this.children.add(this.arrowView);
      }
      /**
      * Creates a {@link module:ui/icon/iconview~IconView} instance as {@link #arrowView}.
      */
      _createArrowView() {
        const arrowView = new IconView();
        arrowView.content = dropdownArrowIcon;
        arrowView.extendTemplate({
          attributes: {
            class: "ck-dropdown__arrow"
          }
        });
        return arrowView;
      }
    }
    class ListItemView extends View {
      /**
      * @inheritDoc
      */
      constructor(locale) {
        super(locale);
        /**
        * Collection of the child views inside of the list item {@link #element}.
        */
        __publicField(this, "children");
        const bind2 = this.bindTemplate;
        this.set("isVisible", true);
        this.children = this.createCollection();
        this.setTemplate({
          tag: "li",
          attributes: {
            class: [
              "ck",
              "ck-list__item",
              bind2.if("isVisible", "ck-hidden", (value) => !value)
            ],
            role: "presentation"
          },
          children: this.children
        });
      }
      /**
      * Focuses the list item.
      */
      focus() {
        if (this.children.first) {
          this.children.first.focus();
        }
      }
    }
    class ListSeparatorView extends View {
      /**
      * @inheritDoc
      */
      constructor(locale) {
        super(locale);
        this.setTemplate({
          tag: "li",
          attributes: {
            class: [
              "ck",
              "ck-list__separator"
            ]
          }
        });
      }
    }
    class ListItemGroupView extends View {
      /**
      * Creates an instance of the list item group view class.
      *
      * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
      * @param labelView The instance of the group's label. If not provided, an instance of
      * {@link module:ui/label/labelview~LabelView} is used.
      */
      constructor(locale, labelView = new LabelView()) {
        super(locale);
        /**
        * Label of the group view. Its text is configurable using the {@link #label label attribute}.
        *
        * If a custom label view is not passed in `ListItemGroupView` constructor, the label is an instance
        * of {@link module:ui/label/labelview~LabelView}.
        */
        __publicField(this, "labelView");
        /**
        * Collection of the child list items inside this group.
        */
        __publicField(this, "items");
        /**
        * Collection of the child elements of the group.
        */
        __publicField(this, "children");
        const bind2 = this.bindTemplate;
        const nestedList = new ListView(locale);
        this.set({
          label: "",
          isVisible: true
        });
        this.labelView = labelView;
        this.labelView.bind("text").to(this, "label");
        this.children = this.createCollection();
        this.children.addMany([
          this.labelView,
          nestedList
        ]);
        nestedList.set({
          role: "group",
          ariaLabelledBy: labelView.id
        });
        nestedList.focusTracker.destroy();
        nestedList.keystrokes.destroy();
        this.items = nestedList.items;
        this.setTemplate({
          tag: "li",
          attributes: {
            role: "presentation",
            class: [
              "ck",
              "ck-list__group",
              bind2.if("isVisible", "ck-hidden", (value) => !value)
            ]
          },
          children: this.children
        });
      }
      /**
      * Focuses the list item (which is not a separator).
      */
      focus() {
        if (this.items) {
          const firstListItem = this.items.find((item) => !(item instanceof ListSeparatorView));
          if (firstListItem) {
            firstListItem.focus();
          }
        }
      }
    }
    class ListView extends View {
      /**
      * @inheritDoc
      */
      constructor(locale) {
        super(locale);
        /**
        * The collection of focusable views in the list. It is used to determine accessible navigation
        * between the {@link module:ui/list/listitemview~ListItemView list items} and
        * {@link module:ui/list/listitemgroupview~ListItemGroupView list groups}.
        */
        __publicField(this, "focusables");
        /**
        * Collection of the child list views.
        */
        __publicField(this, "items");
        /**
        * Tracks information about DOM focus in the list.
        */
        __publicField(this, "focusTracker");
        /**
        * Instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
        */
        __publicField(this, "keystrokes");
        /**
        * Helps cycling over focusable {@link #items} in the list.
        */
        __publicField(this, "_focusCycler");
        /**
        * A cached map of {@link module:ui/list/listitemgroupview~ListItemGroupView} to `change` event listeners for their `items`.
        * Used for accessibility and keyboard navigation purposes.
        */
        __publicField(this, "_listItemGroupToChangeListeners", /* @__PURE__ */ new WeakMap());
        const bind2 = this.bindTemplate;
        this.focusables = new ViewCollection();
        this.items = this.createCollection();
        this.focusTracker = new FocusTracker();
        this.keystrokes = new KeystrokeHandler();
        this._focusCycler = new FocusCycler({
          focusables: this.focusables,
          focusTracker: this.focusTracker,
          keystrokeHandler: this.keystrokes,
          actions: {
            // Navigate list items backwards using the arrowup key.
            focusPrevious: "arrowup",
            // Navigate toolbar items forwards using the arrowdown key.
            focusNext: "arrowdown"
          }
        });
        this.set("ariaLabel", void 0);
        this.set("ariaLabelledBy", void 0);
        this.set("role", void 0);
        this.setTemplate({
          tag: "ul",
          attributes: {
            class: [
              "ck",
              "ck-reset",
              "ck-list"
            ],
            role: bind2.to("role"),
            "aria-label": bind2.to("ariaLabel"),
            "aria-labelledby": bind2.to("ariaLabelledBy")
          },
          children: this.items
        });
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        for (const item of this.items) {
          if (item instanceof ListItemGroupView) {
            this._registerFocusableItemsGroup(item);
          } else if (item instanceof ListItemView) {
            this._registerFocusableListItem(item);
          }
        }
        this.items.on("change", (evt, data) => {
          for (const removed of data.removed) {
            if (removed instanceof ListItemGroupView) {
              this._deregisterFocusableItemsGroup(removed);
            } else if (removed instanceof ListItemView) {
              this._deregisterFocusableListItem(removed);
            }
          }
          for (const added of Array.from(data.added).reverse()) {
            if (added instanceof ListItemGroupView) {
              this._registerFocusableItemsGroup(added, data.index);
            } else {
              this._registerFocusableListItem(added, data.index);
            }
          }
        });
        this.keystrokes.listenTo(this.element);
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        this.focusTracker.destroy();
        this.keystrokes.destroy();
      }
      /**
      * Focuses the first focusable in {@link #items}.
      */
      focus() {
        this._focusCycler.focusFirst();
      }
      /**
      * Focuses the first focusable in {@link #items}.
      */
      focusFirst() {
        this._focusCycler.focusFirst();
      }
      /**
      * Focuses the last focusable in {@link #items}.
      */
      focusLast() {
        this._focusCycler.focusLast();
      }
      /**
      * Registers a list item view in the focus tracker.
      *
      * @param item The list item view to be registered.
      * @param index Index of the list item view in the {@link #items} collection. If not specified, the item will be added at the end.
      */
      _registerFocusableListItem(item, index) {
        this.focusTracker.add(item.element);
        this.focusables.add(item, index);
      }
      /**
      * Removes a list item view from the focus tracker.
      *
      * @param item The list item view to be removed.
      */
      _deregisterFocusableListItem(item) {
        this.focusTracker.remove(item.element);
        this.focusables.remove(item);
      }
      /**
      * Gets a callback that will be called when the `items` collection of a {@link module:ui/list/listitemgroupview~ListItemGroupView}
      * change.
      *
      * @param groupView The group view for which the callback will be created.
      * @returns The callback function to be used for the items `change` event listener in a group.
      */
      _getOnGroupItemsChangeCallback(groupView) {
        return (evt, data) => {
          for (const removed of data.removed) {
            this._deregisterFocusableListItem(removed);
          }
          for (const added of Array.from(data.added).reverse()) {
            this._registerFocusableListItem(added, this.items.getIndex(groupView) + data.index);
          }
        };
      }
      /**
      * Registers a list item group view (and its children) in the focus tracker.
      *
      * @param groupView A group view to be registered.
      * @param groupIndex Index of the group view in the {@link #items} collection. If not specified, the group will be added at the end.
      */
      _registerFocusableItemsGroup(groupView, groupIndex) {
        Array.from(groupView.items).forEach((child, childIndex) => {
          const registeredChildIndex = typeof groupIndex !== "undefined" ? groupIndex + childIndex : void 0;
          this._registerFocusableListItem(child, registeredChildIndex);
        });
        const groupItemsChangeCallback = this._getOnGroupItemsChangeCallback(groupView);
        this._listItemGroupToChangeListeners.set(groupView, groupItemsChangeCallback);
        groupView.items.on("change", groupItemsChangeCallback);
      }
      /**
      * Removes a list item group view (and its children) from the focus tracker.
      *
      * @param groupView The group view to be removed.
      */
      _deregisterFocusableItemsGroup(groupView) {
        for (const child of groupView.items) {
          this._deregisterFocusableListItem(child);
        }
        groupView.items.off("change", this._listItemGroupToChangeListeners.get(groupView));
        this._listItemGroupToChangeListeners.delete(groupView);
      }
    }
    const toPx$5 = /* @__PURE__ */ toUnit("px");
    const POSITION_OFF_SCREEN = {
      top: -99999,
      left: -99999,
      name: "arrowless",
      config: {
        withArrow: false
      }
    };
    const _BalloonPanelView = class _BalloonPanelView extends View {
      /**
      * @inheritDoc
      */
      constructor(locale) {
        super(locale);
        /**
        * A collection of the child views that creates the balloon panel contents.
        */
        __publicField(this, "content");
        /**
        * A callback that starts pinning the panel when {@link #isVisible} gets
        * `true`. Used by {@link #pin}.
        *
        * @private
        */
        __publicField(this, "_pinWhenIsVisibleCallback");
        /**
        * An instance of resize observer used to detect if target element is still visible.
        */
        __publicField(this, "_resizeObserver");
        const bind2 = this.bindTemplate;
        this.set("top", 0);
        this.set("left", 0);
        this.set("position", "arrow_nw");
        this.set("isVisible", false);
        this.set("withArrow", true);
        this.set("class", void 0);
        this._pinWhenIsVisibleCallback = null;
        this._resizeObserver = null;
        this.content = this.createCollection();
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-balloon-panel",
              bind2.to("position", (value) => `ck-balloon-panel_${value}`),
              bind2.if("isVisible", "ck-balloon-panel_visible"),
              bind2.if("withArrow", "ck-balloon-panel_with-arrow"),
              bind2.to("class")
            ],
            style: {
              top: bind2.to("top", toPx$5),
              left: bind2.to("left", toPx$5)
            }
          },
          children: this.content
        });
      }
      /**
      * @inheritDoc
      */
      destroy() {
        this.hide();
        super.destroy();
      }
      /**
      * Shows the panel.
      *
      * See {@link #isVisible}.
      */
      show() {
        this.isVisible = true;
      }
      /**
      * Hides the panel.
      *
      * See {@link #isVisible}.
      */
      hide() {
        this.isVisible = false;
      }
      /**
      * Attaches the panel to a specified {@link module:utils/dom/position~Options#target} with a
      * smart positioning heuristics that chooses from available positions to make sure the panel
      * is visible to the user i.e. within the limits of the viewport.
      *
      * This method accepts configuration {@link module:utils/dom/position~Options options}
      * to set the `target`, optional `limiter` and `positions` the balloon should choose from.
      *
      * ```ts
      * const panel = new BalloonPanelView( locale );
      * const positions = BalloonPanelView.defaultPositions;
      *
      * panel.render();
      *
      * // Attach the panel to an element with the "target" id DOM.
      * panel.attachTo( {
      * 	target: document.querySelector( '#target' ),
      * 	positions: [
      * 		positions.northArrowSouth,
      * 		positions.southArrowNorth
      * 	]
      * } );
      * ```
      *
      * **Note**: Attaching the panel will also automatically {@link #show} it.
      *
      * **Note**: An attached panel will not follow its target when the window is scrolled or resized.
      * See the {@link #pin} method for a more permanent positioning strategy.
      *
      * @param options Positioning options compatible with {@link module:utils/dom/position~getOptimalPosition}.
      * Default `positions` array is {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.defaultPositions}.
      * @returns Whether the balloon was shown and successfully attached or not. Attaching can fail if the target
      * provided in the options is invisible (e.g. element detached from DOM).
      */
      attachTo(options) {
        const target = getDomElement(options.target);
        if (target && !isVisible(target)) {
          return false;
        }
        this.show();
        const defaultPositions = _BalloonPanelView.defaultPositions;
        const positionOptions = Object.assign({}, {
          element: this.element,
          positions: [
            defaultPositions.southArrowNorth,
            defaultPositions.southArrowNorthMiddleWest,
            defaultPositions.southArrowNorthMiddleEast,
            defaultPositions.southArrowNorthWest,
            defaultPositions.southArrowNorthEast,
            defaultPositions.northArrowSouth,
            defaultPositions.northArrowSouthMiddleWest,
            defaultPositions.northArrowSouthMiddleEast,
            defaultPositions.northArrowSouthWest,
            defaultPositions.northArrowSouthEast,
            defaultPositions.viewportStickyNorth
          ],
          limiter: global$1.document.body,
          fitInViewport: true
        }, options);
        const optimalPosition = _BalloonPanelView._getOptimalPosition(positionOptions) || POSITION_OFF_SCREEN;
        const left2 = parseInt(optimalPosition.left);
        const top2 = parseInt(optimalPosition.top);
        const position = optimalPosition.name;
        const config2 = optimalPosition.config || {};
        const { withArrow = true } = config2;
        this.top = top2;
        this.left = left2;
        this.position = position;
        this.withArrow = withArrow;
        return true;
      }
      /**
      * Works the same way as the {@link #attachTo} method except that the position of the panel is
      * continuously updated when:
      *
      * * any ancestor of the {@link module:utils/dom/position~Options#target}
      * or {@link module:utils/dom/position~Options#limiter} is scrolled,
      * * the browser window gets resized or scrolled.
      *
      * Thanks to that, the panel always sticks to the {@link module:utils/dom/position~Options#target}
      * and is immune to the changing environment.
      *
      * ```ts
      * const panel = new BalloonPanelView( locale );
      * const positions = BalloonPanelView.defaultPositions;
      *
      * panel.render();
      *
      * // Pin the panel to an element with the "target" id DOM.
      * panel.pin( {
      * 	target: document.querySelector( '#target' ),
      * 	positions: [
      * 		positions.northArrowSouth,
      * 		positions.southArrowNorth
      * 	]
      * } );
      * ```
      *
      * To leave the pinned state, use the {@link #unpin} method.
      *
      * **Note**: Pinning the panel will also automatically {@link #show} it.
      *
      * @param options Positioning options compatible with {@link module:utils/dom/position~getOptimalPosition}.
      * Default `positions` array is {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.defaultPositions}.
      */
      pin(options) {
        this.unpin();
        if (!this._startPinning(options)) {
          return;
        }
        this._pinWhenIsVisibleCallback = () => {
          if (this.isVisible) {
            this._startPinning(options);
          } else {
            this._stopPinning();
          }
        };
        this.listenTo(this, "change:isVisible", this._pinWhenIsVisibleCallback);
      }
      /**
      * Stops pinning the panel, as set up by {@link #pin}.
      */
      unpin() {
        if (this._pinWhenIsVisibleCallback) {
          this._stopPinning();
          this.stopListening(this, "change:isVisible", this._pinWhenIsVisibleCallback);
          this._pinWhenIsVisibleCallback = null;
          this.hide();
        }
      }
      /**
      * Starts managing the pinned state of the panel. See {@link #pin}.
      *
      * @param options Positioning options compatible with {@link module:utils/dom/position~getOptimalPosition}.
      * @returns Whether the balloon was shown and successfully attached or not. Attaching can fail if the target
      * provided in the options is invisible (e.g. element detached from DOM).
      */
      _startPinning(options) {
        if (!this.attachTo(options)) {
          return false;
        }
        let targetElement = getDomElement(options.target);
        const limiterElement = options.limiter ? getDomElement(options.limiter) : global$1.document.body;
        this.listenTo(global$1.document, "scroll", (evt, domEvt) => {
          const scrollTarget = domEvt.target;
          const isWithinScrollTarget = targetElement && scrollTarget.contains(targetElement);
          const isLimiterWithinScrollTarget = limiterElement && scrollTarget.contains(limiterElement);
          if (isWithinScrollTarget || isLimiterWithinScrollTarget || !targetElement || !limiterElement) {
            this.attachTo(options);
          }
        }, {
          useCapture: true
        });
        this.listenTo(global$1.window, "resize", () => {
          this.attachTo(options);
        });
        if (!this._resizeObserver) {
          if (targetElement && isText(targetElement)) {
            targetElement = targetElement.parentElement;
          }
          if (targetElement) {
            const checkVisibility = () => {
              if (!isVisible(targetElement)) {
                this.unpin();
              }
            };
            this._resizeObserver = new ResizeObserver$1(targetElement, checkVisibility);
          }
        }
        return true;
      }
      /**
      * Stops managing the pinned state of the panel. See {@link #pin}.
      */
      _stopPinning() {
        this.stopListening(global$1.document, "scroll");
        this.stopListening(global$1.window, "resize");
        if (this._resizeObserver) {
          this._resizeObserver.destroy();
          this._resizeObserver = null;
        }
      }
      /**
      * Returns available {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView}
      * {@link module:utils/dom/position~PositioningFunction positioning functions} adjusted by the specific offsets.
      *
      * @internal
      * @param options Options to generate positions. If not specified, this helper will simply return
      * {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.defaultPositions}.
      * @param options.sideOffset A custom side offset (in pixels) of each position. If
      * not specified, {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.arrowSideOffset the default value}
      * will be used.
      * @param options.heightOffset A custom height offset (in pixels) of each position. If
      * not specified, {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.arrowHeightOffset the default value}
      * will be used.
      * @param options.stickyVerticalOffset A custom offset (in pixels) of the `viewportStickyNorth` positioning function.
      * If not specified, {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.stickyVerticalOffset the default value}
      * will be used.
      * @param options.config Additional configuration of the balloon balloon panel view.
      * Currently only {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView#withArrow} is supported. Learn more
      * about {@link module:utils/dom/position~PositioningFunction positioning functions}.
      */
      static generatePositions(options = {}) {
        const { sideOffset = _BalloonPanelView.arrowSideOffset, heightOffset = _BalloonPanelView.arrowHeightOffset, stickyVerticalOffset = _BalloonPanelView.stickyVerticalOffset, config: config2 } = options;
        return {
          // ------- North west
          northWestArrowSouthWest: (targetRect, balloonRect) => ({
            top: getNorthTop(targetRect, balloonRect),
            left: targetRect.left - sideOffset,
            name: "arrow_sw",
            ...config2 && {
              config: config2
            }
          }),
          northWestArrowSouthMiddleWest: (targetRect, balloonRect) => ({
            top: getNorthTop(targetRect, balloonRect),
            left: targetRect.left - balloonRect.width * 0.25 - sideOffset,
            name: "arrow_smw",
            ...config2 && {
              config: config2
            }
          }),
          northWestArrowSouth: (targetRect, balloonRect) => ({
            top: getNorthTop(targetRect, balloonRect),
            left: targetRect.left - balloonRect.width / 2,
            name: "arrow_s",
            ...config2 && {
              config: config2
            }
          }),
          northWestArrowSouthMiddleEast: (targetRect, balloonRect) => ({
            top: getNorthTop(targetRect, balloonRect),
            left: targetRect.left - balloonRect.width * 0.75 + sideOffset,
            name: "arrow_sme",
            ...config2 && {
              config: config2
            }
          }),
          northWestArrowSouthEast: (targetRect, balloonRect) => ({
            top: getNorthTop(targetRect, balloonRect),
            left: targetRect.left - balloonRect.width + sideOffset,
            name: "arrow_se",
            ...config2 && {
              config: config2
            }
          }),
          // ------- North
          northArrowSouthWest: (targetRect, balloonRect) => ({
            top: getNorthTop(targetRect, balloonRect),
            left: targetRect.left + targetRect.width / 2 - sideOffset,
            name: "arrow_sw",
            ...config2 && {
              config: config2
            }
          }),
          northArrowSouthMiddleWest: (targetRect, balloonRect) => ({
            top: getNorthTop(targetRect, balloonRect),
            left: targetRect.left + targetRect.width / 2 - balloonRect.width * 0.25 - sideOffset,
            name: "arrow_smw",
            ...config2 && {
              config: config2
            }
          }),
          northArrowSouth: (targetRect, balloonRect) => ({
            top: getNorthTop(targetRect, balloonRect),
            left: targetRect.left + targetRect.width / 2 - balloonRect.width / 2,
            name: "arrow_s",
            ...config2 && {
              config: config2
            }
          }),
          northArrowSouthMiddleEast: (targetRect, balloonRect) => ({
            top: getNorthTop(targetRect, balloonRect),
            left: targetRect.left + targetRect.width / 2 - balloonRect.width * 0.75 + sideOffset,
            name: "arrow_sme",
            ...config2 && {
              config: config2
            }
          }),
          northArrowSouthEast: (targetRect, balloonRect) => ({
            top: getNorthTop(targetRect, balloonRect),
            left: targetRect.left + targetRect.width / 2 - balloonRect.width + sideOffset,
            name: "arrow_se",
            ...config2 && {
              config: config2
            }
          }),
          // ------- North east
          northEastArrowSouthWest: (targetRect, balloonRect) => ({
            top: getNorthTop(targetRect, balloonRect),
            left: targetRect.right - sideOffset,
            name: "arrow_sw",
            ...config2 && {
              config: config2
            }
          }),
          northEastArrowSouthMiddleWest: (targetRect, balloonRect) => ({
            top: getNorthTop(targetRect, balloonRect),
            left: targetRect.right - balloonRect.width * 0.25 - sideOffset,
            name: "arrow_smw",
            ...config2 && {
              config: config2
            }
          }),
          northEastArrowSouth: (targetRect, balloonRect) => ({
            top: getNorthTop(targetRect, balloonRect),
            left: targetRect.right - balloonRect.width / 2,
            name: "arrow_s",
            ...config2 && {
              config: config2
            }
          }),
          northEastArrowSouthMiddleEast: (targetRect, balloonRect) => ({
            top: getNorthTop(targetRect, balloonRect),
            left: targetRect.right - balloonRect.width * 0.75 + sideOffset,
            name: "arrow_sme",
            ...config2 && {
              config: config2
            }
          }),
          northEastArrowSouthEast: (targetRect, balloonRect) => ({
            top: getNorthTop(targetRect, balloonRect),
            left: targetRect.right - balloonRect.width + sideOffset,
            name: "arrow_se",
            ...config2 && {
              config: config2
            }
          }),
          // ------- South west
          southWestArrowNorthWest: (targetRect) => ({
            top: getSouthTop(targetRect),
            left: targetRect.left - sideOffset,
            name: "arrow_nw",
            ...config2 && {
              config: config2
            }
          }),
          southWestArrowNorthMiddleWest: (targetRect, balloonRect) => ({
            top: getSouthTop(targetRect),
            left: targetRect.left - balloonRect.width * 0.25 - sideOffset,
            name: "arrow_nmw",
            ...config2 && {
              config: config2
            }
          }),
          southWestArrowNorth: (targetRect, balloonRect) => ({
            top: getSouthTop(targetRect),
            left: targetRect.left - balloonRect.width / 2,
            name: "arrow_n",
            ...config2 && {
              config: config2
            }
          }),
          southWestArrowNorthMiddleEast: (targetRect, balloonRect) => ({
            top: getSouthTop(targetRect),
            left: targetRect.left - balloonRect.width * 0.75 + sideOffset,
            name: "arrow_nme",
            ...config2 && {
              config: config2
            }
          }),
          southWestArrowNorthEast: (targetRect, balloonRect) => ({
            top: getSouthTop(targetRect),
            left: targetRect.left - balloonRect.width + sideOffset,
            name: "arrow_ne",
            ...config2 && {
              config: config2
            }
          }),
          // ------- South
          southArrowNorthWest: (targetRect) => ({
            top: getSouthTop(targetRect),
            left: targetRect.left + targetRect.width / 2 - sideOffset,
            name: "arrow_nw",
            ...config2 && {
              config: config2
            }
          }),
          southArrowNorthMiddleWest: (targetRect, balloonRect) => ({
            top: getSouthTop(targetRect),
            left: targetRect.left + targetRect.width / 2 - balloonRect.width * 0.25 - sideOffset,
            name: "arrow_nmw",
            ...config2 && {
              config: config2
            }
          }),
          southArrowNorth: (targetRect, balloonRect) => ({
            top: getSouthTop(targetRect),
            left: targetRect.left + targetRect.width / 2 - balloonRect.width / 2,
            name: "arrow_n",
            ...config2 && {
              config: config2
            }
          }),
          southArrowNorthMiddleEast: (targetRect, balloonRect) => ({
            top: getSouthTop(targetRect),
            left: targetRect.left + targetRect.width / 2 - balloonRect.width * 0.75 + sideOffset,
            name: "arrow_nme",
            ...config2 && {
              config: config2
            }
          }),
          southArrowNorthEast: (targetRect, balloonRect) => ({
            top: getSouthTop(targetRect),
            left: targetRect.left + targetRect.width / 2 - balloonRect.width + sideOffset,
            name: "arrow_ne",
            ...config2 && {
              config: config2
            }
          }),
          // ------- South east
          southEastArrowNorthWest: (targetRect) => ({
            top: getSouthTop(targetRect),
            left: targetRect.right - sideOffset,
            name: "arrow_nw",
            ...config2 && {
              config: config2
            }
          }),
          southEastArrowNorthMiddleWest: (targetRect, balloonRect) => ({
            top: getSouthTop(targetRect),
            left: targetRect.right - balloonRect.width * 0.25 - sideOffset,
            name: "arrow_nmw",
            ...config2 && {
              config: config2
            }
          }),
          southEastArrowNorth: (targetRect, balloonRect) => ({
            top: getSouthTop(targetRect),
            left: targetRect.right - balloonRect.width / 2,
            name: "arrow_n",
            ...config2 && {
              config: config2
            }
          }),
          southEastArrowNorthMiddleEast: (targetRect, balloonRect) => ({
            top: getSouthTop(targetRect),
            left: targetRect.right - balloonRect.width * 0.75 + sideOffset,
            name: "arrow_nme",
            ...config2 && {
              config: config2
            }
          }),
          southEastArrowNorthEast: (targetRect, balloonRect) => ({
            top: getSouthTop(targetRect),
            left: targetRect.right - balloonRect.width + sideOffset,
            name: "arrow_ne",
            ...config2 && {
              config: config2
            }
          }),
          // ------- West
          westArrowEast: (targetRect, balloonRect) => ({
            top: targetRect.top + targetRect.height / 2 - balloonRect.height / 2,
            left: targetRect.left - balloonRect.width - heightOffset,
            name: "arrow_e",
            ...config2 && {
              config: config2
            }
          }),
          // ------- East
          eastArrowWest: (targetRect, balloonRect) => ({
            top: targetRect.top + targetRect.height / 2 - balloonRect.height / 2,
            left: targetRect.right + heightOffset,
            name: "arrow_w",
            ...config2 && {
              config: config2
            }
          }),
          // ------- Sticky
          viewportStickyNorth: (targetRect, balloonRect, viewportRect, limiterRect) => {
            const boundaryRect = limiterRect || viewportRect;
            if (!targetRect.getIntersection(boundaryRect)) {
              return null;
            }
            if (boundaryRect.height - targetRect.height > stickyVerticalOffset) {
              return null;
            }
            return {
              top: boundaryRect.top + stickyVerticalOffset,
              left: targetRect.left + targetRect.width / 2 - balloonRect.width / 2,
              name: "arrowless",
              config: {
                withArrow: false,
                ...config2
              }
            };
          }
        };
        function getNorthTop(targetRect, balloonRect) {
          return targetRect.top - balloonRect.height - heightOffset;
        }
        function getSouthTop(targetRect) {
          return targetRect.bottom + heightOffset;
        }
      }
    };
    /**
    * A side offset of the arrow tip from the edge of the balloon. Controlled by CSS.
    *
    * ```
    *		 
    *		                        
    *		          Balloon       
    *		          Content       
    *		                        
    *		 +    +
    *		 |   \  /
    *		 |    \/
    *		><  side offset
    *
    * ```
    *
    * @default 25
    */
    __publicField(_BalloonPanelView, "arrowSideOffset", 25);
    /**
     * A height offset of the arrow from the edge of the balloon. Controlled by CSS.
     *
     * ```
     *		 
     *		                        
     *		          Balloon       
     *		          Content             -- arrow height offset
     *		                              V
     *		 +    + --- 
     *		     \  /                       
     *		      \/                        
     *		
     *		                                ^
     *
     *
     *		><  arrow height offset
     *		     
     *		     
     *		                             
     *		                             
     *		              Balloon        
     *		              Content        
     *		                             
     *		                             
     *		     
     * ```
     *
     * @default 10
    */
    __publicField(_BalloonPanelView, "arrowHeightOffset", 10);
    /**
    * A vertical offset of the balloon panel from the edge of the viewport if sticky.
    * It helps in accessing toolbar buttons underneath the balloon panel.
    *
    * ```
    *		  
    *		                        Target                       
    *		                                                     
    *		                              / vertical offset    
    *		V
    *		 Toolbar                                
    *		   Balloon   
    *		                                      
    *		                                                     
    *		                                                     
    *		                                                     
    *		  
    *		                        Viewport                       
    *		
    * ```
    *
    * @default 20
    */
    __publicField(_BalloonPanelView, "stickyVerticalOffset", 20);
    /**
    * Function used to calculate the optimal position for the balloon.
    */
    __publicField(_BalloonPanelView, "_getOptimalPosition", getOptimalPosition);
    /**
    * A default set of positioning functions used by the balloon panel view
    * when attaching using the {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView#attachTo} method.
    *
    * The available positioning functions are as follows:
    *
    * **North west**
    *
    * * `northWestArrowSouthWest`
    *
    * ```
    *		+-----------------+
    *		|     Balloon     |
    *		+-----------------+
    *		 V
    *		 [ Target ]
    * ```
    *
    * * `northWestArrowSouthMiddleWest`
    *
    * ```
    *		+-----------------+
    *		|     Balloon     |
    *		+-----------------+
    *		    V
    *		    [ Target ]
    * ```
    *
    * * `northWestArrowSouth`
    *
    * ```
    *		+-----------------+
    *		|     Balloon     |
    *		+-----------------+
    *		         V
    *		         [ Target ]
    * ```
    *
    * * `northWestArrowSouthMiddleEast`
    *
    * ```
    *		+-----------------+
    *		|     Balloon     |
    *		+-----------------+
    *		             V
    *		             [ Target ]
    * ```
    *
    * * `northWestArrowSouthEast`
    *
    * ```
    *		+-----------------+
    *		|     Balloon     |
    *		+-----------------+
    *		                 V
    *		                 [ Target ]
    * ```
    *
    * **North**
    *
    * * `northArrowSouthWest`
    *
    * ```
    *		    +-----------------+
    *		    |     Balloon     |
    *		    +-----------------+
    *		     V
    *		[ Target ]
    * ```
    *
    * * `northArrowSouthMiddleWest`
    *
    * ```
    *		 +-----------------+
    *		 |     Balloon     |
    *		 +-----------------+
    *		     V
    *		[ Target ]
    * ```
    * * `northArrowSouth`
    *
    * ```
    *		+-----------------+
    *		|     Balloon     |
    *		+-----------------+
    *		         V
    *		    [ Target ]
    * ```
    *
    * * `northArrowSouthMiddleEast`
    *
    * ```
    *		+-----------------+
    *		|     Balloon     |
    *		+-----------------+
    *		             V
    *		        [ Target ]
    * ```
    *
    * * `northArrowSouthEast`
    *
    * ```
    *		+-----------------+
    *		|     Balloon     |
    *		+-----------------+
    *		                V
    *		           [ Target ]
    * ```
    *
    * **North east**
    *
    * * `northEastArrowSouthWest`
    *
    * ```
    *		        +-----------------+
    *		        |     Balloon     |
    *		        +-----------------+
    *		         V
    *		[ Target ]
    * ```
    *
    * * `northEastArrowSouthMiddleWest`
    *
    * ```
    *		     +-----------------+
    *		     |     Balloon     |
    *		     +-----------------+
    *		         V
    *		[ Target ]
    * ```
    *
    * * `northEastArrowSouth`
    *
    * ```
    *		+-----------------+
    *		|     Balloon     |
    *		+-----------------+
    *		         V
    *		[ Target ]
    * ```
    *
    * * `northEastArrowSouthMiddleEast`
    *
    * ```
    *		+-----------------+
    *		|     Balloon     |
    *		+-----------------+
    *		             V
    *		    [ Target ]
    * ```
    *
    * * `northEastArrowSouthEast`
    *
    * ```
    *		+-----------------+
    *		|     Balloon     |
    *		+-----------------+
    *		                 V
    *		        [ Target ]
    * ```
    *
    * **South**
    *
    * * `southArrowNorthWest`
    *
    * ```
    *		[ Target ]
    *		     ^
    *		    +-----------------+
    *		    |     Balloon     |
    *		    +-----------------+
    * ```
    *
    * * `southArrowNorthMiddleWest`
    *
    * ```
    *		   [ Target ]
    *		        ^
    *		    +-----------------+
    *		    |     Balloon     |
    *		    +-----------------+
    * ```
    *
    * * `southArrowNorth`
    *
    * ```
    *		    [ Target ]
    *		         ^
    *		+-----------------+
    *		|     Balloon     |
    *		+-----------------+
    * ```
    *
    * * `southArrowNorthMiddleEast`
    *
    * ```
    *		            [ Target ]
    *		                 ^
    *		   +-----------------+
    *		   |     Balloon     |
    *		   +-----------------+
    * ```
    *
    * * `southArrowNorthEast`
    *
    * ```
    *		            [ Target ]
    *		                 ^
    *		+-----------------+
    *		|     Balloon     |
    *		+-----------------+
    * ```
    *
    * **South west**
    *
    * * `southWestArrowNorthWest`
    *
    *
    * ```
    *		 [ Target ]
    *		 ^
    *		+-----------------+
    *		|     Balloon     |
    *		+-----------------+
    * ```
    *
    * * `southWestArrowNorthMiddleWest`
    *
    * ```
    *		     [ Target ]
    *		     ^
    *		 +-----------------+
    *		 |     Balloon     |
    *		 +-----------------+
    * ```
    *
    * * `southWestArrowNorth`
    *
    * ```
    *		         [ Target ]
    *		         ^
    *		+-----------------+
    *		|     Balloon     |
    *		+-----------------+
    * ```
    *
    * * `southWestArrowNorthMiddleEast`
    *
    * ```
    *		              [ Target ]
    *		              ^
    *		+-----------------+
    *		|     Balloon     |
    *		+-----------------+
    * ```
    *
    * * `southWestArrowNorthEast`
    *
    * ```
    *		                 [ Target ]
    *		                 ^
    *		+-----------------+
    *		|     Balloon     |
    *		+-----------------+
    * ```
    *
    * **South east**
    *
    * * `southEastArrowNorthWest`
    *
    * ```
    *		[ Target ]
    *		         ^
    *		        +-----------------+
    *		        |     Balloon     |
    *		        +-----------------+
    * ```
    *
    * * `southEastArrowNorthMiddleWest`
    *
    * ```
    *		   [ Target ]
    *		            ^
    *		        +-----------------+
    *		        |     Balloon     |
    *		        +-----------------+
    * ```
    *
    * * `southEastArrowNorth`
    *
    * ```
    *		[ Target ]
    *		         ^
    *		+-----------------+
    *		|     Balloon     |
    *		+-----------------+
    * ```
    *
    * * `southEastArrowNorthMiddleEast`
    *
    * ```
    *		     [ Target ]
    *		              ^
    *		+-----------------+
    *		|     Balloon     |
    *		+-----------------+
    * ```
    *
    * * `southEastArrowNorthEast`
    *
    * ```
    *		        [ Target ]
    *		                 ^
    *		+-----------------+
    *		|     Balloon     |
    *		+-----------------+
    * ```
    *
    * **West**
    *
    * * `westArrowEast`
    *
    * ```
    *		+-----------------+
    *		|     Balloon     |>[ Target ]
    *		+-----------------+
    * ```
    *
    * **East**
    *
    * * `eastArrowWest`
    *
    * ```
    *		           +-----------------+
    *		[ Target ]<|     Balloon     |
    *		           +-----------------+
    * ```
    *
    * **Sticky**
    *
    * * `viewportStickyNorth`
    *
    * ```
    *		    +---------------------------+
    *		    |        [ Target ]         |
    *		    |                           |
    *		+-----------------------------------+
    *		|   |    +-----------------+    |   |
    *		|   |    |     Balloon     |    |   |
    *		|   |    +-----------------+    |   |
    *		|   |                           |   |
    *		|   |                           |   |
    *		|   |                           |   |
    *		|   |                           |   |
    *		|   +---------------------------+   |
    *		|             Viewport              |
    *		+-----------------------------------+
    * ```
    *
    * See {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView#attachTo}.
    *
    * Positioning functions must be compatible with {@link module:utils/dom/position~DomPoint}.
    *
    * Default positioning functions with customized offsets can be generated using
    * {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.generatePositions}.
    *
    * The name that the position function returns will be reflected in the balloon panel's class that
    * controls the placement of the "arrow". See {@link #position} to learn more.
    */
    __publicField(_BalloonPanelView, "defaultPositions", /* @__PURE__ */ _BalloonPanelView.generatePositions());
    let BalloonPanelView = _BalloonPanelView;
    function getDomElement(object2) {
      if (isElement$3(object2)) {
        return object2;
      }
      if (isRange(object2)) {
        return object2.commonAncestorContainer;
      }
      if (typeof object2 == "function") {
        return getDomElement(object2());
      }
      return null;
    }
    class ToolbarSeparatorView extends View {
      /**
      * @inheritDoc
      */
      constructor(locale) {
        super(locale);
        this.setTemplate({
          tag: "span",
          attributes: {
            class: [
              "ck",
              "ck-toolbar__separator"
            ]
          }
        });
      }
    }
    class ToolbarLineBreakView extends View {
      /**
      * @inheritDoc
      */
      constructor(locale) {
        super(locale);
        this.setTemplate({
          tag: "span",
          attributes: {
            class: [
              "ck",
              "ck-toolbar__line-break"
            ]
          }
        });
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function preventDefault(view) {
      return view.bindTemplate.to((evt) => {
        if (evt.target === view.element) {
          evt.preventDefault();
        }
      });
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function normalizeToolbarConfig(config2) {
      if (Array.isArray(config2)) {
        return {
          items: config2,
          removeItems: []
        };
      }
      const predefinedConfigOptions = {
        items: [],
        removeItems: []
      };
      if (!config2) {
        return predefinedConfigOptions;
      }
      return {
        ...predefinedConfigOptions,
        ...config2
      };
    }
    const NESTED_TOOLBAR_ICONS = /* @__PURE__ */ (() => ({
      alignLeft: icons.alignLeft,
      bold: icons.bold,
      importExport: icons.importExport,
      paragraph: icons.paragraph,
      plus: icons.plus,
      text: icons.text,
      threeVerticalDots: icons.threeVerticalDots,
      pilcrow: icons.pilcrow,
      dragIndicator: icons.dragIndicator
    }))();
    class ToolbarView extends View {
      /**
      * Creates an instance of the {@link module:ui/toolbar/toolbarview~ToolbarView} class.
      *
      * Also see {@link #render}.
      *
      * @param locale The localization services instance.
      * @param options Configuration options of the toolbar.
      */
      constructor(locale, options) {
        super(locale);
        /**
        * A reference to the options object passed to the constructor.
        */
        __publicField(this, "options");
        /**
        * A collection of toolbar items (buttons, dropdowns, etc.).
        */
        __publicField(this, "items");
        /**
        * Tracks information about the DOM focus in the toolbar.
        */
        __publicField(this, "focusTracker");
        /**
        * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}
        * to handle keyboard navigation in the toolbar.
        */
        __publicField(this, "keystrokes");
        /**
        * A (child) view containing {@link #items toolbar items}.
        */
        __publicField(this, "itemsView");
        /**
        * A toplevel collection aggregating building blocks of the toolbar.
        *
        *	 ToolbarView 
        *	|  #children  |
        *	| |    #itemsView    | |
        *	| |   | [ item1 ] [ item2 ] ... [ itemN ] |   | |
        *	| |   -   | |
        *	|  |
        *	
        *
        * By default, it contains the {@link #itemsView} but it can be extended with additional
        * UI elements when necessary.
        */
        __publicField(this, "children");
        /**
        * A collection of {@link #items} that take part in the focus cycling
        * (i.e. navigation using the keyboard). Usually, it contains a subset of {@link #items} with
        * some optional UI elements that also belong to the toolbar and should be focusable
        * by the user.
        */
        __publicField(this, "focusables");
        /**
        * Helps cycling over {@link #focusables focusable items} in the toolbar.
        */
        __publicField(this, "_focusCycler");
        /**
        * An instance of the active toolbar behavior that shapes its look and functionality.
        *
        * See {@link module:ui/toolbar/toolbarview~ToolbarBehavior} to learn more.
        */
        __publicField(this, "_behavior");
        const bind2 = this.bindTemplate;
        const t2 = this.t;
        this.options = options || {};
        this.set("ariaLabel", t2("Editor toolbar"));
        this.set("maxWidth", "auto");
        this.items = this.createCollection();
        this.focusTracker = new FocusTracker();
        this.keystrokes = new KeystrokeHandler();
        this.set("class", void 0);
        this.set("isCompact", false);
        this.itemsView = new ItemsView(locale);
        this.children = this.createCollection();
        this.children.add(this.itemsView);
        this.focusables = this.createCollection();
        const isRtl = locale.uiLanguageDirection === "rtl";
        this._focusCycler = new FocusCycler({
          focusables: this.focusables,
          focusTracker: this.focusTracker,
          keystrokeHandler: this.keystrokes,
          actions: {
            // Navigate toolbar items backwards using the arrow[left,up] keys.
            focusPrevious: [
              isRtl ? "arrowright" : "arrowleft",
              "arrowup"
            ],
            // Navigate toolbar items forwards using the arrow[right,down] keys.
            focusNext: [
              isRtl ? "arrowleft" : "arrowright",
              "arrowdown"
            ]
          }
        });
        const classes = [
          "ck",
          "ck-toolbar",
          bind2.to("class"),
          bind2.if("isCompact", "ck-toolbar_compact")
        ];
        if (this.options.shouldGroupWhenFull && this.options.isFloating) {
          classes.push("ck-toolbar_floating");
        }
        this.setTemplate({
          tag: "div",
          attributes: {
            class: classes,
            role: "toolbar",
            "aria-label": bind2.to("ariaLabel"),
            style: {
              maxWidth: bind2.to("maxWidth")
            },
            tabindex: -1
          },
          children: this.children,
          on: {
            // https://github.com/ckeditor/ckeditor5-ui/issues/206
            mousedown: preventDefault(this)
          }
        });
        this._behavior = this.options.shouldGroupWhenFull ? new DynamicGrouping(this) : new StaticLayout(this);
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        this.focusTracker.add(this.element);
        for (const item of this.items) {
          this.focusTracker.add(item);
        }
        this.items.on("add", (evt, item) => {
          this.focusTracker.add(item);
        });
        this.items.on("remove", (evt, item) => {
          this.focusTracker.remove(item);
        });
        this.keystrokes.listenTo(this.element);
        this._behavior.render(this);
      }
      /**
      * @inheritDoc
      */
      destroy() {
        this._behavior.destroy();
        this.focusTracker.destroy();
        this.keystrokes.destroy();
        return super.destroy();
      }
      /**
      * Focuses the first focusable in {@link #focusables}.
      */
      focus() {
        this._focusCycler.focusFirst();
      }
      /**
      * Focuses the last focusable in {@link #focusables}.
      */
      focusLast() {
        this._focusCycler.focusLast();
      }
      /**
      * A utility that expands the plain toolbar configuration into
      * {@link module:ui/toolbar/toolbarview~ToolbarView#items} using a given component factory.
      *
      * @param itemsOrConfig The toolbar items or the entire toolbar configuration object.
      * @param factory A factory producing toolbar items.
      * @param removeItems An array of items names to be removed from the configuration. When present, applies
      * to this toolbar and all nested ones as well.
      */
      fillFromConfig(itemsOrConfig, factory, removeItems) {
        this.items.addMany(this._buildItemsFromConfig(itemsOrConfig, factory, removeItems));
      }
      /**
      * A utility that expands the plain toolbar configuration into a list of view items using a given component factory.
      *
      * @param itemsOrConfig The toolbar items or the entire toolbar configuration object.
      * @param factory A factory producing toolbar items.
      * @param removeItems An array of items names to be removed from the configuration. When present, applies
      * to this toolbar and all nested ones as well.
      */
      _buildItemsFromConfig(itemsOrConfig, factory, removeItems) {
        const config2 = normalizeToolbarConfig(itemsOrConfig);
        const normalizedRemoveItems = removeItems || config2.removeItems;
        const itemsToAdd = this._cleanItemsConfiguration(config2.items, factory, normalizedRemoveItems).map((item) => {
          if (isObject$3(item)) {
            return this._createNestedToolbarDropdown(item, factory, normalizedRemoveItems);
          } else if (item === "|") {
            return new ToolbarSeparatorView();
          } else if (item === "-") {
            return new ToolbarLineBreakView();
          }
          return factory.create(item);
        }).filter((item) => !!item);
        return itemsToAdd;
      }
      /**
      * Cleans up the {@link module:ui/toolbar/toolbarview~ToolbarView#items} of the toolbar by removing unwanted items and
      * duplicated (obsolete) separators or line breaks.
      *
      * @param items The toolbar items configuration.
      * @param factory A factory producing toolbar items.
      * @param removeItems An array of items names to be removed from the configuration.
      * @returns Items after the clean-up.
      */
      _cleanItemsConfiguration(items, factory, removeItems) {
        const filteredItems = items.filter((item, idx, items2) => {
          if (item === "|") {
            return true;
          }
          if (removeItems.indexOf(item) !== -1) {
            return false;
          }
          if (item === "-") {
            if (this.options.shouldGroupWhenFull) {
              logWarning("toolbarview-line-break-ignored-when-grouping-items", items2);
              return false;
            }
            return true;
          }
          if (!isObject$3(item) && !factory.has(item)) {
            logWarning("toolbarview-item-unavailable", {
              item
            });
            return false;
          }
          return true;
        });
        return this._cleanSeparatorsAndLineBreaks(filteredItems);
      }
      /**
      * Remove leading, trailing, and duplicated separators (`-` and `|`).
      *
      * @returns Toolbar items after the separator and line break clean-up.
      */
      _cleanSeparatorsAndLineBreaks(items) {
        const nonSeparatorPredicate = (item) => item !== "-" && item !== "|";
        const count2 = items.length;
        const firstCommandItemIndex = items.findIndex(nonSeparatorPredicate);
        if (firstCommandItemIndex === -1) {
          return [];
        }
        const lastCommandItemIndex = count2 - items.slice().reverse().findIndex(nonSeparatorPredicate);
        return items.slice(firstCommandItemIndex, lastCommandItemIndex).filter((name, idx, items2) => {
          if (nonSeparatorPredicate(name)) {
            return true;
          }
          const isDuplicated = idx > 0 && items2[idx - 1] === name;
          return !isDuplicated;
        });
      }
      /**
      * Creates a user-defined dropdown containing a toolbar with items.
      *
      * @param definition A definition of the nested toolbar dropdown.
      * @param definition.label A label of the dropdown.
      * @param definition.icon An icon of the drop-down. One of 'bold', 'plus', 'text', 'importExport', 'alignLeft',
      * 'paragraph' or an SVG string. When `false` is passed, no icon will be used.
      * @param definition.withText When set `true`, the label of the dropdown will be visible. See
      * {@link module:ui/button/buttonview~ButtonView#withText} to learn more.
      * @param definition.tooltip A tooltip of the dropdown button. See
      * {@link module:ui/button/buttonview~ButtonView#tooltip} to learn more. Defaults to `true`.
      * @param componentFactory Component factory used to create items
      * of the nested toolbar.
      */
      _createNestedToolbarDropdown(definition, componentFactory, removeItems) {
        let { label, icon, items, tooltip: tooltip2 = true, withText = false } = definition;
        items = this._cleanItemsConfiguration(items, componentFactory, removeItems);
        if (!items.length) {
          return null;
        }
        const locale = this.locale;
        const dropdownView = createDropdown(locale);
        if (!label) {
          logWarning("toolbarview-nested-toolbar-dropdown-missing-label", definition);
        }
        dropdownView.class = "ck-toolbar__nested-toolbar-dropdown";
        dropdownView.buttonView.set({
          label,
          tooltip: tooltip2,
          withText: !!withText
        });
        if (icon !== false) {
          dropdownView.buttonView.icon = NESTED_TOOLBAR_ICONS[icon] || icon || icons.threeVerticalDots;
        } else {
          dropdownView.buttonView.withText = true;
        }
        addToolbarToDropdown(dropdownView, () => dropdownView.toolbarView._buildItemsFromConfig(items, componentFactory, removeItems));
        return dropdownView;
      }
    }
    class ItemsView extends View {
      /**
      * @inheritDoc
      */
      constructor(locale) {
        super(locale);
        /**
        * A collection of items (buttons, dropdowns, etc.).
        */
        __publicField(this, "children");
        this.children = this.createCollection();
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-toolbar__items"
            ]
          },
          children: this.children
        });
      }
    }
    class StaticLayout {
      /**
      * Creates an instance of the {@link module:ui/toolbar/toolbarview~StaticLayout} toolbar
      * behavior.
      *
      * @param view An instance of the toolbar that this behavior is added to.
      */
      constructor(view) {
        const bind2 = view.bindTemplate;
        view.set("isVertical", false);
        view.itemsView.children.bindTo(view.items).using((item) => item);
        view.focusables.bindTo(view.items).using((item) => isFocusable(item) ? item : null);
        view.extendTemplate({
          attributes: {
            class: [
              // When vertical, the toolbar has an additional CSS class.
              bind2.if("isVertical", "ck-toolbar_vertical")
            ]
          }
        });
      }
      /**
      * @inheritDoc
      */
      render() {
      }
      /**
      * @inheritDoc
      */
      destroy() {
      }
    }
    class DynamicGrouping {
      /**
      * Creates an instance of the {@link module:ui/toolbar/toolbarview~DynamicGrouping} toolbar
      * behavior.
      *
      * @param view An instance of the toolbar that this behavior is added to.
      */
      constructor(view) {
        /**
        * A toolbar view this behavior belongs to.
        */
        __publicField(this, "view");
        /**
        * A collection of toolbar children.
        */
        __publicField(this, "viewChildren");
        /**
        * A collection of focusable toolbar elements.
        */
        __publicField(this, "viewFocusables");
        /**
        * A view containing toolbar items.
        */
        __publicField(this, "viewItemsView");
        /**
        * Toolbar focus tracker.
        */
        __publicField(this, "viewFocusTracker");
        /**
        * Toolbar locale.
        */
        __publicField(this, "viewLocale");
        /**
        * A subset of toolbar {@link module:ui/toolbar/toolbarview~ToolbarView#items}.
        * Aggregates items that fit into a single row of the toolbar and were not {@link #groupedItems grouped}
        * into a {@link #groupedItemsDropdown dropdown}. Items of this collection are displayed in the
        * {@link module:ui/toolbar/toolbarview~ToolbarView#itemsView}.
        *
        * When none of the {@link module:ui/toolbar/toolbarview~ToolbarView#items} were grouped, it
        * matches the {@link module:ui/toolbar/toolbarview~ToolbarView#items} collection in size and order.
        */
        __publicField(this, "ungroupedItems");
        /**
        * A subset of toolbar {@link module:ui/toolbar/toolbarview~ToolbarView#items}.
        * A collection of the toolbar items that do not fit into a single row of the toolbar.
        * Grouped items are displayed in a dedicated {@link #groupedItemsDropdown dropdown}.
        *
        * When none of the {@link module:ui/toolbar/toolbarview~ToolbarView#items} were grouped,
        * this collection is empty.
        */
        __publicField(this, "groupedItems");
        /**
        * The dropdown that aggregates {@link #groupedItems grouped items} that do not fit into a single
        * row of the toolbar. It is displayed on demand as the last of
        * {@link module:ui/toolbar/toolbarview~ToolbarView#children toolbar children} and offers another
        * (nested) toolbar which displays items that would normally overflow.
        */
        __publicField(this, "groupedItemsDropdown");
        /**
        * An instance of the resize observer that helps dynamically determine the geometry of the toolbar
        * and manage items that do not fit into a single row.
        *
        * **Note:** Created in {@link #_enableGroupingOnResize}.
        *
        * @readonly
        */
        __publicField(this, "resizeObserver", null);
        /**
        * A cached value of the horizontal padding style used by {@link #_updateGrouping}
        * to manage the {@link module:ui/toolbar/toolbarview~ToolbarView#items} that do not fit into
        * a single toolbar line. This value can be reused between updates because it is unlikely that
        * the padding will change and reusing `Window.getComputedStyle()` is expensive.
        *
        * @readonly
        */
        __publicField(this, "cachedPadding", null);
        /**
        * A flag indicating that an items grouping update has been queued (e.g. due to the toolbar being visible)
        * and should be executed immediately the next time the toolbar shows up.
        *
        * @readonly
        */
        __publicField(this, "shouldUpdateGroupingOnNextResize", false);
        /**
        * Toolbar element.
        *
        * @readonly
        */
        __publicField(this, "viewElement");
        this.view = view;
        this.viewChildren = view.children;
        this.viewFocusables = view.focusables;
        this.viewItemsView = view.itemsView;
        this.viewFocusTracker = view.focusTracker;
        this.viewLocale = view.locale;
        this.ungroupedItems = view.createCollection();
        this.groupedItems = view.createCollection();
        this.groupedItemsDropdown = this._createGroupedItemsDropdown();
        view.itemsView.children.bindTo(this.ungroupedItems).using((item) => item);
        this.ungroupedItems.on("change", this._updateFocusCyclableItems.bind(this));
        view.children.on("change", this._updateFocusCyclableItems.bind(this));
        view.items.on("change", (evt, changeData) => {
          const index = changeData.index;
          const added = Array.from(changeData.added);
          for (const removedItem of changeData.removed) {
            if (index >= this.ungroupedItems.length) {
              this.groupedItems.remove(removedItem);
            } else {
              this.ungroupedItems.remove(removedItem);
            }
          }
          for (let currentIndex = index; currentIndex < index + added.length; currentIndex++) {
            const addedItem = added[currentIndex - index];
            if (currentIndex > this.ungroupedItems.length) {
              this.groupedItems.add(addedItem, currentIndex - this.ungroupedItems.length);
            } else {
              this.ungroupedItems.add(addedItem, currentIndex);
            }
          }
          this._updateGrouping();
        });
        view.extendTemplate({
          attributes: {
            class: [
              // To group items dynamically, the toolbar needs a dedicated CSS class.
              "ck-toolbar_grouping"
            ]
          }
        });
      }
      /**
      * Enables dynamic items grouping based on the dimensions of the toolbar.
      *
      * @param view An instance of the toolbar that this behavior is added to.
      */
      render(view) {
        this.viewElement = view.element;
        this._enableGroupingOnResize();
        this._enableGroupingOnMaxWidthChange(view);
      }
      /**
      * Cleans up the internals used by this behavior.
      */
      destroy() {
        this.groupedItemsDropdown.destroy();
        this.resizeObserver.destroy();
      }
      /**
      * When called, it will check if any of the {@link #ungroupedItems} do not fit into a single row of the toolbar,
      * and it will move them to the {@link #groupedItems} when it happens.
      *
      * At the same time, it will also check if there is enough space in the toolbar for the first of the
      * {@link #groupedItems} to be returned back to {@link #ungroupedItems} and still fit into a single row
      * without the toolbar wrapping.
      */
      _updateGrouping() {
        if (!this.viewElement.ownerDocument.body.contains(this.viewElement)) {
          return;
        }
        if (!isVisible(this.viewElement)) {
          this.shouldUpdateGroupingOnNextResize = true;
          return;
        }
        const initialGroupedItemsCount = this.groupedItems.length;
        let wereItemsGrouped;
        while (this._areItemsOverflowing) {
          this._groupLastItem();
          wereItemsGrouped = true;
        }
        if (!wereItemsGrouped && this.groupedItems.length) {
          while (this.groupedItems.length && !this._areItemsOverflowing) {
            this._ungroupFirstItem();
          }
          if (this._areItemsOverflowing) {
            this._groupLastItem();
          }
        }
        if (this.groupedItems.length !== initialGroupedItemsCount) {
          this.view.fire("groupedItemsUpdate");
        }
      }
      /**
      * Returns `true` when {@link module:ui/toolbar/toolbarview~ToolbarView#element} children visually overflow,
      * for instance if the toolbar is narrower than its members. Returns `false` otherwise.
      */
      get _areItemsOverflowing() {
        if (!this.ungroupedItems.length) {
          return false;
        }
        const element = this.viewElement;
        const uiLanguageDirection = this.viewLocale.uiLanguageDirection;
        const lastChildRect = new Rect(element.lastChild);
        const toolbarRect = new Rect(element);
        if (!this.cachedPadding) {
          const computedStyle = global$1.window.getComputedStyle(element);
          const paddingProperty = uiLanguageDirection === "ltr" ? "paddingRight" : "paddingLeft";
          this.cachedPadding = Number.parseInt(computedStyle[paddingProperty]);
        }
        if (uiLanguageDirection === "ltr") {
          return lastChildRect.right > toolbarRect.right - this.cachedPadding;
        } else {
          return lastChildRect.left < toolbarRect.left + this.cachedPadding;
        }
      }
      /**
      * Enables the functionality that prevents {@link #ungroupedItems} from overflowing (wrapping to the next row)
      * upon resize when there is little space available. Instead, the toolbar items are moved to the
      * {@link #groupedItems} collection and displayed in a dropdown at the end of the row (which has its own nested toolbar).
      *
      * When called, the toolbar will automatically analyze the location of its {@link #ungroupedItems} and "group"
      * them in the dropdown if necessary. It will also observe the browser window for size changes in
      * the future and respond to them by grouping more items or reverting already grouped back, depending
      * on the visual space available.
      */
      _enableGroupingOnResize() {
        let previousWidth;
        this.resizeObserver = new ResizeObserver$1(this.viewElement, (entry) => {
          if (!previousWidth || previousWidth !== entry.contentRect.width || this.shouldUpdateGroupingOnNextResize) {
            this.shouldUpdateGroupingOnNextResize = false;
            this._updateGrouping();
            previousWidth = entry.contentRect.width;
          }
        });
        this._updateGrouping();
      }
      /**
      * Enables the grouping functionality, just like {@link #_enableGroupingOnResize} but the difference is that
      * it listens to the changes of {@link module:ui/toolbar/toolbarview~ToolbarView#maxWidth} instead.
      */
      _enableGroupingOnMaxWidthChange(view) {
        view.on("change:maxWidth", () => {
          this._updateGrouping();
        });
      }
      /**
      * When called, it will remove the last item from {@link #ungroupedItems} and move it back
      * to the {@link #groupedItems} collection.
      *
      * The opposite of {@link #_ungroupFirstItem}.
      */
      _groupLastItem() {
        if (!this.groupedItems.length) {
          this.viewChildren.add(new ToolbarSeparatorView());
          this.viewChildren.add(this.groupedItemsDropdown);
          this.viewFocusTracker.add(this.groupedItemsDropdown.element);
        }
        this.groupedItems.add(this.ungroupedItems.remove(this.ungroupedItems.last), 0);
      }
      /**
      * Moves the very first item belonging to {@link #groupedItems} back
      * to the {@link #ungroupedItems} collection.
      *
      * The opposite of {@link #_groupLastItem}.
      */
      _ungroupFirstItem() {
        this.ungroupedItems.add(this.groupedItems.remove(this.groupedItems.first));
        if (!this.groupedItems.length) {
          this.viewChildren.remove(this.groupedItemsDropdown);
          this.viewChildren.remove(this.viewChildren.last);
          this.viewFocusTracker.remove(this.groupedItemsDropdown.element);
        }
      }
      /**
      * Creates the {@link #groupedItemsDropdown} that hosts the members of the {@link #groupedItems}
      * collection when there is not enough space in the toolbar to display all items in a single row.
      */
      _createGroupedItemsDropdown() {
        const locale = this.viewLocale;
        const t2 = locale.t;
        const dropdown2 = createDropdown(locale);
        dropdown2.class = "ck-toolbar__grouped-dropdown";
        dropdown2.panelPosition = locale.uiLanguageDirection === "ltr" ? "sw" : "se";
        addToolbarToDropdown(dropdown2, this.groupedItems);
        dropdown2.buttonView.set({
          label: t2("Show more items"),
          tooltip: true,
          tooltipPosition: locale.uiLanguageDirection === "rtl" ? "se" : "sw",
          icon: icons.threeVerticalDots
        });
        return dropdown2;
      }
      /**
      * Updates the {@link module:ui/toolbar/toolbarview~ToolbarView#focusables focuscyclable items}
      * collection so it represents the uptodate state of the UI from the perspective of the user.
      *
      * For instance, the {@link #groupedItemsDropdown} can show up and hide but when it is visible,
      * it must be subject to focus cycling in the toolbar.
      *
      * See the {@link module:ui/toolbar/toolbarview~ToolbarView#focusables collection} documentation
      * to learn more about the purpose of this method.
      */
      _updateFocusCyclableItems() {
        this.viewFocusables.clear();
        this.ungroupedItems.map((item) => {
          if (isFocusable(item)) {
            this.viewFocusables.add(item);
          }
        });
        if (this.groupedItems.length) {
          this.viewFocusables.add(this.groupedItemsDropdown);
        }
      }
    }
    class SplitButtonView extends View {
      /**
      * @inheritDoc
      */
      constructor(locale, actionButton2) {
        super(locale);
        /**
        * Collection of the child views inside of the split button {@link #element}.
        */
        __publicField(this, "children");
        /**
        * A main button of split button.
        */
        __publicField(this, "actionView");
        /**
        * A secondary button of split button that opens dropdown.
        */
        __publicField(this, "arrowView");
        /**
        * Instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}. It manages
        * keystrokes of the split button:
        *
        * * <kbd></kbd> moves focus to arrow view when action view is focused,
        * * <kbd></kbd> moves focus to action view when arrow view is focused.
        */
        __publicField(this, "keystrokes");
        /**
        * Tracks information about DOM focus in the dropdown.
        */
        __publicField(this, "focusTracker");
        const bind2 = this.bindTemplate;
        this.set("class", void 0);
        this.set("labelStyle", void 0);
        this.set("icon", void 0);
        this.set("isEnabled", true);
        this.set("isOn", false);
        this.set("isToggleable", false);
        this.set("isVisible", true);
        this.set("keystroke", void 0);
        this.set("withKeystroke", false);
        this.set("label", void 0);
        this.set("tabindex", -1);
        this.set("tooltip", false);
        this.set("tooltipPosition", "s");
        this.set("type", "button");
        this.set("withText", false);
        this.children = this.createCollection();
        this.actionView = this._createActionView(actionButton2);
        this.arrowView = this._createArrowView();
        this.keystrokes = new KeystrokeHandler();
        this.focusTracker = new FocusTracker();
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-splitbutton",
              bind2.to("class"),
              bind2.if("isVisible", "ck-hidden", (value) => !value),
              this.arrowView.bindTemplate.if("isOn", "ck-splitbutton_open")
            ]
          },
          children: this.children
        });
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        this.children.add(this.actionView);
        this.children.add(this.arrowView);
        this.focusTracker.add(this.actionView.element);
        this.focusTracker.add(this.arrowView.element);
        this.keystrokes.listenTo(this.element);
        this.keystrokes.set("arrowright", (evt, cancel2) => {
          if (this.focusTracker.focusedElement === this.actionView.element) {
            this.arrowView.focus();
            cancel2();
          }
        });
        this.keystrokes.set("arrowleft", (evt, cancel2) => {
          if (this.focusTracker.focusedElement === this.arrowView.element) {
            this.actionView.focus();
            cancel2();
          }
        });
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        this.focusTracker.destroy();
        this.keystrokes.destroy();
      }
      /**
      * Focuses the {@link module:ui/button/buttonview~ButtonView#element} of the action part of split button.
      */
      focus() {
        this.actionView.focus();
      }
      /**
      * Creates a {@link module:ui/button/buttonview~ButtonView} instance as {@link #actionView} and binds it with main split button
      * attributes.
      */
      _createActionView(actionButton2) {
        const actionView = actionButton2 || new ButtonView();
        if (!actionButton2) {
          actionView.bind("icon", "isEnabled", "isOn", "isToggleable", "keystroke", "label", "tabindex", "tooltip", "tooltipPosition", "type", "withText").to(this);
        }
        actionView.extendTemplate({
          attributes: {
            class: "ck-splitbutton__action"
          }
        });
        actionView.delegate("execute").to(this);
        return actionView;
      }
      /**
      * Creates a {@link module:ui/button/buttonview~ButtonView} instance as {@link #arrowView} and binds it with main split button
      * attributes.
      */
      _createArrowView() {
        const arrowView = new ButtonView();
        const bind2 = arrowView.bindTemplate;
        arrowView.icon = dropdownArrowIcon;
        arrowView.extendTemplate({
          attributes: {
            class: [
              "ck-splitbutton__arrow"
            ],
            "data-cke-tooltip-disabled": bind2.to("isOn"),
            "aria-haspopup": true,
            "aria-expanded": bind2.to("isOn", (value) => String(value))
          }
        });
        arrowView.bind("isEnabled").to(this);
        arrowView.bind("label").to(this);
        arrowView.bind("tooltip").to(this);
        arrowView.delegate("execute").to(this, "open");
        return arrowView;
      }
    }
    function createDropdown(locale, ButtonClassOrInstance = DropdownButtonView) {
      const buttonView = typeof ButtonClassOrInstance == "function" ? new ButtonClassOrInstance(locale) : ButtonClassOrInstance;
      const panelView = new DropdownPanelView(locale);
      const dropdownView = new DropdownView(locale, buttonView, panelView);
      buttonView.bind("isEnabled").to(dropdownView);
      if (buttonView instanceof SplitButtonView) {
        buttonView.arrowView.bind("isOn").to(dropdownView, "isOpen");
      } else {
        buttonView.bind("isOn").to(dropdownView, "isOpen");
      }
      addDefaultBehaviors(dropdownView);
      return dropdownView;
    }
    function addToolbarToDropdown(dropdownView, buttonsOrCallback, options = {}) {
      dropdownView.extendTemplate({
        attributes: {
          class: [
            "ck-toolbar-dropdown"
          ]
        }
      });
      if (dropdownView.isOpen) {
        addToolbarToOpenDropdown(dropdownView, buttonsOrCallback, options);
      } else {
        dropdownView.once("change:isOpen", () => addToolbarToOpenDropdown(dropdownView, buttonsOrCallback, options), {
          priority: "highest"
        });
      }
      if (options.enableActiveItemFocusOnDropdownOpen) {
        focusChildOnDropdownOpen(dropdownView, () => dropdownView.toolbarView.items.find((item) => item.isOn));
      }
    }
    function addToolbarToOpenDropdown(dropdownView, buttonsOrCallback, options) {
      const locale = dropdownView.locale;
      const t2 = locale.t;
      const toolbarView = dropdownView.toolbarView = new ToolbarView(locale);
      const buttons = typeof buttonsOrCallback == "function" ? buttonsOrCallback() : buttonsOrCallback;
      toolbarView.ariaLabel = options.ariaLabel || t2("Dropdown toolbar");
      if (options.maxWidth) {
        toolbarView.maxWidth = options.maxWidth;
      }
      if (options.class) {
        toolbarView.class = options.class;
      }
      if (options.isCompact) {
        toolbarView.isCompact = options.isCompact;
      }
      if (options.isVertical) {
        toolbarView.isVertical = true;
      }
      if (buttons instanceof ViewCollection) {
        toolbarView.items.bindTo(buttons).using((item) => item);
      } else {
        toolbarView.items.addMany(buttons);
      }
      dropdownView.panelView.children.add(toolbarView);
      dropdownView.focusTracker.add(toolbarView);
      toolbarView.items.delegate("execute").to(dropdownView);
    }
    function addListToDropdown(dropdownView, itemsOrCallback, options = {}) {
      if (dropdownView.isOpen) {
        addListToOpenDropdown(dropdownView, itemsOrCallback, options);
      } else {
        dropdownView.once("change:isOpen", () => addListToOpenDropdown(dropdownView, itemsOrCallback, options), {
          priority: "highest"
        });
      }
      focusChildOnDropdownOpen(dropdownView, () => dropdownView.listView.items.find((item) => {
        if (item instanceof ListItemView) {
          return item.children.first.isOn;
        }
        return false;
      }));
    }
    function addListToOpenDropdown(dropdownView, itemsOrCallback, options) {
      const locale = dropdownView.locale;
      const listView = dropdownView.listView = new ListView(locale);
      const items = typeof itemsOrCallback == "function" ? itemsOrCallback() : itemsOrCallback;
      listView.ariaLabel = options.ariaLabel;
      listView.role = options.role;
      bindViewCollectionItemsToDefinitions(dropdownView, listView.items, items, locale);
      dropdownView.panelView.children.add(listView);
      listView.items.delegate("execute").to(dropdownView);
    }
    function focusChildOnDropdownOpen(dropdownView, childSelectorCallback) {
      dropdownView.on("change:isOpen", () => {
        if (!dropdownView.isOpen) {
          return;
        }
        const childToFocus = childSelectorCallback();
        if (!childToFocus) {
          return;
        }
        if (typeof childToFocus.focus === "function") {
          childToFocus.focus();
        } else {
          logWarning("ui-dropdown-focus-child-on-open-child-missing-focus", {
            view: childToFocus
          });
        }
      }, {
        priority: priorities.low - 10
      });
    }
    function addDefaultBehaviors(dropdownView) {
      closeDropdownOnClickOutside(dropdownView);
      closeDropdownOnExecute(dropdownView);
      closeDropdownOnBlur(dropdownView);
      focusDropdownContentsOnArrows(dropdownView);
      focusDropdownButtonOnClose(dropdownView);
      focusDropdownPanelOnOpen(dropdownView);
    }
    function closeDropdownOnClickOutside(dropdownView) {
      clickOutsideHandler({
        emitter: dropdownView,
        activator: () => dropdownView.isRendered && dropdownView.isOpen,
        callback: () => {
          dropdownView.isOpen = false;
        },
        contextElements: () => [
          dropdownView.element,
          // Include all elements connected to the dropdown's focus tracker, but exclude those that are direct children
          // of DropdownView#element. They would be identified as descendants of #element anyway upon clicking and would
          // not contribute to the logic.
          ...getFocusTrackerTreeElements(dropdownView.focusTracker).filter((element) => !dropdownView.element.contains(element))
        ]
      });
    }
    function getFocusTrackerTreeElements(focusTracker) {
      return [
        ...focusTracker.elements,
        ...focusTracker.externalViews.flatMap((view) => getFocusTrackerTreeElements(view.focusTracker))
      ];
    }
    function closeDropdownOnExecute(dropdownView) {
      dropdownView.on("execute", (evt) => {
        if (evt.source instanceof SwitchButtonView) {
          return;
        }
        dropdownView.isOpen = false;
      });
    }
    function closeDropdownOnBlur(dropdownView) {
      dropdownView.focusTracker.on("change:isFocused", (evt, name, isFocused) => {
        if (isFocused || !dropdownView.isOpen) {
          return;
        }
        dropdownView.isOpen = false;
      });
    }
    function focusDropdownContentsOnArrows(dropdownView) {
      dropdownView.keystrokes.set("arrowdown", (data, cancel2) => {
        if (dropdownView.isOpen) {
          dropdownView.panelView.focus();
          cancel2();
        }
      });
      dropdownView.keystrokes.set("arrowup", (data, cancel2) => {
        if (dropdownView.isOpen) {
          dropdownView.panelView.focusLast();
          cancel2();
        }
      });
    }
    function focusDropdownButtonOnClose(dropdownView) {
      dropdownView.on("change:isOpen", (evt, name, isOpen) => {
        if (isOpen) {
          return;
        }
        const elements2 = dropdownView.focusTracker.elements;
        if (elements2.some((element) => element.contains(global$1.document.activeElement))) {
          dropdownView.buttonView.focus();
        }
      });
    }
    function focusDropdownPanelOnOpen(dropdownView) {
      dropdownView.on("change:isOpen", (evt, name, isOpen) => {
        if (!isOpen) {
          return;
        }
        dropdownView.panelView.focus();
      }, {
        priority: "low"
      });
    }
    function bindViewCollectionItemsToDefinitions(dropdownView, listItems, definitions, locale) {
      listItems.on("change", () => {
        const listItemButtons = [
          ...listItems
        ].reduce((acc, item) => {
          if (item instanceof ListItemView && item.children.first instanceof ListItemButtonView) {
            acc.push(item.children.first);
          }
          return acc;
        }, []);
        const hasAnyCheckboxOnList = listItemButtons.some((button) => button.isToggleable);
        listItemButtons.forEach((item) => {
          item.hasCheckSpace = hasAnyCheckboxOnList;
        });
      });
      listItems.bindTo(definitions).using((def) => {
        if (def.type === "separator") {
          return new ListSeparatorView(locale);
        } else if (def.type === "group") {
          const groupView = new ListItemGroupView(locale);
          groupView.set({
            label: def.label
          });
          bindViewCollectionItemsToDefinitions(dropdownView, groupView.items, def.items, locale);
          groupView.items.delegate("execute").to(dropdownView);
          return groupView;
        } else if (def.type === "button" || def.type === "switchbutton") {
          const isToggleable = def.model.role === "menuitemcheckbox" || def.model.role === "menuitemradio";
          const listItemView = new ListItemView(locale);
          let buttonView;
          if (def.type === "button") {
            buttonView = new ListItemButtonView(locale);
            buttonView.set({
              isToggleable
            });
          } else {
            buttonView = new SwitchButtonView(locale);
          }
          buttonView.bind(...Object.keys(def.model)).to(def.model);
          buttonView.delegate("execute").to(listItemView);
          listItemView.children.add(buttonView);
          return listItemView;
        }
        return null;
      });
    }
    const createLabeledInputText = (labeledFieldView, viewUid, statusUid) => {
      const inputView = new InputTextView(labeledFieldView.locale);
      inputView.set({
        id: viewUid,
        ariaDescribedById: statusUid
      });
      inputView.bind("isReadOnly").to(labeledFieldView, "isEnabled", (value) => !value);
      inputView.bind("hasError").to(labeledFieldView, "errorText", (value) => !!value);
      inputView.on("input", () => {
        labeledFieldView.errorText = null;
      });
      labeledFieldView.bind("isEmpty", "isFocused", "placeholder").to(inputView);
      return inputView;
    };
    class ComponentFactory {
      /**
      * Creates an instance of the factory.
      *
      * @param editor The editor instance.
      */
      constructor(editor2) {
        /**
        * The editor instance that the factory belongs to.
        */
        __publicField(this, "editor");
        /**
        * Registered component factories.
        */
        __publicField(this, "_components", /* @__PURE__ */ new Map());
        this.editor = editor2;
      }
      /**
      * Returns an iterator of registered component names. Names are returned in lower case.
      */
      *names() {
        for (const value of this._components.values()) {
          yield value.originalName;
        }
      }
      /**
      * Registers a component factory function that will be used by the
      * {@link #create create} method and called with the
      * {@link module:core/editor/editor~Editor#locale editor locale} as an argument,
      * allowing localization of the {@link module:ui/view~View view}.
      *
      * @param name The name of the component.
      * @param callback The callback that returns the component.
      */
      add(name, callback) {
        this._components.set(getNormalized(name), {
          callback,
          originalName: name
        });
      }
      /**
      * Creates an instance of a component registered in the factory under a specific name.
      *
      * When called, the {@link module:core/editor/editor~Editor#locale editor locale} is passed to
      * the previously {@link #add added} factory function, allowing localization of the
      * {@link module:ui/view~View view}.
      *
      * @param name The name of the component.
      * @returns The instantiated component view.
      */
      create(name) {
        if (!this.has(name)) {
          throw new CKEditorError("componentfactory-item-missing", this, {
            name
          });
        }
        return this._components.get(getNormalized(name)).callback(this.editor.locale);
      }
      /**
      * Checks if a component of a given name is registered in the factory.
      *
      * @param name The name of the component.
      */
      has(name) {
        return this._components.has(getNormalized(name));
      }
    }
    function getNormalized(name) {
      return String(name).toLowerCase();
    }
    const BALLOON_CLASS = "ck-tooltip";
    const _TooltipManager = class _TooltipManager extends (/* @__PURE__ */ DomEmitterMixin()) {
      /**
      * Creates an instance of the tooltip manager.
      */
      constructor(editor2) {
        super();
        /**
        * The view rendering text of the tooltip.
        */
        __publicField(this, "tooltipTextView");
        /**
        * The instance of the balloon panel that renders and positions the tooltip.
        */
        __publicField(this, "balloonPanelView");
        /**
        * Stores the reference to the DOM element the tooltip is attached to. `null` when there's no tooltip
        * in the UI.
        */
        __publicField(this, "_currentElementWithTooltip", null);
        /**
        * Stores the current tooltip position. `null` when there's no tooltip in the UI.
        */
        __publicField(this, "_currentTooltipPosition", null);
        /**
        * An instance of the mutation observer that keeps track on target element attributes changes.
        */
        __publicField(this, "_mutationObserver", null);
        /**
        * A debounced version of {@link #_pinTooltip}. Tooltips show with a delay to avoid flashing and
        * to improve the UX.
        */
        __publicField(this, "_pinTooltipDebounced");
        /**
        * A debounced version of {@link #_unpinTooltip}. Tooltips hide with a delay to allow hovering of their titles.
        */
        __publicField(this, "_unpinTooltipDebounced");
        __publicField(this, "_watchdogExcluded");
        _TooltipManager._editors.add(editor2);
        if (_TooltipManager._instance) {
          return _TooltipManager._instance;
        }
        _TooltipManager._instance = this;
        this.tooltipTextView = new View(editor2.locale);
        this.tooltipTextView.set("text", "");
        this.tooltipTextView.setTemplate({
          tag: "span",
          attributes: {
            class: [
              "ck",
              "ck-tooltip__text"
            ]
          },
          children: [
            {
              text: this.tooltipTextView.bindTemplate.to("text")
            }
          ]
        });
        this.balloonPanelView = new BalloonPanelView(editor2.locale);
        this.balloonPanelView.class = BALLOON_CLASS;
        this.balloonPanelView.content.add(this.tooltipTextView);
        this._mutationObserver = createMutationObserver(() => {
          this._updateTooltipPosition();
        });
        this._pinTooltipDebounced = debounce$1(this._pinTooltip, 600);
        this._unpinTooltipDebounced = debounce$1(this._unpinTooltip, 400);
        this.listenTo(global$1.document, "keydown", this._onKeyDown.bind(this), {
          useCapture: true
        });
        this.listenTo(global$1.document, "mouseenter", this._onEnterOrFocus.bind(this), {
          useCapture: true
        });
        this.listenTo(global$1.document, "mouseleave", this._onLeaveOrBlur.bind(this), {
          useCapture: true
        });
        this.listenTo(global$1.document, "focus", this._onEnterOrFocus.bind(this), {
          useCapture: true
        });
        this.listenTo(global$1.document, "blur", this._onLeaveOrBlur.bind(this), {
          useCapture: true
        });
        this.listenTo(global$1.document, "scroll", this._onScroll.bind(this), {
          useCapture: true
        });
        this._watchdogExcluded = true;
      }
      /**
      * Destroys the tooltip manager.
      *
      * **Note**: The manager singleton cannot be destroyed until all editors that use it are destroyed.
      *
      * @param editor The editor the manager was created for.
      */
      destroy(editor2) {
        const editorBodyViewCollection = editor2.ui.view && editor2.ui.view.body;
        _TooltipManager._editors.delete(editor2);
        this.stopListening(editor2.ui);
        if (editorBodyViewCollection && editorBodyViewCollection.has(this.balloonPanelView)) {
          editorBodyViewCollection.remove(this.balloonPanelView);
        }
        if (!_TooltipManager._editors.size) {
          this._unpinTooltip();
          this.balloonPanelView.destroy();
          this.stopListening();
          _TooltipManager._instance = null;
        }
      }
      /**
      * Returns {@link #balloonPanelView} {@link module:utils/dom/position~PositioningFunction positioning functions} for a given position
      * name.
      *
      * @param position Name of the position (`s`, `se`, `sw`, `n`, `e`, or `w`).
      * @returns Positioning functions to be used by the {@link #balloonPanelView}.
      */
      static getPositioningFunctions(position) {
        const defaultPositions = _TooltipManager.defaultBalloonPositions;
        return {
          // South is most popular. We can use positioning heuristics to avoid clipping by the viewport with the sane fallback.
          s: [
            defaultPositions.southArrowNorth,
            defaultPositions.southArrowNorthEast,
            defaultPositions.southArrowNorthWest
          ],
          n: [
            defaultPositions.northArrowSouth
          ],
          e: [
            defaultPositions.eastArrowWest
          ],
          w: [
            defaultPositions.westArrowEast
          ],
          sw: [
            defaultPositions.southArrowNorthEast
          ],
          se: [
            defaultPositions.southArrowNorthWest
          ]
        }[position];
      }
      /**
      * Handles hiding tooltips on `keydown` in DOM.
      *
      * @param evt An object containing information about the fired event.
      * @param domEvent The DOM event.
      */
      _onKeyDown(evt, domEvent) {
        if (domEvent.key === "Escape" && this._currentElementWithTooltip) {
          this._unpinTooltip();
          domEvent.stopPropagation();
        }
      }
      /**
      * Handles displaying tooltips on `mouseenter` and `focus` in DOM.
      *
      * @param evt An object containing information about the fired event.
      * @param domEvent The DOM event.
      */
      _onEnterOrFocus(evt, { target }) {
        const elementWithTooltipAttribute = getDescendantWithTooltip(target);
        if (!elementWithTooltipAttribute) {
          if (evt.name === "focus") {
            this._unpinTooltip();
          }
          return;
        }
        if (elementWithTooltipAttribute === this._currentElementWithTooltip) {
          return;
        }
        this._unpinTooltip();
        if (evt.name === "focus" && !elementWithTooltipAttribute.matches(":hover")) {
          this._pinTooltip(elementWithTooltipAttribute, getTooltipData(elementWithTooltipAttribute));
        } else {
          this._pinTooltipDebounced(elementWithTooltipAttribute, getTooltipData(elementWithTooltipAttribute));
        }
      }
      /**
      * Handles hiding tooltips on `mouseleave` and `blur` in DOM.
      *
      * @param evt An object containing information about the fired event.
      * @param domEvent The DOM event.
      */
      _onLeaveOrBlur(evt, { target, relatedTarget }) {
        if (evt.name === "mouseleave") {
          if (!isElement$3(target)) {
            return;
          }
          const balloonElement = this.balloonPanelView.element;
          const isEnteringBalloon = balloonElement && (balloonElement === relatedTarget || balloonElement.contains(relatedTarget));
          const isLeavingBalloon = !isEnteringBalloon && target === balloonElement;
          if (isEnteringBalloon) {
            this._unpinTooltipDebounced.cancel();
            return;
          }
          if (!isLeavingBalloon && this._currentElementWithTooltip && target !== this._currentElementWithTooltip) {
            return;
          }
          const descendantWithTooltip = getDescendantWithTooltip(target);
          const relatedDescendantWithTooltip = getDescendantWithTooltip(relatedTarget);
          if (isLeavingBalloon || descendantWithTooltip && descendantWithTooltip !== relatedDescendantWithTooltip) {
            this._unpinTooltipDebounced();
          }
        } else {
          if (this._currentElementWithTooltip && target !== this._currentElementWithTooltip) {
            return;
          }
          this._unpinTooltipDebounced();
        }
      }
      /**
      * Handles hiding tooltips on `scroll` in DOM.
      *
      * @param evt An object containing information about the fired event.
      * @param domEvent The DOM event.
      */
      _onScroll(evt, { target }) {
        if (!this._currentElementWithTooltip) {
          return;
        }
        if (target.contains(this.balloonPanelView.element) && target.contains(this._currentElementWithTooltip)) {
          return;
        }
        this._unpinTooltip();
      }
      /**
      * Pins the tooltip to a specific DOM element.
      *
      * @param options.text Text of the tooltip to display.
      * @param options.position The position of the tooltip.
      * @param options.cssClass Additional CSS class of the balloon with the tooltip.
      */
      _pinTooltip(targetDomElement, { text: text2, position, cssClass }) {
        this._unpinTooltip();
        const bodyViewCollection = first(_TooltipManager._editors.values()).ui.view.body;
        if (!bodyViewCollection.has(this.balloonPanelView)) {
          bodyViewCollection.add(this.balloonPanelView);
        }
        this.tooltipTextView.text = text2;
        this.balloonPanelView.class = [
          BALLOON_CLASS,
          cssClass
        ].filter((className) => className).join(" ");
        this.balloonPanelView.pin({
          target: targetDomElement,
          positions: _TooltipManager.getPositioningFunctions(position)
        });
        this._mutationObserver.attach(targetDomElement);
        for (const editor2 of _TooltipManager._editors) {
          this.listenTo(editor2.ui, "update", this._updateTooltipPosition.bind(this), {
            priority: "low"
          });
        }
        this._currentElementWithTooltip = targetDomElement;
        this._currentTooltipPosition = position;
      }
      /**
      * Unpins the tooltip and cancels all queued pinning.
      */
      _unpinTooltip() {
        this._unpinTooltipDebounced.cancel();
        this._pinTooltipDebounced.cancel();
        this.balloonPanelView.unpin();
        for (const editor2 of _TooltipManager._editors) {
          this.stopListening(editor2.ui, "update");
        }
        this._currentElementWithTooltip = null;
        this._currentTooltipPosition = null;
        this.tooltipTextView.text = "";
        this._mutationObserver.detach();
      }
      /**
      * Updates the position of the tooltip so it stays in sync with the element it is pinned to.
      *
      * Hides the tooltip when the element is no longer visible in DOM or the tooltip text was removed.
      */
      _updateTooltipPosition() {
        if (!this._currentElementWithTooltip) {
          return;
        }
        const tooltipData = getTooltipData(this._currentElementWithTooltip);
        if (!isVisible(this._currentElementWithTooltip) || !tooltipData.text) {
          this._unpinTooltip();
          return;
        }
        this.balloonPanelView.pin({
          target: this._currentElementWithTooltip,
          positions: _TooltipManager.getPositioningFunctions(tooltipData.position)
        });
      }
    };
    /**
    * A set of default {@link module:utils/dom/position~PositioningFunction positioning functions} used by the `TooltipManager`
    * to pin tooltips in different positions.
    */
    __publicField(_TooltipManager, "defaultBalloonPositions", /* @__PURE__ */ BalloonPanelView.generatePositions({
      heightOffset: 5,
      sideOffset: 13
    }));
    /**
    * A set of editors the single tooltip manager instance must listen to.
    * This is mostly to handle `EditorUI#update` listeners from individual editors.
    */
    __publicField(_TooltipManager, "_editors", /* @__PURE__ */ new Set());
    /**
    * A reference to the `TooltipManager` instance. The class is a singleton and as such,
    * successive attempts at creating instances should return this instance.
    */
    __publicField(_TooltipManager, "_instance", null);
    let TooltipManager = _TooltipManager;
    function getDescendantWithTooltip(element) {
      if (!isElement$3(element)) {
        return null;
      }
      return element.closest("[data-cke-tooltip-text]:not([data-cke-tooltip-disabled])");
    }
    function getTooltipData(element) {
      return {
        text: element.dataset.ckeTooltipText,
        position: element.dataset.ckeTooltipPosition || "s",
        cssClass: element.dataset.ckeTooltipClass || ""
      };
    }
    function createMutationObserver(callback) {
      const mutationObserver = new MutationObserver(() => {
        callback();
      });
      return {
        attach(element) {
          mutationObserver.observe(element, {
            attributes: true,
            attributeFilter: [
              "data-cke-tooltip-text",
              "data-cke-tooltip-position"
            ]
          });
        },
        detach() {
          mutationObserver.disconnect();
        }
      };
    }
    var poweredByIcon = '<svg xmlns="http://www.w3.org/2000/svg" width="53" height="10" viewBox="0 0 53 10"><path fill="#1C2331" d="M31.724 1.492a15.139 15.139 0 0 0 .045 1.16 2.434 2.434 0 0 0-.687-.34 3.68 3.68 0 0 0-1.103-.166 2.332 2.332 0 0 0-1.14.255 1.549 1.549 0 0 0-.686.87c-.15.41-.225.98-.225 1.712 0 .939.148 1.659.444 2.161.297.503.792.754 1.487.754.452.015.9-.094 1.294-.316.296-.174.557-.4.771-.669l.14.852h1.282V.007h-1.623v1.485ZM31 6.496a1.77 1.77 0 0 1-.494.061.964.964 0 0 1-.521-.127.758.758 0 0 1-.296-.466 3.984 3.984 0 0 1-.093-.992 4.208 4.208 0 0 1 .098-1.052.753.753 0 0 1 .307-.477 1.08 1.08 0 0 1 .55-.122c.233-.004.466.026.69.089l.483.144v2.553c-.11.076-.213.143-.307.2a1.73 1.73 0 0 1-.417.189ZM35.68 0l-.702.004c-.322.002-.482.168-.48.497l.004.581c.002.33.164.493.486.49l.702-.004c.322-.002.481-.167.48-.496L36.165.49c-.002-.33-.164-.493-.486-.491ZM36.145 2.313l-1.612.01.034 5.482 1.613-.01-.035-5.482ZM39.623.79 37.989.8 38 2.306l-.946.056.006 1.009.949-.006.024 2.983c.003.476.143.844.419 1.106.275.26.658.39 1.148.387.132 0 .293-.01.483-.03.19-.02.38-.046.57-.08.163-.028.324-.068.482-.119l-.183-1.095-.702.004a.664.664 0 0 1-.456-.123.553.553 0 0 1-.14-.422l-.016-2.621 1.513-.01-.006-1.064-1.514.01-.01-1.503ZM46.226 2.388c-.41-.184-.956-.274-1.636-.27-.673.004-1.215.101-1.627.29-.402.179-.72.505-.888.91-.18.419-.268.979-.264 1.68.004.688.1 1.24.285 1.655.172.404.495.724.9.894.414.18.957.268 1.63.264.68-.004 1.224-.099 1.632-.284.4-.176.714-.501.878-.905.176-.418.263-.971.258-1.658-.004-.702-.097-1.261-.28-1.677a1.696 1.696 0 0 0-.888-.9Zm-.613 3.607a.77.77 0 0 1-.337.501 1.649 1.649 0 0 1-1.317.009.776.776 0 0 1-.343-.497 4.066 4.066 0 0 1-.105-1.02 4.136 4.136 0 0 1 .092-1.03.786.786 0 0 1 .337-.507 1.59 1.59 0 0 1 1.316-.008.79.79 0 0 1 .344.502c.078.337.113.683.105 1.03.012.343-.019.685-.092 1.02ZM52.114 2.07a2.67 2.67 0 0 0-1.128.278c-.39.191-.752.437-1.072.73l-.157-.846-1.273.008.036 5.572 1.623-.01-.024-3.78c.35-.124.646-.22.887-.286.26-.075.53-.114.8-.118l.45-.003.144-1.546-.286.001ZM22.083 7.426l-1.576-2.532a2.137 2.137 0 0 0-.172-.253 1.95 1.95 0 0 0-.304-.29.138.138 0 0 1 .042-.04 1.7 1.7 0 0 0 .328-.374l1.75-2.71c.01-.015.025-.028.024-.048-.01-.01-.021-.007-.031-.007L20.49 1.17a.078.078 0 0 0-.075.045l-.868 1.384c-.23.366-.46.732-.688 1.099a.108.108 0 0 1-.112.06c-.098-.005-.196-.001-.294-.002-.018 0-.038.006-.055-.007.002-.02.002-.039.005-.058a4.6 4.6 0 0 0 .046-.701V1.203c0-.02-.009-.032-.03-.03h-.033L16.93 1.17c-.084 0-.073-.01-.073.076v6.491c-.001.018.006.028.025.027h1.494c.083 0 .072.007.072-.071v-2.19c0-.055-.003-.11-.004-.166a3.366 3.366 0 0 0-.05-.417h.06c.104 0 .209.002.313-.002a.082.082 0 0 1 .084.05c.535.913 1.07 1.824 1.607 2.736a.104.104 0 0 0 .103.062c.554-.003 1.107-.002 1.66-.002l.069-.003-.019-.032-.188-.304ZM27.112 6.555c-.005-.08-.004-.08-.082-.08h-2.414c-.053 0-.106-.003-.159-.011a.279.279 0 0 1-.246-.209.558.558 0 0 1-.022-.15c0-.382 0-.762-.002-1.143 0-.032.007-.049.042-.044h2.504c.029.003.037-.012.034-.038V3.814c0-.089.013-.078-.076-.078h-2.44c-.07 0-.062.003-.062-.06v-.837c0-.047.004-.093.013-.14a.283.283 0 0 1 .241-.246.717.717 0 0 1 .146-.011h2.484c.024.002.035-.009.036-.033l.003-.038.03-.496c.01-.183.024-.365.034-.548.005-.085.003-.087-.082-.094-.218-.018-.437-.038-.655-.05a17.845 17.845 0 0 0-.657-.026 72.994 72.994 0 0 0-1.756-.016 1.7 1.7 0 0 0-.471.064 1.286 1.286 0 0 0-.817.655c-.099.196-.149.413-.145.633v3.875c0 .072.003.144.011.216a1.27 1.27 0 0 0 .711 1.029c.228.113.48.167.734.158.757-.005 1.515.002 2.272-.042.274-.016.548-.034.82-.053.03-.002.043-.008.04-.041-.008-.104-.012-.208-.019-.312a69.964 69.964 0 0 1-.05-.768ZM16.14 7.415l-.127-1.075c-.004-.03-.014-.04-.044-.037a13.125 13.125 0 0 1-.998.073c-.336.01-.672.02-1.008.016-.116-.001-.233-.014-.347-.039a.746.746 0 0 1-.45-.262c-.075-.1-.132-.211-.167-.33a3.324 3.324 0 0 1-.126-.773 9.113 9.113 0 0 1-.015-.749c0-.285.022-.57.065-.852.023-.158.066-.312.127-.46a.728.728 0 0 1 .518-.443 1.64 1.64 0 0 1 .397-.048c.628-.001 1.255.003 1.882.05.022.001.033-.006.036-.026l.003-.031.06-.55c.019-.177.036-.355.057-.532.004-.034-.005-.046-.04-.056a5.595 5.595 0 0 0-1.213-.21 10.783 10.783 0 0 0-.708-.02c-.24-.003-.48.01-.719.041a3.477 3.477 0 0 0-.625.14 1.912 1.912 0 0 0-.807.497c-.185.2-.33.433-.424.688a4.311 4.311 0 0 0-.24 1.096c-.031.286-.045.572-.042.86-.006.43.024.86.091 1.286.04.25.104.497.193.734.098.279.26.53.473.734.214.205.473.358.756.446.344.11.702.17 1.063.177a8.505 8.505 0 0 0 1.578-.083 6.11 6.11 0 0 0 .766-.18c.03-.008.047-.023.037-.057a.157.157 0 0 1-.003-.025Z"/><path fill="#AFE229" d="M6.016 6.69a1.592 1.592 0 0 0-.614.21c-.23.132-.422.32-.56.546-.044.072-.287.539-.287.539l-.836 1.528.009.006c.038.025.08.046.123.063.127.046.26.07.395.073.505.023 1.011-.007 1.517-.003.29.009.58.002.869-.022a.886.886 0 0 0 .395-.116.962.962 0 0 0 .312-.286c.056-.083.114-.163.164-.249.24-.408.48-.816.718-1.226.075-.128.148-.257.222-.386l.112-.192a1.07 1.07 0 0 0 .153-.518l-1.304.023s-1.258-.005-1.388.01Z"/><path fill="#771BFF" d="m2.848 9.044.76-1.39.184-.352c-.124-.067-.245-.14-.367-.21-.346-.204-.706-.384-1.045-.6a.984.984 0 0 1-.244-.207c-.108-.134-.136-.294-.144-.46-.021-.409-.002-.818-.009-1.227-.003-.195 0-.39.003-.585.004-.322.153-.553.427-.713l.833-.488c.22-.13.44-.257.662-.385.05-.029.105-.052.158-.077.272-.128.519-.047.76.085l.044.028c.123.06.242.125.358.196.318.178.635.357.952.537.095.056.187.117.275.184.194.144.254.35.266.578.016.284.007.569.006.853-.001.28.004.558 0 .838.592-.003 1.259 0 1.259 0l.723-.013c-.003-.292-.007-.584-.007-.876 0-.524.015-1.048-.016-1.571-.024-.42-.135-.8-.492-1.067a5.02 5.02 0 0 0-.506-.339A400.52 400.52 0 0 0 5.94.787C5.722.664 5.513.524 5.282.423 5.255.406 5.228.388 5.2.373 4.758.126 4.305-.026 3.807.21c-.097.046-.197.087-.29.14A699.896 699.896 0 0 0 .783 1.948c-.501.294-.773.717-.778 1.31-.004.36-.009.718-.001 1.077.016.754-.017 1.508.024 2.261.016.304.07.6.269.848.127.15.279.28.448.382.622.4 1.283.734 1.92 1.11l.183.109Z"/></svg>\n';
    const ICON_WIDTH = 53;
    const ICON_HEIGHT = 10;
    const NARROW_ROOT_HEIGHT_THRESHOLD = 50;
    const NARROW_ROOT_WIDTH_THRESHOLD = 350;
    const DEFAULT_LABEL = "Powered by";
    class PoweredBy extends (/* @__PURE__ */ DomEmitterMixin()) {
      /**
      * Creates a "powered by" helper for a given editor. The feature is initialized on Editor#ready
      * event.
      *
      * @param editor
      */
      constructor(editor2) {
        super();
        /**
        * Editor instance the helper was created for.
        */
        __publicField(this, "editor");
        /**
        * A reference to the balloon panel hosting and positioning the "powered by" link and logo.
        */
        __publicField(this, "_balloonView");
        /**
        * A throttled version of the {@link #_showBalloon} method meant for frequent use to avoid performance loss.
        */
        __publicField(this, "_showBalloonThrottled");
        /**
        * A reference to the last editable element (root, source editing area, etc.) focused by the user.
        * Since the focus can move to other focusable elements in the UI, this reference allows positioning the balloon over the
        * right element whether the user is typing or using the UI.
        */
        __publicField(this, "_lastFocusedEditableElement");
        this.editor = editor2;
        this._balloonView = null;
        this._lastFocusedEditableElement = null;
        this._showBalloonThrottled = throttle(this._showBalloon.bind(this), 50, {
          leading: true
        });
        editor2.on("ready", this._handleEditorReady.bind(this));
      }
      /**
      * Destroys the "powered by" helper along with its view.
      */
      destroy() {
        const balloon = this._balloonView;
        if (balloon) {
          balloon.unpin();
          this._balloonView = null;
        }
        this._showBalloonThrottled.cancel();
        this.stopListening();
      }
      /**
      * Enables "powered by" label once the editor (ui) is ready.
      */
      _handleEditorReady() {
        const editor2 = this.editor;
        const forceVisible = !!editor2.config.get("ui.poweredBy.forceVisible");
        /* istanbul ignore next -- @preserve */
        if (!forceVisible && verifyLicense(editor2.config.get("licenseKey")) === "VALID") {
          return;
        }
        if (!editor2.ui.view) {
          return;
        }
        editor2.ui.focusTracker.on("change:isFocused", (evt, data, isFocused) => {
          this._updateLastFocusedEditableElement();
          if (isFocused) {
            this._showBalloon();
          } else {
            this._hideBalloon();
          }
        });
        editor2.ui.focusTracker.on("change:focusedElement", (evt, data, focusedElement) => {
          this._updateLastFocusedEditableElement();
          if (focusedElement) {
            this._showBalloon();
          }
        });
        editor2.ui.on("update", () => {
          this._showBalloonThrottled();
        });
      }
      /**
      * Creates an instance of the {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView balloon panel}
      * with the "powered by" view inside ready for positioning.
      */
      _createBalloonView() {
        const editor2 = this.editor;
        const balloon = this._balloonView = new BalloonPanelView();
        const poweredByConfig = getNormalizedConfig(editor2);
        const view = new PoweredByView(editor2.locale, poweredByConfig.label);
        balloon.content.add(view);
        balloon.set({
          class: "ck-powered-by-balloon"
        });
        editor2.ui.view.body.add(balloon);
        this._balloonView = balloon;
      }
      /**
      * Attempts to display the balloon with the "powered by" view.
      */
      _showBalloon() {
        if (!this._lastFocusedEditableElement) {
          return;
        }
        const attachOptions = getBalloonAttachOptions(this.editor, this._lastFocusedEditableElement);
        if (attachOptions) {
          if (!this._balloonView) {
            this._createBalloonView();
          }
          this._balloonView.pin(attachOptions);
        }
      }
      /**
      * Hides the "powered by" balloon if already visible.
      */
      _hideBalloon() {
        if (this._balloonView) {
          this._balloonView.unpin();
        }
      }
      /**
      * Updates the {@link #_lastFocusedEditableElement} based on the state of the global focus tracker.
      */
      _updateLastFocusedEditableElement() {
        const editor2 = this.editor;
        const isFocused = editor2.ui.focusTracker.isFocused;
        const focusedElement = editor2.ui.focusTracker.focusedElement;
        if (!isFocused || !focusedElement) {
          this._lastFocusedEditableElement = null;
          return;
        }
        const editableEditorElements = Array.from(editor2.ui.getEditableElementsNames()).map((name) => {
          return editor2.ui.getEditableElement(name);
        });
        if (editableEditorElements.includes(focusedElement)) {
          this._lastFocusedEditableElement = focusedElement;
        } else {
          this._lastFocusedEditableElement = editableEditorElements[0];
        }
      }
    }
    class PoweredByView extends View {
      /**
      * Created an instance of the "powered by" view.
      *
      * @param locale The localization services instance.
      * @param label The label text.
      */
      constructor(locale, label) {
        super(locale);
        const iconView = new IconView();
        const bind2 = this.bindTemplate;
        iconView.set({
          content: poweredByIcon,
          isColorInherited: false
        });
        iconView.extendTemplate({
          attributes: {
            style: {
              width: ICON_WIDTH + "px",
              height: ICON_HEIGHT + "px"
            }
          }
        });
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-powered-by"
            ],
            "aria-hidden": true
          },
          children: [
            {
              tag: "a",
              attributes: {
                href: "https://ckeditor.com/powered-by-ckeditor/?utm_source=ckeditor&utm_medium=referral&utm_campaign=701Dn000000hVgmIAE_powered_by_ckeditor_logo",
                target: "_blank",
                tabindex: "-1"
              },
              children: [
                ...label ? [
                  {
                    tag: "span",
                    attributes: {
                      class: [
                        "ck",
                        "ck-powered-by__label"
                      ]
                    },
                    children: [
                      label
                    ]
                  }
                ] : [],
                iconView
              ],
              on: {
                dragstart: bind2.to((evt) => evt.preventDefault())
              }
            }
          ]
        });
      }
    }
    function getBalloonAttachOptions(editor2, focusedEditableElement) {
      const poweredByConfig = getNormalizedConfig(editor2);
      const positioningFunction = poweredByConfig.side === "right" ? getLowerRightCornerPosition(focusedEditableElement, poweredByConfig) : getLowerLeftCornerPosition(focusedEditableElement, poweredByConfig);
      return {
        target: focusedEditableElement,
        positions: [
          positioningFunction
        ]
      };
    }
    function getLowerRightCornerPosition(focusedEditableElement, config2) {
      return getLowerCornerPosition(focusedEditableElement, config2, (rootRect, balloonRect) => {
        return rootRect.left + rootRect.width - balloonRect.width - config2.horizontalOffset;
      });
    }
    function getLowerLeftCornerPosition(focusedEditableElement, config2) {
      return getLowerCornerPosition(focusedEditableElement, config2, (rootRect) => rootRect.left + config2.horizontalOffset);
    }
    function getLowerCornerPosition(focusedEditableElement, config2, getBalloonLeft) {
      return (visibleEditableElementRect, balloonRect) => {
        const editableElementRect = new Rect(focusedEditableElement);
        if (editableElementRect.width < NARROW_ROOT_WIDTH_THRESHOLD || editableElementRect.height < NARROW_ROOT_HEIGHT_THRESHOLD) {
          return null;
        }
        let balloonTop;
        if (config2.position === "inside") {
          balloonTop = editableElementRect.bottom - balloonRect.height;
        } else {
          balloonTop = editableElementRect.bottom - balloonRect.height / 2;
        }
        balloonTop -= config2.verticalOffset;
        const balloonLeft = getBalloonLeft(editableElementRect, balloonRect);
        const newBalloonPositionRect = visibleEditableElementRect.clone().moveTo(balloonLeft, balloonTop).getIntersection(balloonRect.clone().moveTo(balloonLeft, balloonTop));
        const newBalloonPositionVisibleRect = newBalloonPositionRect.getVisible();
        if (!newBalloonPositionVisibleRect || newBalloonPositionVisibleRect.getArea() < balloonRect.getArea()) {
          return null;
        }
        return {
          top: balloonTop,
          left: balloonLeft,
          name: `position_${config2.position}-side_${config2.side}`,
          config: {
            withArrow: false
          }
        };
      };
    }
    function getNormalizedConfig(editor2) {
      const userConfig = editor2.config.get("ui.poweredBy");
      const position = userConfig && userConfig.position || "border";
      return {
        position,
        label: DEFAULT_LABEL,
        verticalOffset: position === "inside" ? 5 : 0,
        horizontalOffset: 5,
        side: editor2.locale.contentLanguageDirection === "ltr" ? "right" : "left",
        ...userConfig
      };
    }
    const AriaLiveAnnouncerPoliteness = {
      POLITE: "polite",
      ASSERTIVE: "assertive"
    };
    class AriaLiveAnnouncer {
      /**
      * @inheritDoc
      */
      constructor(editor2) {
        /**
        * The editor instance.
        */
        __publicField(this, "editor");
        /**
        * The view that aggregates all `aria-live` regions.
        */
        __publicField(this, "view");
        this.editor = editor2;
        editor2.once("ready", () => {
          for (const politeness of Object.values(AriaLiveAnnouncerPoliteness)) {
            this.announce("", politeness);
          }
        });
      }
      /**
      * Sets an announcement text to an aria region that is then announced by a screen reader to the user.
      *
      * If the aria region of a specified politeness does not exist, it will be created and can be re-used later.
      *
      * The default announcement politeness level is `'polite'`.
      *
      * ```ts
      * // Most screen readers will queue announcements from multiple aria-live regions and read them out in the order they were emitted.
       * editor.ui.ariaLiveAnnouncer.announce( 'Image uploaded.' );
       * editor.ui.ariaLiveAnnouncer.announce( 'Connection lost. Reconnecting.' );
       * ```
      */
      announce(announcement, attributes = AriaLiveAnnouncerPoliteness.POLITE) {
        const editor2 = this.editor;
        if (!editor2.ui.view) {
          return;
        }
        if (!this.view) {
          this.view = new AriaLiveAnnouncerView(editor2.locale);
          editor2.ui.view.body.add(this.view);
        }
        const { politeness, isUnsafeHTML } = typeof attributes === "string" ? {
          politeness: attributes
        } : attributes;
        let politenessRegionView = this.view.regionViews.find((view) => view.politeness === politeness);
        if (!politenessRegionView) {
          politenessRegionView = new AriaLiveAnnouncerRegionView(editor2, politeness);
          this.view.regionViews.add(politenessRegionView);
        }
        politenessRegionView.announce({
          announcement,
          isUnsafeHTML
        });
      }
    }
    class AriaLiveAnnouncerView extends View {
      constructor(locale) {
        super(locale);
        /**
        * A collection of all views that represent individual `aria-live` regions.
        */
        __publicField(this, "regionViews");
        this.regionViews = this.createCollection();
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-aria-live-announcer"
            ]
          },
          children: this.regionViews
        });
      }
    }
    class AriaLiveAnnouncerRegionView extends View {
      constructor(editor2, politeness) {
        super(editor2.locale);
        /**
        * Current politeness level of the region.
        */
        __publicField(this, "politeness");
        /**
        * DOM converter used to sanitize unsafe HTML passed to {@link #announce} method.
        */
        __publicField(this, "_domConverter");
        /**
        * Interval used to remove additions. It prevents accumulation of added nodes in region.
        */
        __publicField(this, "_pruneAnnouncementsInterval");
        this.setTemplate({
          tag: "div",
          attributes: {
            "aria-live": politeness,
            "aria-relevant": "additions"
          },
          children: [
            {
              tag: "ul",
              attributes: {
                class: [
                  "ck",
                  "ck-aria-live-region-list"
                ]
              }
            }
          ]
        });
        editor2.on("destroy", () => {
          if (this._pruneAnnouncementsInterval !== null) {
            clearInterval(this._pruneAnnouncementsInterval);
            this._pruneAnnouncementsInterval = null;
          }
        });
        this.politeness = politeness;
        this._domConverter = editor2.data.htmlProcessor.domConverter;
        this._pruneAnnouncementsInterval = setInterval(() => {
          if (this.element && this._listElement.firstChild) {
            this._listElement.firstChild.remove();
          }
        }, 5e3);
      }
      /**
      * Appends new announcement to region.
      */
      announce({ announcement, isUnsafeHTML }) {
        if (!announcement.trim().length) {
          return;
        }
        const messageListItem = document.createElement("li");
        if (isUnsafeHTML) {
          this._domConverter.setContentOf(messageListItem, announcement);
        } else {
          messageListItem.innerText = announcement;
        }
        this._listElement.appendChild(messageListItem);
      }
      /**
      * Return current announcements list HTML element.
      */
      get _listElement() {
        return this.element.querySelector("ul");
      }
    }
    class MenuBarMenuListItemView extends ListItemView {
      /**
      * Creates an instance of the list item view.
      *
      * @param locale The localization services instance.
      */
      constructor(locale, parentMenuView) {
        super(locale);
        const bind2 = this.bindTemplate;
        this.extendTemplate({
          attributes: {
            class: [
              "ck-menu-bar__menu__item"
            ]
          },
          on: {
            "mouseenter": bind2.to("mouseenter")
          }
        });
        this.delegate("mouseenter").to(parentMenuView);
      }
    }
    const NESTED_PANEL_HORIZONTAL_OFFSET = 5;
    const MenuBarBehaviors = {
      /**
      * When the bar is already open:
      * * Opens the menu when the user hovers over its button.
      * * Closes open menu when another menu's button gets hovered.
      */
      toggleMenusAndFocusItemsOnHover(menuBarView) {
        menuBarView.on("menu:mouseenter", (evt) => {
          if (!menuBarView.isFocusBorderEnabled && !menuBarView.isOpen) {
            return;
          }
          if (menuBarView.isOpen) {
            for (const menuView of menuBarView.menus) {
              const pathLeaf = evt.path[0];
              const isListItemContainingMenu = pathLeaf instanceof MenuBarMenuListItemView && pathLeaf.children.first === menuView;
              menuView.isOpen = (evt.path.includes(menuView) || isListItemContainingMenu) && menuView.isEnabled;
            }
          }
          evt.source.focus();
        });
      },
      /**
      * Moves between top-level menus using the arrow left and right keys.
      *
      * If the menubar has already been open, the arrow keys move focus between top-level menu buttons and open them.
      * If the menubar is closed, the arrow keys only move focus between top-level menu buttons.
      */
      focusCycleMenusOnArrows(menuBarView) {
        const isContentRTL = menuBarView.locale.uiLanguageDirection === "rtl";
        menuBarView.on("menu:arrowright", (evt) => {
          cycleTopLevelMenus(evt.source, isContentRTL ? -1 : 1);
        });
        menuBarView.on("menu:arrowleft", (evt) => {
          cycleTopLevelMenus(evt.source, isContentRTL ? 1 : -1);
        });
        function cycleTopLevelMenus(currentMenuView, step) {
          const currentIndex = menuBarView.children.getIndex(currentMenuView);
          const isCurrentMenuViewOpen = currentMenuView.isOpen;
          const menusCount = menuBarView.children.length;
          const menuViewToOpen = menuBarView.children.get((currentIndex + menusCount + step) % menusCount);
          currentMenuView.isOpen = false;
          if (isCurrentMenuViewOpen) {
            menuViewToOpen.isOpen = true;
          }
          menuViewToOpen.buttonView.focus();
        }
      },
      /**
      * Closes the entire sub-menu structure when the bar is closed. This prevents sub-menus from being open if the user
      * closes the entire bar, and then re-opens some top-level menu.
      */
      closeMenusWhenTheBarCloses(menuBarView) {
        menuBarView.on("change:isOpen", () => {
          if (!menuBarView.isOpen) {
            menuBarView.menus.forEach((menuView) => {
              menuView.isOpen = false;
            });
          }
        });
      },
      /**
      * Handles the following case:
      * 1. Hover to open a sub-menu (A). The button has focus.
      * 2. Press arrow up/down to move focus to another sub-menu (B) button.
      * 3. Press arrow right to open the sub-menu (B).
      * 4. The sub-menu (A) should close as it would with `toggleMenusAndFocusItemsOnHover()`.
      */
      closeMenuWhenAnotherOnTheSameLevelOpens(menuBarView) {
        menuBarView.on("menu:change:isOpen", (evt, name, isOpen) => {
          if (isOpen) {
            menuBarView.menus.filter((menuView) => {
              return evt.source.parentMenuView === menuView.parentMenuView && evt.source !== menuView && menuView.isOpen;
            }).forEach((menuView) => {
              menuView.isOpen = false;
            });
          }
        });
      },
      /**
      * Closes the bar when the user clicked outside of it (page body, editor root, etc.).
      */
      closeOnClickOutside(menuBarView) {
        clickOutsideHandler({
          emitter: menuBarView,
          activator: () => menuBarView.isOpen,
          callback: () => menuBarView.close(),
          contextElements: () => menuBarView.children.map((child) => child.element)
        });
      },
      /**
      * Tracks the keyboard focus interaction on the menu bar view. It is used to determine if the nested items
      * of the menu bar should render focus rings after first interaction with the keyboard.
      */
      enableFocusHighlightOnInteraction(menuBarView) {
        let isKeyPressed = false;
        menuBarView.on("change:isOpen", (_2, evt, isOpen) => {
          if (!isOpen) {
            if (!isKeyPressed) {
              menuBarView.isFocusBorderEnabled = false;
            }
            isKeyPressed = false;
          }
        });
        menuBarView.listenTo(menuBarView.element, "keydown", () => {
          isKeyPressed = true;
        }, {
          useCapture: true
        });
        menuBarView.listenTo(menuBarView.element, "keyup", () => {
          isKeyPressed = false;
        }, {
          useCapture: true
        });
        menuBarView.listenTo(menuBarView.element, "focus", () => {
          if (isKeyPressed) {
            menuBarView.isFocusBorderEnabled = true;
          }
        }, {
          useCapture: true
        });
      }
    };
    const MenuBarMenuBehaviors = {
      /**
      * If the button of the menu is focused, pressing the arrow down key should open the panel and focus it.
      * This is analogous to the {@link module:ui/dropdown/dropdownview~DropdownView}.
      */
      openAndFocusPanelOnArrowDownKey(menuView) {
        menuView.keystrokes.set("arrowdown", (data, cancel2) => {
          if (menuView.focusTracker.focusedElement === menuView.buttonView.element) {
            if (!menuView.isOpen) {
              menuView.isOpen = true;
            }
            menuView.panelView.focus();
            cancel2();
          }
        });
      },
      /**
      * Open the menu on the right arrow key press. This allows for navigating to sub-menus using the keyboard.
      */
      openOnArrowRightKey(menuView) {
        const keystroke = menuView.locale.uiLanguageDirection === "rtl" ? "arrowleft" : "arrowright";
        menuView.keystrokes.set(keystroke, (data, cancel2) => {
          if (menuView.focusTracker.focusedElement !== menuView.buttonView.element || !menuView.isEnabled) {
            return;
          }
          if (!menuView.isOpen) {
            menuView.isOpen = true;
          }
          menuView.panelView.focus();
          cancel2();
        });
      },
      /**
      * Opens the menu on its button click. Note that this behavior only opens but never closes the menu (unlike
      * {@link module:ui/dropdown/dropdownview~DropdownView}).
      */
      openOnButtonClick(menuView) {
        menuView.buttonView.on("execute", () => {
          menuView.isOpen = true;
        });
      },
      /**
      * Toggles the menu on its button click. This behavior is analogous to {@link module:ui/dropdown/dropdownview~DropdownView}.
      */
      toggleOnButtonClick(menuView) {
        menuView.buttonView.on("execute", () => {
          menuView.isOpen = !menuView.isOpen;
        });
      },
      /**
      * Opens the menu and focuses the panel content upon pressing the Enter key.
      */
      openAndFocusOnEnterKeyPress(menuView) {
        menuView.keystrokes.set("enter", (data, cancel2) => {
          if (menuView.focusTracker.focusedElement !== menuView.buttonView.element) {
            return;
          }
          menuView.isOpen = true;
          menuView.panelView.focus();
          cancel2();
        });
      },
      /**
      * Closes the menu on the right left key press. This allows for navigating to sub-menus using the keyboard.
      */
      closeOnArrowLeftKey(menuView) {
        const keystroke = menuView.locale.uiLanguageDirection === "rtl" ? "arrowright" : "arrowleft";
        menuView.keystrokes.set(keystroke, (data, cancel2) => {
          if (menuView.isOpen) {
            menuView.isOpen = false;
            menuView.focus();
            cancel2();
          }
        });
      },
      /**
      * Closes the menu on the esc key press. This allows for navigating to sub-menus using the keyboard.
      */
      closeOnEscKey(menuView) {
        menuView.keystrokes.set("esc", (data, cancel2) => {
          if (menuView.isOpen) {
            menuView.isOpen = false;
            menuView.focus();
            cancel2();
          }
        });
      },
      /**
      * Closes the menu when its parent menu also closed. This prevents from orphaned open menus when the parent menu re-opens.
      */
      closeOnParentClose(menuView) {
        menuView.parentMenuView.on("change:isOpen", (evt, name, isOpen) => {
          if (!isOpen && evt.source === menuView.parentMenuView) {
            menuView.isOpen = false;
          }
        });
      }
    };
    const MenuBarMenuViewPanelPositioningFunctions = {
      southEast: (buttonRect) => {
        return {
          top: buttonRect.bottom,
          left: buttonRect.left,
          name: "se"
        };
      },
      southWest: (buttonRect, panelRect) => {
        return {
          top: buttonRect.bottom,
          left: buttonRect.left - panelRect.width + buttonRect.width,
          name: "sw"
        };
      },
      northEast: (buttonRect, panelRect) => {
        return {
          top: buttonRect.top - panelRect.height,
          left: buttonRect.left,
          name: "ne"
        };
      },
      northWest: (buttonRect, panelRect) => {
        return {
          top: buttonRect.top - panelRect.height,
          left: buttonRect.left - panelRect.width + buttonRect.width,
          name: "nw"
        };
      },
      eastSouth: (buttonRect) => {
        return {
          top: buttonRect.top,
          left: buttonRect.right - NESTED_PANEL_HORIZONTAL_OFFSET,
          name: "es"
        };
      },
      eastNorth: (buttonRect, panelRect) => {
        return {
          top: buttonRect.top - panelRect.height,
          left: buttonRect.right - NESTED_PANEL_HORIZONTAL_OFFSET,
          name: "en"
        };
      },
      westSouth: (buttonRect, panelRect) => {
        return {
          top: buttonRect.top,
          left: buttonRect.left - panelRect.width + NESTED_PANEL_HORIZONTAL_OFFSET,
          name: "ws"
        };
      },
      westNorth: (buttonRect, panelRect) => {
        return {
          top: buttonRect.top - panelRect.height,
          left: buttonRect.left - panelRect.width + NESTED_PANEL_HORIZONTAL_OFFSET,
          name: "wn"
        };
      }
    };
    const DefaultMenuBarItems = [
      {
        menuId: "file",
        label: "File",
        groups: [
          {
            groupId: "export",
            items: [
              "menuBar:exportPdf",
              "menuBar:exportWord"
            ]
          },
          {
            groupId: "import",
            items: [
              "menuBar:importWord"
            ]
          },
          {
            groupId: "revisionHistory",
            items: [
              "menuBar:revisionHistory"
            ]
          }
        ]
      },
      {
        menuId: "edit",
        label: "Edit",
        groups: [
          {
            groupId: "undo",
            items: [
              "menuBar:undo",
              "menuBar:redo"
            ]
          },
          {
            groupId: "selectAll",
            items: [
              "menuBar:selectAll"
            ]
          },
          {
            groupId: "findAndReplace",
            items: [
              "menuBar:findAndReplace"
            ]
          }
        ]
      },
      {
        menuId: "view",
        label: "View",
        groups: [
          {
            groupId: "sourceEditing",
            items: [
              "menuBar:sourceEditing"
            ]
          },
          {
            groupId: "showBlocks",
            items: [
              "menuBar:showBlocks"
            ]
          },
          {
            groupId: "previewMergeFields",
            items: [
              "menuBar:previewMergeFields"
            ]
          },
          {
            groupId: "restrictedEditing",
            items: [
              "menuBar:restrictedEditing"
            ]
          }
        ]
      },
      {
        menuId: "insert",
        label: "Insert",
        groups: [
          {
            groupId: "insertMainWidgets",
            items: [
              "menuBar:insertImage",
              "menuBar:ckbox",
              "menuBar:ckfinder",
              "menuBar:insertTable"
            ]
          },
          {
            groupId: "insertInline",
            items: [
              "menuBar:link",
              "menuBar:comment",
              "menuBar:insertMergeField"
            ]
          },
          {
            groupId: "insertMinorWidgets",
            items: [
              "menuBar:mediaEmbed",
              "menuBar:insertTemplate",
              "menuBar:specialCharacters",
              "menuBar:blockQuote",
              "menuBar:codeBlock",
              "menuBar:htmlEmbed"
            ]
          },
          {
            groupId: "insertStructureWidgets",
            items: [
              "menuBar:horizontalLine",
              "menuBar:pageBreak",
              "menuBar:tableOfContents"
            ]
          },
          {
            groupId: "restrictedEditingException",
            items: [
              "menuBar:restrictedEditingException"
            ]
          }
        ]
      },
      {
        menuId: "format",
        label: "Format",
        groups: [
          {
            groupId: "textAndFont",
            items: [
              {
                menuId: "text",
                label: "Text",
                groups: [
                  {
                    groupId: "basicStyles",
                    items: [
                      "menuBar:bold",
                      "menuBar:italic",
                      "menuBar:underline",
                      "menuBar:strikethrough",
                      "menuBar:superscript",
                      "menuBar:subscript",
                      "menuBar:code"
                    ]
                  },
                  {
                    groupId: "textPartLanguage",
                    items: [
                      "menuBar:textPartLanguage"
                    ]
                  }
                ]
              },
              {
                menuId: "font",
                label: "Font",
                groups: [
                  {
                    groupId: "fontProperties",
                    items: [
                      "menuBar:fontSize",
                      "menuBar:fontFamily"
                    ]
                  },
                  {
                    groupId: "fontColors",
                    items: [
                      "menuBar:fontColor",
                      "menuBar:fontBackgroundColor"
                    ]
                  },
                  {
                    groupId: "highlight",
                    items: [
                      "menuBar:highlight"
                    ]
                  }
                ]
              },
              "menuBar:heading"
            ]
          },
          {
            groupId: "list",
            items: [
              "menuBar:bulletedList",
              "menuBar:numberedList",
              "menuBar:multiLevelList",
              "menuBar:todoList"
            ]
          },
          {
            groupId: "indent",
            items: [
              "menuBar:alignment",
              "menuBar:indent",
              "menuBar:outdent"
            ]
          },
          {
            groupId: "caseChange",
            items: [
              "menuBar:caseChange"
            ]
          },
          {
            groupId: "removeFormat",
            items: [
              "menuBar:removeFormat"
            ]
          }
        ]
      },
      {
        menuId: "tools",
        label: "Tools",
        groups: [
          {
            groupId: "aiTools",
            items: [
              "menuBar:aiAssistant",
              "menuBar:aiCommands"
            ]
          },
          {
            groupId: "tools",
            items: [
              "menuBar:trackChanges",
              "menuBar:commentsArchive"
            ]
          }
        ]
      },
      {
        menuId: "help",
        label: "Help",
        groups: [
          {
            groupId: "help",
            items: [
              "menuBar:accessibilityHelp"
            ]
          }
        ]
      }
    ];
    function normalizeMenuBarConfig(config2) {
      let configObject;
      if (!("items" in config2) || !config2.items) {
        configObject = {
          items: cloneDeep(DefaultMenuBarItems),
          addItems: [],
          removeItems: [],
          isVisible: true,
          isUsingDefaultConfig: true,
          ...config2
        };
      } else {
        configObject = {
          items: config2.items,
          removeItems: [],
          addItems: [],
          isVisible: true,
          isUsingDefaultConfig: false,
          ...config2
        };
      }
      return configObject;
    }
    function processMenuBarConfig({ normalizedConfig, locale, componentFactory, extraItems }) {
      const configClone = cloneDeep(normalizedConfig);
      handleAdditions(normalizedConfig, configClone, extraItems);
      handleRemovals(normalizedConfig, configClone);
      handleAdditions(normalizedConfig, configClone, configClone.addItems);
      purgeUnavailableComponents(normalizedConfig, configClone, componentFactory);
      purgeEmptyMenus(normalizedConfig, configClone);
      localizeMenuLabels(configClone, locale);
      return configClone;
    }
    function handleRemovals(originalConfig, config2) {
      const itemsToBeRemoved = config2.removeItems;
      const successfullyRemovedItems = [];
      config2.items = config2.items.filter(({ menuId }) => {
        if (itemsToBeRemoved.includes(menuId)) {
          successfullyRemovedItems.push(menuId);
          return false;
        }
        return true;
      });
      walkConfigMenus(config2.items, (menuDefinition) => {
        menuDefinition.groups = menuDefinition.groups.filter(({ groupId }) => {
          if (itemsToBeRemoved.includes(groupId)) {
            successfullyRemovedItems.push(groupId);
            return false;
          }
          return true;
        });
        for (const groupDefinition of menuDefinition.groups) {
          groupDefinition.items = groupDefinition.items.filter((item) => {
            const itemId = getIdFromGroupItem(item);
            if (itemsToBeRemoved.includes(itemId)) {
              successfullyRemovedItems.push(itemId);
              return false;
            }
            return true;
          });
        }
      });
      for (const itemName of itemsToBeRemoved) {
        if (!successfullyRemovedItems.includes(itemName)) {
          logWarning("menu-bar-item-could-not-be-removed", {
            menuBarConfig: originalConfig,
            itemName
          });
        }
      }
    }
    function handleAdditions(originalConfig, config2, items) {
      const successFullyAddedItems = [];
      if (items.length == 0) {
        return;
      }
      for (const itemToAdd of items) {
        const relation = getRelationFromPosition(itemToAdd.position);
        const relativeId = getRelativeIdFromPosition(itemToAdd.position);
        if (isMenuBarMenuAddition(itemToAdd)) {
          if (!relativeId) {
            if (relation === "start") {
              config2.items.unshift(itemToAdd.menu);
              successFullyAddedItems.push(itemToAdd);
            } else if (relation === "end") {
              config2.items.push(itemToAdd.menu);
              successFullyAddedItems.push(itemToAdd);
            }
          } else {
            const topLevelMenuDefinitionIndex = config2.items.findIndex((menuDefinition) => menuDefinition.menuId === relativeId);
            if (topLevelMenuDefinitionIndex != -1) {
              if (relation === "before") {
                config2.items.splice(topLevelMenuDefinitionIndex, 0, itemToAdd.menu);
                successFullyAddedItems.push(itemToAdd);
              } else if (relation === "after") {
                config2.items.splice(topLevelMenuDefinitionIndex + 1, 0, itemToAdd.menu);
                successFullyAddedItems.push(itemToAdd);
              }
            } else {
              const wasAdded = addMenuOrItemToGroup(config2, itemToAdd.menu, relativeId, relation);
              if (wasAdded) {
                successFullyAddedItems.push(itemToAdd);
              }
            }
          }
        } else if (isMenuBarMenuGroupAddition(itemToAdd)) {
          walkConfigMenus(config2.items, (menuDefinition) => {
            if (menuDefinition.menuId === relativeId) {
              if (relation === "start") {
                menuDefinition.groups.unshift(itemToAdd.group);
                successFullyAddedItems.push(itemToAdd);
              } else if (relation === "end") {
                menuDefinition.groups.push(itemToAdd.group);
                successFullyAddedItems.push(itemToAdd);
              }
            } else {
              const relativeGroupIndex = menuDefinition.groups.findIndex((group) => group.groupId === relativeId);
              if (relativeGroupIndex !== -1) {
                if (relation === "before") {
                  menuDefinition.groups.splice(relativeGroupIndex, 0, itemToAdd.group);
                  successFullyAddedItems.push(itemToAdd);
                } else if (relation === "after") {
                  menuDefinition.groups.splice(relativeGroupIndex + 1, 0, itemToAdd.group);
                  successFullyAddedItems.push(itemToAdd);
                }
              }
            }
          });
        } else {
          const wasAdded = addMenuOrItemToGroup(config2, itemToAdd.item, relativeId, relation);
          if (wasAdded) {
            successFullyAddedItems.push(itemToAdd);
          }
        }
      }
      for (const addedItemConfig of items) {
        if (!successFullyAddedItems.includes(addedItemConfig)) {
          logWarning("menu-bar-item-could-not-be-added", {
            menuBarConfig: originalConfig,
            addedItemConfig
          });
        }
      }
    }
    function addMenuOrItemToGroup(config2, itemOrMenuToAdd, relativeId, relation) {
      let wasAdded = false;
      walkConfigMenus(config2.items, (menuDefinition) => {
        for (const { groupId, items: groupItems } of menuDefinition.groups) {
          if (wasAdded) {
            return;
          }
          if (groupId === relativeId) {
            if (relation === "start") {
              groupItems.unshift(itemOrMenuToAdd);
              wasAdded = true;
            } else if (relation === "end") {
              groupItems.push(itemOrMenuToAdd);
              wasAdded = true;
            }
          } else {
            const relativeItemIndex = groupItems.findIndex((groupItem) => {
              return getIdFromGroupItem(groupItem) === relativeId;
            });
            if (relativeItemIndex !== -1) {
              if (relation === "before") {
                groupItems.splice(relativeItemIndex, 0, itemOrMenuToAdd);
                wasAdded = true;
              } else if (relation === "after") {
                groupItems.splice(relativeItemIndex + 1, 0, itemOrMenuToAdd);
                wasAdded = true;
              }
            }
          }
        }
      });
      return wasAdded;
    }
    function purgeUnavailableComponents(originalConfig, config2, componentFactory) {
      walkConfigMenus(config2.items, (menuDefinition) => {
        for (const groupDefinition of menuDefinition.groups) {
          groupDefinition.items = groupDefinition.items.filter((item) => {
            const isItemUnavailable = typeof item === "string" && !componentFactory.has(item);
            if (isItemUnavailable && !config2.isUsingDefaultConfig) {
              logWarning("menu-bar-item-unavailable", {
                menuBarConfig: originalConfig,
                parentMenuConfig: cloneDeep(menuDefinition),
                componentName: item
              });
            }
            return !isItemUnavailable;
          });
        }
      });
    }
    function purgeEmptyMenus(originalConfig, config2) {
      const isUsingDefaultConfig = config2.isUsingDefaultConfig;
      let wasSubMenuPurged = false;
      config2.items = config2.items.filter((menuDefinition) => {
        if (!menuDefinition.groups.length) {
          warnAboutEmptyMenu(originalConfig, menuDefinition, isUsingDefaultConfig);
          return false;
        }
        return true;
      });
      if (!config2.items.length) {
        warnAboutEmptyMenu(originalConfig, originalConfig, isUsingDefaultConfig);
        return;
      }
      walkConfigMenus(config2.items, (menuDefinition) => {
        menuDefinition.groups = menuDefinition.groups.filter((groupDefinition) => {
          if (!groupDefinition.items.length) {
            wasSubMenuPurged = true;
            return false;
          }
          return true;
        });
        for (const groupDefinition of menuDefinition.groups) {
          groupDefinition.items = groupDefinition.items.filter((item) => {
            if (isMenuDefinition(item) && !item.groups.length) {
              warnAboutEmptyMenu(originalConfig, item, isUsingDefaultConfig);
              wasSubMenuPurged = true;
              return false;
            }
            return true;
          });
        }
      });
      if (wasSubMenuPurged) {
        purgeEmptyMenus(originalConfig, config2);
      }
    }
    function warnAboutEmptyMenu(originalConfig, emptyMenuConfig, isUsingDefaultConfig) {
      if (isUsingDefaultConfig) {
        return;
      }
      logWarning("menu-bar-menu-empty", {
        menuBarConfig: originalConfig,
        emptyMenuConfig
      });
    }
    function localizeMenuLabels(config2, locale) {
      const t2 = locale.t;
      const localizedCategoryLabels = {
        // Top-level categories.
        "File": t2({
          string: "File",
          id: "MENU_BAR_MENU_FILE"
        }),
        "Edit": t2({
          string: "Edit",
          id: "MENU_BAR_MENU_EDIT"
        }),
        "View": t2({
          string: "View",
          id: "MENU_BAR_MENU_VIEW"
        }),
        "Insert": t2({
          string: "Insert",
          id: "MENU_BAR_MENU_INSERT"
        }),
        "Format": t2({
          string: "Format",
          id: "MENU_BAR_MENU_FORMAT"
        }),
        "Tools": t2({
          string: "Tools",
          id: "MENU_BAR_MENU_TOOLS"
        }),
        "Help": t2({
          string: "Help",
          id: "MENU_BAR_MENU_HELP"
        }),
        // Sub-menus.
        "Text": t2({
          string: "Text",
          id: "MENU_BAR_MENU_TEXT"
        }),
        "Font": t2({
          string: "Font",
          id: "MENU_BAR_MENU_FONT"
        })
      };
      walkConfigMenus(config2.items, (definition) => {
        if (definition.label in localizedCategoryLabels) {
          definition.label = localizedCategoryLabels[definition.label];
        }
      });
    }
    function walkConfigMenus(definition, callback) {
      if (Array.isArray(definition)) {
        for (const topLevelMenuDefinition of definition) {
          walk(topLevelMenuDefinition);
        }
      }
      function walk(menuDefinition) {
        callback(menuDefinition);
        for (const groupDefinition of menuDefinition.groups) {
          for (const groupItem of groupDefinition.items) {
            if (isMenuDefinition(groupItem)) {
              walk(groupItem);
            }
          }
        }
      }
    }
    function isMenuBarMenuAddition(definition) {
      return typeof definition === "object" && "menu" in definition;
    }
    function isMenuBarMenuGroupAddition(definition) {
      return typeof definition === "object" && "group" in definition;
    }
    function getRelationFromPosition(position) {
      if (position.startsWith("start")) {
        return "start";
      } else if (position.startsWith("end")) {
        return "end";
      } else if (position.startsWith("after")) {
        return "after";
      } else {
        return "before";
      }
    }
    function getRelativeIdFromPosition(position) {
      const match = position.match(/^[^:]+:(.+)/);
      if (match) {
        return match[1];
      }
      return null;
    }
    function getIdFromGroupItem(item) {
      return typeof item === "string" ? item : item.menuId;
    }
    function isMenuDefinition(definition) {
      return typeof definition === "object" && "menuId" in definition;
    }
    class EditorUI extends (/* @__PURE__ */ ObservableMixin()) {
      /**
      * Creates an instance of the editor UI class.
      *
      * @param editor The editor instance.
      */
      constructor(editor2) {
        super();
        /**
        * The editor that the UI belongs to.
        */
        __publicField(this, "editor");
        /**
        * An instance of the {@link module:ui/componentfactory~ComponentFactory}, a registry used by plugins
        * to register factories of specific UI components.
        */
        __publicField(this, "componentFactory");
        /**
        * Stores the information about the editor UI focus and propagates it so various plugins and components
        * are unified as a focus group.
        */
        __publicField(this, "focusTracker");
        /**
        * Manages the tooltips displayed on mouseover and focus across the UI.
        */
        __publicField(this, "tooltipManager");
        /**
        * A helper that enables the "powered by" feature in the editor and renders a link to the project's webpage.
        */
        __publicField(this, "poweredBy");
        /**
        * A helper that manages the content of an `aria-live` regions used by editor features to announce status changes
        * to screen readers.
        */
        __publicField(this, "ariaLiveAnnouncer");
        /**
        * Indicates the UI is ready. Set `true` after {@link #event:ready} event is fired.
        *
        * @readonly
        * @default false
        */
        __publicField(this, "isReady", false);
        /**
        * Stores all editable elements used by the editor instance.
        */
        __publicField(this, "_editableElementsMap", /* @__PURE__ */ new Map());
        /**
        * All available & focusable toolbars.
        */
        __publicField(this, "_focusableToolbarDefinitions", []);
        /**
        * All additional menu bar items, groups or menus that have their default location defined.
        */
        __publicField(this, "_extraMenuBarElements", []);
        /**
        * The last focused element to which focus should return on `Esc` press.
        */
        __publicField(this, "_lastFocusedForeignElement", null);
        const editingView = editor2.editing.view;
        this.editor = editor2;
        this.componentFactory = new ComponentFactory(editor2);
        this.focusTracker = new FocusTracker();
        this.tooltipManager = new TooltipManager(editor2);
        this.poweredBy = new PoweredBy(editor2);
        this.ariaLiveAnnouncer = new AriaLiveAnnouncer(editor2);
        this.set("viewportOffset", this._readViewportOffsetFromConfig());
        this.once("ready", () => {
          this._bindBodyCollectionWithFocusTracker();
          this.isReady = true;
        });
        this.listenTo(editingView.document, "layoutChanged", this.update.bind(this));
        this.listenTo(editingView, "scrollToTheSelection", this._handleScrollToTheSelection.bind(this));
        this._initFocusTracking();
      }
      /**
      * The main (outermost) DOM element of the editor UI.
      *
      * For example, in {@link module:editor-classic/classiceditor~ClassicEditor} it is a `<div>` which
      * wraps the editable element and the toolbar. In {@link module:editor-inline/inlineeditor~InlineEditor}
      * it is the editable element itself (as there is no other wrapper). However, in
      * {@link module:editor-decoupled/decouplededitor~DecoupledEditor} it is set to `null` because this editor does not
      * come with a single "main" HTML element (its editable element and toolbar are separate).
      *
      * This property can be understood as a shorthand for retrieving the element that a specific editor integration
      * considers to be its main DOM element.
      */
      get element() {
        return null;
      }
      /**
      * Fires the {@link module:ui/editorui/editorui~EditorUI#event:update `update`} event.
      *
      * This method should be called when the editor UI (e.g. positions of its balloons) needs to be updated due to
      * some environmental change which CKEditor 5 is not aware of (e.g. resize of a container in which it is used).
      */
      update() {
        this.fire("update");
      }
      /**
      * Destroys the UI.
      */
      destroy() {
        this.stopListening();
        this.focusTracker.destroy();
        this.tooltipManager.destroy(this.editor);
        this.poweredBy.destroy();
        for (const domElement of this._editableElementsMap.values()) {
          domElement.ckeditorInstance = null;
          this.editor.keystrokes.stopListening(domElement);
        }
        this._editableElementsMap = /* @__PURE__ */ new Map();
        this._focusableToolbarDefinitions = [];
      }
      /**
      * Stores the native DOM editable element used by the editor under a unique name.
      *
      * Also, registers the element in the editor to maintain the accessibility of the UI. When the user is editing text in a focusable
      * editable area, they can use the <kbd>Alt</kbd> + <kbd>F10</kbd> keystroke to navigate over editor toolbars. See {@link #addToolbar}.
      *
      * @param rootName The unique name of the editable element.
      * @param domElement The native DOM editable element.
      */
      setEditableElement(rootName, domElement) {
        this._editableElementsMap.set(rootName, domElement);
        if (!domElement.ckeditorInstance) {
          domElement.ckeditorInstance = this.editor;
        }
        this.focusTracker.add(domElement);
        const setUpKeystrokeHandler = () => {
          if (this.editor.editing.view.getDomRoot(rootName)) {
            return;
          }
          this.editor.keystrokes.listenTo(domElement);
        };
        if (this.isReady) {
          setUpKeystrokeHandler();
        } else {
          this.once("ready", setUpKeystrokeHandler);
        }
      }
      /**
      * Removes the editable from the editor UI. Removes all handlers added by {@link #setEditableElement}.
      *
      * @param rootName The name of the editable element to remove.
      */
      removeEditableElement(rootName) {
        const domElement = this._editableElementsMap.get(rootName);
        if (!domElement) {
          return;
        }
        this._editableElementsMap.delete(rootName);
        this.editor.keystrokes.stopListening(domElement);
        this.focusTracker.remove(domElement);
        domElement.ckeditorInstance = null;
      }
      /**
      * Returns the editable editor element with the given name or null if editable does not exist.
      *
      * @param rootName The editable name.
      */
      getEditableElement(rootName = "main") {
        return this._editableElementsMap.get(rootName);
      }
      /**
      * Returns array of names of all editor editable elements.
      */
      getEditableElementsNames() {
        return this._editableElementsMap.keys();
      }
      /**
      * Adds a toolbar to the editor UI. Used primarily to maintain the accessibility of the UI.
      *
      * Focusable toolbars can be accessed (focused) by users by pressing the <kbd>Alt</kbd> + <kbd>F10</kbd> keystroke.
      * Successive keystroke presses navigate over available toolbars.
      *
      * @param toolbarView A instance of the toolbar to be registered.
      */
      addToolbar(toolbarView, options = {}) {
        if (toolbarView.isRendered) {
          this.focusTracker.add(toolbarView);
          this.editor.keystrokes.listenTo(toolbarView.element);
        } else {
          toolbarView.once("render", () => {
            this.focusTracker.add(toolbarView);
            this.editor.keystrokes.listenTo(toolbarView.element);
          });
        }
        this._focusableToolbarDefinitions.push({
          toolbarView,
          options
        });
      }
      /**
      * Registers an extra menu bar element, which could be a single item, a group of items, or a menu containing groups.
      *
      * ```ts
      * // Register a new menu bar item.
      * editor.ui.extendMenuBar( {
      *   item: 'menuBar:customFunctionButton',
      *   position: 'after:menuBar:bold'
      * } );
      *
      * // Register a new menu bar group.
      * editor.ui.extendMenuBar( {
      *   group: {
      *     groupId: 'customGroup',
      *     items: [
      *       'menuBar:customFunctionButton'
      *     ]
      *   },
      *   position: 'start:help'
      * } );
      *
      * // Register a new menu bar menu.
      * editor.ui.extendMenuBar( {
      *   menu: {
      *     menuId: 'customMenu',
      *     label: 'customMenu',
      *     groups: [
      *       {
      *         groupId: 'customGroup',
      *         items: [
      *           'menuBar:customFunctionButton'
      *         ]
      *       }
      *     ]
      *   },
      *   position: 'after:help'
      * } );
      * ```
      */
      extendMenuBar(config2) {
        this._extraMenuBarElements.push(config2);
      }
      /**
      * Stores all editable elements used by the editor instance.
      *
      * @deprecated
      */
      get _editableElements() {
        console.warn("editor-ui-deprecated-editable-elements: The EditorUI#_editableElements property has been deprecated and will be removed in the near future.", {
          editorUI: this
        });
        return this._editableElementsMap;
      }
      /**
      * Initializes menu bar.
      */
      _initMenuBar(menuBarView) {
        const menuBarViewElement = menuBarView.element;
        this.focusTracker.add(menuBarViewElement);
        this.editor.keystrokes.listenTo(menuBarViewElement);
        const normalizedMenuBarConfig = normalizeMenuBarConfig(this.editor.config.get("menuBar") || {});
        menuBarView.fillFromConfig(normalizedMenuBarConfig, this.componentFactory, this._extraMenuBarElements);
        this.editor.keystrokes.set("Esc", (data, cancel2) => {
          if (!menuBarViewElement.contains(this.editor.ui.focusTracker.focusedElement)) {
            return;
          }
          if (this._lastFocusedForeignElement) {
            this._lastFocusedForeignElement.focus();
            this._lastFocusedForeignElement = null;
          } else {
            this.editor.editing.view.focus();
          }
          cancel2();
        });
        this.editor.keystrokes.set("Alt+F9", (data, cancel2) => {
          if (menuBarViewElement.contains(this.editor.ui.focusTracker.focusedElement)) {
            return;
          }
          this._saveLastFocusedForeignElement();
          menuBarView.isFocusBorderEnabled = true;
          menuBarView.focus();
          cancel2();
        });
      }
      /**
      * Returns viewport offsets object:
      *
      * ```js
      * {
      * 	top: Number,
      * 	right: Number,
      * 	bottom: Number,
      * 	left: Number
      * }
      * ```
      *
      * Only top property is currently supported.
      */
      _readViewportOffsetFromConfig() {
        const editor2 = this.editor;
        const viewportOffsetConfig = editor2.config.get("ui.viewportOffset");
        if (viewportOffsetConfig) {
          return viewportOffsetConfig;
        }
        const legacyOffsetConfig = editor2.config.get("toolbar.viewportTopOffset");
        if (legacyOffsetConfig) {
          console.warn("editor-ui-deprecated-viewport-offset-config: The `toolbar.vieportTopOffset` configuration option is deprecated. It will be removed from future CKEditor versions. Use `ui.viewportOffset.top` instead.");
          return {
            top: legacyOffsetConfig
          };
        }
        return {
          top: 0
        };
      }
      /**
      * Starts listening for <kbd>Alt</kbd> + <kbd>F10</kbd> and <kbd>Esc</kbd> keystrokes in the context of focusable
      * {@link #setEditableElement editable elements} and {@link #addToolbar toolbars}
      * to allow users navigate across the UI.
      */
      _initFocusTracking() {
        const editor2 = this.editor;
        let candidateDefinitions;
        editor2.keystrokes.set("Alt+F10", (data, cancel2) => {
          this._saveLastFocusedForeignElement();
          const currentFocusedToolbarDefinition = this._getCurrentFocusedToolbarDefinition();
          if (!currentFocusedToolbarDefinition || !candidateDefinitions) {
            candidateDefinitions = this._getFocusableCandidateToolbarDefinitions();
          }
          for (let i2 = 0; i2 < candidateDefinitions.length; i2++) {
            const candidateDefinition = candidateDefinitions.shift();
            candidateDefinitions.push(candidateDefinition);
            if (candidateDefinition !== currentFocusedToolbarDefinition && this._focusFocusableCandidateToolbar(candidateDefinition)) {
              if (currentFocusedToolbarDefinition && currentFocusedToolbarDefinition.options.afterBlur) {
                currentFocusedToolbarDefinition.options.afterBlur();
              }
              break;
            }
          }
          cancel2();
        });
        editor2.keystrokes.set("Esc", (data, cancel2) => {
          const focusedToolbarDef = this._getCurrentFocusedToolbarDefinition();
          if (!focusedToolbarDef) {
            return;
          }
          if (this._lastFocusedForeignElement) {
            this._lastFocusedForeignElement.focus();
            this._lastFocusedForeignElement = null;
          } else {
            editor2.editing.view.focus();
          }
          if (focusedToolbarDef.options.afterBlur) {
            focusedToolbarDef.options.afterBlur();
          }
          cancel2();
        });
      }
      /**
      * Saves last focused element that doen not belong to editing view to restore focus on `Esc`.
      */
      _saveLastFocusedForeignElement() {
        const focusedElement = this.focusTracker.focusedElement;
        if (Array.from(this._editableElementsMap.values()).includes(focusedElement) && !Array.from(this.editor.editing.view.domRoots.values()).includes(focusedElement)) {
          this._lastFocusedForeignElement = focusedElement;
        }
      }
      /**
      * Returns definitions of toolbars that could potentially be focused, sorted by their importance for the user.
      *
      * Focusable toolbars candidates are either:
      * * already visible,
      * * have `beforeFocus()` set in their {@link module:ui/editorui/editorui~FocusableToolbarDefinition definition} that suggests that
      * they might show up when called. Keep in mind that determining whether a toolbar will show up (and become focusable) is impossible
      * at this stage because it depends on its implementation, that in turn depends on the editing context (selection).
      *
      * **Note**: Contextual toolbars take precedence over regular toolbars.
      */
      _getFocusableCandidateToolbarDefinitions() {
        const definitions = [];
        for (const toolbarDef of this._focusableToolbarDefinitions) {
          const { toolbarView, options } = toolbarDef;
          if (isVisible(toolbarView.element) || options.beforeFocus) {
            definitions.push(toolbarDef);
          }
        }
        definitions.sort((defA, defB) => getToolbarDefinitionWeight(defA) - getToolbarDefinitionWeight(defB));
        return definitions;
      }
      /**
      * Returns a definition of the toolbar that is currently visible and focused (one of its children has focus).
      *
      * `null` is returned when no toolbar is currently focused.
      */
      _getCurrentFocusedToolbarDefinition() {
        for (const definition of this._focusableToolbarDefinitions) {
          if (definition.toolbarView.element && definition.toolbarView.element.contains(this.focusTracker.focusedElement)) {
            return definition;
          }
        }
        return null;
      }
      /**
      * Focuses a focusable toolbar candidate using its definition.
      *
      * @param candidateToolbarDefinition A definition of the toolbar to focus.
      * @returns `true` when the toolbar candidate was focused. `false` otherwise.
      */
      _focusFocusableCandidateToolbar(candidateToolbarDefinition) {
        const { toolbarView, options: { beforeFocus } } = candidateToolbarDefinition;
        if (beforeFocus) {
          beforeFocus();
        }
        if (!isVisible(toolbarView.element)) {
          return false;
        }
        toolbarView.focus();
        return true;
      }
      /**
      * Provides an integration between {@link #viewportOffset} and {@link module:utils/dom/scroll~scrollViewportToShowTarget}.
      * It allows the UI-agnostic engine method to consider user-configured viewport offsets specific for the integration.
      *
      * @param evt The `scrollToTheSelection` event info.
      * @param data The payload carried by the `scrollToTheSelection` event.
      */
      _handleScrollToTheSelection(evt, data) {
        const configuredViewportOffset = {
          top: 0,
          bottom: 0,
          left: 0,
          right: 0,
          ...this.viewportOffset
        };
        data.viewportOffset.top += configuredViewportOffset.top;
        data.viewportOffset.bottom += configuredViewportOffset.bottom;
        data.viewportOffset.left += configuredViewportOffset.left;
        data.viewportOffset.right += configuredViewportOffset.right;
      }
      /**
      * Ensures that the focus tracker is aware of all views' DOM elements in the body collection.
      */
      _bindBodyCollectionWithFocusTracker() {
        const body = this.view.body;
        for (const view of body) {
          this.focusTracker.add(view.element);
        }
        body.on("add", (evt, view) => {
          this.focusTracker.add(view.element);
        });
        body.on("remove", (evt, view) => {
          this.focusTracker.remove(view.element);
        });
      }
    }
    function getToolbarDefinitionWeight(toolbarDef) {
      const { toolbarView, options } = toolbarDef;
      let weight = 10;
      if (isVisible(toolbarView.element)) {
        weight--;
      }
      if (options.isContextual) {
        weight--;
      }
      return weight;
    }
    class EditorUIView extends View {
      /**
      * Creates an instance of the editor UI view class.
      *
      * @param locale The locale instance.
      */
      constructor(locale) {
        super(locale);
        /**
        * Collection of the child views, detached from the DOM
        * structure of the editor, like panels, icons etc.
        */
        __publicField(this, "body");
        /**
        * Menu bar view instance. May not be initialized in some editor types.
        */
        __publicField(this, "menuBarView");
        this.body = new BodyCollection(locale);
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        this.body.attachToDom();
      }
      /**
      * @inheritDoc
      */
      destroy() {
        this.body.detachFromDom();
        return super.destroy();
      }
    }
    class BoxedEditorUIView extends EditorUIView {
      /**
      * Creates an instance of the boxed editor UI view class.
      *
      * @param locale The locale instance..
      */
      constructor(locale) {
        super(locale);
        /**
        * Collection of the child views located in the top (`.ck-editor__top`)
        * area of the UI.
        */
        __publicField(this, "top");
        /**
        * Collection of the child views located in the main (`.ck-editor__main`)
        * area of the UI.
        */
        __publicField(this, "main");
        /**
        * Voice label of the UI.
        */
        __publicField(this, "_voiceLabelView");
        this.top = this.createCollection();
        this.main = this.createCollection();
        this._voiceLabelView = this._createVoiceLabel();
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-reset",
              "ck-editor",
              "ck-rounded-corners"
            ],
            role: "application",
            dir: locale.uiLanguageDirection,
            lang: locale.uiLanguage,
            "aria-labelledby": this._voiceLabelView.id
          },
          children: [
            this._voiceLabelView,
            {
              tag: "div",
              attributes: {
                class: [
                  "ck",
                  "ck-editor__top",
                  "ck-reset_all"
                ],
                role: "presentation"
              },
              children: this.top
            },
            {
              tag: "div",
              attributes: {
                class: [
                  "ck",
                  "ck-editor__main"
                ],
                role: "presentation"
              },
              children: this.main
            }
          ]
        });
      }
      /**
      * Creates a voice label view instance.
      */
      _createVoiceLabel() {
        const t2 = this.t;
        const voiceLabel = new LabelView();
        voiceLabel.text = t2("Rich Text Editor");
        voiceLabel.extendTemplate({
          attributes: {
            class: "ck-voice-label"
          }
        });
        return voiceLabel;
      }
    }
    class EditableUIView extends View {
      /**
      * Creates an instance of EditableUIView class.
      *
      * @param locale The locale instance.
      * @param editingView The editing view instance the editable is related to.
      * @param editableElement The editable element. If not specified, this view
      * should create it. Otherwise, the existing element should be used.
      */
      constructor(locale, editingView, editableElement) {
        super(locale);
        /**
        * The name of the editable UI view.
        */
        __publicField(this, "name", null);
        /**
        * The editing view instance the editable is related to. Editable uses the editing
        * view to dynamically modify its certain DOM attributes after {@link #render rendering}.
        *
        * **Note**: The DOM attributes are performed by the editing view and not UI
        * {@link module:ui/view~View#bindTemplate template bindings} because once rendered,
        * the editable DOM element must remain under the full control of the engine to work properly.
        */
        __publicField(this, "_editingView");
        /**
        * The element which is the main editable element (usually the one with `contentEditable="true"`).
        */
        __publicField(this, "_editableElement");
        /**
        * Whether an external {@link #_editableElement} was passed into the constructor, which also means
        * the view will not render its {@link #template}.
        */
        __publicField(this, "_hasExternalElement");
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-content",
              "ck-editor__editable",
              "ck-rounded-corners"
            ],
            lang: locale.contentLanguage,
            dir: locale.contentLanguageDirection
          }
        });
        this.set("isFocused", false);
        this._editableElement = editableElement;
        this._hasExternalElement = !!this._editableElement;
        this._editingView = editingView;
      }
      /**
      * Renders the view by either applying the {@link #template} to the existing
      * {@link module:ui/editableui/editableuiview~EditableUIView#_editableElement} or assigning {@link #element}
      * as {@link module:ui/editableui/editableuiview~EditableUIView#_editableElement}.
      */
      render() {
        super.render();
        if (this._hasExternalElement) {
          this.template.apply(this.element = this._editableElement);
        } else {
          this._editableElement = this.element;
        }
        this.on("change:isFocused", () => this._updateIsFocusedClasses());
        this._updateIsFocusedClasses();
      }
      /**
      * @inheritDoc
      */
      destroy() {
        if (this._hasExternalElement) {
          this.template.revert(this._editableElement);
        }
        super.destroy();
      }
      /**
      * Whether an external {@link #_editableElement} was passed into the constructor, which also means
      * the view will not render its {@link #template}.
      */
      get hasExternalElement() {
        return this._hasExternalElement;
      }
      /**
      * Updates the `ck-focused` and `ck-blurred` CSS classes on the {@link #element} according to
      * the {@link #isFocused} property value using the {@link #_editingView editing view} API.
      */
      _updateIsFocusedClasses() {
        const editingView = this._editingView;
        if (editingView.isRenderingInProgress) {
          updateAfterRender(this);
        } else {
          update2(this);
        }
        function update2(view) {
          editingView.change((writer) => {
            const viewRoot = editingView.document.getRoot(view.name);
            writer.addClass(view.isFocused ? "ck-focused" : "ck-blurred", viewRoot);
            writer.removeClass(view.isFocused ? "ck-blurred" : "ck-focused", viewRoot);
          });
        }
        function updateAfterRender(view) {
          editingView.once("change:isRenderingInProgress", (evt, name, value) => {
            if (!value) {
              update2(view);
            } else {
              updateAfterRender(view);
            }
          });
        }
      }
    }
    class InlineEditableUIView extends EditableUIView {
      /**
      * Creates an instance of the InlineEditableUIView class.
      *
      * @param locale The locale instance.
      * @param editingView The editing view instance the editable is related to.
      * @param editableElement The editable element. If not specified, the
      * {@link module:ui/editableui/editableuiview~EditableUIView}
      * will create it. Otherwise, the existing element will be used.
      * @param options Additional configuration of the view.
      * @param options.label The label of the editable for assistive technologies. If not provided, a default label is used or,
      * the existing `aria-label` attribute value from the specified `editableElement` is preserved.
      */
      constructor(locale, editingView, editableElement, options = {}) {
        super(locale, editingView, editableElement);
        /**
        * The cached options object passed to the constructor.
        */
        __publicField(this, "_options");
        this._options = options;
        this.extendTemplate({
          attributes: {
            role: "textbox",
            class: "ck-editor__editable_inline"
          }
        });
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        const editingView = this._editingView;
        editingView.change((writer) => {
          const viewRoot = editingView.document.getRoot(this.name);
          writer.setAttribute("aria-label", this.getEditableAriaLabel(), viewRoot);
        });
      }
      /**
      * Returns a normalized label for the editable view based on the environment.
      */
      getEditableAriaLabel() {
        const t2 = this.locale.t;
        const label = this._options.label;
        const editableElement = this._editableElement;
        const editableName = this.name;
        if (typeof label == "string") {
          return label;
        } else if (typeof label === "object") {
          return label[editableName];
        } else if (typeof label === "function") {
          return label(this);
        } else if (editableElement) {
          const existingLabel = editableElement.getAttribute("aria-label");
          if (existingLabel) {
            return existingLabel;
          }
        }
        return t2("Rich Text Editor. Editing area: %0", editableName);
      }
    }
    class Model extends (/* @__PURE__ */ ObservableMixin()) {
      /**
      * Creates a new Model instance.
      *
      * @param attributes The model state attributes to be defined during the instance creation.
      * @param properties The (out of state) properties to be appended to the instance during creation.
      */
      constructor(attributes, properties) {
        super();
        if (properties) {
          assignIn(this, properties);
        }
        if (attributes) {
          this.set(attributes);
        }
      }
    }
    const toPx$4 = /* @__PURE__ */ toUnit("px");
    class ContextualBalloon extends Plugin {
      /**
      * @inheritDoc
      */
      constructor(editor2) {
        super(editor2);
        /**
        * The {@link module:utils/dom/position~Options#limiter position limiter}
        * for the {@link #view balloon}, used when no `limiter` has been passed into {@link #add}
        * or {@link #updatePosition}.
        *
        * By default, a function that obtains the farthest DOM
        * {@link module:engine/view/rooteditableelement~RootEditableElement}
        * of the {@link module:engine/view/document~Document#selection}.
        */
        __publicField(this, "positionLimiter");
        __publicField(this, "visibleStack");
        /**
        * The map of views and their stacks.
        */
        __publicField(this, "_viewToStack", /* @__PURE__ */ new Map());
        /**
        * The map of IDs and stacks.
        */
        __publicField(this, "_idToStack", /* @__PURE__ */ new Map());
        /**
        * The common balloon panel view.
        */
        __publicField(this, "_view", null);
        /**
        * Rotator view embedded in the contextual balloon.
        * Displays the currently visible view in the balloon and provides navigation for switching stacks.
        */
        __publicField(this, "_rotatorView", null);
        /**
        * Displays fake panels under the balloon panel view when multiple stacks are added to the balloon.
        */
        __publicField(this, "_fakePanelsView", null);
        this.positionLimiter = () => {
          const view = this.editor.editing.view;
          const viewDocument = view.document;
          const editableElement = viewDocument.selection.editableElement;
          if (editableElement) {
            return view.domConverter.mapViewToDom(editableElement.root);
          }
          return null;
        };
        this.decorate("getPositionOptions");
        this.set("visibleView", null);
        this.set("_numberOfStacks", 0);
        this.set("_singleViewMode", false);
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "ContextualBalloon";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        if (this._view) {
          this._view.destroy();
        }
        if (this._rotatorView) {
          this._rotatorView.destroy();
        }
        if (this._fakePanelsView) {
          this._fakePanelsView.destroy();
        }
      }
      /**
      * The common balloon panel view.
      */
      get view() {
        if (!this._view) {
          this._createPanelView();
        }
        return this._view;
      }
      /**
      * Returns `true` when the given view is in one of the stacks. Otherwise returns `false`.
      */
      hasView(view) {
        return Array.from(this._viewToStack.keys()).includes(view);
      }
      /**
      * Adds a new view to the stack and makes it visible if the current stack is visible
      * or it is the first view in the balloon.
      *
      * @param data The configuration of the view.
      * @param data.stackId The ID of the stack that the view is added to. Defaults to `'main'`.
      * @param data.view The content of the balloon.
      * @param data.position Positioning options.
      * @param data.balloonClassName An additional CSS class added to the {@link #view balloon} when visible.
      * @param data.withArrow Whether the {@link #view balloon} should be rendered with an arrow. Defaults to `true`.
      * @param data.singleViewMode Whether the view should be the only visible view even if other stacks were added. Defaults to `false`.
      */
      add(data) {
        if (!this._view) {
          this._createPanelView();
        }
        if (this.hasView(data.view)) {
          throw new CKEditorError("contextualballoon-add-view-exist", [
            this,
            data
          ]);
        }
        const stackId = data.stackId || "main";
        if (!this._idToStack.has(stackId)) {
          this._idToStack.set(stackId, /* @__PURE__ */ new Map([
            [
              data.view,
              data
            ]
          ]));
          this._viewToStack.set(data.view, this._idToStack.get(stackId));
          this._numberOfStacks = this._idToStack.size;
          if (!this._visibleStack || data.singleViewMode) {
            this.showStack(stackId);
          }
          return;
        }
        const stack = this._idToStack.get(stackId);
        if (data.singleViewMode) {
          this.showStack(stackId);
        }
        stack.set(data.view, data);
        this._viewToStack.set(data.view, stack);
        if (stack === this._visibleStack) {
          this._showView(data);
        }
      }
      /**
      * Removes the given view from the stack. If the removed view was visible,
      * the view preceding it in the stack will become visible instead.
      * When there is no view in the stack, the next stack will be displayed.
      * When there are no more stacks, the balloon will hide.
      *
      * @param view A view to be removed from the balloon.
      */
      remove(view) {
        if (!this.hasView(view)) {
          throw new CKEditorError("contextualballoon-remove-view-not-exist", [
            this,
            view
          ]);
        }
        const stack = this._viewToStack.get(view);
        if (this._singleViewMode && this.visibleView === view) {
          this._singleViewMode = false;
        }
        if (this.visibleView === view) {
          if (stack.size === 1) {
            if (this._idToStack.size > 1) {
              this._showNextStack();
            } else {
              this.view.hide();
              this.visibleView = null;
              this._rotatorView.hideView();
            }
          } else {
            this._showView(Array.from(stack.values())[stack.size - 2]);
          }
        }
        if (stack.size === 1) {
          this._idToStack.delete(this._getStackId(stack));
          this._numberOfStacks = this._idToStack.size;
        } else {
          stack.delete(view);
        }
        this._viewToStack.delete(view);
      }
      /**
      * Updates the position of the balloon using the position data of the first visible view in the stack.
      * When new position data is given, the position data of the currently visible view will be updated.
      *
      * @param position Position options.
      */
      updatePosition(position) {
        if (position) {
          this._visibleStack.get(this.visibleView).position = position;
        }
        this.view.pin(this.getPositionOptions());
        this._fakePanelsView.updatePosition();
      }
      /**
      * Returns position options of the last view in the stack.
      * This keeps the balloon in the same position when the view is changed.
      */
      getPositionOptions() {
        let position = Array.from(this._visibleStack.values()).pop().position;
        if (position) {
          if (!position.limiter) {
            position = Object.assign({}, position, {
              limiter: this.positionLimiter
            });
          }
          position = Object.assign({}, position, {
            viewportOffsetConfig: this.editor.ui.viewportOffset
          });
        }
        return position;
      }
      /**
      * Shows the last view from the stack of a given ID.
      */
      showStack(id) {
        this.visibleStack = id;
        const stack = this._idToStack.get(id);
        if (!stack) {
          throw new CKEditorError("contextualballoon-showstack-stack-not-exist", this);
        }
        if (this._visibleStack === stack) {
          return;
        }
        this._showView(Array.from(stack.values()).pop());
      }
      /**
      * Initializes view instances.
      */
      _createPanelView() {
        this._view = new BalloonPanelView(this.editor.locale);
        this.editor.ui.view.body.add(this._view);
        this._rotatorView = this._createRotatorView();
        this._fakePanelsView = this._createFakePanelsView();
      }
      /**
      * Returns the stack of the currently visible view.
      */
      get _visibleStack() {
        return this._viewToStack.get(this.visibleView);
      }
      /**
      * Returns the ID of the given stack.
      */
      _getStackId(stack) {
        const entry = Array.from(this._idToStack.entries()).find((entry2) => entry2[1] === stack);
        return entry[0];
      }
      /**
      * Shows the last view from the next stack.
      */
      _showNextStack() {
        const stacks = Array.from(this._idToStack.values());
        let nextIndex = stacks.indexOf(this._visibleStack) + 1;
        if (!stacks[nextIndex]) {
          nextIndex = 0;
        }
        this.showStack(this._getStackId(stacks[nextIndex]));
      }
      /**
      * Shows the last view from the previous stack.
      */
      _showPrevStack() {
        const stacks = Array.from(this._idToStack.values());
        let nextIndex = stacks.indexOf(this._visibleStack) - 1;
        if (!stacks[nextIndex]) {
          nextIndex = stacks.length - 1;
        }
        this.showStack(this._getStackId(stacks[nextIndex]));
      }
      /**
      * Creates a rotator view.
      */
      _createRotatorView() {
        const view = new RotatorView(this.editor.locale);
        const t2 = this.editor.locale.t;
        this.view.content.add(view);
        view.bind("isNavigationVisible").to(this, "_numberOfStacks", this, "_singleViewMode", (value, isSingleViewMode) => {
          return !isSingleViewMode && value > 1;
        });
        view.on("change:isNavigationVisible", () => this.updatePosition(), {
          priority: "low"
        });
        view.bind("counter").to(this, "visibleView", this, "_numberOfStacks", (visibleView, numberOfStacks) => {
          if (numberOfStacks < 2) {
            return "";
          }
          const current = Array.from(this._idToStack.values()).indexOf(this._visibleStack) + 1;
          return t2("%0 of %1", [
            current,
            numberOfStacks
          ]);
        });
        view.buttonNextView.on("execute", () => {
          if (view.focusTracker.isFocused) {
            this.editor.editing.view.focus();
          }
          this._showNextStack();
        });
        view.buttonPrevView.on("execute", () => {
          if (view.focusTracker.isFocused) {
            this.editor.editing.view.focus();
          }
          this._showPrevStack();
        });
        return view;
      }
      /**
      * Creates a fake panels view.
      */
      _createFakePanelsView() {
        const view = new FakePanelsView(this.editor.locale, this.view);
        view.bind("numberOfPanels").to(this, "_numberOfStacks", this, "_singleViewMode", (number2, isSingleViewMode) => {
          const showPanels = !isSingleViewMode && number2 >= 2;
          return showPanels ? Math.min(number2 - 1, 2) : 0;
        });
        view.listenTo(this.view, "change:top", () => view.updatePosition());
        view.listenTo(this.view, "change:left", () => view.updatePosition());
        this.editor.ui.view.body.add(view);
        return view;
      }
      /**
      * Sets the view as the content of the balloon and attaches the balloon using position
      * options of the first view.
      *
      * @param data Configuration.
      * @param data.view The view to show in the balloon.
      * @param data.balloonClassName Additional class name which will be added to the {@link #view balloon}.
      * @param data.withArrow Whether the {@link #view balloon} should be rendered with an arrow.
      */
      _showView({ view, balloonClassName = "", withArrow = true, singleViewMode = false }) {
        this.view.class = balloonClassName;
        this.view.withArrow = withArrow;
        this._rotatorView.showView(view);
        this.visibleView = view;
        this.view.pin(this.getPositionOptions());
        this._fakePanelsView.updatePosition();
        if (singleViewMode) {
          this._singleViewMode = true;
        }
      }
    }
    class RotatorView extends View {
      /**
      * @inheritDoc
      */
      constructor(locale) {
        super(locale);
        /**
        * Used for checking if a view is focused or not.
        */
        __publicField(this, "focusTracker");
        /**
        * Navigation button for switching the stack to the previous one.
        */
        __publicField(this, "buttonPrevView");
        /**
        * Navigation button for switching the stack to the next one.
        */
        __publicField(this, "buttonNextView");
        /**
        * A collection of the child views that creates the rotator content.
        */
        __publicField(this, "content");
        const t2 = locale.t;
        const bind2 = this.bindTemplate;
        this.set("isNavigationVisible", true);
        this.focusTracker = new FocusTracker();
        this.buttonPrevView = this._createButtonView(t2("Previous"), icons.previousArrow);
        this.buttonNextView = this._createButtonView(t2("Next"), icons.nextArrow);
        this.content = this.createCollection();
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-balloon-rotator"
            ],
            "z-index": "-1"
          },
          children: [
            {
              tag: "div",
              attributes: {
                class: [
                  "ck-balloon-rotator__navigation",
                  bind2.to("isNavigationVisible", (value) => value ? "" : "ck-hidden")
                ]
              },
              children: [
                this.buttonPrevView,
                {
                  tag: "span",
                  attributes: {
                    class: [
                      "ck-balloon-rotator__counter"
                    ]
                  },
                  children: [
                    {
                      text: bind2.to("counter")
                    }
                  ]
                },
                this.buttonNextView
              ]
            },
            {
              tag: "div",
              attributes: {
                class: "ck-balloon-rotator__content"
              },
              children: this.content
            }
          ]
        });
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        this.focusTracker.add(this.element);
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        this.focusTracker.destroy();
      }
      /**
      * Shows a given view.
      *
      * @param view The view to show.
      */
      showView(view) {
        this.hideView();
        this.content.add(view);
      }
      /**
      * Hides the currently displayed view.
      */
      hideView() {
        this.content.clear();
      }
      /**
      * Creates a navigation button view.
      *
      * @param label The button label.
      * @param icon The button icon.
      */
      _createButtonView(label, icon) {
        const view = new ButtonView(this.locale);
        view.set({
          label,
          icon,
          tooltip: true
        });
        return view;
      }
    }
    class FakePanelsView extends View {
      /**
      * @inheritDoc
      */
      constructor(locale, balloonPanelView) {
        super(locale);
        /**
        * Collection of the child views which creates fake panel content.
        */
        __publicField(this, "content");
        /**
        * Context.
        */
        __publicField(this, "_balloonPanelView");
        const bind2 = this.bindTemplate;
        this.set("top", 0);
        this.set("left", 0);
        this.set("height", 0);
        this.set("width", 0);
        this.set("numberOfPanels", 0);
        this.content = this.createCollection();
        this._balloonPanelView = balloonPanelView;
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck-fake-panel",
              bind2.to("numberOfPanels", (number2) => number2 ? "" : "ck-hidden")
            ],
            style: {
              top: bind2.to("top", toPx$4),
              left: bind2.to("left", toPx$4),
              width: bind2.to("width", toPx$4),
              height: bind2.to("height", toPx$4)
            }
          },
          children: this.content
        });
        this.on("change:numberOfPanels", (evt, name, next, prev) => {
          if (next > prev) {
            this._addPanels(next - prev);
          } else {
            this._removePanels(prev - next);
          }
          this.updatePosition();
        });
      }
      _addPanels(number2) {
        while (number2--) {
          const view = new View();
          view.setTemplate({
            tag: "div"
          });
          this.content.add(view);
          this.registerChild(view);
        }
      }
      _removePanels(number2) {
        while (number2--) {
          const view = this.content.last;
          this.content.remove(view);
          this.deregisterChild(view);
          view.destroy();
        }
      }
      /**
      * Updates coordinates of fake panels.
      */
      updatePosition() {
        if (this.numberOfPanels) {
          const { top: top2, left: left2 } = this._balloonPanelView;
          const { width, height } = new Rect(this._balloonPanelView.element);
          Object.assign(this, {
            top: top2,
            left: left2,
            width,
            height
          });
        }
      }
    }
    const toPx$3 = /* @__PURE__ */ toUnit("px");
    class StickyPanelView extends View {
      /**
      * @inheritDoc
      */
      constructor(locale) {
        super(locale);
        /**
        * Collection of the child views which creates balloon panel contents.
        */
        __publicField(this, "content");
        /**
        * The panel which accepts children into {@link #content} collection.
        * Also an element which is positioned when {@link #isSticky}.
        */
        __publicField(this, "contentPanelElement");
        /**
        * A dummy element which visually fills the space as long as the
        * actual panel is sticky. It prevents flickering of the UI.
        */
        __publicField(this, "_contentPanelPlaceholder");
        const bind2 = this.bindTemplate;
        this.set("isActive", false);
        this.set("isSticky", false);
        this.set("limiterElement", null);
        this.set("limiterBottomOffset", 50);
        this.set("viewportTopOffset", 0);
        this.set("_marginLeft", null);
        this.set("_isStickyToTheBottomOfLimiter", false);
        this.set("_stickyTopOffset", null);
        this.set("_stickyBottomOffset", null);
        this.content = this.createCollection();
        this._contentPanelPlaceholder = new Template({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-sticky-panel__placeholder"
            ],
            style: {
              display: bind2.to("isSticky", (isSticky) => isSticky ? "block" : "none"),
              height: bind2.to("isSticky", (isSticky) => {
                return isSticky ? toPx$3(this._contentPanelRect.height) : null;
              })
            }
          }
        }).render();
        this.contentPanelElement = new Template({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-sticky-panel__content",
              // Toggle class of the panel when "sticky" state changes in the view.
              bind2.if("isSticky", "ck-sticky-panel__content_sticky"),
              bind2.if("_isStickyToTheBottomOfLimiter", "ck-sticky-panel__content_sticky_bottom-limit")
            ],
            style: {
              width: bind2.to("isSticky", (isSticky) => {
                return isSticky ? toPx$3(this._contentPanelPlaceholder.getBoundingClientRect().width) : null;
              }),
              top: bind2.to("_stickyTopOffset", (value) => value ? toPx$3(value) : value),
              bottom: bind2.to("_stickyBottomOffset", (value) => value ? toPx$3(value) : value),
              marginLeft: bind2.to("_marginLeft")
            }
          },
          children: this.content
        }).render();
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-sticky-panel"
            ]
          },
          children: [
            this._contentPanelPlaceholder,
            this.contentPanelElement
          ]
        });
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        this.checkIfShouldBeSticky();
        this.listenTo(global$1.document, "scroll", () => {
          this.checkIfShouldBeSticky();
        }, {
          useCapture: true
        });
        this.listenTo(this, "change:isActive", () => {
          this.checkIfShouldBeSticky();
        });
      }
      /**
      * Analyzes the environment to decide whether the panel should be sticky or not.
      * Then handles the positioning of the panel.
      */
      checkIfShouldBeSticky() {
        if (!this.limiterElement || !this.isActive) {
          this._unstick();
          return;
        }
        const limiterRect = new Rect(this.limiterElement);
        let visibleLimiterRect = limiterRect.getVisible();
        if (visibleLimiterRect) {
          const windowRect = new Rect(global$1.window);
          windowRect.top += this.viewportTopOffset;
          windowRect.height -= this.viewportTopOffset;
          visibleLimiterRect = visibleLimiterRect.getIntersection(windowRect);
        }
        if (visibleLimiterRect && limiterRect.top < visibleLimiterRect.top) {
          const visibleLimiterTop = visibleLimiterRect.top;
          if (visibleLimiterTop + this._contentPanelRect.height + this.limiterBottomOffset > visibleLimiterRect.bottom) {
            const stickyBottomOffset = Math.max(limiterRect.bottom - visibleLimiterRect.bottom, 0) + this.limiterBottomOffset;
            if (limiterRect.bottom - stickyBottomOffset > limiterRect.top + this._contentPanelRect.height) {
              this._stickToBottomOfLimiter(stickyBottomOffset);
            } else {
              this._unstick();
            }
          } else {
            if (this._contentPanelRect.height + this.limiterBottomOffset < limiterRect.height) {
              this._stickToTopOfAncestors(visibleLimiterTop);
            } else {
              this._unstick();
            }
          }
        } else {
          this._unstick();
        }
      }
      /**
      * Sticks the panel at the given CSS `top` offset.
      *
      * @private
      * @param topOffset
      */
      _stickToTopOfAncestors(topOffset) {
        this.isSticky = true;
        this._isStickyToTheBottomOfLimiter = false;
        this._stickyTopOffset = topOffset;
        this._stickyBottomOffset = null;
        this._marginLeft = toPx$3(-global$1.window.scrollX);
      }
      /**
      * Sticks the panel at the bottom of the limiter with a given CSS `bottom` offset.
      *
      * @private
      * @param stickyBottomOffset
      */
      _stickToBottomOfLimiter(stickyBottomOffset) {
        this.isSticky = true;
        this._isStickyToTheBottomOfLimiter = true;
        this._stickyTopOffset = null;
        this._stickyBottomOffset = stickyBottomOffset;
        this._marginLeft = toPx$3(-global$1.window.scrollX);
      }
      /**
      * Unsticks the panel putting it back to its original position.
      *
      * @private
      */
      _unstick() {
        this.isSticky = false;
        this._isStickyToTheBottomOfLimiter = false;
        this._stickyTopOffset = null;
        this._stickyBottomOffset = null;
        this._marginLeft = null;
      }
      /**
      * Returns the bounding rect of the {@link #contentPanelElement}.
      *
      * @private
      */
      get _contentPanelRect() {
        return new Rect(this.contentPanelElement);
      }
    }
    class MenuBarMenuButtonView extends ListItemButtonView {
      /**
      * Creates an instance of the menu bar button view.
      *
      * @param locale The localization services instance.
      */
      constructor(locale) {
        super(locale);
        /**
        * An icon that displays an arrow to indicate a direction of the menu.
        */
        __publicField(this, "arrowView");
        const bind2 = this.bindTemplate;
        this.set({
          withText: true,
          role: "menuitem"
        });
        this.arrowView = this._createArrowView();
        this.extendTemplate({
          attributes: {
            class: [
              "ck-menu-bar__menu__button"
            ],
            "aria-haspopup": true,
            "aria-expanded": this.bindTemplate.to("isOn", (value) => String(value)),
            "data-cke-tooltip-disabled": bind2.to("isOn")
          },
          on: {
            "mouseenter": bind2.to("mouseenter")
          }
        });
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        this.children.add(this.arrowView);
      }
      /**
      * Creates the {@link #arrowView} instance.
      */
      _createArrowView() {
        const arrowView = new IconView();
        arrowView.content = dropdownArrowIcon;
        arrowView.extendTemplate({
          attributes: {
            class: "ck-menu-bar__menu__button__arrow"
          }
        });
        return arrowView;
      }
    }
    class MenuBarMenuPanelView extends View {
      /**
      * Creates an instance of the menu panel view.
      *
      * @param locale The localization services instance.
      */
      constructor(locale) {
        super(locale);
        /**
        * Collection of the child views in this panel.
        */
        __publicField(this, "children");
        const bind2 = this.bindTemplate;
        this.set("isVisible", false);
        this.set("position", "se");
        this.children = this.createCollection();
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-reset",
              "ck-menu-bar__menu__panel",
              bind2.to("position", (value) => `ck-menu-bar__menu__panel_position_${value}`),
              bind2.if("isVisible", "ck-hidden", (value) => !value)
            ],
            tabindex: "-1"
          },
          children: this.children,
          on: {
            // Drag and drop in the panel should not break the selection in the editor.
            // https://github.com/ckeditor/ckeditor5-ui/issues/228
            selectstart: bind2.to((evt) => {
              if (evt.target.tagName.toLocaleLowerCase() === "input") {
                return;
              }
              evt.preventDefault();
            })
          }
        });
      }
      /**
      * Focuses the first child of the panel (default) or the last one if the `direction` is `-1`.
      */
      focus(direction = 1) {
        if (this.children.length) {
          if (direction === 1) {
            this.children.first.focus();
          } else {
            this.children.last.focus();
          }
        }
      }
    }
    const _MenuBarMenuView = class _MenuBarMenuView extends View {
      /**
      * Creates an instance of the menu view.
      *
      * @param locale The localization services instance.
      */
      constructor(locale) {
        super(locale);
        /**
        * Button of the menu view.
        */
        __publicField(this, "buttonView");
        /**
        * Panel of the menu. It hosts children of the menu.
        */
        __publicField(this, "panelView");
        /**
        * Tracks information about the DOM focus in the menu.
        */
        __publicField(this, "focusTracker");
        /**
        * Instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}. It manages
        * keystrokes of the menu.
        */
        __publicField(this, "keystrokes");
        const bind2 = this.bindTemplate;
        this.buttonView = new MenuBarMenuButtonView(locale);
        this.buttonView.delegate("mouseenter").to(this);
        this.buttonView.bind("isOn", "isEnabled").to(this, "isOpen", "isEnabled");
        this.panelView = new MenuBarMenuPanelView(locale);
        this.panelView.bind("isVisible").to(this, "isOpen");
        this.keystrokes = new KeystrokeHandler();
        this.focusTracker = new FocusTracker();
        this.set("isOpen", false);
        this.set("isEnabled", true);
        this.set("panelPosition", "w");
        this.set("class", void 0);
        this.set("parentMenuView", null);
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-menu-bar__menu",
              bind2.to("class"),
              bind2.if("isEnabled", "ck-disabled", (value) => !value),
              bind2.if("parentMenuView", "ck-menu-bar__menu_top-level", (value) => !value)
            ]
          },
          children: [
            this.buttonView,
            this.panelView
          ]
        });
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        this.focusTracker.add(this.buttonView.element);
        this.focusTracker.add(this.panelView.element);
        this.keystrokes.listenTo(this.element);
        MenuBarMenuBehaviors.closeOnEscKey(this);
        this._repositionPanelOnOpen();
      }
      // For now, this method cannot be called in the render process because the `parentMenuView` may be assigned
      // after the rendering process.
      //
      // TODO: We should reconsider the way we handle this logic.
      /**
      * Attach all keyboard behaviors for the menu bar view.
      *
      * @internal
      */
      _attachBehaviors() {
        if (!this.parentMenuView) {
          this._propagateArrowKeystrokeEvents();
          MenuBarMenuBehaviors.openAndFocusPanelOnArrowDownKey(this);
          MenuBarMenuBehaviors.toggleOnButtonClick(this);
        } else {
          MenuBarMenuBehaviors.openOnButtonClick(this);
          MenuBarMenuBehaviors.openOnArrowRightKey(this);
          MenuBarMenuBehaviors.closeOnArrowLeftKey(this);
          MenuBarMenuBehaviors.openAndFocusOnEnterKeyPress(this);
          MenuBarMenuBehaviors.closeOnParentClose(this);
        }
      }
      /**
      * Fires `arrowright` and `arrowleft` events when the user pressed corresponding arrow keys.
      */
      _propagateArrowKeystrokeEvents() {
        this.keystrokes.set("arrowright", (data, cancel2) => {
          this.fire("arrowright");
          cancel2();
        });
        this.keystrokes.set("arrowleft", (data, cancel2) => {
          this.fire("arrowleft");
          cancel2();
        });
      }
      /**
      * Sets the position of the panel when the menu opens. The panel is positioned
      * so that it optimally uses the available space in the viewport.
      */
      _repositionPanelOnOpen() {
        this.on("change:isOpen", (evt, name, isOpen) => {
          if (!isOpen) {
            return;
          }
          const optimalPanelPosition = _MenuBarMenuView._getOptimalPosition({
            element: this.panelView.element,
            target: this.buttonView.element,
            fitInViewport: true,
            positions: this._panelPositions
          });
          this.panelView.position = optimalPanelPosition ? optimalPanelPosition.name : this._panelPositions[0].name;
        });
      }
      /**
      * @inheritDoc
      */
      focus() {
        this.buttonView.focus();
      }
      /**
      * Positioning functions for the {@link #panelView} . They change depending on the role of the menu (top-level vs sub-menu) in
      * the {@link module:ui/menubar/menubarview~MenuBarView menu bar} and the UI language direction.
      */
      get _panelPositions() {
        const { southEast, southWest, northEast, northWest, westSouth, eastSouth, westNorth, eastNorth } = MenuBarMenuViewPanelPositioningFunctions;
        if (this.locale.uiLanguageDirection === "ltr") {
          if (this.parentMenuView) {
            return [
              eastSouth,
              eastNorth,
              westSouth,
              westNorth
            ];
          } else {
            return [
              southEast,
              southWest,
              northEast,
              northWest
            ];
          }
        } else {
          if (this.parentMenuView) {
            return [
              westSouth,
              westNorth,
              eastSouth,
              eastNorth
            ];
          } else {
            return [
              southWest,
              southEast,
              northWest,
              northEast
            ];
          }
        }
      }
    };
    /**
    * A function used to calculate the optimal position for the dropdown panel.
    *
    * Referenced for unit testing purposes.
    */
    __publicField(_MenuBarMenuView, "_getOptimalPosition", getOptimalPosition);
    let MenuBarMenuView = _MenuBarMenuView;
    class MenuBarMenuListView extends ListView {
      /**
      * Creates an instance of the list view.
      *
      * @param locale The localization services instance.
      */
      constructor(locale) {
        super(locale);
        this.role = "menu";
        this.items.on("change", this._setItemsCheckSpace.bind(this));
      }
      /**
      * This method adds empty space if there is any toggleable item in the list.
      * It makes the list properly aligned.
      */
      _setItemsCheckSpace() {
        const hasAnyToggleableItem = Array.from(this.items).some((item) => {
          const listButtonView = pickListButtonMenuViewIfPresent(item);
          return listButtonView && listButtonView.isToggleable;
        });
        this.items.forEach((item) => {
          const listButtonView = pickListButtonMenuViewIfPresent(item);
          if (listButtonView) {
            listButtonView.hasCheckSpace = hasAnyToggleableItem;
          }
        });
      }
    }
    function pickListButtonMenuViewIfPresent(item) {
      if (!(item instanceof ListItemView)) {
        return null;
      }
      return item.children.map((child) => isNestedMenuLikeView(child) ? child.buttonView : child).find((item2) => item2 instanceof ListItemButtonView);
    }
    function isNestedMenuLikeView(item) {
      return typeof item === "object" && "buttonView" in item && item.buttonView instanceof ButtonView;
    }
    class MenuBarMenuListItemFileDialogButtonView extends FileDialogListItemButtonView {
      /**
      * Creates an instance of the menu bar list button view.
      *
      * @param locale The localization services instance.
      */
      constructor(locale) {
        super(locale);
        this.set({
          withText: true,
          withKeystroke: true,
          tooltip: false,
          role: "menuitem"
        });
        this.extendTemplate({
          attributes: {
            class: [
              "ck-menu-bar__menu__item__button"
            ]
          }
        });
      }
    }
    const EVENT_NAME_DELEGATES = [
      "mouseenter",
      "arrowleft",
      "arrowright",
      "change:isOpen"
    ];
    class MenuBarView extends View {
      /**
      * Creates an instance of the menu bar view.
      *
      * @param locale The localization services instance.
      */
      constructor(locale) {
        super(locale);
        /**
        * Collection of the child views inside the {@link #element}.
        */
        __publicField(this, "children");
        /**
        * A list of {@link module:ui/menubar/menubarmenuview~MenuBarMenuView} instances registered in the menu bar.
        *
        * @observable
        */
        __publicField(this, "menus", []);
        const t2 = locale.t;
        const bind2 = this.bindTemplate;
        this.set({
          isOpen: false,
          isFocusBorderEnabled: false
        });
        this._setupIsOpenUpdater();
        this.children = this.createCollection();
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-menu-bar",
              bind2.if("isFocusBorderEnabled", "ck-menu-bar_focus-border-enabled")
            ],
            "aria-label": t2("Editor menu bar"),
            role: "menubar"
          },
          children: this.children
        });
      }
      /**
      * A utility that expands a plain menu bar configuration into a structure of menus (also: sub-menus)
      * and items using a given {@link module:ui/componentfactory~ComponentFactory component factory}.
      *
      * See the {@link module:core/editor/editorconfig~EditorConfig#menuBar menu bar} in the editor
      * configuration reference to learn how to configure the menu bar.
      */
      fillFromConfig(config2, componentFactory, extraItems = []) {
        const locale = this.locale;
        const processedConfig = processMenuBarConfig({
          normalizedConfig: config2,
          locale,
          componentFactory,
          extraItems
        });
        const topLevelCategoryMenuViews = processedConfig.items.map((menuDefinition) => this._createMenu({
          componentFactory,
          menuDefinition
        }));
        this.children.addMany(topLevelCategoryMenuViews);
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        MenuBarBehaviors.toggleMenusAndFocusItemsOnHover(this);
        MenuBarBehaviors.closeMenusWhenTheBarCloses(this);
        MenuBarBehaviors.closeMenuWhenAnotherOnTheSameLevelOpens(this);
        MenuBarBehaviors.focusCycleMenusOnArrows(this);
        MenuBarBehaviors.closeOnClickOutside(this);
        MenuBarBehaviors.enableFocusHighlightOnInteraction(this);
      }
      /**
      * Focuses the menu bar.
      */
      focus() {
        if (this.children.first) {
          this.children.first.focus();
        }
      }
      /**
      * Closes all menus in the bar.
      */
      close() {
        for (const topLevelCategoryMenuView of this.children) {
          topLevelCategoryMenuView.isOpen = false;
        }
      }
      /**
      * Registers a menu view in the menu bar. Every {@link module:ui/menubar/menubarmenuview~MenuBarMenuView} instance must be registered
      * in the menu bar to be properly managed.
      */
      registerMenu(menuView, parentMenuView = null) {
        if (parentMenuView) {
          menuView.delegate(...EVENT_NAME_DELEGATES).to(parentMenuView);
          menuView.parentMenuView = parentMenuView;
        } else {
          menuView.delegate(...EVENT_NAME_DELEGATES).to(this, (name) => "menu:" + name);
        }
        menuView._attachBehaviors();
        this.menus.push(menuView);
      }
      /**
      * Creates a {@link module:ui/menubar/menubarmenuview~MenuBarMenuView} based on the given definition.
      */
      _createMenu({ componentFactory, menuDefinition, parentMenuView }) {
        const locale = this.locale;
        const menuView = new MenuBarMenuView(locale);
        this.registerMenu(menuView, parentMenuView);
        menuView.buttonView.set({
          label: menuDefinition.label
        });
        menuView.once("change:isOpen", () => {
          const listView = new MenuBarMenuListView(locale);
          listView.ariaLabel = menuDefinition.label;
          menuView.panelView.children.add(listView);
          listView.items.addMany(this._createMenuItems({
            menuDefinition,
            parentMenuView: menuView,
            componentFactory
          }));
        });
        return menuView;
      }
      /**
      * Creates a {@link module:ui/menubar/menubarmenuview~MenuBarMenuView} items based on the given definition.
      */
      _createMenuItems({ menuDefinition, parentMenuView, componentFactory }) {
        const locale = this.locale;
        const items = [];
        for (const menuGroupDefinition of menuDefinition.groups) {
          for (const itemDefinition of menuGroupDefinition.items) {
            const menuItemView = new MenuBarMenuListItemView(locale, parentMenuView);
            if (isObject$3(itemDefinition)) {
              menuItemView.children.add(this._createMenu({
                componentFactory,
                menuDefinition: itemDefinition,
                parentMenuView
              }));
            } else {
              const componentView = this._createMenuItemContentFromFactory({
                componentName: itemDefinition,
                componentFactory,
                parentMenuView
              });
              if (!componentView) {
                continue;
              }
              menuItemView.children.add(componentView);
            }
            items.push(menuItemView);
          }
          if (menuGroupDefinition !== menuDefinition.groups[menuDefinition.groups.length - 1]) {
            items.push(new ListSeparatorView(locale));
          }
        }
        return items;
      }
      /**
      * Uses the component factory to create a content of the menu item (a button or a sub-menu).
      */
      _createMenuItemContentFromFactory({ componentName, parentMenuView, componentFactory }) {
        const componentView = componentFactory.create(componentName);
        if (!(componentView instanceof MenuBarMenuView || componentView instanceof MenuBarMenuListItemButtonView || componentView instanceof MenuBarMenuListItemFileDialogButtonView)) {
          logWarning("menu-bar-component-unsupported", {
            componentName,
            componentView
          });
          return null;
        }
        this._registerMenuTree(componentView, parentMenuView);
        componentView.on("execute", () => {
          this.close();
        });
        return componentView;
      }
      /**
      * Checks component and its children recursively and calls {@link #registerMenu}
      * for each item that is {@link module:ui/menubar/menubarmenuview~MenuBarMenuView}.
      *
      * @internal
      */
      _registerMenuTree(componentView, parentMenuView) {
        if (!(componentView instanceof MenuBarMenuView)) {
          componentView.delegate("mouseenter").to(parentMenuView);
          return;
        }
        this.registerMenu(componentView, parentMenuView);
        const menuBarItemsList = componentView.panelView.children.filter((child) => child instanceof MenuBarMenuListView)[0];
        if (!menuBarItemsList) {
          componentView.delegate("mouseenter").to(parentMenuView);
          return;
        }
        const nonSeparatorItems = menuBarItemsList.items.filter((item) => item instanceof ListItemView);
        for (const item of nonSeparatorItems) {
          this._registerMenuTree(item.children.get(0), componentView);
        }
      }
      /**
      * Manages the state of the {@link #isOpen} property of the menu bar. Because the state is a sum of individual
      * top-level menus' states, it's necessary to listen to their changes and update the state accordingly.
      *
      * Additionally, it prevents from unnecessary changes of `isOpen` when one top-level menu opens and another closes
      * (regardless of in which order), maintaining a stable `isOpen === true` in that situation.
      */
      _setupIsOpenUpdater() {
        let closeTimeout;
        this.on("menu:change:isOpen", (evt, name, isOpen) => {
          clearTimeout(closeTimeout);
          if (isOpen) {
            this.isOpen = true;
          } else {
            closeTimeout = setTimeout(() => {
              this.isOpen = Array.from(this.children).some((menuView) => menuView.isOpen);
            }, 0);
          }
        });
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class ChangeBuffer {
      /**
      * Creates a new instance of the change buffer.
      *
      * @param limit The maximum number of atomic changes which can be contained in one batch.
      */
      constructor(model, limit = 20) {
        /**
        * The model instance.
        */
        __publicField(this, "model");
        /**
        * The maximum number of atomic changes which can be contained in one batch.
        */
        __publicField(this, "limit");
        /**
        * Whether the buffer is locked. A locked buffer cannot be reset unless it gets unlocked.
        */
        __publicField(this, "_isLocked");
        /**
        * The number of atomic changes in the buffer. Once it exceeds the {@link #limit},
        * the {@link #batch batch} is set to a new one.
        */
        __publicField(this, "_size");
        /**
        * The current batch instance.
        */
        __publicField(this, "_batch", null);
        /**
        * The callback to document the change event which later needs to be removed.
        */
        __publicField(this, "_changeCallback");
        /**
        * The callback to document selection `change:attribute` and `change:range` events which resets the buffer.
        */
        __publicField(this, "_selectionChangeCallback");
        this.model = model;
        this._size = 0;
        this.limit = limit;
        this._isLocked = false;
        this._changeCallback = (evt, batch) => {
          if (batch.isLocal && batch.isUndoable && batch !== this._batch) {
            this._reset(true);
          }
        };
        this._selectionChangeCallback = () => {
          this._reset();
        };
        this.model.document.on("change", this._changeCallback);
        this.model.document.selection.on("change:range", this._selectionChangeCallback);
        this.model.document.selection.on("change:attribute", this._selectionChangeCallback);
      }
      /**
      * The current batch to which a feature should add its operations. Once the {@link #size}
      * is reached or exceeds the {@link #limit}, the batch is set to a new instance and the size is reset.
      */
      get batch() {
        if (!this._batch) {
          this._batch = this.model.createBatch({
            isTyping: true
          });
        }
        return this._batch;
      }
      /**
      * The number of atomic changes in the buffer. Once it exceeds the {@link #limit},
      * the {@link #batch batch} is set to a new one.
      */
      get size() {
        return this._size;
      }
      /**
      * The input number of changes into the buffer. Once the {@link #size} is
      * reached or exceeds the {@link #limit}, the batch is set to a new instance and the size is reset.
      *
      * @param changeCount The number of atomic changes to input.
      */
      input(changeCount) {
        this._size += changeCount;
        if (this._size >= this.limit) {
          this._reset(true);
        }
      }
      /**
      * Whether the buffer is locked. A locked buffer cannot be reset unless it gets unlocked.
      */
      get isLocked() {
        return this._isLocked;
      }
      /**
      * Locks the buffer.
      */
      lock() {
        this._isLocked = true;
      }
      /**
      * Unlocks the buffer.
      */
      unlock() {
        this._isLocked = false;
      }
      /**
      * Destroys the buffer.
      */
      destroy() {
        this.model.document.off("change", this._changeCallback);
        this.model.document.selection.off("change:range", this._selectionChangeCallback);
        this.model.document.selection.off("change:attribute", this._selectionChangeCallback);
      }
      /**
      * Resets the change buffer.
      *
      * @param ignoreLock Whether internal lock {@link #isLocked} should be ignored.
      */
      _reset(ignoreLock = false) {
        if (!this.isLocked || ignoreLock) {
          this._batch = null;
          this._size = 0;
        }
      }
    }
    class InsertTextCommand extends Command {
      /**
      * Creates an instance of the command.
      *
      * @param undoStepSize The maximum number of atomic changes
      * which can be contained in one batch in the command buffer.
      */
      constructor(editor2, undoStepSize) {
        super(editor2);
        /**
        * Typing's change buffer used to group subsequent changes into batches.
        */
        __publicField(this, "_buffer");
        this._buffer = new ChangeBuffer(editor2.model, undoStepSize);
        this._isEnabledBasedOnSelection = false;
      }
      /**
      * The current change buffer.
      */
      get buffer() {
        return this._buffer;
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        this._buffer.destroy();
      }
      /**
      * Executes the input command. It replaces the content within the given range with the given text.
      * Replacing is a two step process, first the content within the range is removed and then the new text is inserted
      * at the beginning of the range (which after the removal is a collapsed range).
      *
      * @fires execute
      * @param options The command options.
      */
      execute(options = {}) {
        const model = this.editor.model;
        const doc = model.document;
        const text2 = options.text || "";
        const textInsertions = text2.length;
        let selection = doc.selection;
        if (options.selection) {
          selection = options.selection;
        } else if (options.range) {
          selection = model.createSelection(options.range);
        }
        if (!model.canEditAt(selection)) {
          return;
        }
        const resultRange = options.resultRange;
        model.enqueueChange(this._buffer.batch, (writer) => {
          this._buffer.lock();
          const selectionAttributes = Array.from(doc.selection.getAttributes());
          model.deleteContent(selection);
          if (text2) {
            model.insertContent(writer.createText(text2, selectionAttributes), selection);
          }
          if (resultRange) {
            writer.setSelection(resultRange);
          } else if (!selection.is("documentSelection")) {
            writer.setSelection(selection);
          }
          this._buffer.unlock();
          this._buffer.input(textInsertions);
        });
      }
    }
    const TYPING_INPUT_TYPES = [
      // For collapsed range:
      //	- This one is a regular typing (all browsers, all systems).
      //	- This one is used by Chrome when typing accented letter  2nd step when the user selects the accent (Mac).
      // For non-collapsed range:
      //	- This one is used by Chrome when typing accented letter  when the selection box first appears (Mac).
      //	- This one is used by Safari when accepting spell check suggestions from the context menu (Mac).
      "insertText",
      // This one is used by Safari when typing accented letter (Mac).
      // This one is used by Safari when accepting spell check suggestions from the autocorrection pop-up (Mac).
      "insertReplacementText"
    ];
    const TYPING_INPUT_TYPES_ANDROID = [
      ...TYPING_INPUT_TYPES,
      "insertCompositionText"
    ];
    class InsertTextObserver extends Observer {
      /**
      * @inheritDoc
      */
      constructor(view) {
        super(view);
        /**
        * Instance of the focus observer. Insert text observer calls
        * {@link module:engine/view/observer/focusobserver~FocusObserver#flush} to mark the latest focus change as complete.
        */
        __publicField(this, "focusObserver");
        this.focusObserver = view.getObserver(FocusObserver);
        const typingInputTypes = env.isAndroid ? TYPING_INPUT_TYPES_ANDROID : TYPING_INPUT_TYPES;
        const viewDocument = view.document;
        viewDocument.on("beforeinput", (evt, data) => {
          if (!this.isEnabled) {
            return;
          }
          const { data: text2, targetRanges, inputType, domEvent } = data;
          if (!typingInputTypes.includes(inputType)) {
            return;
          }
          this.focusObserver.flush();
          const eventInfo = new EventInfo(viewDocument, "insertText");
          viewDocument.fire(eventInfo, new DomEventData(view, domEvent, {
            text: text2,
            selection: view.createSelection(targetRanges)
          }));
          if (eventInfo.stop.called) {
            evt.stop();
          }
        });
        if (!env.isAndroid) {
          viewDocument.on("compositionend", (evt, { data, domEvent }) => {
            if (!this.isEnabled) {
              return;
            }
            if (!data) {
              return;
            }
            viewDocument.fire("insertText", new DomEventData(view, domEvent, {
              text: data
            }));
          }, {
            priority: "lowest"
          });
        }
      }
      /**
      * @inheritDoc
      */
      observe() {
      }
      /**
      * @inheritDoc
      */
      stopObserving() {
      }
    }
    class Input extends Plugin {
      constructor() {
        super(...arguments);
        /**
        * The queue of `insertText` command executions that are waiting for the DOM to get updated after beforeinput event.
        */
        __publicField(this, "_compositionQueue");
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "Input";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor2 = this.editor;
        const model = editor2.model;
        const view = editor2.editing.view;
        const mapper = editor2.editing.mapper;
        const modelSelection = model.document.selection;
        this._compositionQueue = new CompositionQueue(editor2);
        view.addObserver(InsertTextObserver);
        const insertTextCommand = new InsertTextCommand(editor2, editor2.config.get("typing.undoStep") || 20);
        editor2.commands.add("insertText", insertTextCommand);
        editor2.commands.add("input", insertTextCommand);
        this.listenTo(view.document, "insertText", (evt, data) => {
          if (!view.document.isComposing) {
            data.preventDefault();
          }
          if (env.isAndroid && view.document.isComposing) {
            this._compositionQueue.flush("next beforeinput");
          }
          const { text: text2, selection: viewSelection } = data;
          let modelRanges;
          if (viewSelection) {
            modelRanges = Array.from(viewSelection.getRanges()).map((viewRange) => mapper.toModelRange(viewRange));
          } else {
            modelRanges = Array.from(modelSelection.getRanges());
          }
          let insertText2 = text2;
          if (env.isAndroid) {
            const selectedText = Array.from(modelRanges[0].getItems()).reduce((rangeText, node) => {
              return rangeText + (node.is("$textProxy") ? node.data : "");
            }, "");
            if (selectedText) {
              if (selectedText.length <= insertText2.length) {
                if (insertText2.startsWith(selectedText)) {
                  insertText2 = insertText2.substring(selectedText.length);
                  modelRanges[0].start = modelRanges[0].start.getShiftedBy(selectedText.length);
                }
              } else {
                if (selectedText.startsWith(insertText2)) {
                  modelRanges[0].start = modelRanges[0].start.getShiftedBy(insertText2.length);
                  insertText2 = "";
                }
              }
            }
            if (insertText2.length == 0 && modelRanges[0].isCollapsed) {
              return;
            }
          }
          const commandData = {
            text: insertText2,
            selection: model.createSelection(modelRanges)
          };
          if (env.isAndroid && view.document.isComposing) {
            this._compositionQueue.push(commandData);
          } else {
            editor2.execute("insertText", commandData);
            view.scrollToTheSelection();
          }
        });
        if (env.isAndroid) {
          this.listenTo(view.document, "keydown", (evt, data) => {
            if (modelSelection.isCollapsed || data.keyCode != 229 || !view.document.isComposing) {
              return;
            }
            deleteSelectionContent(model, insertTextCommand);
          });
        } else {
          this.listenTo(view.document, "compositionstart", () => {
            if (modelSelection.isCollapsed) {
              return;
            }
            deleteSelectionContent(model, insertTextCommand);
          });
        }
        if (env.isAndroid) {
          this.listenTo(view.document, "mutations", (evt, { mutations }) => {
            if (!view.document.isComposing) {
              return;
            }
            for (const { node } of mutations) {
              const viewElement = findMappedViewAncestor(node, mapper);
              const modelElement = mapper.toModelElement(viewElement);
              if (this._compositionQueue.isComposedElement(modelElement)) {
                this._compositionQueue.flush("mutations");
                return;
              }
            }
          });
          this.listenTo(view.document, "compositionend", () => {
            this._compositionQueue.flush("composition end");
          });
          this.listenTo(view.document, "compositionend", () => {
            const mutations = [];
            for (const element of this._compositionQueue.flushComposedElements()) {
              const viewElement = mapper.toViewElement(element);
              if (!viewElement) {
                continue;
              }
              mutations.push({
                type: "children",
                node: viewElement
              });
            }
            if (mutations.length) {
              view.document.fire("mutations", {
                mutations
              });
            }
          }, {
            priority: "lowest"
          });
        } else {
          this.listenTo(view.document, "compositionend", () => {
            view.document.fire("mutations", {
              mutations: []
            });
          }, {
            priority: "lowest"
          });
        }
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        this._compositionQueue.destroy();
      }
    }
    class CompositionQueue {
      /**
      * @inheritDoc
      */
      constructor(editor2) {
        /**
        * The editor instance.
        */
        __publicField(this, "editor");
        /**
        * Debounced queue flush as a safety mechanism for cases of mutation observer not triggering.
        */
        __publicField(this, "flushDebounced", debounce$1(() => this.flush("timeout"), 50));
        /**
        * The queue of `insertText` command executions that are waiting for the DOM to get updated after beforeinput event.
        */
        __publicField(this, "_queue", []);
        /**
        * A set of model elements. The composition happened in those elements. It's used for mutations check.
        */
        __publicField(this, "_compositionElements", /* @__PURE__ */ new Set());
        this.editor = editor2;
      }
      /**
      * Destroys the helper object.
      */
      destroy() {
        this.flushDebounced.cancel();
        this._compositionElements.clear();
        while (this._queue.length) {
          this.shift();
        }
      }
      /**
      * Returns the size of the queue.
      */
      get length() {
        return this._queue.length;
      }
      /**
      * Push next insertText command data to the queue.
      */
      push(commandData) {
        const commandLiveData = {
          text: commandData.text
        };
        if (commandData.selection) {
          commandLiveData.selectionRanges = [];
          for (const range2 of commandData.selection.getRanges()) {
            commandLiveData.selectionRanges.push(LiveRange.fromRange(range2));
            this._compositionElements.add(range2.start.parent);
          }
        }
        this._queue.push(commandLiveData);
        this.flushDebounced();
      }
      /**
      * Shift the first item from the insertText command data queue.
      */
      shift() {
        const commandLiveData = this._queue.shift();
        const commandData = {
          text: commandLiveData.text
        };
        if (commandLiveData.selectionRanges) {
          const ranges = commandLiveData.selectionRanges.map((liveRange) => detachLiveRange(liveRange)).filter((range2) => !!range2);
          if (ranges.length) {
            commandData.selection = this.editor.model.createSelection(ranges);
          }
        }
        return commandData;
      }
      /**
      * Applies all queued insertText command executions.
      *
      * @param reason Used only for debugging.
      */
      flush(reason) {
        const editor2 = this.editor;
        const model = editor2.model;
        const view = editor2.editing.view;
        this.flushDebounced.cancel();
        if (!this._queue.length) {
          return;
        }
        const insertTextCommand = editor2.commands.get("insertText");
        const buffer = insertTextCommand.buffer;
        model.enqueueChange(buffer.batch, () => {
          buffer.lock();
          while (this._queue.length) {
            const commandData = this.shift();
            editor2.execute("insertText", commandData);
          }
          buffer.unlock();
        });
        view.scrollToTheSelection();
      }
      /**
      * Returns `true` if the given model element is related to recent composition.
      */
      isComposedElement(element) {
        return this._compositionElements.has(element);
      }
      /**
      * Returns an array of composition-related elements and clears the internal list.
      */
      flushComposedElements() {
        const result2 = Array.from(this._compositionElements);
        this._compositionElements.clear();
        return result2;
      }
    }
    function deleteSelectionContent(model, insertTextCommand) {
      if (!insertTextCommand.isEnabled) {
        return;
      }
      const buffer = insertTextCommand.buffer;
      buffer.lock();
      model.enqueueChange(buffer.batch, () => {
        model.deleteContent(model.document.selection);
      });
      buffer.unlock();
    }
    function detachLiveRange(liveRange) {
      const range2 = liveRange.toRange();
      liveRange.detach();
      if (range2.root.rootName == "$graveyard") {
        return null;
      }
      return range2;
    }
    function findMappedViewAncestor(viewNode, mapper) {
      let node = viewNode.is("$text") ? viewNode.parent : viewNode;
      while (!mapper.toModelElement(node)) {
        node = node.parent;
      }
      return node;
    }
    class DeleteCommand extends Command {
      /**
      * Creates an instance of the command.
      *
      * @param direction The directionality of the delete describing in what direction it
      * should consume the content when the selection is collapsed.
      */
      constructor(editor2, direction) {
        super(editor2);
        /**
        * The directionality of the delete describing in what direction it should
        * consume the content when the selection is collapsed.
        */
        __publicField(this, "direction");
        /**
        * Delete's change buffer used to group subsequent changes into batches.
        */
        __publicField(this, "_buffer");
        this.direction = direction;
        this._buffer = new ChangeBuffer(editor2.model, editor2.config.get("typing.undoStep"));
        this._isEnabledBasedOnSelection = false;
      }
      /**
      * The current change buffer.
      */
      get buffer() {
        return this._buffer;
      }
      /**
      * Executes the delete command. Depending on whether the selection is collapsed or not, deletes its content
      * or a piece of content in the {@link #direction defined direction}.
      *
      * @fires execute
      * @param options The command options.
      * @param options.unit See {@link module:engine/model/utils/modifyselection~modifySelection}'s options.
      * @param options.sequence A number describing which subsequent delete event it is without the key being released.
      * See the {@link module:engine/view/document~Document#event:delete} event data.
      * @param options.selection Selection to remove. If not set, current model selection will be used.
      */
      execute(options = {}) {
        const model = this.editor.model;
        const doc = model.document;
        model.enqueueChange(this._buffer.batch, (writer) => {
          this._buffer.lock();
          const selection = writer.createSelection(options.selection || doc.selection);
          if (!model.canEditAt(selection)) {
            return;
          }
          const sequence = options.sequence || 1;
          const doNotResetEntireContent = selection.isCollapsed;
          if (selection.isCollapsed) {
            model.modifySelection(selection, {
              direction: this.direction,
              unit: options.unit,
              treatEmojiAsSingleUnit: true
            });
          }
          if (this._shouldEntireContentBeReplacedWithParagraph(sequence)) {
            this._replaceEntireContentWithParagraph(writer);
            return;
          }
          if (this._shouldReplaceFirstBlockWithParagraph(selection, sequence)) {
            this.editor.execute("paragraph", {
              selection
            });
            return;
          }
          if (selection.isCollapsed) {
            return;
          }
          let changeCount = 0;
          selection.getFirstRange().getMinimalFlatRanges().forEach((range2) => {
            changeCount += count(range2.getWalker({
              singleCharacters: true,
              ignoreElementEnd: true,
              shallow: true
            }));
          });
          model.deleteContent(selection, {
            doNotResetEntireContent,
            direction: this.direction
          });
          this._buffer.input(changeCount);
          writer.setSelection(selection);
          this._buffer.unlock();
        });
      }
      /**
      * If the user keeps <kbd>Backspace</kbd> or <kbd>Delete</kbd> key pressed, the content of the current
      * editable will be cleared. However, this will not yet lead to resetting the remaining block to a paragraph
      * (which happens e.g. when the user does <kbd>Ctrl</kbd> + <kbd>A</kbd>, <kbd>Backspace</kbd>).
      *
      * But, if the user pressed the key in an empty editable for the first time,
      * we want to replace the entire content with a paragraph if:
      *
      * * the current limit element is empty,
      * * the paragraph is allowed in the limit element,
      * * the limit doesn't already have a paragraph inside.
      *
      * See https://github.com/ckeditor/ckeditor5-typing/issues/61.
      *
      * @param sequence A number describing which subsequent delete event it is without the key being released.
      */
      _shouldEntireContentBeReplacedWithParagraph(sequence) {
        if (sequence > 1) {
          return false;
        }
        const model = this.editor.model;
        const doc = model.document;
        const selection = doc.selection;
        const limitElement = model.schema.getLimitElement(selection);
        const limitElementIsEmpty = selection.isCollapsed && selection.containsEntireContent(limitElement);
        if (!limitElementIsEmpty) {
          return false;
        }
        if (!model.schema.checkChild(limitElement, "paragraph")) {
          return false;
        }
        const limitElementFirstChild = limitElement.getChild(0);
        if (limitElementFirstChild && limitElementFirstChild.is("element", "paragraph")) {
          return false;
        }
        return true;
      }
      /**
      * The entire content is replaced with the paragraph. Selection is moved inside the paragraph.
      *
      * @param writer The model writer.
      */
      _replaceEntireContentWithParagraph(writer) {
        const model = this.editor.model;
        const doc = model.document;
        const selection = doc.selection;
        const limitElement = model.schema.getLimitElement(selection);
        const paragraph2 = writer.createElement("paragraph");
        writer.remove(writer.createRangeIn(limitElement));
        writer.insert(paragraph2, limitElement);
        writer.setSelection(paragraph2, 0);
      }
      /**
      * Checks if the selection is inside an empty element that is the first child of the limit element
      * and should be replaced with a paragraph.
      *
      * @param selection The selection.
      * @param sequence A number describing which subsequent delete event it is without the key being released.
      */
      _shouldReplaceFirstBlockWithParagraph(selection, sequence) {
        const model = this.editor.model;
        if (sequence > 1 || this.direction != "backward") {
          return false;
        }
        if (!selection.isCollapsed) {
          return false;
        }
        const position = selection.getFirstPosition();
        const limitElement = model.schema.getLimitElement(position);
        const limitElementFirstChild = limitElement.getChild(0);
        if (position.parent != limitElementFirstChild) {
          return false;
        }
        if (!selection.containsEntireContent(limitElementFirstChild)) {
          return false;
        }
        if (!model.schema.checkChild(limitElement, "paragraph")) {
          return false;
        }
        if (limitElementFirstChild.name == "paragraph") {
          return false;
        }
        return true;
      }
    }
    const DELETE_CHARACTER = "character";
    const DELETE_WORD = "word";
    const DELETE_CODE_POINT = "codePoint";
    const DELETE_SELECTION = "selection";
    const DELETE_BACKWARD = "backward";
    const DELETE_FORWARD = "forward";
    const DELETE_EVENT_TYPES = {
      // --------------------------------------- Backward delete types -----------------------------------------------------
      // This happens in Safari on Mac when some content is selected and Ctrl + K is pressed.
      deleteContent: {
        unit: DELETE_SELECTION,
        // According to the Input Events Level 2 spec, this delete type has no direction
        // but to keep things simple, let's default to backward.
        direction: DELETE_BACKWARD
      },
      // Chrome and Safari on Mac: Backspace or Ctrl + H
      deleteContentBackward: {
        // This kind of deletions must be done on the code point-level instead of target range provided by the DOM beforeinput event.
        // Take for instance "", it equals:
        //
        //	* [ "", "ZERO WIDTH JOINER", "", "ZERO WIDTH JOINER", "", "ZERO WIDTH JOINER", "" ]
        //	* or simply "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F467}"
        //
        // The range provided by the browser would cause the entire multi-byte grapheme to disappear while the user
        // intention when deleting backwards ("[]", then backspace) is gradual "decomposition" (first to "[]",
        // then to "[]", etc.).
        //
        //	* "[]" + backward delete (by code point)  -> results in "[]", removed the last "" 
        //	* "[]" + backward delete (by character)  -> results in "[]", removed the whole grapheme 
        //
        // Deleting by code-point is simply a better UX. See "deleteContentForward" to learn more.
        unit: DELETE_CODE_POINT,
        direction: DELETE_BACKWARD
      },
      // On Mac: Option + Backspace.
      // On iOS: Hold the backspace for a while and the whole words will start to disappear.
      deleteWordBackward: {
        unit: DELETE_WORD,
        direction: DELETE_BACKWARD
      },
      // Safari on Mac: Cmd + Backspace
      deleteHardLineBackward: {
        unit: DELETE_SELECTION,
        direction: DELETE_BACKWARD
      },
      // Chrome on Mac: Cmd + Backspace.
      deleteSoftLineBackward: {
        unit: DELETE_SELECTION,
        direction: DELETE_BACKWARD
      },
      // --------------------------------------- Forward delete types -----------------------------------------------------
      // Chrome on Mac: Fn + Backspace or Ctrl + D
      // Safari on Mac: Ctrl + K or Ctrl + D
      deleteContentForward: {
        // Unlike backward delete, this delete must be performed by character instead of by code point, which
        // provides the best UX for working with accented letters.
        // Take, for example "b" ("\u0062\u0302", or [ "LATIN SMALL LETTER B", "COMBINING CIRCUMFLEX ACCENT" ]):
        //
        //	* "b[]" + backward delete (by code point)  -> results in "b[]", removed the combining mark 
        //	* "[]b" + forward delete (by code point)   -> results in "[]^", a bare combining mark does that not make sense when alone 
        //	* "[]b" + forward delete (by character)    -> results in "[]", removed both "b" and the combining mark 
        //
        // See: "deleteContentBackward" to learn more.
        unit: DELETE_CHARACTER,
        direction: DELETE_FORWARD
      },
      // On Mac: Fn + Option + Backspace.
      deleteWordForward: {
        unit: DELETE_WORD,
        direction: DELETE_FORWARD
      },
      // Chrome on Mac: Ctrl + K (you have to disable the Link plugin first, though, because it uses the same keystroke)
      // This is weird that it does not work in Safari on Mac despite being listed in the official shortcuts listing
      // on Apple's webpage.
      deleteHardLineForward: {
        unit: DELETE_SELECTION,
        direction: DELETE_FORWARD
      },
      // At this moment there is no known way to trigger this event type but let's keep it for the symmetry with
      // deleteSoftLineBackward.
      deleteSoftLineForward: {
        unit: DELETE_SELECTION,
        direction: DELETE_FORWARD
      }
    };
    class DeleteObserver extends Observer {
      /**
      * @inheritDoc
      */
      constructor(view) {
        super(view);
        const document2 = view.document;
        let sequence = 0;
        document2.on("keydown", () => {
          sequence++;
        });
        document2.on("keyup", () => {
          sequence = 0;
        });
        document2.on("beforeinput", (evt, data) => {
          if (!this.isEnabled) {
            return;
          }
          const { targetRanges, domEvent, inputType } = data;
          const deleteEventSpec = DELETE_EVENT_TYPES[inputType];
          if (!deleteEventSpec) {
            return;
          }
          const deleteData = {
            direction: deleteEventSpec.direction,
            unit: deleteEventSpec.unit,
            sequence
          };
          if (deleteData.unit == DELETE_SELECTION) {
            deleteData.selectionToRemove = view.createSelection(targetRanges[0]);
          }
          if (inputType === "deleteContentBackward") {
            if (env.isAndroid) {
              deleteData.sequence = 1;
            }
            if (shouldUseTargetRanges(targetRanges)) {
              deleteData.unit = DELETE_SELECTION;
              deleteData.selectionToRemove = view.createSelection(targetRanges);
            }
          }
          const eventInfo = new BubblingEventInfo(document2, "delete", targetRanges[0]);
          document2.fire(eventInfo, new DomEventData(view, domEvent, deleteData));
          if (eventInfo.stop.called) {
            evt.stop();
          }
        });
        if (env.isBlink) {
          enableChromeWorkaround(this);
        }
      }
      /**
      * @inheritDoc
      */
      observe() {
      }
      /**
      * @inheritDoc
      */
      stopObserving() {
      }
    }
    function enableChromeWorkaround(observer) {
      const view = observer.view;
      const document2 = view.document;
      let pressedKeyCode = null;
      let beforeInputReceived = false;
      document2.on("keydown", (evt, { keyCode }) => {
        pressedKeyCode = keyCode;
        beforeInputReceived = false;
      });
      document2.on("keyup", (evt, { keyCode, domEvent }) => {
        const selection = document2.selection;
        const shouldFireDeleteEvent = observer.isEnabled && keyCode == pressedKeyCode && isDeleteKeyCode(keyCode) && !selection.isCollapsed && !beforeInputReceived;
        pressedKeyCode = null;
        if (shouldFireDeleteEvent) {
          const targetRange = selection.getFirstRange();
          const eventInfo = new BubblingEventInfo(document2, "delete", targetRange);
          const deleteData = {
            unit: DELETE_SELECTION,
            direction: getDeleteDirection(keyCode),
            selectionToRemove: selection
          };
          document2.fire(eventInfo, new DomEventData(view, domEvent, deleteData));
        }
      });
      document2.on("beforeinput", (evt, { inputType }) => {
        const deleteEventSpec = DELETE_EVENT_TYPES[inputType];
        const isMatchingBeforeInput = isDeleteKeyCode(pressedKeyCode) && deleteEventSpec && deleteEventSpec.direction == getDeleteDirection(pressedKeyCode);
        if (isMatchingBeforeInput) {
          beforeInputReceived = true;
        }
      }, {
        priority: "high"
      });
      document2.on("beforeinput", (evt, { inputType, data }) => {
        const shouldIgnoreBeforeInput = pressedKeyCode == keyCodes.delete && inputType == "insertText" && data == "";
        if (shouldIgnoreBeforeInput) {
          evt.stop();
        }
      }, {
        priority: "high"
      });
      function isDeleteKeyCode(keyCode) {
        return keyCode == keyCodes.backspace || keyCode == keyCodes.delete;
      }
      function getDeleteDirection(keyCode) {
        return keyCode == keyCodes.backspace ? DELETE_BACKWARD : DELETE_FORWARD;
      }
    }
    function shouldUseTargetRanges(targetRanges) {
      if (targetRanges.length != 1 || targetRanges[0].isCollapsed) {
        return false;
      }
      const walker = targetRanges[0].getWalker({
        direction: "backward",
        singleCharacters: true,
        ignoreElementEnd: true
      });
      let count2 = 0;
      for (const { nextPosition, item } of walker) {
        if (nextPosition.parent.is("$text")) {
          const data = nextPosition.parent.data;
          const offset2 = nextPosition.offset;
          if (isInsideSurrogatePair(data, offset2) || isInsideCombinedSymbol(data, offset2) || isInsideEmojiSequence(data, offset2)) {
            continue;
          }
          count2++;
        } else if (item.is("containerElement") || item.is("emptyElement")) {
          count2++;
        }
        if (count2 > 1) {
          return true;
        }
      }
      return false;
    }
    class Delete extends Plugin {
      constructor() {
        super(...arguments);
        /**
        * Whether pressing backspace should trigger undo action
        */
        __publicField(this, "_undoOnBackspace");
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "Delete";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor2 = this.editor;
        const view = editor2.editing.view;
        const viewDocument = view.document;
        const modelDocument = editor2.model.document;
        view.addObserver(DeleteObserver);
        this._undoOnBackspace = false;
        const deleteForwardCommand = new DeleteCommand(editor2, "forward");
        editor2.commands.add("deleteForward", deleteForwardCommand);
        editor2.commands.add("forwardDelete", deleteForwardCommand);
        editor2.commands.add("delete", new DeleteCommand(editor2, "backward"));
        this.listenTo(viewDocument, "delete", (evt, data) => {
          if (!viewDocument.isComposing) {
            data.preventDefault();
          }
          const { direction, sequence, selectionToRemove, unit } = data;
          const commandName = direction === "forward" ? "deleteForward" : "delete";
          const commandData = {
            sequence
          };
          if (unit == "selection") {
            const modelRanges = Array.from(selectionToRemove.getRanges()).map((viewRange) => {
              return editor2.editing.mapper.toModelRange(viewRange);
            });
            commandData.selection = editor2.model.createSelection(modelRanges);
          } else {
            commandData.unit = unit;
          }
          editor2.execute(commandName, commandData);
          view.scrollToTheSelection();
        }, {
          priority: "low"
        });
        if (this.editor.plugins.has("UndoEditing")) {
          this.listenTo(viewDocument, "delete", (evt, data) => {
            if (this._undoOnBackspace && data.direction == "backward" && data.sequence == 1 && data.unit == "codePoint") {
              this._undoOnBackspace = false;
              editor2.execute("undo");
              data.preventDefault();
              evt.stop();
            }
          }, {
            context: "$capture"
          });
          this.listenTo(modelDocument, "change", () => {
            this._undoOnBackspace = false;
          });
        }
      }
      /**
      * If the next user action after calling this method is pressing backspace, it would undo the last change.
      *
      * Requires {@link module:undo/undoediting~UndoEditing} plugin. If not loaded, does nothing.
      */
      requestUndoOnBackspace() {
        if (this.editor.plugins.has("UndoEditing")) {
          this._undoOnBackspace = true;
        }
      }
    }
    class Typing extends Plugin {
      static get requires() {
        return [
          Input,
          Delete
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "Typing";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function getLastTextLine(range2, model) {
      let start2 = range2.start;
      const text2 = Array.from(range2.getWalker({
        ignoreElementEnd: false
      })).reduce((rangeText, { item }) => {
        if (!(item.is("$text") || item.is("$textProxy"))) {
          start2 = model.createPositionAfter(item);
          return "";
        }
        return rangeText + item.data;
      }, "");
      return {
        text: text2,
        range: model.createRange(start2, range2.end)
      };
    }
    class TextWatcher extends (/* @__PURE__ */ ObservableMixin()) {
      /**
      * Creates a text watcher instance.
      *
      * @param testCallback See {@link module:typing/textwatcher~TextWatcher#testCallback}.
      */
      constructor(model, testCallback) {
        super();
        /**
        * The editor's model.
        */
        __publicField(this, "model");
        /**
        * The function used to match the text.
        *
        * The test callback can return 3 values:
        *
        * * `false` if there is no match,
        * * `true` if there is a match,
        * * an object if there is a match and we want to pass some additional information to the {@link #event:matched:data} event.
        */
        __publicField(this, "testCallback");
        /**
        * Whether there is a match currently.
        */
        __publicField(this, "_hasMatch");
        this.model = model;
        this.testCallback = testCallback;
        this._hasMatch = false;
        this.set("isEnabled", true);
        this.on("change:isEnabled", () => {
          if (this.isEnabled) {
            this._startListening();
          } else {
            this.stopListening(model.document.selection);
            this.stopListening(model.document);
          }
        });
        this._startListening();
      }
      /**
      * Flag indicating whether there is a match currently.
      */
      get hasMatch() {
        return this._hasMatch;
      }
      /**
      * Starts listening to the editor for typing and selection events.
      */
      _startListening() {
        const model = this.model;
        const document2 = model.document;
        this.listenTo(document2.selection, "change:range", (evt, { directChange }) => {
          if (!directChange) {
            return;
          }
          if (!document2.selection.isCollapsed) {
            if (this.hasMatch) {
              this.fire("unmatched");
              this._hasMatch = false;
            }
            return;
          }
          this._evaluateTextBeforeSelection("selection");
        });
        this.listenTo(document2, "change:data", (evt, batch) => {
          if (batch.isUndo || !batch.isLocal) {
            return;
          }
          this._evaluateTextBeforeSelection("data", {
            batch
          });
        });
      }
      /**
      * Checks the editor content for matched text.
      *
      * @fires matched:data
      * @fires matched:selection
      * @fires unmatched
      *
      * @param suffix A suffix used for generating the event name.
      * @param data Data object for event.
      */
      _evaluateTextBeforeSelection(suffix, data = {}) {
        const model = this.model;
        const document2 = model.document;
        const selection = document2.selection;
        const rangeBeforeSelection = model.createRange(model.createPositionAt(selection.focus.parent, 0), selection.focus);
        const { text: text2, range: range2 } = getLastTextLine(rangeBeforeSelection, model);
        const testResult = this.testCallback(text2);
        if (!testResult && this.hasMatch) {
          this.fire("unmatched");
        }
        this._hasMatch = !!testResult;
        if (testResult) {
          const eventData = Object.assign(data, {
            text: text2,
            range: range2
          });
          if (typeof testResult == "object") {
            Object.assign(eventData, testResult);
          }
          this.fire(`matched:${suffix}`, eventData);
        }
      }
    }
    class TwoStepCaretMovement extends Plugin {
      /**
      * @inheritDoc
      */
      constructor(editor2) {
        super(editor2);
        /**
        * A set of attributes to handle.
        */
        __publicField(this, "attributes");
        /**
        * The current UID of the overridden gravity, as returned by
        * {@link module:engine/model/writer~Writer#overrideSelectionGravity}.
        */
        __publicField(this, "_overrideUid");
        /**
        * A flag indicating that the automatic gravity restoration should not happen upon the next
        * gravity restoration.
        * {@link module:engine/model/selection~Selection#event:change:range} event.
        */
        __publicField(this, "_isNextGravityRestorationSkipped", false);
        this.attributes = /* @__PURE__ */ new Set();
        this._overrideUid = null;
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "TwoStepCaretMovement";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor2 = this.editor;
        const model = editor2.model;
        const view = editor2.editing.view;
        const locale = editor2.locale;
        const modelSelection = model.document.selection;
        this.listenTo(view.document, "arrowKey", (evt, data) => {
          if (!modelSelection.isCollapsed) {
            return;
          }
          if (data.shiftKey || data.altKey || data.ctrlKey) {
            return;
          }
          const arrowRightPressed = data.keyCode == keyCodes.arrowright;
          const arrowLeftPressed = data.keyCode == keyCodes.arrowleft;
          if (!arrowRightPressed && !arrowLeftPressed) {
            return;
          }
          const contentDirection = locale.contentLanguageDirection;
          let isMovementHandled = false;
          if (contentDirection === "ltr" && arrowRightPressed || contentDirection === "rtl" && arrowLeftPressed) {
            isMovementHandled = this._handleForwardMovement(data);
          } else {
            isMovementHandled = this._handleBackwardMovement(data);
          }
          if (isMovementHandled === true) {
            evt.stop();
          }
        }, {
          context: "$text",
          priority: "highest"
        });
        this.listenTo(modelSelection, "change:range", (evt, data) => {
          if (this._isNextGravityRestorationSkipped) {
            this._isNextGravityRestorationSkipped = false;
            return;
          }
          if (!this._isGravityOverridden) {
            return;
          }
          if (!data.directChange && isBetweenDifferentAttributes(modelSelection.getFirstPosition(), this.attributes)) {
            return;
          }
          this._restoreGravity();
        });
        this._enableClickingAfterNode();
        this._enableInsertContentSelectionAttributesFixer();
        this._handleDeleteContentAfterNode();
      }
      /**
      * Registers a given attribute for the two-step caret movement.
      *
      * @param attribute Name of the attribute to handle.
      */
      registerAttribute(attribute) {
        this.attributes.add(attribute);
      }
      /**
      * Updates the document selection and the view according to the twostep caret movement state
      * when moving **forwards**. Executed upon `keypress` in the {@link module:engine/view/view~View}.
      *
      * @param data Data of the key press.
      * @returns `true` when the handler prevented caret movement.
      */
      _handleForwardMovement(data) {
        const attributes = this.attributes;
        const model = this.editor.model;
        const selection = model.document.selection;
        const position = selection.getFirstPosition();
        if (this._isGravityOverridden) {
          return false;
        }
        if (position.isAtStart && hasAnyAttribute(selection, attributes)) {
          return false;
        }
        if (isBetweenDifferentAttributes(position, attributes)) {
          preventCaretMovement(data);
          if (hasAnyAttribute(selection, attributes) && isBetweenDifferentAttributes(position, attributes, true)) {
            clearSelectionAttributes(model, attributes);
          } else {
            this._overrideGravity();
          }
          return true;
        }
        return false;
      }
      /**
      * Updates the document selection and the view according to the twostep caret movement state
      * when moving **backwards**. Executed upon `keypress` in the {@link module:engine/view/view~View}.
      *
      * @param data Data of the key press.
      * @returns `true` when the handler prevented caret movement
      */
      _handleBackwardMovement(data) {
        const attributes = this.attributes;
        const model = this.editor.model;
        const selection = model.document.selection;
        const position = selection.getFirstPosition();
        if (this._isGravityOverridden) {
          preventCaretMovement(data);
          this._restoreGravity();
          if (isBetweenDifferentAttributes(position, attributes, true)) {
            clearSelectionAttributes(model, attributes);
          } else {
            setSelectionAttributesFromTheNodeBefore(model, attributes, position);
          }
          return true;
        } else {
          if (position.isAtStart) {
            if (hasAnyAttribute(selection, attributes)) {
              preventCaretMovement(data);
              setSelectionAttributesFromTheNodeBefore(model, attributes, position);
              return true;
            }
            return false;
          }
          if (!hasAnyAttribute(selection, attributes) && isBetweenDifferentAttributes(position, attributes, true)) {
            preventCaretMovement(data);
            setSelectionAttributesFromTheNodeBefore(model, attributes, position);
            return true;
          }
          if (isStepAfterAnyAttributeBoundary(position, attributes)) {
            if (position.isAtEnd && !hasAnyAttribute(selection, attributes) && isBetweenDifferentAttributes(position, attributes)) {
              preventCaretMovement(data);
              setSelectionAttributesFromTheNodeBefore(model, attributes, position);
              return true;
            }
            this._isNextGravityRestorationSkipped = true;
            this._overrideGravity();
            return false;
          }
        }
        return false;
      }
      /**
      * Starts listening to {@link module:engine/view/document~Document#event:mousedown} and
      * {@link module:engine/view/document~Document#event:selectionChange} and puts the selection before/after a 2-step node
      * if clicked at the beginning/ending of the 2-step node.
      *
      * The purpose of this action is to allow typing around the 2-step node directly after a click.
      *
      * See https://github.com/ckeditor/ckeditor5/issues/1016.
      */
      _enableClickingAfterNode() {
        const editor2 = this.editor;
        const model = editor2.model;
        const selection = model.document.selection;
        const document2 = editor2.editing.view.document;
        editor2.editing.view.addObserver(MouseObserver);
        let clicked = false;
        this.listenTo(document2, "mousedown", () => {
          clicked = true;
        });
        this.listenTo(document2, "selectionChange", () => {
          const attributes = this.attributes;
          if (!clicked) {
            return;
          }
          clicked = false;
          if (!selection.isCollapsed) {
            return;
          }
          if (!hasAnyAttribute(selection, attributes)) {
            return;
          }
          const position = selection.getFirstPosition();
          if (!isBetweenDifferentAttributes(position, attributes)) {
            return;
          }
          if (position.isAtStart || isBetweenDifferentAttributes(position, attributes, true)) {
            clearSelectionAttributes(model, attributes);
          } else if (!this._isGravityOverridden) {
            this._overrideGravity();
          }
        });
      }
      /**
      * Starts listening to {@link module:engine/model/model~Model#event:insertContent} and corrects the model
      * selection attributes if the selection is at the end of a two-step node after inserting the content.
      *
      * The purpose of this action is to improve the overall UX because the user is no longer "trapped" by the
      * two-step attribute of the selection, and they can type a "clean" (`linkHref`less) text right away.
      *
      * See https://github.com/ckeditor/ckeditor5/issues/6053.
      */
      _enableInsertContentSelectionAttributesFixer() {
        const editor2 = this.editor;
        const model = editor2.model;
        const selection = model.document.selection;
        const attributes = this.attributes;
        this.listenTo(model, "insertContent", () => {
          const position = selection.getFirstPosition();
          if (hasAnyAttribute(selection, attributes) && isBetweenDifferentAttributes(position, attributes)) {
            clearSelectionAttributes(model, attributes);
          }
        }, {
          priority: "low"
        });
      }
      /**
      * Starts listening to {@link module:engine/model/model~Model#deleteContent} and checks whether
      * removing a content right after the tow-step attribute.
      *
      * If so, the selection should not preserve the two-step attribute. However, if
      * the {@link module:typing/twostepcaretmovement~TwoStepCaretMovement} plugin is active and
      * the selection has the two-step attribute due to overridden gravity (at the end), the two-step attribute should stay untouched.
      *
      * The purpose of this action is to allow removing the link text and keep the selection outside the link.
      *
      * See https://github.com/ckeditor/ckeditor5/issues/7521.
      */
      _handleDeleteContentAfterNode() {
        const editor2 = this.editor;
        const model = editor2.model;
        const selection = model.document.selection;
        const view = editor2.editing.view;
        let isBackspace = false;
        let shouldPreserveAttributes = false;
        this.listenTo(view.document, "delete", (evt, data) => {
          isBackspace = data.direction === "backward";
        }, {
          priority: "high"
        });
        this.listenTo(model, "deleteContent", () => {
          if (!isBackspace) {
            return;
          }
          const position = selection.getFirstPosition();
          shouldPreserveAttributes = hasAnyAttribute(selection, this.attributes) && !isStepAfterAnyAttributeBoundary(position, this.attributes);
        }, {
          priority: "high"
        });
        this.listenTo(model, "deleteContent", () => {
          if (!isBackspace) {
            return;
          }
          isBackspace = false;
          if (shouldPreserveAttributes) {
            return;
          }
          editor2.model.enqueueChange(() => {
            const position = selection.getFirstPosition();
            if (hasAnyAttribute(selection, this.attributes) && isBetweenDifferentAttributes(position, this.attributes)) {
              if (position.isAtStart || isBetweenDifferentAttributes(position, this.attributes, true)) {
                clearSelectionAttributes(model, this.attributes);
              } else if (!this._isGravityOverridden) {
                this._overrideGravity();
              }
            }
          });
        }, {
          priority: "low"
        });
      }
      /**
      * `true` when the gravity is overridden for the plugin.
      */
      get _isGravityOverridden() {
        return !!this._overrideUid;
      }
      /**
      * Overrides the gravity using the {@link module:engine/model/writer~Writer model writer}
      * and stores the information about this fact in the {@link #_overrideUid}.
      *
      * A shorthand for {@link module:engine/model/writer~Writer#overrideSelectionGravity}.
      */
      _overrideGravity() {
        this._overrideUid = this.editor.model.change((writer) => {
          return writer.overrideSelectionGravity();
        });
      }
      /**
      * Restores the gravity using the {@link module:engine/model/writer~Writer model writer}.
      *
      * A shorthand for {@link module:engine/model/writer~Writer#restoreSelectionGravity}.
      */
      _restoreGravity() {
        this.editor.model.change((writer) => {
          writer.restoreSelectionGravity(this._overrideUid);
          this._overrideUid = null;
        });
      }
    }
    function hasAnyAttribute(selection, attributes) {
      for (const observedAttribute of attributes) {
        if (selection.hasAttribute(observedAttribute)) {
          return true;
        }
      }
      return false;
    }
    function setSelectionAttributesFromTheNodeBefore(model, attributes, position) {
      const nodeBefore = position.nodeBefore;
      model.change((writer) => {
        if (nodeBefore) {
          const attributes2 = [];
          const isInlineObject = model.schema.isObject(nodeBefore) && model.schema.isInline(nodeBefore);
          for (const [key, value] of nodeBefore.getAttributes()) {
            if (model.schema.checkAttribute("$text", key) && (!isInlineObject || model.schema.getAttributeProperties(key).copyFromObject !== false)) {
              attributes2.push([
                key,
                value
              ]);
            }
          }
          writer.setSelectionAttribute(attributes2);
        } else {
          writer.removeSelectionAttribute(attributes);
        }
      });
    }
    function clearSelectionAttributes(model, attributes) {
      model.change((writer) => {
        writer.removeSelectionAttribute(attributes);
      });
    }
    function preventCaretMovement(data) {
      data.preventDefault();
    }
    function isStepAfterAnyAttributeBoundary(position, attributes) {
      const positionBefore = position.getShiftedBy(-1);
      return isBetweenDifferentAttributes(positionBefore, attributes);
    }
    function isBetweenDifferentAttributes(position, attributes, isStrict = false) {
      const { nodeBefore, nodeAfter } = position;
      for (const observedAttribute of attributes) {
        const attrBefore = nodeBefore ? nodeBefore.getAttribute(observedAttribute) : void 0;
        const attrAfter = nodeAfter ? nodeAfter.getAttribute(observedAttribute) : void 0;
        if (isStrict && (attrBefore === void 0 || attrAfter === void 0)) {
          continue;
        }
        if (attrAfter !== attrBefore) {
          return true;
        }
      }
      return false;
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function findAttributeRange(position, attributeName, value, model) {
      return model.createRange(findAttributeRangeBound(position, attributeName, value, true, model), findAttributeRangeBound(position, attributeName, value, false, model));
    }
    function findAttributeRangeBound(position, attributeName, value, lookBack, model) {
      let node = position.textNode || (lookBack ? position.nodeBefore : position.nodeAfter);
      let lastNode = null;
      while (node && node.getAttribute(attributeName) == value) {
        lastNode = node;
        node = lookBack ? node.previousSibling : node.nextSibling;
      }
      return lastNode ? model.createPositionAt(lastNode, lookBack ? "before" : "after") : position;
    }
    function inlineHighlight(editor2, attributeName, tagName, className) {
      const view = editor2.editing.view;
      const highlightedElements = /* @__PURE__ */ new Set();
      view.document.registerPostFixer((writer) => {
        const selection = editor2.model.document.selection;
        let changed = false;
        if (selection.hasAttribute(attributeName)) {
          const modelRange = findAttributeRange(selection.getFirstPosition(), attributeName, selection.getAttribute(attributeName), editor2.model);
          const viewRange = editor2.editing.mapper.toViewRange(modelRange);
          for (const item of viewRange.getItems()) {
            if (item.is("element", tagName) && !item.hasClass(className)) {
              writer.addClass(className, item);
              highlightedElements.add(item);
              changed = true;
            }
          }
        }
        return changed;
      });
      editor2.conversion.for("editingDowncast").add((dispatcher) => {
        dispatcher.on("insert", removeHighlight2, {
          priority: "highest"
        });
        dispatcher.on("remove", removeHighlight2, {
          priority: "highest"
        });
        dispatcher.on("attribute", removeHighlight2, {
          priority: "highest"
        });
        dispatcher.on("selection", removeHighlight2, {
          priority: "highest"
        });
        function removeHighlight2() {
          view.change((writer) => {
            for (const item of highlightedElements.values()) {
              writer.removeClass(className, item);
              highlightedElements.delete(item);
            }
          });
        }
      });
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class AttributeCommand extends Command {
      /**
      * @param attributeKey Attribute that will be set by the command.
      */
      constructor(editor2, attributeKey) {
        super(editor2);
        /**
        * The attribute that will be set by the command.
        */
        __publicField(this, "attributeKey");
        this.attributeKey = attributeKey;
      }
      /**
      * Updates the command's {@link #value} and {@link #isEnabled} based on the current selection.
      */
      refresh() {
        const model = this.editor.model;
        const doc = model.document;
        this.value = this._getValueFromFirstAllowedNode();
        this.isEnabled = model.schema.checkAttributeInSelection(doc.selection, this.attributeKey);
      }
      /**
      * Executes the command &ndash; applies the attribute to the selection or removes it from the selection.
      *
      * If the command is active (`value == true`), it will remove attributes. Otherwise, it will set attributes.
      *
      * The execution result differs, depending on the {@link module:engine/model/document~Document#selection}:
      *
      * * If the selection is on a range, the command applies the attribute to all nodes in that range
      * (if they are allowed to have this attribute by the {@link module:engine/model/schema~Schema schema}).
      * * If the selection is collapsed in a non-empty node, the command applies the attribute to the
      * {@link module:engine/model/document~Document#selection} itself (note that typed characters copy attributes from the selection).
      * * If the selection is collapsed in an empty node, the command applies the attribute to the parent node of the selection (note
      * that the selection inherits all attributes from a node if it is in an empty node).
      *
      * @fires execute
      * @param options Command options.
      * @param options.forceValue If set, it will force the command behavior. If `true`,
      * the command will apply the attribute, otherwise the command will remove the attribute.
      * If not set, the command will look for its current value to decide what it should do.
      */
      execute(options = {}) {
        const model = this.editor.model;
        const doc = model.document;
        const selection = doc.selection;
        const value = options.forceValue === void 0 ? !this.value : options.forceValue;
        model.change((writer) => {
          if (selection.isCollapsed) {
            if (value) {
              writer.setSelectionAttribute(this.attributeKey, true);
            } else {
              writer.removeSelectionAttribute(this.attributeKey);
            }
          } else {
            const ranges = model.schema.getValidRanges(selection.getRanges(), this.attributeKey);
            for (const range2 of ranges) {
              if (value) {
                writer.setAttribute(this.attributeKey, value, range2);
              } else {
                writer.removeAttribute(this.attributeKey, range2);
              }
            }
          }
        });
      }
      /**
      * Checks the attribute value of the first node in the selection that allows the attribute.
      * For the collapsed selection returns the selection attribute.
      *
      * @returns The attribute value.
      */
      _getValueFromFirstAllowedNode() {
        const model = this.editor.model;
        const schema = model.schema;
        const selection = model.document.selection;
        if (selection.isCollapsed) {
          return selection.hasAttribute(this.attributeKey);
        }
        for (const range2 of selection.getRanges()) {
          for (const item of range2.getItems()) {
            if (schema.checkAttribute(item, this.attributeKey)) {
              return item.hasAttribute(this.attributeKey);
            }
          }
        }
        return false;
      }
    }
    const BOLD$1 = "bold";
    class BoldEditing extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "BoldEditing";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor2 = this.editor;
        const t2 = this.editor.t;
        editor2.model.schema.extend("$text", {
          allowAttributes: BOLD$1
        });
        editor2.model.schema.setAttributeProperties(BOLD$1, {
          isFormatting: true,
          copyOnEnter: true
        });
        editor2.conversion.attributeToElement({
          model: BOLD$1,
          view: "strong",
          upcastAlso: [
            "b",
            (viewElement) => {
              const fontWeight = viewElement.getStyle("font-weight");
              if (!fontWeight) {
                return null;
              }
              if (fontWeight == "bold" || Number(fontWeight) >= 600) {
                return {
                  name: true,
                  styles: [
                    "font-weight"
                  ]
                };
              }
              return null;
            }
          ]
        });
        editor2.commands.add(BOLD$1, new AttributeCommand(editor2, BOLD$1));
        editor2.keystrokes.set("CTRL+B", BOLD$1);
        editor2.accessibility.addKeystrokeInfos({
          keystrokes: [
            {
              label: t2("Bold text"),
              keystroke: "CTRL+B"
            }
          ]
        });
      }
    }
    function getButtonCreator({ editor: editor2, commandName, plugin, icon, label, keystroke }) {
      return (ButtonClass) => {
        const command = editor2.commands.get(commandName);
        const view = new ButtonClass(editor2.locale);
        view.set({
          label,
          icon,
          keystroke,
          isToggleable: true
        });
        view.bind("isEnabled").to(command, "isEnabled");
        view.bind("isOn").to(command, "value");
        if (view instanceof MenuBarMenuListItemButtonView) {
          view.set({
            role: "menuitemcheckbox"
          });
        } else {
          view.set({
            tooltip: true
          });
        }
        plugin.listenTo(view, "execute", () => {
          editor2.execute(commandName);
          editor2.editing.view.focus();
        });
        return view;
      };
    }
    const BOLD = "bold";
    class BoldUI extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "BoldUI";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor2 = this.editor;
        const t2 = editor2.locale.t;
        const createButton = getButtonCreator({
          editor: editor2,
          commandName: BOLD,
          plugin: this,
          icon: icons.bold,
          label: t2("Bold"),
          keystroke: "CTRL+B"
        });
        editor2.ui.componentFactory.add(BOLD, () => createButton(ButtonView));
        editor2.ui.componentFactory.add("menuBar:" + BOLD, () => createButton(MenuBarMenuListItemButtonView));
      }
    }
    class Bold extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          BoldEditing,
          BoldUI
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "Bold";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
    }
    const ITALIC$1 = "italic";
    class ItalicEditing extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "ItalicEditing";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor2 = this.editor;
        const t2 = this.editor.t;
        editor2.model.schema.extend("$text", {
          allowAttributes: ITALIC$1
        });
        editor2.model.schema.setAttributeProperties(ITALIC$1, {
          isFormatting: true,
          copyOnEnter: true
        });
        editor2.conversion.attributeToElement({
          model: ITALIC$1,
          view: "i",
          upcastAlso: [
            "em",
            {
              styles: {
                "font-style": "italic"
              }
            }
          ]
        });
        editor2.commands.add(ITALIC$1, new AttributeCommand(editor2, ITALIC$1));
        editor2.keystrokes.set("CTRL+I", ITALIC$1);
        editor2.accessibility.addKeystrokeInfos({
          keystrokes: [
            {
              label: t2("Italic text"),
              keystroke: "CTRL+I"
            }
          ]
        });
      }
    }
    var italicIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.586 14.633.021.004c-.036.335.095.655.393.962.082.083.173.15.274.201h1.474a.6.6 0 1 1 0 1.2H5.304a.6.6 0 0 1 0-1.2h1.15c.474-.07.809-.182 1.005-.334.157-.122.291-.32.404-.597l2.416-9.55a1.053 1.053 0 0 0-.281-.823 1.12 1.12 0 0 0-.442-.296H8.15a.6.6 0 0 1 0-1.2h6.443a.6.6 0 1 1 0 1.2h-1.195c-.376.056-.65.155-.823.296-.215.175-.423.439-.623.79l-2.366 9.347z"/></svg>';
    const ITALIC = "italic";
    class ItalicUI extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "ItalicUI";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor2 = this.editor;
        const t2 = editor2.locale.t;
        const createButton = getButtonCreator({
          editor: editor2,
          commandName: ITALIC,
          plugin: this,
          icon: italicIcon,
          keystroke: "CTRL+I",
          label: t2("Italic")
        });
        editor2.ui.componentFactory.add(ITALIC, () => createButton(ButtonView));
        editor2.ui.componentFactory.add("menuBar:" + ITALIC, () => createButton(MenuBarMenuListItemButtonView));
      }
    }
    class Italic extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          ItalicEditing,
          ItalicUI
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "Italic";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function* getCopyOnEnterAttributes(schema, allAttributes) {
      for (const attribute of allAttributes) {
        if (attribute && schema.getAttributeProperties(attribute[0]).copyOnEnter) {
          yield attribute;
        }
      }
    }
    class EnterCommand extends Command {
      /**
      * @inheritDoc
      */
      execute() {
        this.editor.model.change((writer) => {
          this.enterBlock(writer);
          this.fire("afterExecute", {
            writer
          });
        });
      }
      /**
      * Splits a block where the document selection is placed, in the way how the <kbd>Enter</kbd> key is expected to work:
      *
      * ```
      * <p>Foo[]bar</p>   ->   <p>Foo</p><p>[]bar</p>
      * <p>Foobar[]</p>   ->   <p>Foobar</p><p>[]</p>
      * <p>Fo[ob]ar</p>   ->   <p>Fo</p><p>[]ar</p>
      * ```
      *
      * In some cases, the split will not happen:
      *
      * ```
      * // The selection parent is a limit element:
      * <figcaption>A[bc]d</figcaption>   ->   <figcaption>A[]d</figcaption>
      *
      * // The selection spans over multiple elements:
      * <h>x[x</h><p>y]y<p>   ->   <h>x</h><p>[]y</p>
      * ```
      *
      * @param writer Writer to use when performing the enter action.
      * @returns Boolean indicating if the block was split.
      */
      enterBlock(writer) {
        const model = this.editor.model;
        const selection = model.document.selection;
        const schema = model.schema;
        const isSelectionEmpty = selection.isCollapsed;
        const range2 = selection.getFirstRange();
        const startElement = range2.start.parent;
        const endElement = range2.end.parent;
        if (schema.isLimit(startElement) || schema.isLimit(endElement)) {
          if (!isSelectionEmpty && startElement == endElement) {
            model.deleteContent(selection);
          }
          return false;
        }
        if (isSelectionEmpty) {
          const attributesToCopy = getCopyOnEnterAttributes(writer.model.schema, selection.getAttributes());
          splitBlock(writer, range2.start);
          writer.setSelectionAttribute(attributesToCopy);
          return true;
        } else {
          const leaveUnmerged = !(range2.start.isAtStart && range2.end.isAtEnd);
          const isContainedWithinOneElement = startElement == endElement;
          model.deleteContent(selection, {
            leaveUnmerged
          });
          if (leaveUnmerged) {
            if (isContainedWithinOneElement) {
              splitBlock(writer, selection.focus);
              return true;
            } else {
              writer.setSelection(endElement, 0);
            }
          }
        }
        return false;
      }
    }
    function splitBlock(writer, splitPos) {
      writer.split(splitPos);
      writer.setSelection(splitPos.parent.nextSibling, 0);
    }
    const ENTER_EVENT_TYPES = {
      insertParagraph: {
        isSoft: false
      },
      insertLineBreak: {
        isSoft: true
      }
    };
    class EnterObserver extends Observer {
      /**
      * @inheritDoc
      */
      constructor(view) {
        super(view);
        const doc = this.document;
        let shiftPressed = false;
        doc.on("keydown", (evt, data) => {
          shiftPressed = data.shiftKey;
        });
        doc.on("beforeinput", (evt, data) => {
          if (!this.isEnabled) {
            return;
          }
          let inputType = data.inputType;
          if (env.isSafari && shiftPressed && inputType == "insertParagraph") {
            inputType = "insertLineBreak";
          }
          const domEvent = data.domEvent;
          const enterEventSpec = ENTER_EVENT_TYPES[inputType];
          if (!enterEventSpec) {
            return;
          }
          const event = new BubblingEventInfo(doc, "enter", data.targetRanges[0]);
          doc.fire(event, new DomEventData(view, domEvent, {
            isSoft: enterEventSpec.isSoft
          }));
          if (event.stop.called) {
            evt.stop();
          }
        });
      }
      /**
      * @inheritDoc
      */
      observe() {
      }
      /**
      * @inheritDoc
      */
      stopObserving() {
      }
    }
    class Enter extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "Enter";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
      init() {
        const editor2 = this.editor;
        const view = editor2.editing.view;
        const viewDocument = view.document;
        const t2 = this.editor.t;
        view.addObserver(EnterObserver);
        editor2.commands.add("enter", new EnterCommand(editor2));
        this.listenTo(viewDocument, "enter", (evt, data) => {
          if (!viewDocument.isComposing) {
            data.preventDefault();
          }
          if (data.isSoft) {
            return;
          }
          editor2.execute("enter");
          view.scrollToTheSelection();
        }, {
          priority: "low"
        });
        editor2.accessibility.addKeystrokeInfos({
          keystrokes: [
            {
              label: t2("Insert a hard break (a new paragraph)"),
              keystroke: "Enter"
            }
          ]
        });
      }
    }
    class ShiftEnterCommand extends Command {
      /**
      * @inheritDoc
      */
      execute() {
        const model = this.editor.model;
        const doc = model.document;
        model.change((writer) => {
          softBreakAction(model, writer, doc.selection);
          this.fire("afterExecute", {
            writer
          });
        });
      }
      /**
      * @inheritDoc
      */
      refresh() {
        const model = this.editor.model;
        const doc = model.document;
        this.isEnabled = isEnabled(model.schema, doc.selection);
      }
    }
    function isEnabled(schema, selection) {
      if (selection.rangeCount > 1) {
        return false;
      }
      const anchorPos = selection.anchor;
      if (!anchorPos || !schema.checkChild(anchorPos, "softBreak")) {
        return false;
      }
      const range2 = selection.getFirstRange();
      const startElement = range2.start.parent;
      const endElement = range2.end.parent;
      if ((isInsideLimitElement(startElement, schema) || isInsideLimitElement(endElement, schema)) && startElement !== endElement) {
        return false;
      }
      return true;
    }
    function softBreakAction(model, writer, selection) {
      const isSelectionEmpty = selection.isCollapsed;
      const range2 = selection.getFirstRange();
      const startElement = range2.start.parent;
      const endElement = range2.end.parent;
      const isContainedWithinOneElement = startElement == endElement;
      if (isSelectionEmpty) {
        const attributesToCopy = getCopyOnEnterAttributes(model.schema, selection.getAttributes());
        insertBreak(model, writer, range2.end);
        writer.removeSelectionAttribute(selection.getAttributeKeys());
        writer.setSelectionAttribute(attributesToCopy);
      } else {
        const leaveUnmerged = !(range2.start.isAtStart && range2.end.isAtEnd);
        model.deleteContent(selection, {
          leaveUnmerged
        });
        if (isContainedWithinOneElement) {
          insertBreak(model, writer, selection.focus);
        } else {
          if (leaveUnmerged) {
            writer.setSelection(endElement, 0);
          }
        }
      }
    }
    function insertBreak(model, writer, position) {
      const breakLineElement = writer.createElement("softBreak");
      model.insertContent(breakLineElement, position);
      writer.setSelection(breakLineElement, "after");
    }
    function isInsideLimitElement(element, schema) {
      if (element.is("rootElement")) {
        return false;
      }
      return schema.isLimit(element) || isInsideLimitElement(element.parent, schema);
    }
    class ShiftEnter extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "ShiftEnter";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
      init() {
        const editor2 = this.editor;
        const schema = editor2.model.schema;
        const conversion = editor2.conversion;
        const view = editor2.editing.view;
        const viewDocument = view.document;
        const t2 = this.editor.t;
        schema.register("softBreak", {
          allowWhere: "$text",
          isInline: true
        });
        conversion.for("upcast").elementToElement({
          model: "softBreak",
          view: "br"
        });
        conversion.for("downcast").elementToElement({
          model: "softBreak",
          view: (modelElement, { writer }) => writer.createEmptyElement("br")
        });
        view.addObserver(EnterObserver);
        editor2.commands.add("shiftEnter", new ShiftEnterCommand(editor2));
        this.listenTo(viewDocument, "enter", (evt, data) => {
          if (!viewDocument.isComposing) {
            data.preventDefault();
          }
          if (!data.isSoft) {
            return;
          }
          editor2.execute("shiftEnter");
          view.scrollToTheSelection();
        }, {
          priority: "low"
        });
        editor2.accessibility.addKeystrokeInfos({
          keystrokes: [
            {
              label: t2("Insert a soft break (a <code>&lt;br&gt;</code> element)"),
              keystroke: "Shift+Enter"
            }
          ]
        });
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    const WIDGET_SELECTED_CLASS_NAME = "ck-widget_selected";
    function isWidget(node) {
      if (!node.is("element")) {
        return false;
      }
      return !!node.getCustomProperty("widget");
    }
    function getLabel(element) {
      const widgetLabel = element.getCustomProperty("widgetLabel");
      return widgetLabel.reduce((prev, current) => {
        if (typeof current === "function") {
          return prev ? prev + ". " + current() : current();
        } else {
          return prev ? prev + ". " + current : current;
        }
      }, "");
    }
    const TYPE_AROUND_SELECTION_ATTRIBUTE = "widget-type-around";
    function isTypeAroundWidget(viewElement, modelElement, schema) {
      return !!viewElement && isWidget(viewElement) && !schema.isInline(modelElement);
    }
    function getClosestTypeAroundDomButton(domElement) {
      return domElement.closest(".ck-widget__type-around__button");
    }
    function getTypeAroundButtonPosition(domElement) {
      return domElement.classList.contains("ck-widget__type-around__button_before") ? "before" : "after";
    }
    function getClosestWidgetViewElement(domElement, domConverter) {
      const widgetDomElement = domElement.closest(".ck-widget");
      return domConverter.mapDomToView(widgetDomElement);
    }
    function getTypeAroundFakeCaretPosition(selection) {
      return selection.getAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);
    }
    var returnIcon = '<svg viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg"><path d="M9.055.263v3.972h-6.77M1 4.216l2-2.038m-2 2 2 2.038"/></svg>';
    const POSSIBLE_INSERTION_POSITIONS = [
      "before",
      "after"
    ];
    const RETURN_ARROW_ICON_ELEMENT = new DOMParser().parseFromString(returnIcon, "image/svg+xml").firstChild;
    const PLUGIN_DISABLED_EDITING_ROOT_CLASS = "ck-widget__type-around_disabled";
    class WidgetTypeAround extends Plugin {
      constructor() {
        super(...arguments);
        /**
        * A reference to the model widget element that has the fake caret active
        * on either side of it. It is later used to remove CSS classes associated with the fake caret
        * when the widget no longer needs it.
        */
        __publicField(this, "_currentFakeCaretModelElement", null);
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "WidgetTypeAround";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          Enter,
          Delete
        ];
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor2 = this.editor;
        const editingView = editor2.editing.view;
        this.on("change:isEnabled", (evt, data, isEnabled2) => {
          editingView.change((writer) => {
            for (const root2 of editingView.document.roots) {
              if (isEnabled2) {
                writer.removeClass(PLUGIN_DISABLED_EDITING_ROOT_CLASS, root2);
              } else {
                writer.addClass(PLUGIN_DISABLED_EDITING_ROOT_CLASS, root2);
              }
            }
          });
          if (!isEnabled2) {
            editor2.model.change((writer) => {
              writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);
            });
          }
        });
        this._enableTypeAroundUIInjection();
        this._enableInsertingParagraphsOnButtonClick();
        this._enableInsertingParagraphsOnEnterKeypress();
        this._enableInsertingParagraphsOnTypingKeystroke();
        this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows();
        this._enableDeleteIntegration();
        this._enableInsertContentIntegration();
        this._enableInsertObjectIntegration();
        this._enableDeleteContentIntegration();
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        this._currentFakeCaretModelElement = null;
      }
      /**
      * Inserts a new paragraph next to a widget element with the selection anchored in it.
      *
      * **Note**: This method is heavily user-oriented and will both focus the editing view and scroll
      * the viewport to the selection in the inserted paragraph.
      *
      * @param widgetModelElement The model widget element next to which a paragraph is inserted.
      * @param position The position where the paragraph is inserted. Either `'before'` or `'after'` the widget.
      */
      _insertParagraph(widgetModelElement, position) {
        const editor2 = this.editor;
        const editingView = editor2.editing.view;
        const attributesToCopy = editor2.model.schema.getAttributesWithProperty(widgetModelElement, "copyOnReplace", true);
        editor2.execute("insertParagraph", {
          position: editor2.model.createPositionAt(widgetModelElement, position),
          attributes: attributesToCopy
        });
        editingView.focus();
        editingView.scrollToTheSelection();
      }
      /**
      * A wrapper for the {@link module:utils/emittermixin~Emitter#listenTo} method that executes the callbacks only
      * when the plugin {@link #isEnabled is enabled}.
      *
      * @param emitter The object that fires the event.
      * @param event The name of the event.
      * @param callback The function to be called on event.
      * @param options Additional options.
      * @param options.priority The priority of this event callback. The higher the priority value the sooner
      * the callback will be fired. Events having the same priority are called in the order they were added.
      */
      _listenToIfEnabled(emitter, event, callback, options) {
        this.listenTo(emitter, event, (...args) => {
          if (this.isEnabled) {
            callback(...args);
          }
        }, options);
      }
      /**
      * Similar to {@link #_insertParagraph}, this method inserts a paragraph except that it
      * does not expect a position. Instead, it performs the insertion next to a selected widget
      * according to the `widget-type-around` model selection attribute value (fake caret position).
      *
      * Because this method requires the `widget-type-around` attribute to be set,
      * the insertion can only happen when the widget's fake caret is active (e.g. activated
      * using the keyboard).
      *
      * @returns Returns `true` when the paragraph was inserted (the attribute was present) and `false` otherwise.
      */
      _insertParagraphAccordingToFakeCaretPosition() {
        const editor2 = this.editor;
        const model = editor2.model;
        const modelSelection = model.document.selection;
        const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(modelSelection);
        if (!typeAroundFakeCaretPosition) {
          return false;
        }
        const selectedModelElement = modelSelection.getSelectedElement();
        this._insertParagraph(selectedModelElement, typeAroundFakeCaretPosition);
        return true;
      }
      /**
      * Creates a listener in the editing conversion pipeline that injects the widget type around
      * UI into every single widget instance created in the editor.
      *
      * The UI is delivered as a {@link module:engine/view/uielement~UIElement}
      * wrapper which renders DOM buttons that users can use to insert paragraphs.
      */
      _enableTypeAroundUIInjection() {
        const editor2 = this.editor;
        const schema = editor2.model.schema;
        const t2 = editor2.locale.t;
        const buttonTitles = {
          before: t2("Insert paragraph before block"),
          after: t2("Insert paragraph after block")
        };
        editor2.editing.downcastDispatcher.on("insert", (evt, data, conversionApi) => {
          const viewElement = conversionApi.mapper.toViewElement(data.item);
          if (!viewElement) {
            return;
          }
          if (isTypeAroundWidget(viewElement, data.item, schema)) {
            injectUIIntoWidget(conversionApi.writer, buttonTitles, viewElement);
            const widgetLabel = viewElement.getCustomProperty("widgetLabel");
            widgetLabel.push(() => {
              return this.isEnabled ? t2("Press Enter to type after or press Shift + Enter to type before the widget") : "";
            });
          }
        }, {
          priority: "low"
        });
      }
      /**
      * Brings support for the fake caret that appears when either:
      *
      * * the selection moves to a widget from a position next to it using arrow keys,
      * * the arrow key is pressed when the widget is already selected.
      *
      * The fake caret lets the user know that they can start typing or just press
      * <kbd>Enter</kbd> to insert a paragraph at the position next to a widget as suggested by the fake caret.
      *
      * The fake caret disappears when the user changes the selection or the editor
      * gets blurred.
      *
      * The whole idea is as follows:
      *
      * 1. A user does one of the 2 scenarios described at the beginning.
      * 2. The "keydown" listener is executed and the decision is made whether to show or hide the fake caret.
      * 3. If it should show up, the `widget-type-around` model selection attribute is set indicating
      *    on which side of the widget it should appear.
      * 4. The selection dispatcher reacts to the selection attribute and sets CSS classes responsible for the
      *    fake caret on the view widget.
      * 5. If the fake caret should disappear, the selection attribute is removed and the dispatcher
      *    does the CSS class clean-up in the view.
      * 6. Additionally, `change:range` and `FocusTracker#isFocused` listeners also remove the selection
      *    attribute (the former also removes widget CSS classes).
      */
      _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {
        const editor2 = this.editor;
        const model = editor2.model;
        const modelSelection = model.document.selection;
        const schema = model.schema;
        const editingView = editor2.editing.view;
        this._listenToIfEnabled(editingView.document, "arrowKey", (evt, domEventData) => {
          this._handleArrowKeyPress(evt, domEventData);
        }, {
          context: [
            isWidget,
            "$text"
          ],
          priority: "high"
        });
        this._listenToIfEnabled(modelSelection, "change:range", (evt, data) => {
          if (!data.directChange) {
            return;
          }
          editor2.model.change((writer) => {
            writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);
          });
        });
        this._listenToIfEnabled(model.document, "change:data", () => {
          const selectedModelElement = modelSelection.getSelectedElement();
          if (selectedModelElement) {
            const selectedViewElement = editor2.editing.mapper.toViewElement(selectedModelElement);
            if (isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {
              return;
            }
          }
          editor2.model.change((writer) => {
            writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);
          });
        });
        this._listenToIfEnabled(editor2.editing.downcastDispatcher, "selection", (evt, data, conversionApi) => {
          const writer = conversionApi.writer;
          if (this._currentFakeCaretModelElement) {
            const selectedViewElement2 = conversionApi.mapper.toViewElement(this._currentFakeCaretModelElement);
            if (selectedViewElement2) {
              writer.removeClass(POSSIBLE_INSERTION_POSITIONS.map(positionToWidgetCssClass), selectedViewElement2);
              this._currentFakeCaretModelElement = null;
            }
          }
          const selectedModelElement = data.selection.getSelectedElement();
          if (!selectedModelElement) {
            return;
          }
          const selectedViewElement = conversionApi.mapper.toViewElement(selectedModelElement);
          if (!isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {
            return;
          }
          const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(data.selection);
          if (!typeAroundFakeCaretPosition) {
            return;
          }
          writer.addClass(positionToWidgetCssClass(typeAroundFakeCaretPosition), selectedViewElement);
          this._currentFakeCaretModelElement = selectedModelElement;
        });
        this._listenToIfEnabled(editor2.ui.focusTracker, "change:isFocused", (evt, name, isFocused) => {
          if (!isFocused) {
            editor2.model.change((writer) => {
              writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);
            });
          }
        });
        function positionToWidgetCssClass(position) {
          return `ck-widget_type-around_show-fake-caret_${position}`;
        }
      }
      /**
      * A listener executed on each "keydown" in the view document, a part of
      * {@link #_enableTypeAroundFakeCaretActivationUsingKeyboardArrows}.
      *
      * It decides whether the arrow keypress should activate the fake caret or not (also whether it should
      * be deactivated).
      *
      * The fake caret activation is done by setting the `widget-type-around` model selection attribute
      * in this listener, and stopping and preventing the event that would normally be handled by the widget
      * plugin that is responsible for the regular keyboard navigation near/across all widgets (that
      * includes inline widgets, which are ignored by the widget type around plugin).
      */
      _handleArrowKeyPress(evt, domEventData) {
        const editor2 = this.editor;
        const model = editor2.model;
        const modelSelection = model.document.selection;
        const schema = model.schema;
        const editingView = editor2.editing.view;
        const keyCode = domEventData.keyCode;
        const isForward = isForwardArrowKeyCode(keyCode, editor2.locale.contentLanguageDirection);
        const selectedViewElement = editingView.document.selection.getSelectedElement();
        const selectedModelElement = editor2.editing.mapper.toModelElement(selectedViewElement);
        let shouldStopAndPreventDefault;
        if (isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {
          shouldStopAndPreventDefault = this._handleArrowKeyPressOnSelectedWidget(isForward);
        } else if (modelSelection.isCollapsed) {
          shouldStopAndPreventDefault = this._handleArrowKeyPressWhenSelectionNextToAWidget(isForward);
        } else if (!domEventData.shiftKey) {
          shouldStopAndPreventDefault = this._handleArrowKeyPressWhenNonCollapsedSelection(isForward);
        }
        if (shouldStopAndPreventDefault) {
          domEventData.preventDefault();
          evt.stop();
        }
      }
      /**
      * Handles the keyboard navigation on "keydown" when a widget is currently selected and activates or deactivates
      * the fake caret for that widget, depending on the current value of the `widget-type-around` model
      * selection attribute and the direction of the pressed arrow key.
      *
      * @param isForward `true` when the pressed arrow key was responsible for the forward model selection movement
      * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.
      * @returns Returns `true` when the keypress was handled and no other keydown listener of the editor should
      * process the event any further. Returns `false` otherwise.
      */
      _handleArrowKeyPressOnSelectedWidget(isForward) {
        const editor2 = this.editor;
        const model = editor2.model;
        const modelSelection = model.document.selection;
        const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(modelSelection);
        return model.change((writer) => {
          if (typeAroundFakeCaretPosition) {
            const isLeavingWidget = typeAroundFakeCaretPosition === (isForward ? "after" : "before");
            if (!isLeavingWidget) {
              writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);
              return true;
            }
          } else {
            writer.setSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? "after" : "before");
            return true;
          }
          return false;
        });
      }
      /**
      * Handles the keyboard navigation on "keydown" when **no** widget is selected but the selection is **directly** next
      * to one and upon the fake caret should become active for this widget upon arrow keypress
      * (AKA entering/selecting the widget).
      *
      * **Note**: This code mirrors the implementation from the widget plugin but also adds the selection attribute.
      * Unfortunately, there is no safe way to let the widget plugin do the selection part first and then just set the
      * selection attribute here in the widget type around plugin. This is why this code must duplicate some from the widget plugin.
      *
      * @param isForward `true` when the pressed arrow key was responsible for the forward model selection movement
      * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.
      * @returns Returns `true` when the keypress was handled and no other keydown listener of the editor should
      * process the event any further. Returns `false` otherwise.
      */
      _handleArrowKeyPressWhenSelectionNextToAWidget(isForward) {
        const editor2 = this.editor;
        const model = editor2.model;
        const schema = model.schema;
        const widgetPlugin = editor2.plugins.get("Widget");
        const modelElementNextToSelection = widgetPlugin._getObjectElementNextToSelection(isForward);
        const viewElementNextToSelection = editor2.editing.mapper.toViewElement(modelElementNextToSelection);
        if (isTypeAroundWidget(viewElementNextToSelection, modelElementNextToSelection, schema)) {
          model.change((writer) => {
            widgetPlugin._setSelectionOverElement(modelElementNextToSelection);
            writer.setSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? "before" : "after");
          });
          return true;
        }
        return false;
      }
      /**
      * Handles the keyboard navigation on "keydown" when a widget is currently selected (together with some other content)
      * and the widget is the first or last element in the selection. It activates or deactivates the fake caret for that widget.
      *
      * @param isForward `true` when the pressed arrow key was responsible for the forward model selection movement
      * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.
      * @returns Returns `true` when the keypress was handled and no other keydown listener of the editor should
      * process the event any further. Returns `false` otherwise.
      */
      _handleArrowKeyPressWhenNonCollapsedSelection(isForward) {
        const editor2 = this.editor;
        const model = editor2.model;
        const schema = model.schema;
        const mapper = editor2.editing.mapper;
        const modelSelection = model.document.selection;
        const selectedModelNode = isForward ? modelSelection.getLastPosition().nodeBefore : modelSelection.getFirstPosition().nodeAfter;
        const selectedViewNode = mapper.toViewElement(selectedModelNode);
        if (isTypeAroundWidget(selectedViewNode, selectedModelNode, schema)) {
          model.change((writer) => {
            writer.setSelection(selectedModelNode, "on");
            writer.setSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? "after" : "before");
          });
          return true;
        }
        return false;
      }
      /**
      * Registers a `mousedown` listener for the view document which intercepts events
      * coming from the widget type around UI, which happens when a user clicks one of the buttons
      * that insert a paragraph next to a widget.
      */
      _enableInsertingParagraphsOnButtonClick() {
        const editor2 = this.editor;
        const editingView = editor2.editing.view;
        this._listenToIfEnabled(editingView.document, "mousedown", (evt, domEventData) => {
          const button = getClosestTypeAroundDomButton(domEventData.domTarget);
          if (!button) {
            return;
          }
          const buttonPosition = getTypeAroundButtonPosition(button);
          const widgetViewElement = getClosestWidgetViewElement(button, editingView.domConverter);
          const widgetModelElement = editor2.editing.mapper.toModelElement(widgetViewElement);
          this._insertParagraph(widgetModelElement, buttonPosition);
          domEventData.preventDefault();
          evt.stop();
        });
      }
      /**
      * Creates the <kbd>Enter</kbd> key listener on the view document that allows the user to insert a paragraph
      * near the widget when either:
      *
      * * The fake caret was first activated using the arrow keys,
      * * The entire widget is selected in the model.
      *
      * In the first case, the new paragraph is inserted according to the `widget-type-around` selection
      * attribute (see {@link #_handleArrowKeyPress}).
      *
      * In the second case, the new paragraph is inserted based on whether a soft (<kbd>Shift</kbd>+<kbd>Enter</kbd>) keystroke
      * was pressed or not.
      */
      _enableInsertingParagraphsOnEnterKeypress() {
        const editor2 = this.editor;
        const selection = editor2.model.document.selection;
        const editingView = editor2.editing.view;
        this._listenToIfEnabled(editingView.document, "enter", (evt, domEventData) => {
          if (evt.eventPhase != "atTarget") {
            return;
          }
          const selectedModelElement = selection.getSelectedElement();
          const selectedViewElement = editor2.editing.mapper.toViewElement(selectedModelElement);
          const schema = editor2.model.schema;
          let wasHandled;
          if (this._insertParagraphAccordingToFakeCaretPosition()) {
            wasHandled = true;
          } else if (isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {
            this._insertParagraph(selectedModelElement, domEventData.isSoft ? "before" : "after");
            wasHandled = true;
          }
          if (wasHandled) {
            domEventData.preventDefault();
            evt.stop();
          }
        }, {
          context: isWidget
        });
      }
      /**
      * Similar to the {@link #_enableInsertingParagraphsOnEnterKeypress}, it allows the user
      * to insert a paragraph next to a widget when the fake caret was activated using arrow
      * keys but it responds to typing instead of <kbd>Enter</kbd>.
      *
      * Listener enabled by this method will insert a new paragraph according to the `widget-type-around`
      * model selection attribute as the user simply starts typing, which creates the impression that the fake caret
      * behaves like a real one rendered by the browser (AKA your text appears where the caret was).
      *
      * **Note**: At the moment this listener creates 2 undo steps: one for the `insertParagraph` command
      * and another one for actual typing. It is not a disaster but this may need to be fixed
      * sooner or later.
      */
      _enableInsertingParagraphsOnTypingKeystroke() {
        const editor2 = this.editor;
        const viewDocument = editor2.editing.view.document;
        this._listenToIfEnabled(viewDocument, "insertText", (evt, data) => {
          if (this._insertParagraphAccordingToFakeCaretPosition()) {
            data.selection = viewDocument.selection;
          }
        }, {
          priority: "high"
        });
        if (env.isAndroid) {
          this._listenToIfEnabled(viewDocument, "keydown", (evt, data) => {
            if (data.keyCode == 229) {
              this._insertParagraphAccordingToFakeCaretPosition();
            }
          });
        } else {
          this._listenToIfEnabled(viewDocument, "compositionstart", () => {
            this._insertParagraphAccordingToFakeCaretPosition();
          }, {
            priority: "high"
          });
        }
      }
      /**
      * It creates a "delete" event listener on the view document to handle cases when the <kbd>Delete</kbd> or <kbd>Backspace</kbd>
      * is pressed and the fake caret is currently active.
      *
      * The fake caret should create an illusion of a real browser caret so that when it appears before or after
      * a widget, pressing <kbd>Delete</kbd> or <kbd>Backspace</kbd> should remove a widget or delete the content
      * before or after a widget (depending on the content surrounding the widget).
      */
      _enableDeleteIntegration() {
        const editor2 = this.editor;
        const editingView = editor2.editing.view;
        const model = editor2.model;
        const schema = model.schema;
        this._listenToIfEnabled(editingView.document, "delete", (evt, domEventData) => {
          if (evt.eventPhase != "atTarget") {
            return;
          }
          const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(model.document.selection);
          if (!typeAroundFakeCaretPosition) {
            return;
          }
          const direction = domEventData.direction;
          const selectedModelWidget = model.document.selection.getSelectedElement();
          const isFakeCaretBefore = typeAroundFakeCaretPosition === "before";
          const isDeleteForward = direction == "forward";
          const shouldDeleteEntireWidget = isFakeCaretBefore === isDeleteForward;
          if (shouldDeleteEntireWidget) {
            editor2.execute("delete", {
              selection: model.createSelection(selectedModelWidget, "on")
            });
          } else {
            const range2 = schema.getNearestSelectionRange(model.createPositionAt(selectedModelWidget, typeAroundFakeCaretPosition), direction);
            if (range2) {
              if (!range2.isCollapsed) {
                model.change((writer) => {
                  writer.setSelection(range2);
                  editor2.execute(isDeleteForward ? "deleteForward" : "delete");
                });
              } else {
                const probe = model.createSelection(range2.start);
                model.modifySelection(probe, {
                  direction
                });
                if (!probe.focus.isEqual(range2.start)) {
                  model.change((writer) => {
                    writer.setSelection(range2);
                    editor2.execute(isDeleteForward ? "deleteForward" : "delete");
                  });
                } else {
                  const deepestEmptyRangeAncestor = getDeepestEmptyElementAncestor(schema, range2.start.parent);
                  model.deleteContent(model.createSelection(deepestEmptyRangeAncestor, "on"), {
                    doNotAutoparagraph: true
                  });
                }
              }
            }
          }
          domEventData.preventDefault();
          evt.stop();
        }, {
          context: isWidget
        });
      }
      /**
      * Attaches the {@link module:engine/model/model~Model#event:insertContent} event listener that, for instance, allows the user to paste
      * content near a widget when the fake caret is first activated using the arrow keys.
      *
      * The content is inserted according to the `widget-type-around` selection attribute (see {@link #_handleArrowKeyPress}).
      */
      _enableInsertContentIntegration() {
        const editor2 = this.editor;
        const model = this.editor.model;
        const documentSelection = model.document.selection;
        this._listenToIfEnabled(editor2.model, "insertContent", (evt, [content, selectable]) => {
          if (selectable && !selectable.is("documentSelection")) {
            return;
          }
          const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(documentSelection);
          if (!typeAroundFakeCaretPosition) {
            return;
          }
          evt.stop();
          return model.change((writer) => {
            const selectedElement = documentSelection.getSelectedElement();
            const position = model.createPositionAt(selectedElement, typeAroundFakeCaretPosition);
            const selection = writer.createSelection(position);
            const result2 = model.insertContent(content, selection);
            writer.setSelection(selection);
            return result2;
          });
        }, {
          priority: "high"
        });
      }
      /**
      * Attaches the {@link module:engine/model/model~Model#event:insertObject} event listener that modifies the
      * `options.findOptimalPosition`parameter to position of fake caret in relation to selected element
      * to reflect user's intent of desired insertion position.
      *
      * The object is inserted according to the `widget-type-around` selection attribute (see {@link #_handleArrowKeyPress}).
      */
      _enableInsertObjectIntegration() {
        const editor2 = this.editor;
        const model = this.editor.model;
        const documentSelection = model.document.selection;
        this._listenToIfEnabled(editor2.model, "insertObject", (evt, args) => {
          const [, selectable, options = {}] = args;
          if (selectable && !selectable.is("documentSelection")) {
            return;
          }
          const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(documentSelection);
          if (!typeAroundFakeCaretPosition) {
            return;
          }
          options.findOptimalPosition = typeAroundFakeCaretPosition;
          args[3] = options;
        }, {
          priority: "high"
        });
      }
      /**
      * Attaches the {@link module:engine/model/model~Model#event:deleteContent} event listener to block the event when the fake
      * caret is active.
      *
      * This is required for cases that trigger {@link module:engine/model/model~Model#deleteContent `model.deleteContent()`}
      * before calling {@link module:engine/model/model~Model#insertContent `model.insertContent()`} like, for instance,
      * plain text pasting.
      */
      _enableDeleteContentIntegration() {
        const editor2 = this.editor;
        const model = this.editor.model;
        const documentSelection = model.document.selection;
        this._listenToIfEnabled(editor2.model, "deleteContent", (evt, [selection]) => {
          if (selection && !selection.is("documentSelection")) {
            return;
          }
          const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(documentSelection);
          if (typeAroundFakeCaretPosition) {
            evt.stop();
          }
        }, {
          priority: "high"
        });
      }
    }
    function injectUIIntoWidget(viewWriter, buttonTitles, widgetViewElement) {
      const typeAroundWrapper = viewWriter.createUIElement("div", {
        class: "ck ck-reset_all ck-widget__type-around"
      }, function(domDocument) {
        const wrapperDomElement = this.toDomElement(domDocument);
        injectButtons(wrapperDomElement, buttonTitles);
        injectFakeCaret(wrapperDomElement);
        return wrapperDomElement;
      });
      viewWriter.insert(viewWriter.createPositionAt(widgetViewElement, "end"), typeAroundWrapper);
    }
    function injectButtons(wrapperDomElement, buttonTitles) {
      for (const position of POSSIBLE_INSERTION_POSITIONS) {
        const buttonTemplate = new Template({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-widget__type-around__button",
              `ck-widget__type-around__button_${position}`
            ],
            title: buttonTitles[position],
            "aria-hidden": "true"
          },
          children: [
            wrapperDomElement.ownerDocument.importNode(RETURN_ARROW_ICON_ELEMENT, true)
          ]
        });
        wrapperDomElement.appendChild(buttonTemplate.render());
      }
    }
    function injectFakeCaret(wrapperDomElement) {
      const caretTemplate = new Template({
        tag: "div",
        attributes: {
          class: [
            "ck",
            "ck-widget__type-around__fake-caret"
          ]
        }
      });
      wrapperDomElement.appendChild(caretTemplate.render());
    }
    function getDeepestEmptyElementAncestor(schema, element) {
      let deepestEmptyAncestor = element;
      for (const ancestor of element.getAncestors({
        parentFirst: true
      })) {
        if (ancestor.childCount > 1 || schema.isLimit(ancestor)) {
          break;
        }
        deepestEmptyAncestor = ancestor;
      }
      return deepestEmptyAncestor;
    }
    function verticalNavigationHandler(editing) {
      const model = editing.model;
      return (evt, data) => {
        const arrowUpPressed = data.keyCode == keyCodes.arrowup;
        const arrowDownPressed = data.keyCode == keyCodes.arrowdown;
        const expandSelection = data.shiftKey;
        const selection = model.document.selection;
        if (!arrowUpPressed && !arrowDownPressed) {
          return;
        }
        const isForward = arrowDownPressed;
        if (expandSelection && selectionWillShrink(selection, isForward)) {
          return;
        }
        const range2 = findTextRangeFromSelection(editing, selection, isForward);
        if (!range2) {
          return;
        }
        if (range2.isCollapsed) {
          if (selection.isCollapsed) {
            return;
          } else if (expandSelection) {
            return;
          }
        }
        if (range2.isCollapsed || isSingleLineRange(editing, range2, isForward)) {
          model.change((writer) => {
            const newPosition = isForward ? range2.end : range2.start;
            if (expandSelection) {
              const newSelection = model.createSelection(selection.anchor);
              newSelection.setFocus(newPosition);
              writer.setSelection(newSelection);
            } else {
              writer.setSelection(newPosition);
            }
          });
          evt.stop();
          data.preventDefault();
          data.stopPropagation();
        }
      };
    }
    function findTextRangeFromSelection(editing, selection, isForward) {
      const model = editing.model;
      if (isForward) {
        const startPosition = selection.isCollapsed ? selection.focus : selection.getLastPosition();
        const endPosition = getNearestNonInlineLimit(model, startPosition, "forward");
        if (!endPosition) {
          return null;
        }
        const range2 = model.createRange(startPosition, endPosition);
        const lastRangePosition = getNearestTextPosition(model.schema, range2, "backward");
        if (lastRangePosition) {
          return model.createRange(startPosition, lastRangePosition);
        }
        return null;
      } else {
        const endPosition = selection.isCollapsed ? selection.focus : selection.getFirstPosition();
        const startPosition = getNearestNonInlineLimit(model, endPosition, "backward");
        if (!startPosition) {
          return null;
        }
        const range2 = model.createRange(startPosition, endPosition);
        const firstRangePosition = getNearestTextPosition(model.schema, range2, "forward");
        if (firstRangePosition) {
          return model.createRange(firstRangePosition, endPosition);
        }
        return null;
      }
    }
    function getNearestNonInlineLimit(model, startPosition, direction) {
      const schema = model.schema;
      const range2 = model.createRangeIn(startPosition.root);
      const walkerValueType = direction == "forward" ? "elementStart" : "elementEnd";
      for (const { previousPosition, item, type } of range2.getWalker({
        startPosition,
        direction
      })) {
        if (schema.isLimit(item) && !schema.isInline(item)) {
          return previousPosition;
        }
        if (type == walkerValueType && schema.isBlock(item)) {
          return null;
        }
      }
      return null;
    }
    function getNearestTextPosition(schema, range2, direction) {
      const position = direction == "backward" ? range2.end : range2.start;
      if (schema.checkChild(position, "$text")) {
        return position;
      }
      for (const { nextPosition } of range2.getWalker({
        direction
      })) {
        if (schema.checkChild(nextPosition, "$text")) {
          return nextPosition;
        }
      }
      return null;
    }
    function isSingleLineRange(editing, modelRange, isForward) {
      const model = editing.model;
      const domConverter = editing.view.domConverter;
      if (isForward) {
        const probe = model.createSelection(modelRange.start);
        model.modifySelection(probe);
        if (!probe.focus.isAtEnd && !modelRange.start.isEqual(probe.focus)) {
          modelRange = model.createRange(probe.focus, modelRange.end);
        }
      }
      const viewRange = editing.mapper.toViewRange(modelRange);
      const domRange = domConverter.viewRangeToDom(viewRange);
      const rects = Rect.getDomRangeRects(domRange);
      let boundaryVerticalPosition;
      for (const rect of rects) {
        if (boundaryVerticalPosition === void 0) {
          boundaryVerticalPosition = Math.round(rect.bottom);
          continue;
        }
        if (Math.round(rect.top) >= boundaryVerticalPosition) {
          return false;
        }
        boundaryVerticalPosition = Math.max(boundaryVerticalPosition, Math.round(rect.bottom));
      }
      return true;
    }
    function selectionWillShrink(selection, isForward) {
      return !selection.isCollapsed && selection.isBackward == isForward;
    }
    class Widget extends Plugin {
      constructor() {
        super(...arguments);
        /**
        * Holds previously selected widgets.
        */
        __publicField(this, "_previouslySelected", /* @__PURE__ */ new Set());
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "Widget";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          WidgetTypeAround,
          Delete
        ];
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor2 = this.editor;
        const view = editor2.editing.view;
        const viewDocument = view.document;
        const t2 = editor2.t;
        this.editor.editing.downcastDispatcher.on("selection", (evt, data, conversionApi) => {
          const viewWriter = conversionApi.writer;
          const modelSelection = data.selection;
          if (modelSelection.isCollapsed) {
            return;
          }
          const selectedModelElement = modelSelection.getSelectedElement();
          if (!selectedModelElement) {
            return;
          }
          const selectedViewElement = editor2.editing.mapper.toViewElement(selectedModelElement);
          if (!isWidget(selectedViewElement)) {
            return;
          }
          if (!conversionApi.consumable.consume(modelSelection, "selection")) {
            return;
          }
          viewWriter.setSelection(viewWriter.createRangeOn(selectedViewElement), {
            fake: true,
            label: getLabel(selectedViewElement)
          });
        });
        this.editor.editing.downcastDispatcher.on("selection", (evt, data, conversionApi) => {
          this._clearPreviouslySelectedWidgets(conversionApi.writer);
          const viewWriter = conversionApi.writer;
          const viewSelection = viewWriter.document.selection;
          let lastMarked = null;
          for (const range2 of viewSelection.getRanges()) {
            for (const value of range2) {
              const node = value.item;
              if (isWidget(node) && !isChild(node, lastMarked)) {
                viewWriter.addClass(WIDGET_SELECTED_CLASS_NAME, node);
                this._previouslySelected.add(node);
                lastMarked = node;
              }
            }
          }
        }, {
          priority: "low"
        });
        view.addObserver(MouseObserver);
        this.listenTo(viewDocument, "mousedown", (...args) => this._onMousedown(...args));
        this.listenTo(viewDocument, "arrowKey", (...args) => {
          this._handleSelectionChangeOnArrowKeyPress(...args);
        }, {
          context: [
            isWidget,
            "$text"
          ]
        });
        this.listenTo(viewDocument, "arrowKey", (...args) => {
          this._preventDefaultOnArrowKeyPress(...args);
        }, {
          context: "$root"
        });
        this.listenTo(viewDocument, "arrowKey", verticalNavigationHandler(this.editor.editing), {
          context: "$text"
        });
        this.listenTo(viewDocument, "delete", (evt, data) => {
          if (this._handleDelete(data.direction == "forward")) {
            data.preventDefault();
            evt.stop();
          }
        }, {
          context: "$root"
        });
        this.listenTo(viewDocument, "tab", (evt, data) => {
          if (evt.eventPhase != "atTarget") {
            return;
          }
          if (data.shiftKey) {
            return;
          }
          if (this._selectFirstNestedEditable()) {
            data.preventDefault();
            evt.stop();
          }
        }, {
          context: isWidget,
          priority: "low"
        });
        this.listenTo(viewDocument, "tab", (evt, data) => {
          if (!data.shiftKey) {
            return;
          }
          if (this._selectAncestorWidget()) {
            data.preventDefault();
            evt.stop();
          }
        }, {
          priority: "low"
        });
        this.listenTo(viewDocument, "keydown", (evt, data) => {
          if (data.keystroke != keyCodes.esc) {
            return;
          }
          if (this._selectAncestorWidget()) {
            data.preventDefault();
            evt.stop();
          }
        }, {
          priority: "low"
        });
        editor2.accessibility.addKeystrokeInfoGroup({
          id: "widget",
          label: t2("Keystrokes that can be used when a widget is selected (for example: image, table, etc.)"),
          keystrokes: [
            {
              label: t2("Move focus from an editable area back to the parent widget"),
              keystroke: "Esc"
            },
            {
              label: t2("Insert a new paragraph directly after a widget"),
              keystroke: "Enter"
            },
            {
              label: t2("Insert a new paragraph directly before a widget"),
              keystroke: "Shift+Enter"
            },
            {
              label: t2("Move the caret to allow typing directly before a widget"),
              keystroke: [
                [
                  "arrowup"
                ],
                [
                  "arrowleft"
                ]
              ]
            },
            {
              label: t2("Move the caret to allow typing directly after a widget"),
              keystroke: [
                [
                  "arrowdown"
                ],
                [
                  "arrowright"
                ]
              ]
            }
          ]
        });
      }
      /**
      * Handles {@link module:engine/view/document~Document#event:mousedown mousedown} events on widget elements.
      */
      _onMousedown(eventInfo, domEventData) {
        const editor2 = this.editor;
        const view = editor2.editing.view;
        const viewDocument = view.document;
        let element = domEventData.target;
        if (!element) {
          return;
        }
        if (domEventData.domEvent.detail >= 3) {
          if (this._selectBlockContent(element)) {
            domEventData.preventDefault();
          }
          return;
        }
        if (!isWidget(element)) {
          const editableOrWidgetElement = findClosestEditableOrWidgetAncestor(element);
          if (!editableOrWidgetElement) {
            return;
          }
          if (isWidget(editableOrWidgetElement)) {
            element = editableOrWidgetElement;
          } else {
            const clickTargetFromPoint = getElementFromMouseEvent(view, domEventData);
            if (clickTargetFromPoint && isWidget(clickTargetFromPoint)) {
              element = clickTargetFromPoint;
            } else {
              return;
            }
          }
        }
        if (env.isAndroid) {
          domEventData.preventDefault();
        }
        if (!viewDocument.isFocused) {
          view.focus();
        }
        const modelElement = editor2.editing.mapper.toModelElement(element);
        this._setSelectionOverElement(modelElement);
      }
      /**
      * Selects entire block content, e.g. on triple click it selects entire paragraph.
      */
      _selectBlockContent(element) {
        const editor2 = this.editor;
        const model = editor2.model;
        const mapper = editor2.editing.mapper;
        const schema = model.schema;
        const viewElement = mapper.findMappedViewAncestor(this.editor.editing.view.createPositionAt(element, 0));
        const modelElement = findTextBlockAncestor(mapper.toModelElement(viewElement), model.schema);
        if (!modelElement) {
          return false;
        }
        model.change((writer) => {
          const nextTextBlock = !schema.isLimit(modelElement) ? findNextTextBlock(writer.createPositionAfter(modelElement), schema) : null;
          const start2 = writer.createPositionAt(modelElement, 0);
          const end2 = nextTextBlock ? writer.createPositionAt(nextTextBlock, 0) : writer.createPositionAt(modelElement, "end");
          writer.setSelection(writer.createRange(start2, end2));
        });
        return true;
      }
      /**
      * Handles {@link module:engine/view/document~Document#event:keydown keydown} events and changes
      * the model selection when:
      *
      * * arrow key is pressed when the widget is selected,
      * * the selection is next to a widget and the widget should become selected upon the arrow key press.
      *
      * See {@link #_preventDefaultOnArrowKeyPress}.
      */
      _handleSelectionChangeOnArrowKeyPress(eventInfo, domEventData) {
        const keyCode = domEventData.keyCode;
        const model = this.editor.model;
        const schema = model.schema;
        const modelSelection = model.document.selection;
        const objectElement = modelSelection.getSelectedElement();
        const direction = getLocalizedArrowKeyCodeDirection(keyCode, this.editor.locale.contentLanguageDirection);
        const isForward = direction == "down" || direction == "right";
        const isVerticalNavigation = direction == "up" || direction == "down";
        if (objectElement && schema.isObject(objectElement)) {
          const position = isForward ? modelSelection.getLastPosition() : modelSelection.getFirstPosition();
          const newRange = schema.getNearestSelectionRange(position, isForward ? "forward" : "backward");
          if (newRange) {
            model.change((writer) => {
              writer.setSelection(newRange);
            });
            domEventData.preventDefault();
            eventInfo.stop();
          }
          return;
        }
        if (!modelSelection.isCollapsed && !domEventData.shiftKey) {
          const firstPosition = modelSelection.getFirstPosition();
          const lastPosition = modelSelection.getLastPosition();
          const firstSelectedNode = firstPosition.nodeAfter;
          const lastSelectedNode = lastPosition.nodeBefore;
          if (firstSelectedNode && schema.isObject(firstSelectedNode) || lastSelectedNode && schema.isObject(lastSelectedNode)) {
            model.change((writer) => {
              writer.setSelection(isForward ? lastPosition : firstPosition);
            });
            domEventData.preventDefault();
            eventInfo.stop();
          }
          return;
        }
        if (!modelSelection.isCollapsed) {
          return;
        }
        const objectElementNextToSelection = this._getObjectElementNextToSelection(isForward);
        if (objectElementNextToSelection && schema.isObject(objectElementNextToSelection)) {
          if (schema.isInline(objectElementNextToSelection) && isVerticalNavigation) {
            return;
          }
          this._setSelectionOverElement(objectElementNextToSelection);
          domEventData.preventDefault();
          eventInfo.stop();
        }
      }
      /**
      * Handles {@link module:engine/view/document~Document#event:keydown keydown} events and prevents
      * the default browser behavior to make sure the fake selection is not being moved from a fake selection
      * container.
      *
      * See {@link #_handleSelectionChangeOnArrowKeyPress}.
      */
      _preventDefaultOnArrowKeyPress(eventInfo, domEventData) {
        const model = this.editor.model;
        const schema = model.schema;
        const objectElement = model.document.selection.getSelectedElement();
        if (objectElement && schema.isObject(objectElement)) {
          domEventData.preventDefault();
          eventInfo.stop();
        }
      }
      /**
      * Handles delete keys: backspace and delete.
      *
      * @param isForward Set to true if delete was performed in forward direction.
      * @returns Returns `true` if keys were handled correctly.
      */
      _handleDelete(isForward) {
        const modelDocument = this.editor.model.document;
        const modelSelection = modelDocument.selection;
        if (!this.editor.model.canEditAt(modelSelection)) {
          return;
        }
        if (!modelSelection.isCollapsed) {
          return;
        }
        const objectElement = this._getObjectElementNextToSelection(isForward);
        if (objectElement) {
          this.editor.model.change((writer) => {
            let previousNode = modelSelection.anchor.parent;
            while (previousNode.isEmpty) {
              const nodeToRemove = previousNode;
              previousNode = nodeToRemove.parent;
              writer.remove(nodeToRemove);
            }
            this._setSelectionOverElement(objectElement);
          });
          return true;
        }
      }
      /**
      * Sets {@link module:engine/model/selection~Selection document's selection} over given element.
      *
      * @internal
      */
      _setSelectionOverElement(element) {
        this.editor.model.change((writer) => {
          writer.setSelection(writer.createRangeOn(element));
        });
      }
      /**
      * Checks if {@link module:engine/model/element~Element element} placed next to the current
      * {@link module:engine/model/selection~Selection model selection} exists and is marked in
      * {@link module:engine/model/schema~Schema schema} as `object`.
      *
      * @internal
      * @param forward Direction of checking.
      */
      _getObjectElementNextToSelection(forward) {
        const model = this.editor.model;
        const schema = model.schema;
        const modelSelection = model.document.selection;
        const probe = model.createSelection(modelSelection);
        model.modifySelection(probe, {
          direction: forward ? "forward" : "backward"
        });
        if (probe.isEqual(modelSelection)) {
          return null;
        }
        const objectElement = forward ? probe.focus.nodeBefore : probe.focus.nodeAfter;
        if (!!objectElement && schema.isObject(objectElement)) {
          return objectElement;
        }
        return null;
      }
      /**
      * Removes CSS class from previously selected widgets.
      */
      _clearPreviouslySelectedWidgets(writer) {
        for (const widget of this._previouslySelected) {
          writer.removeClass(WIDGET_SELECTED_CLASS_NAME, widget);
        }
        this._previouslySelected.clear();
      }
      /**
      * Moves the document selection into the first nested editable.
      */
      _selectFirstNestedEditable() {
        const editor2 = this.editor;
        const view = this.editor.editing.view;
        const viewDocument = view.document;
        for (const item of viewDocument.selection.getFirstRange().getItems()) {
          if (item.is("editableElement")) {
            const modelElement = editor2.editing.mapper.toModelElement(item);
            /* istanbul ignore next -- @preserve */
            if (!modelElement) {
              continue;
            }
            const position = editor2.model.createPositionAt(modelElement, 0);
            const newRange = editor2.model.schema.getNearestSelectionRange(position, "forward");
            editor2.model.change((writer) => {
              writer.setSelection(newRange);
            });
            return true;
          }
        }
        return false;
      }
      /**
      * Updates the document selection so that it selects first ancestor widget.
      */
      _selectAncestorWidget() {
        const editor2 = this.editor;
        const mapper = editor2.editing.mapper;
        const selection = editor2.editing.view.document.selection;
        const positionParent = selection.getFirstPosition().parent;
        const positionParentElement = positionParent.is("$text") ? positionParent.parent : positionParent;
        const viewElement = positionParentElement.findAncestor(isWidget);
        if (!viewElement) {
          return false;
        }
        const modelElement = mapper.toModelElement(viewElement);
        /* istanbul ignore next -- @preserve */
        if (!modelElement) {
          return false;
        }
        editor2.model.change((writer) => {
          writer.setSelection(modelElement, "on");
        });
        return true;
      }
    }
    function findClosestEditableOrWidgetAncestor(element) {
      let currentElement = element;
      while (currentElement) {
        if (currentElement.is("editableElement") || isWidget(currentElement)) {
          return currentElement;
        }
        currentElement = currentElement.parent;
      }
      return null;
    }
    function getElementFromMouseEvent(view, domEventData) {
      const domRange = getRangeFromMouseEvent(domEventData.domEvent);
      let viewRange = null;
      if (domRange) {
        viewRange = view.domConverter.domRangeToView(domRange);
      } else {
        viewRange = view.createRange(view.createPositionAt(domEventData.target, 0));
      }
      if (!viewRange) {
        return null;
      }
      const viewPosition = viewRange.start;
      if (!viewPosition.parent) {
        return null;
      }
      let viewNode = viewPosition.parent;
      if (viewPosition.parent.is("editableElement")) {
        if (viewPosition.isAtEnd && viewPosition.nodeBefore) {
          viewNode = viewPosition.nodeBefore;
        } else if (viewPosition.isAtStart && viewPosition.nodeAfter) {
          viewNode = viewPosition.nodeAfter;
        }
      }
      if (viewNode.is("$text")) {
        return viewNode.parent;
      }
      return viewNode;
    }
    function isChild(element, parent2) {
      if (!parent2) {
        return false;
      }
      return Array.from(element.getAncestors()).includes(parent2);
    }
    function findTextBlockAncestor(modelElement, schema) {
      for (const element of modelElement.getAncestors({
        includeSelf: true,
        parentFirst: true
      })) {
        if (schema.checkChild(element, "$text")) {
          return element;
        }
        if (schema.isLimit(element) && !schema.isObject(element)) {
          break;
        }
      }
      return null;
    }
    function findNextTextBlock(position, schema) {
      const treeWalker = new TreeWalker({
        startPosition: position
      });
      for (const { item } of treeWalker) {
        if (schema.isLimit(item) || !item.is("element")) {
          return null;
        }
        if (schema.checkChild(item, "$text")) {
          return item;
        }
      }
      return null;
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class ClipboardObserver extends DomEventObserver {
      constructor(view) {
        super(view);
        __publicField(this, "domEventType", [
          "paste",
          "copy",
          "cut",
          "drop",
          "dragover",
          "dragstart",
          "dragend",
          "dragenter",
          "dragleave"
        ]);
        const viewDocument = this.document;
        this.listenTo(viewDocument, "paste", handleInput("clipboardInput"), {
          priority: "low"
        });
        this.listenTo(viewDocument, "drop", handleInput("clipboardInput"), {
          priority: "low"
        });
        this.listenTo(viewDocument, "dragover", handleInput("dragging"), {
          priority: "low"
        });
        function handleInput(type) {
          return (evt, data) => {
            data.preventDefault();
            const targetRanges = data.dropRange ? [
              data.dropRange
            ] : null;
            const eventInfo = new EventInfo(viewDocument, type);
            viewDocument.fire(eventInfo, {
              dataTransfer: data.dataTransfer,
              method: evt.name,
              targetRanges,
              target: data.target,
              domEvent: data.domEvent
            });
            if (eventInfo.stop.called) {
              data.stopPropagation();
            }
          };
        }
      }
      onDomEvent(domEvent) {
        const nativeDataTransfer = "clipboardData" in domEvent ? domEvent.clipboardData : domEvent.dataTransfer;
        const cacheFiles = domEvent.type == "drop" || domEvent.type == "paste";
        const evtData = {
          dataTransfer: new DataTransfer(nativeDataTransfer, {
            cacheFiles
          })
        };
        if (domEvent.type == "drop" || domEvent.type == "dragover") {
          const domRange = getRangeFromMouseEvent(domEvent);
          evtData.dropRange = domRange && this.view.domConverter.domRangeToView(domRange);
        }
        this.fire(domEvent.type, domEvent, evtData);
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function plainTextToHtml(text2) {
      text2 = text2.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r?\n\r?\n/g, "</p><p>").replace(/\r?\n/g, "<br>").replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;").replace(/^\s/, "&nbsp;").replace(/\s$/, "&nbsp;").replace(/\s\s/g, " &nbsp;");
      if (text2.includes("</p><p>") || text2.includes("<br>")) {
        text2 = `<p>${text2}</p>`;
      }
      return text2;
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function normalizeClipboardData(data) {
      return data.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (fullMatch, spaces) => {
        if (spaces.length == 1) {
          return " ";
        }
        return spaces;
      }).replace(/<!--[\s\S]*?-->/g, "");
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    const smallPaddingElements = [
      "figcaption",
      "li"
    ];
    const listElements = [
      "ol",
      "ul"
    ];
    function viewToPlainText(viewItem) {
      if (viewItem.is("$text") || viewItem.is("$textProxy")) {
        return viewItem.data;
      }
      if (viewItem.is("element", "img") && viewItem.hasAttribute("alt")) {
        return viewItem.getAttribute("alt");
      }
      if (viewItem.is("element", "br")) {
        return "\n";
      }
      let text2 = "";
      let prev = null;
      for (const child of viewItem.getChildren()) {
        text2 += newLinePadding(child, prev) + viewToPlainText(child);
        prev = child;
      }
      return text2;
    }
    function newLinePadding(element, previous) {
      if (!previous) {
        return "";
      }
      if (element.is("element", "li") && !element.isEmpty && element.getChild(0).is("containerElement")) {
        return "\n\n";
      }
      if (listElements.includes(element.name) && listElements.includes(previous.name)) {
        return "\n\n";
      }
      if (!element.is("containerElement") && !previous.is("containerElement")) {
        return "";
      }
      if (smallPaddingElements.includes(element.name) || smallPaddingElements.includes(previous.name)) {
        return "\n";
      }
      if (element.is("element") && element.getCustomProperty("dataPipeline:transparentRendering") || previous.is("element") && previous.getCustomProperty("dataPipeline:transparentRendering")) {
        return "";
      }
      return "\n\n";
    }
    class ClipboardMarkersUtils extends Plugin {
      constructor() {
        super(...arguments);
        /**
        * Map of marker names that can be copied.
        *
        * @internal
        */
        __publicField(this, "_markersToCopy", /* @__PURE__ */ new Map());
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "ClipboardMarkersUtils";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
      /**
      * Registers marker name as copyable in clipboard pipeline.
      *
      * @param markerName Name of marker that can be copied.
      * @param config Configuration that describes what can be performed on specified marker.
      * @internal
      */
      _registerMarkerToCopy(markerName, config2) {
        this._markersToCopy.set(markerName, config2);
      }
      /**
      * Performs copy markers on provided selection and paste it to fragment returned from `getCopiedFragment`.
      *
      * 	1. Picks all markers in provided selection.
      * 	2. Inserts fake markers to document.
      * 	3. Gets copied selection fragment from document.
      * 	4. Removes fake elements from fragment and document.
      * 	5. Inserts markers in the place of removed fake markers.
      *
      * Due to selection modification, when inserting items, `getCopiedFragment` must *always* operate on `writer.model.document.selection'.
      * Do not use any other custom selection object within callback, as this will lead to out-of-bounds exceptions in rare scenarios.
      *
      * @param action Type of clipboard action.
      * @param writer An instance of the model writer.
      * @param selection Selection to be checked.
      * @param getCopiedFragment	Callback that performs copy of selection and returns it as fragment.
      * @internal
      */
      _copySelectedFragmentWithMarkers(action, selection, getCopiedFragment = (writer) => writer.model.getSelectedContent(writer.model.document.selection)) {
        return this.editor.model.change((writer) => {
          const oldSelection = writer.model.document.selection;
          writer.setSelection(selection);
          const sourceSelectionInsertedMarkers = this._insertFakeMarkersIntoSelection(writer, writer.model.document.selection, action);
          const fragment = getCopiedFragment(writer);
          const fakeMarkersRangesInsideRange = this._removeFakeMarkersInsideElement(writer, fragment);
          for (const [markerName, elements2] of Object.entries(sourceSelectionInsertedMarkers)) {
            fakeMarkersRangesInsideRange[markerName] || (fakeMarkersRangesInsideRange[markerName] = writer.createRangeIn(fragment));
            for (const element of elements2) {
              writer.remove(element);
            }
          }
          fragment.markers.clear();
          for (const [markerName, range2] of Object.entries(fakeMarkersRangesInsideRange)) {
            fragment.markers.set(markerName, range2);
          }
          writer.setSelection(oldSelection);
          return fragment;
        });
      }
      /**
      * Performs paste of markers on already pasted element.
      *
      * 	1. Inserts fake markers that are present in fragment element (such fragment will be processed in `getPastedDocumentElement`).
      * 	2. Calls `getPastedDocumentElement` and gets element that is inserted into root model.
      * 	3. Removes all fake markers present in transformed element.
      * 	4. Inserts new markers with removed fake markers ranges into pasted fragment.
      *
      * There are multiple edge cases that have to be considered before calling this function:
      *
      * 	* `markers` are inserted into the same element that must be later transformed inside `getPastedDocumentElement`.
      * 	* Fake marker elements inside `getPastedDocumentElement` can be cloned, but their ranges cannot overlap.
      * 	* If `duplicateOnPaste` is `true` in marker config then associated marker ID is regenerated before pasting.
      *
      * @param action Type of clipboard action.
      * @param markers Object that maps marker name to corresponding range.
      * @param getPastedDocumentElement Getter used to get target markers element.
      * @internal
      */
      _pasteMarkersIntoTransformedElement(markers, getPastedDocumentElement) {
        const pasteMarkers = this._getPasteMarkersFromRangeMap(markers);
        return this.editor.model.change((writer) => {
          const sourceFragmentFakeMarkers = this._insertFakeMarkersElements(writer, pasteMarkers);
          const transformedElement = getPastedDocumentElement(writer);
          const removedFakeMarkers = this._removeFakeMarkersInsideElement(writer, transformedElement);
          for (const element of Object.values(sourceFragmentFakeMarkers).flat()) {
            writer.remove(element);
          }
          for (const [markerName, range2] of Object.entries(removedFakeMarkers)) {
            if (!writer.model.markers.has(markerName)) {
              writer.addMarker(markerName, {
                usingOperation: true,
                affectsData: true,
                range: range2
              });
            }
          }
          return transformedElement;
        });
      }
      /**
      * Pastes document fragment with markers to document.
      * If `duplicateOnPaste` is `true` in marker config then associated markers IDs
      * are regenerated before pasting to avoid markers duplications in content.
      *
      * @param fragment Document fragment that should contain already processed by pipeline markers.
      * @internal
      */
      _pasteFragmentWithMarkers(fragment) {
        const pasteMarkers = this._getPasteMarkersFromRangeMap(fragment.markers);
        fragment.markers.clear();
        for (const copyableMarker of pasteMarkers) {
          fragment.markers.set(copyableMarker.name, copyableMarker.range);
        }
        return this.editor.model.insertContent(fragment);
      }
      /**
      * In some situations we have to perform copy on selected fragment with certain markers. This function allows to temporarily bypass
      * restrictions on markers that we want to copy.
      *
      * This function executes `executor()` callback. For the duration of the callback, if the clipboard pipeline is used to copy
      * content, markers with the specified name will be copied to the clipboard as well.
      *
      * @param markerName Which markers should be copied.
      * @param executor Callback executed.
      * @param config Optional configuration flags used to copy (such like partial copy flag).
      * @internal
      */
      _forceMarkersCopy(markerName, executor, config2 = {
        allowedActions: "all",
        copyPartiallySelected: true,
        duplicateOnPaste: true
      }) {
        const before2 = this._markersToCopy.get(markerName);
        this._markersToCopy.set(markerName, config2);
        executor();
        if (before2) {
          this._markersToCopy.set(markerName, before2);
        } else {
          this._markersToCopy.delete(markerName);
        }
      }
      /**
      * Checks if marker can be copied.
      *
      * @param markerName Name of checked marker.
      * @param action Type of clipboard action. If null then checks only if marker is registered as copyable.
      * @internal
      */
      _isMarkerCopyable(markerName, action) {
        const config2 = this._getMarkerClipboardConfig(markerName);
        if (!config2) {
          return false;
        }
        if (!action) {
          return true;
        }
        const { allowedActions } = config2;
        return allowedActions === "all" || allowedActions.includes(action);
      }
      /**
      * Checks if marker has any clipboard copy behavior configuration.
      *
      * @param markerName Name of checked marker.
      */
      _hasMarkerConfiguration(markerName) {
        return !!this._getMarkerClipboardConfig(markerName);
      }
      /**
      * Returns marker's configuration flags passed during registration.
      *
      * @param markerName Name of marker that should be returned.
      * @internal
      */
      _getMarkerClipboardConfig(markerName) {
        const [markerNamePrefix] = markerName.split(":");
        return this._markersToCopy.get(markerNamePrefix) || null;
      }
      /**
      * First step of copying markers. It looks for markers intersecting with given selection and inserts `$marker` elements
      * at positions where document markers start or end. This way `$marker` elements can be easily copied together with
      * the rest of the content of the selection.
      *
      * @param writer An instance of the model writer.
      * @param selection Selection to be checked.
      * @param action Type of clipboard action.
      */
      _insertFakeMarkersIntoSelection(writer, selection, action) {
        const copyableMarkers = this._getCopyableMarkersFromSelection(writer, selection, action);
        return this._insertFakeMarkersElements(writer, copyableMarkers);
      }
      /**
      * Returns array of markers that can be copied in specified selection.
      *
      * If marker cannot be copied partially (according to `copyPartiallySelected` configuration flag) and
      * is not present entirely in any selection range then it will be skipped.
      *
      * @param writer An instance of the model writer.
      * @param selection  Selection which will be checked.
      * @param action Type of clipboard action. If null then checks only if marker is registered as copyable.
      */
      _getCopyableMarkersFromSelection(writer, selection, action) {
        const selectionRanges = Array.from(selection.getRanges());
        const markersInRanges = new Set(selectionRanges.flatMap((selectionRange) => Array.from(writer.model.markers.getMarkersIntersectingRange(selectionRange))));
        const isSelectionMarkerCopyable = (marker) => {
          const isCopyable = this._isMarkerCopyable(marker.name, action);
          if (!isCopyable) {
            return false;
          }
          const { copyPartiallySelected } = this._getMarkerClipboardConfig(marker.name);
          if (!copyPartiallySelected) {
            const markerRange = marker.getRange();
            return selectionRanges.some((selectionRange) => selectionRange.containsRange(markerRange, true));
          }
          return true;
        };
        return Array.from(markersInRanges).filter(isSelectionMarkerCopyable).map((copyableMarker) => {
          const name = action === "dragstart" ? this._getUniqueMarkerName(copyableMarker.name) : copyableMarker.name;
          return {
            name,
            range: copyableMarker.getRange()
          };
        });
      }
      /**
      * Picks all markers from markers map that can be pasted.
      * If `duplicateOnPaste` is `true`, it regenerates their IDs to ensure uniqueness.
      * If marker is not registered, it will be kept in the array anyway.
      *
      * @param markers Object that maps marker name to corresponding range.
      * @param action Type of clipboard action. If null then checks only if marker is registered as copyable.
      */
      _getPasteMarkersFromRangeMap(markers, action = null) {
        const { model } = this.editor;
        const entries = markers instanceof Map ? Array.from(markers.entries()) : Object.entries(markers);
        return entries.flatMap(([markerName, range2]) => {
          if (!this._hasMarkerConfiguration(markerName)) {
            return [
              {
                name: markerName,
                range: range2
              }
            ];
          }
          if (this._isMarkerCopyable(markerName, action)) {
            const copyMarkerConfig = this._getMarkerClipboardConfig(markerName);
            const isInGraveyard = model.markers.has(markerName) && model.markers.get(markerName).getRange().root.rootName === "$graveyard";
            if (copyMarkerConfig.duplicateOnPaste || isInGraveyard) {
              markerName = this._getUniqueMarkerName(markerName);
            }
            return [
              {
                name: markerName,
                range: range2
              }
            ];
          }
          return [];
        });
      }
      /**
      * Inserts specified array of fake markers elements to document and assigns them `type` and `name` attributes.
      * Fake markers elements are used to calculate position of markers on pasted fragment that were transformed during
      * steps between copy and paste.
      *
      * @param writer An instance of the model writer.
      * @param markers Array of markers that will be inserted.
      */
      _insertFakeMarkersElements(writer, markers) {
        const mappedMarkers = {};
        const sortedMarkers = markers.flatMap((marker) => {
          const { start: start2, end: end2 } = marker.range;
          return [
            {
              position: start2,
              marker,
              type: "start"
            },
            {
              position: end2,
              marker,
              type: "end"
            }
          ];
        }).sort(({ position: posA }, { position: posB }) => posA.isBefore(posB) ? 1 : -1);
        for (const { position, marker, type } of sortedMarkers) {
          const fakeMarker = writer.createElement("$marker", {
            "data-name": marker.name,
            "data-type": type
          });
          if (!mappedMarkers[marker.name]) {
            mappedMarkers[marker.name] = [];
          }
          mappedMarkers[marker.name].push(fakeMarker);
          writer.insert(fakeMarker, position);
        }
        return mappedMarkers;
      }
      /**
      * Removes all `$marker` elements from the given document fragment.
      *
      * Returns an object where keys are marker names, and values are ranges corresponding to positions
      * where `$marker` elements were inserted.
      *
      * If the document fragment had only one `$marker` element for given marker (start or end) the other boundary is set automatically
      * (to the end or start of the document fragment, respectively).
      *
      * @param writer An instance of the model writer.
      * @param rootElement The element to be checked.
      */
      _removeFakeMarkersInsideElement(writer, rootElement) {
        const fakeMarkersElements = this._getAllFakeMarkersFromElement(writer, rootElement);
        const fakeMarkersRanges = fakeMarkersElements.reduce((acc, fakeMarker) => {
          const position = fakeMarker.markerElement && writer.createPositionBefore(fakeMarker.markerElement);
          let prevFakeMarker = acc[fakeMarker.name];
          let skipAssign = false;
          if (prevFakeMarker && prevFakeMarker.start && prevFakeMarker.end) {
            const config2 = this._getMarkerClipboardConfig(fakeMarker.name);
            if (config2.duplicateOnPaste) {
              acc[this._getUniqueMarkerName(fakeMarker.name)] = acc[fakeMarker.name];
            } else {
              skipAssign = true;
            }
            prevFakeMarker = null;
          }
          if (!skipAssign) {
            acc[fakeMarker.name] = {
              ...prevFakeMarker,
              [fakeMarker.type]: position
            };
          }
          if (fakeMarker.markerElement) {
            writer.remove(fakeMarker.markerElement);
          }
          return acc;
        }, {});
        return mapValues(fakeMarkersRanges, (range2) => new Range(range2.start || writer.createPositionFromPath(rootElement, [
          0
        ]), range2.end || writer.createPositionAt(rootElement, "end")));
      }
      /**
      * Returns array that contains list of fake markers with corresponding `$marker` elements.
      *
      * For each marker, there can be two `$marker` elements or only one (if the document fragment contained
      * only the beginning or only the end of a marker).
      *
      * @param writer An instance of the model writer.
      * @param rootElement The element to be checked.
      */
      _getAllFakeMarkersFromElement(writer, rootElement) {
        const foundFakeMarkers = Array.from(writer.createRangeIn(rootElement)).flatMap(({ item }) => {
          if (!item.is("element", "$marker")) {
            return [];
          }
          const name = item.getAttribute("data-name");
          const type = item.getAttribute("data-type");
          return [
            {
              markerElement: item,
              name,
              type
            }
          ];
        });
        const prependFakeMarkers = [];
        const appendFakeMarkers = [];
        for (const fakeMarker of foundFakeMarkers) {
          if (fakeMarker.type === "end") {
            const hasMatchingStartMarker = foundFakeMarkers.some((otherFakeMarker) => otherFakeMarker.name === fakeMarker.name && otherFakeMarker.type === "start");
            if (!hasMatchingStartMarker) {
              prependFakeMarkers.push({
                markerElement: null,
                name: fakeMarker.name,
                type: "start"
              });
            }
          }
          if (fakeMarker.type === "start") {
            const hasMatchingEndMarker = foundFakeMarkers.some((otherFakeMarker) => otherFakeMarker.name === fakeMarker.name && otherFakeMarker.type === "end");
            if (!hasMatchingEndMarker) {
              appendFakeMarkers.unshift({
                markerElement: null,
                name: fakeMarker.name,
                type: "end"
              });
            }
          }
        }
        return [
          ...prependFakeMarkers,
          ...foundFakeMarkers,
          ...appendFakeMarkers
        ];
      }
      /**
      * When copy of markers occurs we have to make sure that pasted markers have different names
      * than source markers. This functions helps with assigning unique part to marker name to
      * prevent duplicated markers error.
      *
      * @param name Name of marker
      */
      _getUniqueMarkerName(name) {
        const parts = name.split(":");
        const newId = uid().substring(1, 6);
        if (parts.length === 3) {
          return `${parts.slice(0, 2).join(":")}:${newId}`;
        }
        return `${parts.join(":")}:${newId}`;
      }
    }
    class ClipboardPipeline extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "ClipboardPipeline";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          ClipboardMarkersUtils
        ];
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor2 = this.editor;
        const view = editor2.editing.view;
        view.addObserver(ClipboardObserver);
        this._setupPasteDrop();
        this._setupCopyCut();
      }
      /**
      * Fires Clipboard `'outputTransformation'` event for given parameters.
      *
      * @internal
      */
      _fireOutputTransformationEvent(dataTransfer, selection, method2) {
        const clipboardMarkersUtils = this.editor.plugins.get("ClipboardMarkersUtils");
        this.editor.model.enqueueChange({
          isUndoable: method2 === "cut"
        }, () => {
          const documentFragment = clipboardMarkersUtils._copySelectedFragmentWithMarkers(method2, selection);
          this.fire("outputTransformation", {
            dataTransfer,
            content: documentFragment,
            method: method2
          });
        });
      }
      /**
      * The clipboard paste pipeline.
      */
      _setupPasteDrop() {
        const editor2 = this.editor;
        const model = editor2.model;
        const view = editor2.editing.view;
        const viewDocument = view.document;
        const clipboardMarkersUtils = this.editor.plugins.get("ClipboardMarkersUtils");
        this.listenTo(viewDocument, "clipboardInput", (evt, data) => {
          if (data.method == "paste" && !editor2.model.canEditAt(editor2.model.document.selection)) {
            evt.stop();
          }
        }, {
          priority: "highest"
        });
        this.listenTo(viewDocument, "clipboardInput", (evt, data) => {
          const dataTransfer = data.dataTransfer;
          let content;
          if (data.content) {
            content = data.content;
          } else {
            let contentData = "";
            if (dataTransfer.getData("text/html")) {
              contentData = normalizeClipboardData(dataTransfer.getData("text/html"));
            } else if (dataTransfer.getData("text/plain")) {
              contentData = plainTextToHtml(dataTransfer.getData("text/plain"));
            }
            content = this.editor.data.htmlProcessor.toView(contentData);
          }
          const eventInfo = new EventInfo(this, "inputTransformation");
          this.fire(eventInfo, {
            content,
            dataTransfer,
            targetRanges: data.targetRanges,
            method: data.method
          });
          if (eventInfo.stop.called) {
            evt.stop();
          }
          view.scrollToTheSelection();
        }, {
          priority: "low"
        });
        this.listenTo(this, "inputTransformation", (evt, data) => {
          if (data.content.isEmpty) {
            return;
          }
          const dataController = this.editor.data;
          const modelFragment = dataController.toModel(data.content, "$clipboardHolder");
          if (modelFragment.childCount == 0) {
            return;
          }
          evt.stop();
          model.change(() => {
            this.fire("contentInsertion", {
              content: modelFragment,
              method: data.method,
              dataTransfer: data.dataTransfer,
              targetRanges: data.targetRanges
            });
          });
        }, {
          priority: "low"
        });
        this.listenTo(this, "contentInsertion", (evt, data) => {
          data.resultRange = clipboardMarkersUtils._pasteFragmentWithMarkers(data.content);
        }, {
          priority: "low"
        });
      }
      /**
      * The clipboard copy/cut pipeline.
      */
      _setupCopyCut() {
        const editor2 = this.editor;
        const modelDocument = editor2.model.document;
        const view = editor2.editing.view;
        const viewDocument = view.document;
        const onCopyCut = (evt, data) => {
          const dataTransfer = data.dataTransfer;
          data.preventDefault();
          this._fireOutputTransformationEvent(dataTransfer, modelDocument.selection, evt.name);
        };
        this.listenTo(viewDocument, "copy", onCopyCut, {
          priority: "low"
        });
        this.listenTo(viewDocument, "cut", (evt, data) => {
          if (!editor2.model.canEditAt(editor2.model.document.selection)) {
            data.preventDefault();
          } else {
            onCopyCut(evt, data);
          }
        }, {
          priority: "low"
        });
        this.listenTo(this, "outputTransformation", (evt, data) => {
          const content = editor2.data.toView(data.content);
          viewDocument.fire("clipboardOutput", {
            dataTransfer: data.dataTransfer,
            content,
            method: data.method
          });
        }, {
          priority: "low"
        });
        this.listenTo(viewDocument, "clipboardOutput", (evt, data) => {
          if (!data.content.isEmpty) {
            data.dataTransfer.setData("text/html", this.editor.data.htmlProcessor.toData(data.content));
            data.dataTransfer.setData("text/plain", viewToPlainText(data.content));
          }
          if (data.method == "cut") {
            editor2.model.deleteContent(modelDocument.selection);
          }
        }, {
          priority: "low"
        });
      }
    }
    const toPx = /* @__PURE__ */ toUnit("px");
    class LineView extends View {
      /**
      * @inheritDoc
      */
      constructor() {
        super();
        const bind2 = this.bindTemplate;
        this.set({
          isVisible: false,
          left: null,
          top: null,
          width: null
        });
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-clipboard-drop-target-line",
              bind2.if("isVisible", "ck-hidden", (value) => !value)
            ],
            style: {
              left: bind2.to("left", (left2) => toPx(left2)),
              top: bind2.to("top", (top2) => toPx(top2)),
              width: bind2.to("width", (width) => toPx(width))
            }
          }
        });
      }
    }
    class DragDropTarget extends Plugin {
      constructor() {
        super(...arguments);
        /**
        * A delayed callback removing the drop marker.
        *
        * @internal
        */
        __publicField(this, "removeDropMarkerDelayed", delay(() => this.removeDropMarker(), 40));
        /**
        * A throttled callback updating the drop marker.
        */
        __publicField(this, "_updateDropMarkerThrottled", throttle((targetRange) => this._updateDropMarker(targetRange), 40));
        /**
        * A throttled callback reconverting the drop parker.
        */
        __publicField(this, "_reconvertMarkerThrottled", throttle(() => {
          if (this.editor.model.markers.has("drop-target")) {
            this.editor.editing.reconvertMarker("drop-target");
          }
        }, 0));
        /**
        * The horizontal drop target line view.
        */
        __publicField(this, "_dropTargetLineView", new LineView());
        /**
        * DOM Emitter.
        */
        __publicField(this, "_domEmitter", new (DomEmitterMixin())());
        /**
        * Map of document scrollable elements.
        */
        __publicField(this, "_scrollables", /* @__PURE__ */ new Map());
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "DragDropTarget";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
      /**
      * @inheritDoc
      */
      init() {
        this._setupDropMarker();
      }
      /**
      * @inheritDoc
      */
      destroy() {
        this._domEmitter.stopListening();
        for (const { resizeObserver } of this._scrollables.values()) {
          resizeObserver.destroy();
        }
        this._updateDropMarkerThrottled.cancel();
        this.removeDropMarkerDelayed.cancel();
        this._reconvertMarkerThrottled.cancel();
        return super.destroy();
      }
      /**
      * Finds the drop target range and updates the drop marker.
      *
      * @internal
      */
      updateDropMarker(targetViewElement, targetViewRanges, clientX, clientY, blockMode, draggedRange) {
        this.removeDropMarkerDelayed.cancel();
        const targetRange = findDropTargetRange(this.editor, targetViewElement, targetViewRanges, clientX, clientY, blockMode, draggedRange);
        /* istanbul ignore next -- @preserve */
        if (!targetRange) {
          return;
        }
        if (draggedRange && draggedRange.containsRange(targetRange)) {
          return this.removeDropMarker();
        }
        this._updateDropMarkerThrottled(targetRange);
      }
      /**
      * Finds the final drop target range.
      *
      * @internal
      */
      getFinalDropRange(targetViewElement, targetViewRanges, clientX, clientY, blockMode, draggedRange) {
        const targetRange = findDropTargetRange(this.editor, targetViewElement, targetViewRanges, clientX, clientY, blockMode, draggedRange);
        this.removeDropMarker();
        return targetRange;
      }
      /**
      * Removes the drop target marker.
      *
      * @internal
      */
      removeDropMarker() {
        const model = this.editor.model;
        this.removeDropMarkerDelayed.cancel();
        this._updateDropMarkerThrottled.cancel();
        this._dropTargetLineView.isVisible = false;
        if (model.markers.has("drop-target")) {
          model.change((writer) => {
            writer.removeMarker("drop-target");
          });
        }
      }
      /**
      * Creates downcast conversion for the drop target marker.
      */
      _setupDropMarker() {
        const editor2 = this.editor;
        editor2.ui.view.body.add(this._dropTargetLineView);
        editor2.conversion.for("editingDowncast").markerToHighlight({
          model: "drop-target",
          view: {
            classes: [
              "ck-clipboard-drop-target-range"
            ]
          }
        });
        editor2.conversion.for("editingDowncast").markerToElement({
          model: "drop-target",
          view: (data, { writer }) => {
            if (editor2.model.schema.checkChild(data.markerRange.start, "$text")) {
              this._dropTargetLineView.isVisible = false;
              return this._createDropTargetPosition(writer);
            } else {
              if (data.markerRange.isCollapsed) {
                this._updateDropTargetLine(data.markerRange);
              } else {
                this._dropTargetLineView.isVisible = false;
              }
            }
          }
        });
      }
      /**
      * Updates the drop target marker to the provided range.
      *
      * @param targetRange The range to set the marker to.
      */
      _updateDropMarker(targetRange) {
        const editor2 = this.editor;
        const markers = editor2.model.markers;
        editor2.model.change((writer) => {
          if (markers.has("drop-target")) {
            if (!markers.get("drop-target").getRange().isEqual(targetRange)) {
              writer.updateMarker("drop-target", {
                range: targetRange
              });
            }
          } else {
            writer.addMarker("drop-target", {
              range: targetRange,
              usingOperation: false,
              affectsData: false
            });
          }
        });
      }
      /**
      * Creates the UI element for vertical (in-line) drop target.
      */
      _createDropTargetPosition(writer) {
        return writer.createUIElement("span", {
          class: "ck ck-clipboard-drop-target-position"
        }, function(domDocument) {
          const domElement = this.toDomElement(domDocument);
          domElement.append("", domDocument.createElement("span"), "");
          return domElement;
        });
      }
      /**
      * Updates the horizontal drop target line.
      */
      _updateDropTargetLine(range2) {
        const editing = this.editor.editing;
        const nodeBefore = range2.start.nodeBefore;
        const nodeAfter = range2.start.nodeAfter;
        const nodeParent = range2.start.parent;
        const viewElementBefore = nodeBefore ? editing.mapper.toViewElement(nodeBefore) : null;
        const domElementBefore = viewElementBefore ? editing.view.domConverter.mapViewToDom(viewElementBefore) : null;
        const viewElementAfter = nodeAfter ? editing.mapper.toViewElement(nodeAfter) : null;
        const domElementAfter = viewElementAfter ? editing.view.domConverter.mapViewToDom(viewElementAfter) : null;
        const viewElementParent = editing.mapper.toViewElement(nodeParent);
        if (!viewElementParent) {
          return;
        }
        const domElementParent = editing.view.domConverter.mapViewToDom(viewElementParent);
        const domScrollableRect = this._getScrollableRect(viewElementParent);
        const { scrollX, scrollY } = global$1.window;
        const rectBefore = domElementBefore ? new Rect(domElementBefore) : null;
        const rectAfter = domElementAfter ? new Rect(domElementAfter) : null;
        const rectParent = new Rect(domElementParent).excludeScrollbarsAndBorders();
        const above = rectBefore ? rectBefore.bottom : rectParent.top;
        const below = rectAfter ? rectAfter.top : rectParent.bottom;
        const parentStyle = global$1.window.getComputedStyle(domElementParent);
        const top2 = above <= below ? (above + below) / 2 : below;
        if (domScrollableRect.top < top2 && top2 < domScrollableRect.bottom) {
          const left2 = rectParent.left + parseFloat(parentStyle.paddingLeft);
          const right2 = rectParent.right - parseFloat(parentStyle.paddingRight);
          const leftClamped = Math.max(left2 + scrollX, domScrollableRect.left);
          const rightClamped = Math.min(right2 + scrollX, domScrollableRect.right);
          this._dropTargetLineView.set({
            isVisible: true,
            left: leftClamped,
            top: top2 + scrollY,
            width: rightClamped - leftClamped
          });
        } else {
          this._dropTargetLineView.isVisible = false;
        }
      }
      /**
      * Finds the closest scrollable element rect for the given view element.
      */
      _getScrollableRect(viewElement) {
        const rootName = viewElement.root.rootName;
        let domScrollable;
        if (this._scrollables.has(rootName)) {
          domScrollable = this._scrollables.get(rootName).domElement;
        } else {
          const domElement = this.editor.editing.view.domConverter.mapViewToDom(viewElement);
          domScrollable = findScrollableElement(domElement);
          this._domEmitter.listenTo(domScrollable, "scroll", this._reconvertMarkerThrottled, {
            usePassive: true
          });
          const resizeObserver = new ResizeObserver$1(domScrollable, this._reconvertMarkerThrottled);
          this._scrollables.set(rootName, {
            domElement: domScrollable,
            resizeObserver
          });
        }
        return new Rect(domScrollable).excludeScrollbarsAndBorders();
      }
    }
    function findDropTargetRange(editor2, targetViewElement, targetViewRanges, clientX, clientY, blockMode, draggedRange) {
      const model = editor2.model;
      const mapper = editor2.editing.mapper;
      const targetModelElement = getClosestMappedModelElement(editor2, targetViewElement);
      let modelElement = targetModelElement;
      while (modelElement) {
        if (!blockMode) {
          if (model.schema.checkChild(modelElement, "$text")) {
            if (targetViewRanges) {
              const targetViewPosition = targetViewRanges[0].start;
              const targetModelPosition = mapper.toModelPosition(targetViewPosition);
              const canDropOnPosition = !draggedRange || Array.from(draggedRange.getItems()).every((item) => model.schema.checkChild(targetModelPosition, item));
              if (canDropOnPosition) {
                if (model.schema.checkChild(targetModelPosition, "$text")) {
                  return model.createRange(targetModelPosition);
                } else if (targetViewPosition) {
                  return findDropTargetRangeForElement(editor2, getClosestMappedModelElement(editor2, targetViewPosition.parent), clientX, clientY);
                }
              }
            }
          } else if (model.schema.isInline(modelElement)) {
            return findDropTargetRangeForElement(editor2, modelElement, clientX, clientY);
          }
        }
        if (model.schema.isBlock(modelElement)) {
          return findDropTargetRangeForElement(editor2, modelElement, clientX, clientY);
        } else if (model.schema.checkChild(modelElement, "$block")) {
          const childNodes = Array.from(modelElement.getChildren()).filter((node) => node.is("element") && !shouldIgnoreElement(editor2, node));
          let startIndex = 0;
          let endIndex = childNodes.length;
          if (endIndex == 0) {
            return model.createRange(model.createPositionAt(modelElement, "end"));
          }
          while (startIndex < endIndex - 1) {
            const middleIndex = Math.floor((startIndex + endIndex) / 2);
            const side = findElementSide(editor2, childNodes[middleIndex], clientX, clientY);
            if (side == "before") {
              endIndex = middleIndex;
            } else {
              startIndex = middleIndex;
            }
          }
          return findDropTargetRangeForElement(editor2, childNodes[startIndex], clientX, clientY);
        }
        modelElement = modelElement.parent;
      }
      return null;
    }
    function shouldIgnoreElement(editor2, modelElement) {
      const mapper = editor2.editing.mapper;
      const domConverter = editor2.editing.view.domConverter;
      const viewElement = mapper.toViewElement(modelElement);
      if (!viewElement) {
        return true;
      }
      const domElement = domConverter.mapViewToDom(viewElement);
      return global$1.window.getComputedStyle(domElement).float != "none";
    }
    function findDropTargetRangeForElement(editor2, modelElement, clientX, clientY) {
      const model = editor2.model;
      return model.createRange(model.createPositionAt(modelElement, findElementSide(editor2, modelElement, clientX, clientY)));
    }
    function findElementSide(editor2, modelElement, clientX, clientY) {
      const mapper = editor2.editing.mapper;
      const domConverter = editor2.editing.view.domConverter;
      const viewElement = mapper.toViewElement(modelElement);
      const domElement = domConverter.mapViewToDom(viewElement);
      const rect = new Rect(domElement);
      if (editor2.model.schema.isInline(modelElement)) {
        return clientX < (rect.left + rect.right) / 2 ? "before" : "after";
      } else {
        return clientY < (rect.top + rect.bottom) / 2 ? "before" : "after";
      }
    }
    function getClosestMappedModelElement(editor2, element) {
      const mapper = editor2.editing.mapper;
      const view = editor2.editing.view;
      const targetModelElement = mapper.toModelElement(element);
      if (targetModelElement) {
        return targetModelElement;
      }
      const viewPosition = view.createPositionBefore(element);
      const viewElement = mapper.findMappedViewAncestor(viewPosition);
      return mapper.toModelElement(viewElement);
    }
    function findScrollableElement(domNode) {
      let domElement = domNode;
      do {
        domElement = domElement.parentElement;
        const overflow = global$1.window.getComputedStyle(domElement).overflowY;
        if (overflow == "auto" || overflow == "scroll") {
          break;
        }
      } while (domElement.tagName != "BODY");
      return domElement;
    }
    class DragDropBlockToolbar extends Plugin {
      constructor() {
        super(...arguments);
        /**
        * Whether current dragging is started by block toolbar button dragging.
        */
        __publicField(this, "_isBlockDragging", false);
        /**
        * DOM Emitter.
        */
        __publicField(this, "_domEmitter", new (DomEmitterMixin())());
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "DragDropBlockToolbar";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor2 = this.editor;
        this.listenTo(editor2, "change:isReadOnly", (evt, name, isReadOnly) => {
          if (isReadOnly) {
            this.forceDisabled("readOnlyMode");
            this._isBlockDragging = false;
          } else {
            this.clearForceDisabled("readOnlyMode");
          }
        });
        if (env.isAndroid) {
          this.forceDisabled("noAndroidSupport");
        }
        if (editor2.plugins.has("BlockToolbar")) {
          const blockToolbar = editor2.plugins.get("BlockToolbar");
          const element = blockToolbar.buttonView.element;
          this._domEmitter.listenTo(element, "dragstart", (evt, data) => this._handleBlockDragStart(data));
          this._domEmitter.listenTo(global$1.document, "dragover", (evt, data) => this._handleBlockDragging(data));
          this._domEmitter.listenTo(global$1.document, "drop", (evt, data) => this._handleBlockDragging(data));
          this._domEmitter.listenTo(global$1.document, "dragend", () => this._handleBlockDragEnd(), {
            useCapture: true
          });
          if (this.isEnabled) {
            element.setAttribute("draggable", "true");
          }
          this.on("change:isEnabled", (evt, name, isEnabled2) => {
            element.setAttribute("draggable", isEnabled2 ? "true" : "false");
          });
        }
      }
      /**
      * @inheritDoc
      */
      destroy() {
        this._domEmitter.stopListening();
        return super.destroy();
      }
      /**
      * The `dragstart` event handler.
      */
      _handleBlockDragStart(domEvent) {
        if (!this.isEnabled) {
          return;
        }
        const model = this.editor.model;
        const selection = model.document.selection;
        const view = this.editor.editing.view;
        const blocks = Array.from(selection.getSelectedBlocks());
        const draggedRange = model.createRange(model.createPositionBefore(blocks[0]), model.createPositionAfter(blocks[blocks.length - 1]));
        model.change((writer) => writer.setSelection(draggedRange));
        this._isBlockDragging = true;
        view.focus();
        view.getObserver(ClipboardObserver).onDomEvent(domEvent);
      }
      /**
      * The `dragover` and `drop` event handler.
      */
      _handleBlockDragging(domEvent) {
        if (!this.isEnabled || !this._isBlockDragging) {
          return;
        }
        const clientX = domEvent.clientX + (this.editor.locale.contentLanguageDirection == "ltr" ? 100 : -100);
        const clientY = domEvent.clientY;
        const target = document.elementFromPoint(clientX, clientY);
        const view = this.editor.editing.view;
        if (!target || !target.closest(".ck-editor__editable")) {
          return;
        }
        view.getObserver(ClipboardObserver).onDomEvent({
          ...domEvent,
          type: domEvent.type,
          dataTransfer: domEvent.dataTransfer,
          target,
          clientX,
          clientY,
          preventDefault: () => domEvent.preventDefault(),
          stopPropagation: () => domEvent.stopPropagation()
        });
      }
      /**
      * The `dragend` event handler.
      */
      _handleBlockDragEnd() {
        this._isBlockDragging = false;
      }
    }
    class DragDrop extends Plugin {
      constructor() {
        super(...arguments);
        /**
        * The live range over the original content that is being dragged.
        */
        __publicField(this, "_draggedRange");
        /**
        * The UID of current dragging that is used to verify if the drop started in the same editor as the drag start.
        *
        * **Note**: This is a workaround for broken 'dragend' events (they are not fired if the source text node got removed).
        */
        __publicField(this, "_draggingUid");
        /**
        * The reference to the model element that currently has a `draggable` attribute set (it is set while dragging).
        */
        __publicField(this, "_draggableElement");
        /**
        * A delayed callback removing draggable attributes.
        */
        __publicField(this, "_clearDraggableAttributesDelayed", delay(() => this._clearDraggableAttributes(), 40));
        /**
        * Whether the dragged content can be dropped only in block context.
        */
        // TODO handle drag from other editor instance
        // TODO configure to use block, inline or both
        __publicField(this, "_blockMode", false);
        /**
        * DOM Emitter.
        */
        __publicField(this, "_domEmitter", new (DomEmitterMixin())());
        /**
        * The DOM element used to generate dragged preview image.
        */
        __publicField(this, "_previewContainer");
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "DragDrop";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          ClipboardPipeline,
          Widget,
          DragDropTarget,
          DragDropBlockToolbar
        ];
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor2 = this.editor;
        const view = editor2.editing.view;
        this._draggedRange = null;
        this._draggingUid = "";
        this._draggableElement = null;
        view.addObserver(ClipboardObserver);
        view.addObserver(MouseObserver);
        this._setupDragging();
        this._setupContentInsertionIntegration();
        this._setupClipboardInputIntegration();
        this._setupDraggableAttributeHandling();
        this.listenTo(editor2, "change:isReadOnly", (evt, name, isReadOnly) => {
          if (isReadOnly) {
            this.forceDisabled("readOnlyMode");
          } else {
            this.clearForceDisabled("readOnlyMode");
          }
        });
        this.on("change:isEnabled", (evt, name, isEnabled2) => {
          if (!isEnabled2) {
            this._finalizeDragging(false);
          }
        });
        if (env.isAndroid) {
          this.forceDisabled("noAndroidSupport");
        }
      }
      /**
      * @inheritDoc
      */
      destroy() {
        if (this._draggedRange) {
          this._draggedRange.detach();
          this._draggedRange = null;
        }
        if (this._previewContainer) {
          this._previewContainer.remove();
        }
        this._domEmitter.stopListening();
        this._clearDraggableAttributesDelayed.cancel();
        return super.destroy();
      }
      /**
      * Drag and drop events handling.
      */
      _setupDragging() {
        const editor2 = this.editor;
        const model = editor2.model;
        const view = editor2.editing.view;
        const viewDocument = view.document;
        const dragDropTarget = editor2.plugins.get(DragDropTarget);
        this.listenTo(viewDocument, "dragstart", (evt, data) => {
          if (data.target && data.target.is("editableElement")) {
            data.preventDefault();
            return;
          }
          this._prepareDraggedRange(data.target);
          if (!this._draggedRange) {
            data.preventDefault();
            return;
          }
          this._draggingUid = uid();
          data.dataTransfer.effectAllowed = this.isEnabled ? "copyMove" : "copy";
          data.dataTransfer.setData("application/ckeditor5-dragging-uid", this._draggingUid);
          const draggedSelection = model.createSelection(this._draggedRange.toRange());
          const clipboardPipeline = this.editor.plugins.get("ClipboardPipeline");
          clipboardPipeline._fireOutputTransformationEvent(data.dataTransfer, draggedSelection, "dragstart");
          const { dataTransfer, domTarget, domEvent } = data;
          const { clientX } = domEvent;
          this._updatePreview({
            dataTransfer,
            domTarget,
            clientX
          });
          data.stopPropagation();
          if (!this.isEnabled) {
            this._draggedRange.detach();
            this._draggedRange = null;
            this._draggingUid = "";
          }
        }, {
          priority: "low"
        });
        this.listenTo(viewDocument, "dragend", (evt, data) => {
          this._finalizeDragging(!data.dataTransfer.isCanceled && data.dataTransfer.dropEffect == "move");
        }, {
          priority: "low"
        });
        this._domEmitter.listenTo(global$1.document, "dragend", () => {
          this._blockMode = false;
        }, {
          useCapture: true
        });
        this.listenTo(viewDocument, "dragenter", () => {
          if (!this.isEnabled) {
            return;
          }
          view.focus();
        });
        this.listenTo(viewDocument, "dragleave", () => {
          dragDropTarget.removeDropMarkerDelayed();
        });
        this.listenTo(viewDocument, "dragging", (evt, data) => {
          if (!this.isEnabled) {
            data.dataTransfer.dropEffect = "none";
            return;
          }
          const { clientX, clientY } = data.domEvent;
          dragDropTarget.updateDropMarker(data.target, data.targetRanges, clientX, clientY, this._blockMode, this._draggedRange);
          if (!this._draggedRange) {
            data.dataTransfer.dropEffect = "copy";
          }
          if (!env.isGecko) {
            if (data.dataTransfer.effectAllowed == "copy") {
              data.dataTransfer.dropEffect = "copy";
            } else if ([
              "all",
              "copyMove"
            ].includes(data.dataTransfer.effectAllowed)) {
              data.dataTransfer.dropEffect = "move";
            }
          }
          evt.stop();
        }, {
          priority: "low"
        });
      }
      /**
      * Integration with the `clipboardInput` event.
      */
      _setupClipboardInputIntegration() {
        const editor2 = this.editor;
        const view = editor2.editing.view;
        const viewDocument = view.document;
        const dragDropTarget = editor2.plugins.get(DragDropTarget);
        this.listenTo(viewDocument, "clipboardInput", (evt, data) => {
          if (data.method != "drop") {
            return;
          }
          const { clientX, clientY } = data.domEvent;
          const targetRange = dragDropTarget.getFinalDropRange(data.target, data.targetRanges, clientX, clientY, this._blockMode, this._draggedRange);
          if (!targetRange) {
            this._finalizeDragging(false);
            evt.stop();
            return;
          }
          if (this._draggedRange && this._draggingUid != data.dataTransfer.getData("application/ckeditor5-dragging-uid")) {
            this._draggedRange.detach();
            this._draggedRange = null;
            this._draggingUid = "";
          }
          const isMove = getFinalDropEffect(data.dataTransfer) == "move";
          if (isMove && this._draggedRange && this._draggedRange.containsRange(targetRange, true)) {
            this._finalizeDragging(false);
            evt.stop();
            return;
          }
          data.targetRanges = [
            editor2.editing.mapper.toViewRange(targetRange)
          ];
        }, {
          priority: "high"
        });
      }
      /**
      * Integration with the `contentInsertion` event of the clipboard pipeline.
      */
      _setupContentInsertionIntegration() {
        const clipboardPipeline = this.editor.plugins.get(ClipboardPipeline);
        clipboardPipeline.on("contentInsertion", (evt, data) => {
          if (!this.isEnabled || data.method !== "drop") {
            return;
          }
          const ranges = data.targetRanges.map((viewRange) => this.editor.editing.mapper.toModelRange(viewRange));
          this.editor.model.change((writer) => writer.setSelection(ranges));
        }, {
          priority: "high"
        });
        clipboardPipeline.on("contentInsertion", (evt, data) => {
          if (!this.isEnabled || data.method !== "drop") {
            return;
          }
          const isMove = getFinalDropEffect(data.dataTransfer) == "move";
          const isSuccess = !data.resultRange || !data.resultRange.isCollapsed;
          this._finalizeDragging(isSuccess && isMove);
        }, {
          priority: "lowest"
        });
      }
      /**
      * Adds listeners that add the `draggable` attribute to the elements while the mouse button is down so the dragging could start.
      */
      _setupDraggableAttributeHandling() {
        const editor2 = this.editor;
        const view = editor2.editing.view;
        const viewDocument = view.document;
        this.listenTo(viewDocument, "mousedown", (evt, data) => {
          if (env.isAndroid || !data) {
            return;
          }
          this._clearDraggableAttributesDelayed.cancel();
          let draggableElement = findDraggableWidget(data.target);
          if (env.isBlink && !editor2.isReadOnly && !draggableElement && !viewDocument.selection.isCollapsed) {
            const selectedElement = viewDocument.selection.getSelectedElement();
            if (!selectedElement || !isWidget(selectedElement)) {
              draggableElement = viewDocument.selection.editableElement;
            }
          }
          if (draggableElement) {
            view.change((writer) => {
              writer.setAttribute("draggable", "true", draggableElement);
            });
            this._draggableElement = editor2.editing.mapper.toModelElement(draggableElement);
          }
        });
        this.listenTo(viewDocument, "mouseup", () => {
          if (!env.isAndroid) {
            this._clearDraggableAttributesDelayed();
          }
        });
      }
      /**
      * Removes the `draggable` attribute from the element that was used for dragging.
      */
      _clearDraggableAttributes() {
        const editing = this.editor.editing;
        editing.view.change((writer) => {
          if (this._draggableElement && this._draggableElement.root.rootName != "$graveyard") {
            writer.removeAttribute("draggable", editing.mapper.toViewElement(this._draggableElement));
          }
          this._draggableElement = null;
        });
      }
      /**
      * Deletes the dragged content from its original range and clears the dragging state.
      *
      * @param moved Whether the move succeeded.
      */
      _finalizeDragging(moved) {
        const editor2 = this.editor;
        const model = editor2.model;
        const dragDropTarget = editor2.plugins.get(DragDropTarget);
        dragDropTarget.removeDropMarker();
        this._clearDraggableAttributes();
        if (editor2.plugins.has("WidgetToolbarRepository")) {
          const widgetToolbarRepository = editor2.plugins.get("WidgetToolbarRepository");
          widgetToolbarRepository.clearForceDisabled("dragDrop");
        }
        this._draggingUid = "";
        if (this._previewContainer) {
          this._previewContainer.remove();
          this._previewContainer = void 0;
        }
        if (!this._draggedRange) {
          return;
        }
        if (moved && this.isEnabled) {
          model.change((writer) => {
            const selection = model.createSelection(this._draggedRange);
            model.deleteContent(selection, {
              doNotAutoparagraph: true
            });
            const selectionParent = selection.getFirstPosition().parent;
            if (selectionParent.isEmpty && !model.schema.checkChild(selectionParent, "$text") && model.schema.checkChild(selectionParent, "paragraph")) {
              writer.insertElement("paragraph", selectionParent, 0);
            }
          });
        }
        this._draggedRange.detach();
        this._draggedRange = null;
      }
      /**
      * Sets the dragged source range based on event target and document selection.
      */
      _prepareDraggedRange(target) {
        const editor2 = this.editor;
        const model = editor2.model;
        const selection = model.document.selection;
        const draggableWidget = target ? findDraggableWidget(target) : null;
        if (draggableWidget) {
          const modelElement = editor2.editing.mapper.toModelElement(draggableWidget);
          this._draggedRange = LiveRange.fromRange(model.createRangeOn(modelElement));
          this._blockMode = model.schema.isBlock(modelElement);
          if (editor2.plugins.has("WidgetToolbarRepository")) {
            const widgetToolbarRepository = editor2.plugins.get("WidgetToolbarRepository");
            widgetToolbarRepository.forceDisabled("dragDrop");
          }
          return;
        }
        if (selection.isCollapsed && !selection.getFirstPosition().parent.isEmpty) {
          return;
        }
        const blocks = Array.from(selection.getSelectedBlocks());
        const draggedRange = selection.getFirstRange();
        if (blocks.length == 0) {
          this._draggedRange = LiveRange.fromRange(draggedRange);
          return;
        }
        const blockRange = getRangeIncludingFullySelectedParents(model, blocks);
        if (blocks.length > 1) {
          this._draggedRange = LiveRange.fromRange(blockRange);
          this._blockMode = true;
        } else if (blocks.length == 1) {
          const touchesBlockEdges = draggedRange.start.isTouching(blockRange.start) && draggedRange.end.isTouching(blockRange.end);
          this._draggedRange = LiveRange.fromRange(touchesBlockEdges ? blockRange : draggedRange);
          this._blockMode = touchesBlockEdges;
        }
        model.change((writer) => writer.setSelection(this._draggedRange.toRange()));
      }
      /**
      * Updates the dragged preview image.
      */
      _updatePreview({ dataTransfer, domTarget, clientX }) {
        const view = this.editor.editing.view;
        const editable = view.document.selection.editableElement;
        const domEditable = view.domConverter.mapViewToDom(editable);
        const computedStyle = global$1.window.getComputedStyle(domEditable);
        if (!this._previewContainer) {
          this._previewContainer = createElement(global$1.document, "div", {
            style: "position: fixed; left: -999999px;"
          });
          global$1.document.body.appendChild(this._previewContainer);
        } else if (this._previewContainer.firstElementChild) {
          this._previewContainer.removeChild(this._previewContainer.firstElementChild);
        }
        const domRect = new Rect(domEditable);
        if (domEditable.contains(domTarget)) {
          return;
        }
        const domEditablePaddingLeft = parseFloat(computedStyle.paddingLeft);
        const preview = createElement(global$1.document, "div");
        preview.className = "ck ck-content";
        preview.style.width = computedStyle.width;
        preview.style.paddingLeft = `${domRect.left - clientX + domEditablePaddingLeft}px`;
        if (env.isiOS) {
          preview.style.backgroundColor = "white";
        }
        view.domConverter.setContentOf(preview, dataTransfer.getData("text/html"));
        dataTransfer.setDragImage(preview, 0, 0);
        this._previewContainer.appendChild(preview);
      }
    }
    function getFinalDropEffect(dataTransfer) {
      if (env.isGecko) {
        return dataTransfer.dropEffect;
      }
      return [
        "all",
        "copyMove"
      ].includes(dataTransfer.effectAllowed) ? "move" : "copy";
    }
    function findDraggableWidget(target) {
      if (target.is("editableElement")) {
        return null;
      }
      if (target.hasClass("ck-widget__selection-handle")) {
        return target.findAncestor(isWidget);
      }
      if (isWidget(target)) {
        return target;
      }
      const ancestor = target.findAncestor((node) => isWidget(node) || node.is("editableElement"));
      if (isWidget(ancestor)) {
        return ancestor;
      }
      return null;
    }
    function getRangeIncludingFullySelectedParents(model, elements2) {
      const firstElement = elements2[0];
      const lastElement = elements2[elements2.length - 1];
      const parent2 = firstElement.getCommonAncestor(lastElement);
      const startPosition = model.createPositionBefore(firstElement);
      const endPosition = model.createPositionAfter(lastElement);
      if (parent2 && parent2.is("element") && !model.schema.isLimit(parent2)) {
        const parentRange = model.createRangeOn(parent2);
        const touchesStart = startPosition.isTouching(parentRange.start);
        const touchesEnd = endPosition.isTouching(parentRange.end);
        if (touchesStart && touchesEnd) {
          return getRangeIncludingFullySelectedParents(model, [
            parent2
          ]);
        }
      }
      return model.createRange(startPosition, endPosition);
    }
    class PastePlainText extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "PastePlainText";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          ClipboardPipeline
        ];
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor2 = this.editor;
        const model = editor2.model;
        const view = editor2.editing.view;
        const selection = model.document.selection;
        view.addObserver(ClipboardObserver);
        editor2.plugins.get(ClipboardPipeline).on("contentInsertion", (evt, data) => {
          if (!isUnformattedInlineContent(data.content, model)) {
            return;
          }
          model.change((writer) => {
            const textAttributes = Array.from(selection.getAttributes()).filter(([key]) => model.schema.getAttributeProperties(key).isFormatting);
            if (!selection.isCollapsed) {
              model.deleteContent(selection, {
                doNotAutoparagraph: true
              });
            }
            textAttributes.push(...selection.getAttributes());
            const range2 = writer.createRangeIn(data.content);
            for (const item of range2.getItems()) {
              for (const attribute of textAttributes) {
                if (model.schema.checkAttribute(item, attribute[0])) {
                  writer.setAttribute(attribute[0], attribute[1], item);
                }
              }
            }
          });
        });
      }
    }
    function isUnformattedInlineContent(documentFragment, model) {
      let range2 = model.createRangeIn(documentFragment);
      if (documentFragment.childCount == 1) {
        const child = documentFragment.getChild(0);
        if (child.is("element") && model.schema.isBlock(child) && !model.schema.isObject(child) && !model.schema.isLimit(child)) {
          range2 = model.createRangeIn(child);
        }
      }
      for (const child of range2.getItems()) {
        if (!model.schema.isInline(child)) {
          return false;
        }
        const attributeKeys = Array.from(child.getAttributeKeys());
        if (attributeKeys.find((key) => model.schema.getAttributeProperties(key).isFormatting)) {
          return false;
        }
      }
      return true;
    }
    class Clipboard extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "Clipboard";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          ClipboardMarkersUtils,
          ClipboardPipeline,
          DragDrop,
          PastePlainText
        ];
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor2 = this.editor;
        const t2 = this.editor.t;
        editor2.accessibility.addKeystrokeInfos({
          keystrokes: [
            {
              label: t2("Copy selected content"),
              keystroke: "CTRL+C"
            },
            {
              label: t2("Paste content"),
              keystroke: "CTRL+V"
            },
            {
              label: t2("Paste content as plain text"),
              keystroke: "CTRL+SHIFT+V"
            }
          ]
        });
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class ClassicEditorUI extends EditorUI {
      /**
      * Creates an instance of the classic editor UI class.
      *
      * @param editor The editor instance.
      * @param view The view of the UI.
      */
      constructor(editor2, view) {
        super(editor2);
        /**
        * The main (topmost) view of the editor UI.
        */
        __publicField(this, "view");
        /**
        * A normalized `config.toolbar` object.
        */
        __publicField(this, "_toolbarConfig");
        /**
        * The element replacer instance used to hide the editor's source element.
        */
        __publicField(this, "_elementReplacer");
        this.view = view;
        this._toolbarConfig = normalizeToolbarConfig(editor2.config.get("toolbar"));
        this._elementReplacer = new ElementReplacer();
        this.listenTo(editor2.editing.view, "scrollToTheSelection", this._handleScrollToTheSelectionWithStickyPanel.bind(this));
      }
      /**
      * @inheritDoc
      */
      get element() {
        return this.view.element;
      }
      /**
      * Initializes the UI.
      *
      * @param replacementElement The DOM element that will be the source for the created editor.
      */
      init(replacementElement) {
        const editor2 = this.editor;
        const view = this.view;
        const editingView = editor2.editing.view;
        const editable = view.editable;
        const editingRoot = editingView.document.getRoot();
        editable.name = editingRoot.rootName;
        view.render();
        const editableElement = editable.element;
        this.setEditableElement(editable.name, editableElement);
        view.editable.bind("isFocused").to(this.focusTracker);
        editingView.attachDomRoot(editableElement);
        if (replacementElement) {
          this._elementReplacer.replace(replacementElement, this.element);
        }
        this._initPlaceholder();
        this._initToolbar();
        if (view.menuBarView) {
          this._initMenuBar(view.menuBarView);
        }
        this._initDialogPluginIntegration();
        this._initContextualBalloonIntegration();
        this.fire("ready");
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        const view = this.view;
        const editingView = this.editor.editing.view;
        this._elementReplacer.restore();
        if (editingView.getDomRoot(view.editable.name)) {
          editingView.detachDomRoot(view.editable.name);
        }
        view.destroy();
      }
      /**
      * Initializes the editor toolbar.
      */
      _initToolbar() {
        const view = this.view;
        view.stickyPanel.bind("isActive").to(this.focusTracker, "isFocused");
        view.stickyPanel.limiterElement = view.element;
        view.stickyPanel.bind("viewportTopOffset").to(this, "viewportOffset", ({ top: top2 }) => top2 || 0);
        view.toolbar.fillFromConfig(this._toolbarConfig, this.componentFactory);
        this.addToolbar(view.toolbar);
      }
      /**
      * Enable the placeholder text on the editing root.
      */
      _initPlaceholder() {
        const editor2 = this.editor;
        const editingView = editor2.editing.view;
        const editingRoot = editingView.document.getRoot();
        const sourceElement = editor2.sourceElement;
        let placeholderText;
        const placeholder = editor2.config.get("placeholder");
        if (placeholder) {
          placeholderText = typeof placeholder === "string" ? placeholder : placeholder[this.view.editable.name];
        }
        if (!placeholderText && sourceElement && sourceElement.tagName.toLowerCase() === "textarea") {
          placeholderText = sourceElement.getAttribute("placeholder");
        }
        if (placeholderText) {
          editingRoot.placeholder = placeholderText;
        }
        enablePlaceholder({
          view: editingView,
          element: editingRoot,
          isDirectHost: false,
          keepOnFocus: true
        });
      }
      /**
      * Provides an integration between the sticky toolbar and {@link module:ui/panel/balloon/contextualballoon contextual balloon plugin}.
      * It allows the contextual balloon to consider the height of the
      * {@link module:editor-classic/classiceditoruiview~ClassicEditorUIView#stickyPanel}. It prevents the balloon from overlapping
      * the sticky toolbar by adjusting the balloon's position using viewport offset configuration.
      */
      _initContextualBalloonIntegration() {
        if (!this.editor.plugins.has("ContextualBalloon")) {
          return;
        }
        const { stickyPanel } = this.view;
        const contextualBalloon = this.editor.plugins.get("ContextualBalloon");
        contextualBalloon.on("getPositionOptions", (evt) => {
          const position = evt.return;
          if (!position || !stickyPanel.isSticky || !stickyPanel.element) {
            return;
          }
          const stickyPanelHeight = new Rect(stickyPanel.element).height;
          const target = typeof position.target === "function" ? position.target() : position.target;
          const limiter = typeof position.limiter === "function" ? position.limiter() : position.limiter;
          if (target && limiter && new Rect(target).height >= new Rect(limiter).height - stickyPanelHeight) {
            return;
          }
          const viewportOffsetConfig = {
            ...position.viewportOffsetConfig
          };
          const newTopViewportOffset = (viewportOffsetConfig.top || 0) + stickyPanelHeight;
          evt.return = {
            ...position,
            viewportOffsetConfig: {
              ...viewportOffsetConfig,
              top: newTopViewportOffset
            }
          };
        }, {
          priority: "low"
        });
        const updateBalloonPosition = () => {
          if (contextualBalloon.visibleView) {
            contextualBalloon.updatePosition();
          }
        };
        this.listenTo(stickyPanel, "change:isSticky", updateBalloonPosition);
        this.listenTo(this.editor.ui, "change:viewportOffset", updateBalloonPosition);
      }
      /**
      * Provides an integration between the sticky toolbar and {@link module:utils/dom/scroll~scrollViewportToShowTarget}.
      * It allows the UI-agnostic engine method to consider the geometry of the
      * {@link module:editor-classic/classiceditoruiview~ClassicEditorUIView#stickyPanel} that pins to the
      * edge of the viewport and can obscure the user caret after scrolling the window.
      *
      * @param evt The `scrollToTheSelection` event info.
      * @param data The payload carried by the `scrollToTheSelection` event.
      * @param originalArgs The original arguments passed to `scrollViewportToShowTarget()` method (see implementation to learn more).
      */
      _handleScrollToTheSelectionWithStickyPanel(evt, data, originalArgs) {
        const stickyPanel = this.view.stickyPanel;
        if (stickyPanel.isSticky) {
          const stickyPanelHeight = new Rect(stickyPanel.element).height;
          data.viewportOffset.top += stickyPanelHeight;
        } else {
          const scrollViewportOnPanelGettingSticky = () => {
            this.editor.editing.view.scrollToTheSelection(originalArgs);
          };
          this.listenTo(stickyPanel, "change:isSticky", scrollViewportOnPanelGettingSticky);
          setTimeout(() => {
            this.stopListening(stickyPanel, "change:isSticky", scrollViewportOnPanelGettingSticky);
          }, 20);
        }
      }
      /**
      * Provides an integration between the sticky toolbar and {@link module:ui/dialog/dialog the Dialog plugin}.
      *
      * It moves the dialog down to ensure that the
      * {@link module:editor-classic/classiceditoruiview~ClassicEditorUIView#stickyPanel sticky panel}
      * used by the editor UI will not get obscured by the dialog when the dialog uses one of its automatic positions.
      */
      _initDialogPluginIntegration() {
        if (!this.editor.plugins.has("Dialog")) {
          return;
        }
        const stickyPanel = this.view.stickyPanel;
        const dialogPlugin = this.editor.plugins.get("Dialog");
        dialogPlugin.on("show", () => {
          const dialogView = dialogPlugin.view;
          dialogView.on("moveTo", (evt, data) => {
            if (!stickyPanel.isSticky || dialogView.wasMoved) {
              return;
            }
            const stickyPanelContentRect = new Rect(stickyPanel.contentPanelElement);
            if (data[1] < stickyPanelContentRect.bottom + DialogView.defaultOffset) {
              data[1] = stickyPanelContentRect.bottom + DialogView.defaultOffset;
            }
          }, {
            priority: "high"
          });
        }, {
          priority: "low"
        });
      }
    }
    class ClassicEditorUIView extends BoxedEditorUIView {
      /**
      * Creates an instance of the classic editor UI view.
      *
      * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
      * @param editingView The editing view instance this view is related to.
      * @param options Configuration options for the view instance.
      * @param options.shouldToolbarGroupWhenFull When set `true` enables automatic items grouping
      * in the main {@link module:editor-classic/classiceditoruiview~ClassicEditorUIView#toolbar toolbar}.
      * See {@link module:ui/toolbar/toolbarview~ToolbarOptions#shouldGroupWhenFull} to learn more.
      * @param options.label When set, this value will be used as an accessible `aria-label` of the
      * {@link module:ui/editableui/editableuiview~EditableUIView editable view}.
      */
      constructor(locale, editingView, options = {}) {
        super(locale);
        /**
        * Sticky panel view instance. This is a parent view of a {@link #toolbar}
        * that makes toolbar sticky.
        */
        __publicField(this, "stickyPanel");
        /**
        * Toolbar view instance.
        */
        __publicField(this, "toolbar");
        /**
        * Editable UI view.
        */
        __publicField(this, "editable");
        this.stickyPanel = new StickyPanelView(locale);
        this.toolbar = new ToolbarView(locale, {
          shouldGroupWhenFull: options.shouldToolbarGroupWhenFull
        });
        if (options.useMenuBar) {
          this.menuBarView = new MenuBarView(locale);
        }
        this.editable = new InlineEditableUIView(locale, editingView, void 0, {
          label: options.label
        });
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        if (this.menuBarView) {
          this.stickyPanel.content.addMany([
            this.menuBarView,
            this.toolbar
          ]);
        } else {
          this.stickyPanel.content.add(this.toolbar);
        }
        this.top.add(this.stickyPanel);
        this.main.add(this.editable);
      }
    }
    class ClassicEditor extends (/* @__PURE__ */ ElementApiMixin(Editor)) {
      /**
      * Creates an instance of the classic editor.
      *
      * **Note:** do not use the constructor to create editor instances. Use the static
      * {@link module:editor-classic/classiceditor~ClassicEditor.create `ClassicEditor.create()`} method instead.
      *
      * @param sourceElementOrData The DOM element that will be the source for the created editor
      * or the editor's initial data. For more information see
      * {@link module:editor-classic/classiceditor~ClassicEditor.create `ClassicEditor.create()`}.
      * @param config The editor configuration.
      */
      constructor(sourceElementOrData, config2 = {}) {
        if (!isElement$1(sourceElementOrData) && config2.initialData !== void 0) {
          throw new CKEditorError("editor-create-initial-data", null);
        }
        super(config2);
        /**
        * @inheritDoc
        */
        __publicField(this, "ui");
        this.config.define("menuBar.isVisible", false);
        if (this.config.get("initialData") === void 0) {
          this.config.set("initialData", getInitialData(sourceElementOrData));
        }
        if (isElement$1(sourceElementOrData)) {
          this.sourceElement = sourceElementOrData;
        }
        this.model.document.createRoot();
        const shouldToolbarGroupWhenFull = !this.config.get("toolbar.shouldNotGroupWhenFull");
        const menuBarConfig = this.config.get("menuBar");
        const view = new ClassicEditorUIView(this.locale, this.editing.view, {
          shouldToolbarGroupWhenFull,
          useMenuBar: menuBarConfig.isVisible,
          label: this.config.get("label")
        });
        this.ui = new ClassicEditorUI(this, view);
        attachToForm(this);
      }
      /**
      * Destroys the editor instance, releasing all resources used by it.
      *
      * Updates the original editor element with the data if the
      * {@link module:core/editor/editorconfig~EditorConfig#updateSourceElementOnDestroy `updateSourceElementOnDestroy`}
      * configuration option is set to `true`.
      */
      destroy() {
        if (this.sourceElement) {
          this.updateSourceElement();
        }
        this.ui.destroy();
        return super.destroy();
      }
      /**
      * Creates a new classic editor instance.
      *
      * There are three ways how the editor can be initialized.
      *
      * # Replacing a DOM element (and loading data from it)
      *
      * You can initialize the editor using an existing DOM element:
      *
      * ```ts
      * ClassicEditor
      * 	.create( document.querySelector( '#editor' ) )
      * 	.then( editor => {
      * 		console.log( 'Editor was initialized', editor );
      * 	} )
      * 	.catch( err => {
      * 		console.error( err.stack );
      * 	} );
      * ```
      *
      * The element's content will be used as the editor data and the element will be replaced by the editor UI.
      *
      * # Creating a detached editor
      *
      * Alternatively, you can initialize the editor by passing the initial data directly as a string.
      * In this case, the editor will render an element that must be inserted into the DOM:
      *
      * ```ts
      * ClassicEditor
      * 	.create( '<p>Hello world!</p>' )
      * 	.then( editor => {
      * 		console.log( 'Editor was initialized', editor );
      *
      * 		// Initial data was provided so the editor UI element needs to be added manually to the DOM.
      * 		document.body.appendChild( editor.ui.element );
      * 	} )
      * 	.catch( err => {
      * 		console.error( err.stack );
      * 	} );
      * ```
      *
      * This lets you dynamically append the editor to your web page whenever it is convenient for you. You may use this method if your
      * web page content is generated on the client side and the DOM structure is not ready at the moment when you initialize the editor.
      *
      * # Replacing a DOM element (and data provided in `config.initialData`)
      *
      * You can also mix these two ways by providing a DOM element to be used and passing the initial data through the configuration:
      *
      * ```ts
      * ClassicEditor
      * 	.create( document.querySelector( '#editor' ), {
      * 		initialData: '<h2>Initial data</h2><p>Foo bar.</p>'
      * 	} )
      * 	.then( editor => {
      * 		console.log( 'Editor was initialized', editor );
      * 	} )
      * 	.catch( err => {
      * 		console.error( err.stack );
      * 	} );
      * ```
      *
      * This method can be used to initialize the editor on an existing element with the specified content in case if your integration
      * makes it difficult to set the content of the source element.
      *
      * Note that an error will be thrown if you pass the initial data both as the first parameter and also in the configuration.
      *
      * # Configuring the editor
      *
      * See the {@link module:core/editor/editorconfig~EditorConfig editor configuration documentation} to learn more about
      * customizing plugins, toolbar and more.
      *
      * @param sourceElementOrData The DOM element that will be the source for the created editor
      * or the editor's initial data.
      *
      * If a DOM element is passed, its content will be automatically loaded to the editor upon initialization
      * and the {@link module:editor-classic/classiceditorui~ClassicEditorUI#element editor element} will replace the passed element
      * in the DOM (the original one will be hidden and the editor will be injected next to it).
      *
      * If the {@link module:core/editor/editorconfig~EditorConfig#updateSourceElementOnDestroy updateSourceElementOnDestroy}
      * option is set to `true`, the editor data will be set back to the original element once the editor is destroyed and when a form,
      * in which this element is contained, is submitted (if the original element is a `<textarea>`). This ensures seamless integration
      * with native web forms.
      *
      * If the initial data is passed, a detached editor will be created. In this case you need to insert it into the DOM manually.
      * It is available under the {@link module:editor-classic/classiceditorui~ClassicEditorUI#element `editor.ui.element`} property.
      *
      * @param config The editor configuration.
      * @returns A promise resolved once the editor is ready. The promise resolves with the created editor instance.
      */
      static create(sourceElementOrData, config2 = {}) {
        return new Promise((resolve) => {
          const editor2 = new this(sourceElementOrData, config2);
          resolve(editor2.initPlugins().then(() => editor2.ui.init(isElement$1(sourceElementOrData) ? sourceElementOrData : null)).then(() => editor2.data.init(editor2.config.get("initialData"))).then(() => editor2.fire("ready")).then(() => editor2));
        });
      }
    }
    function getInitialData(sourceElementOrData) {
      return isElement$1(sourceElementOrData) ? getDataFromElement(sourceElementOrData) : sourceElementOrData;
    }
    function isElement$1(value) {
      return isElement$3(value);
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class SelectAllCommand extends Command {
      /**
      * @inheritDoc
      */
      constructor(editor2) {
        super(editor2);
        this.affectsData = false;
      }
      /**
      * @inheritDoc
      */
      execute() {
        const model = this.editor.model;
        const selection = model.document.selection;
        let scopeElement = model.schema.getLimitElement(selection);
        if (selection.containsEntireContent(scopeElement) || !isSelectAllScope(model.schema, scopeElement)) {
          do {
            scopeElement = scopeElement.parent;
            if (!scopeElement) {
              return;
            }
          } while (!isSelectAllScope(model.schema, scopeElement));
        }
        model.change((writer) => {
          writer.setSelection(scopeElement, "in");
        });
      }
    }
    function isSelectAllScope(schema, element) {
      return schema.isLimit(element) && (schema.checkChild(element, "$text") || schema.checkChild(element, "paragraph"));
    }
    const SELECT_ALL_KEYSTROKE = /* @__PURE__ */ parseKeystroke("Ctrl+A");
    class SelectAllEditing extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "SelectAllEditing";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor2 = this.editor;
        const t2 = editor2.t;
        const view = editor2.editing.view;
        const viewDocument = view.document;
        editor2.commands.add("selectAll", new SelectAllCommand(editor2));
        this.listenTo(viewDocument, "keydown", (eventInfo, domEventData) => {
          if (getCode(domEventData) === SELECT_ALL_KEYSTROKE) {
            editor2.execute("selectAll");
            domEventData.preventDefault();
          }
        });
        editor2.accessibility.addKeystrokeInfos({
          keystrokes: [
            {
              label: t2("Select all"),
              keystroke: "CTRL+A"
            }
          ]
        });
      }
    }
    var selectAllIcon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M.75 15.5a.75.75 0 0 1 .75.75V18l.008.09A.5.5 0 0 0 2 18.5h1.75a.75.75 0 1 1 0 1.5H1.5l-.144-.007a1.5 1.5 0 0 1-1.35-1.349L0 18.5v-2.25a.75.75 0 0 1 .75-.75zm18.5 0a.75.75 0 0 1 .75.75v2.25l-.007.144a1.5 1.5 0 0 1-1.349 1.35L18.5 20h-2.25a.75.75 0 1 1 0-1.5H18a.5.5 0 0 0 .492-.41L18.5 18v-1.75a.75.75 0 0 1 .75-.75zm-10.45 3c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm.45-5.5a.75.75 0 1 1 0 1.5h-8.5a.75.75 0 1 1 0-1.5h8.5zM1.3 11c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM1.3 7c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5h2.5zm-5 0a.75.75 0 1 1 0 1.5h-5.5a.75.75 0 0 1 0-1.5h5.5zm-6.5-5a.75.75 0 0 1 0 1.5H2a.5.5 0 0 0-.492.41L1.5 2v1.75a.75.75 0 0 1-1.5 0V1.5l.007-.144A1.5 1.5 0 0 1 1.356.006L1.5 0h2.25zM18.5 0l.144.007a1.5 1.5 0 0 1 1.35 1.349L20 1.5v2.25a.75.75 0 1 1-1.5 0V2l-.008-.09A.5.5 0 0 0 18 1.5h-1.75a.75.75 0 1 1 0-1.5h2.25zM8.8 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6z"/></svg>';
    class SelectAllUI extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "SelectAllUI";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor2 = this.editor;
        editor2.ui.componentFactory.add("selectAll", () => {
          const buttonView = this._createButton(ButtonView);
          buttonView.set({
            tooltip: true
          });
          return buttonView;
        });
        editor2.ui.componentFactory.add("menuBar:selectAll", () => {
          return this._createButton(MenuBarMenuListItemButtonView);
        });
      }
      /**
      * Creates a button for select all command to use either in toolbar or in menu bar.
      */
      _createButton(ButtonClass) {
        const editor2 = this.editor;
        const locale = editor2.locale;
        const command = editor2.commands.get("selectAll");
        const view = new ButtonClass(editor2.locale);
        const t2 = locale.t;
        view.set({
          label: t2("Select all"),
          icon: selectAllIcon,
          keystroke: "Ctrl+A"
        });
        view.bind("isEnabled").to(command, "isEnabled");
        this.listenTo(view, "execute", () => {
          editor2.execute("selectAll");
          editor2.editing.view.focus();
        });
        return view;
      }
    }
    class SelectAll extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          SelectAllEditing,
          SelectAllUI
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "SelectAll";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class BaseCommand extends Command {
      /**
      * @inheritDoc
      */
      constructor(editor2) {
        super(editor2);
        /**
        * Stack of items stored by the command. These are pairs of:
        *
        * * {@link module:engine/model/batch~Batch batch} saved by the command,
        * * {@link module:engine/model/selection~Selection selection} state at the moment of saving the batch.
        */
        __publicField(this, "_stack", []);
        /**
        * Stores all batches that were created by this command.
        *
        * @internal
        */
        __publicField(this, "_createdBatches", /* @__PURE__ */ new WeakSet());
        this.refresh();
        this._isEnabledBasedOnSelection = false;
        this.listenTo(editor2.data, "set", (evt, data) => {
          data[1] = {
            ...data[1]
          };
          const options = data[1];
          if (!options.batchType) {
            options.batchType = {
              isUndoable: false
            };
          }
        }, {
          priority: "high"
        });
        this.listenTo(editor2.data, "set", (evt, data) => {
          const options = data[1];
          if (!options.batchType.isUndoable) {
            this.clearStack();
          }
        });
      }
      /**
      * @inheritDoc
      */
      refresh() {
        this.isEnabled = this._stack.length > 0;
      }
      /**
      * Returns all batches created by this command.
      */
      get createdBatches() {
        return this._createdBatches;
      }
      /**
      * Stores a batch in the command, together with the selection state of the {@link module:engine/model/document~Document document}
      * created by the editor which this command is registered to.
      *
      * @param batch The batch to add.
      */
      addBatch(batch) {
        const docSelection = this.editor.model.document.selection;
        const selection = {
          ranges: docSelection.hasOwnRange ? Array.from(docSelection.getRanges()) : [],
          isBackward: docSelection.isBackward
        };
        this._stack.push({
          batch,
          selection
        });
        this.refresh();
      }
      /**
      * Removes all items from the stack.
      */
      clearStack() {
        this._stack = [];
        this.refresh();
      }
      /**
      * Restores the {@link module:engine/model/document~Document#selection document selection} state after a batch was undone.
      *
      * @param ranges Ranges to be restored.
      * @param isBackward A flag describing whether the restored range was selected forward or backward.
      * @param operations Operations which has been applied since selection has been stored.
      */
      _restoreSelection(ranges, isBackward, operations2) {
        const model = this.editor.model;
        const document2 = model.document;
        const selectionRanges = [];
        const transformedRangeGroups = ranges.map((range2) => range2.getTransformedByOperations(operations2));
        const allRanges = transformedRangeGroups.flat();
        for (const rangeGroup of transformedRangeGroups) {
          const transformed = rangeGroup.filter((range2) => range2.root != document2.graveyard).filter((range2) => !isRangeContainedByAnyOtherRange(range2, allRanges));
          if (!transformed.length) {
            continue;
          }
          normalizeRanges(transformed);
          selectionRanges.push(transformed[0]);
        }
        if (selectionRanges.length) {
          model.change((writer) => {
            writer.setSelection(selectionRanges, {
              backward: isBackward
            });
          });
        }
      }
      /**
      * Undoes a batch by reversing that batch, transforming reversed batch and finally applying it.
      * This is a helper method for {@link #execute}.
      *
      * @param batchToUndo The batch to be undone.
      * @param undoingBatch The batch that will contain undoing changes.
      */
      _undo(batchToUndo, undoingBatch) {
        const model = this.editor.model;
        const document2 = model.document;
        this._createdBatches.add(undoingBatch);
        const operationsToUndo = batchToUndo.operations.slice().filter((operation) => operation.isDocumentOperation);
        operationsToUndo.reverse();
        for (const operationToUndo of operationsToUndo) {
          const nextBaseVersion = operationToUndo.baseVersion + 1;
          const historyOperations = Array.from(document2.history.getOperations(nextBaseVersion));
          const transformedSets = transformSets([
            operationToUndo.getReversed()
          ], historyOperations, {
            useRelations: true,
            document: this.editor.model.document,
            padWithNoOps: false,
            forceWeakRemove: true
          });
          const reversedOperations = transformedSets.operationsA;
          for (let operation of reversedOperations) {
            const affectedSelectable = operation.affectedSelectable;
            if (affectedSelectable && !model.canEditAt(affectedSelectable)) {
              operation = new NoOperation(operation.baseVersion);
            }
            undoingBatch.addOperation(operation);
            model.applyOperation(operation);
            document2.history.setOperationAsUndone(operationToUndo, operation);
          }
        }
      }
    }
    function normalizeRanges(ranges) {
      ranges.sort((a2, b2) => a2.start.isBefore(b2.start) ? -1 : 1);
      for (let i2 = 1; i2 < ranges.length; i2++) {
        const previousRange = ranges[i2 - 1];
        const joinedRange = previousRange.getJoined(ranges[i2], true);
        if (joinedRange) {
          i2--;
          ranges.splice(i2, 2, joinedRange);
        }
      }
    }
    function isRangeContainedByAnyOtherRange(range2, ranges) {
      return ranges.some((otherRange) => otherRange !== range2 && otherRange.containsRange(range2, true));
    }
    class UndoCommand extends BaseCommand {
      /**
      * Executes the command. This method reverts a {@link module:engine/model/batch~Batch batch} added to the command's stack, transforms
      * and applies the reverted version on the {@link module:engine/model/document~Document document} and removes the batch from the stack.
      * Then, it restores the {@link module:engine/model/document~Document#selection document selection}.
      *
      * @fires execute
      * @fires revert
      * @param batch A batch that should be undone. If not set, the last added batch will be undone.
      */
      execute(batch = null) {
        const batchIndex = batch ? this._stack.findIndex((a2) => a2.batch == batch) : this._stack.length - 1;
        const item = this._stack.splice(batchIndex, 1)[0];
        const undoingBatch = this.editor.model.createBatch({
          isUndo: true
        });
        this.editor.model.enqueueChange(undoingBatch, () => {
          this._undo(item.batch, undoingBatch);
          const operations2 = this.editor.model.document.history.getOperations(item.batch.baseVersion);
          this._restoreSelection(item.selection.ranges, item.selection.isBackward, operations2);
        });
        this.fire("revert", item.batch, undoingBatch);
        this.refresh();
      }
    }
    class RedoCommand extends BaseCommand {
      /**
      * Executes the command. This method reverts the last {@link module:engine/model/batch~Batch batch} added to
      * the command's stack, applies the reverted and transformed version on the
      * {@link module:engine/model/document~Document document} and removes the batch from the stack.
      * Then, it restores the {@link module:engine/model/document~Document#selection document selection}.
      *
      * @fires execute
      */
      execute() {
        const item = this._stack.pop();
        const redoingBatch = this.editor.model.createBatch({
          isUndo: true
        });
        this.editor.model.enqueueChange(redoingBatch, () => {
          const lastOperation = item.batch.operations[item.batch.operations.length - 1];
          const nextBaseVersion = lastOperation.baseVersion + 1;
          const operations2 = this.editor.model.document.history.getOperations(nextBaseVersion);
          this._restoreSelection(item.selection.ranges, item.selection.isBackward, operations2);
          this._undo(item.batch, redoingBatch);
        });
        this.refresh();
      }
    }
    class UndoEditing extends Plugin {
      constructor() {
        super(...arguments);
        /**
        * The command that manages the undo {@link module:engine/model/batch~Batch batches} stack (history).
        * Created and registered during the {@link #init feature initialization}.
        */
        __publicField(this, "_undoCommand");
        /**
        * The command that manages the redo {@link module:engine/model/batch~Batch batches} stack (history).
        * Created and registered during the {@link #init feature initialization}.
        */
        __publicField(this, "_redoCommand");
        /**
        * Keeps track of which batches were registered in undo.
        */
        __publicField(this, "_batchRegistry", /* @__PURE__ */ new WeakSet());
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "UndoEditing";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor2 = this.editor;
        const t2 = editor2.t;
        this._undoCommand = new UndoCommand(editor2);
        this._redoCommand = new RedoCommand(editor2);
        editor2.commands.add("undo", this._undoCommand);
        editor2.commands.add("redo", this._redoCommand);
        this.listenTo(editor2.model, "applyOperation", (evt, args) => {
          const operation = args[0];
          if (!operation.isDocumentOperation) {
            return;
          }
          const batch = operation.batch;
          const isRedoBatch = this._redoCommand.createdBatches.has(batch);
          const isUndoBatch = this._undoCommand.createdBatches.has(batch);
          const wasProcessed = this._batchRegistry.has(batch);
          if (wasProcessed) {
            return;
          }
          this._batchRegistry.add(batch);
          if (!batch.isUndoable) {
            return;
          }
          if (isRedoBatch) {
            this._undoCommand.addBatch(batch);
          } else if (!isUndoBatch) {
            this._undoCommand.addBatch(batch);
            this._redoCommand.clearStack();
          }
        }, {
          priority: "highest"
        });
        this.listenTo(this._undoCommand, "revert", (evt, undoneBatch, undoingBatch) => {
          this._redoCommand.addBatch(undoingBatch);
        });
        editor2.keystrokes.set("CTRL+Z", "undo");
        editor2.keystrokes.set("CTRL+Y", "redo");
        editor2.keystrokes.set("CTRL+SHIFT+Z", "redo");
        editor2.accessibility.addKeystrokeInfos({
          keystrokes: [
            {
              label: t2("Undo"),
              keystroke: "CTRL+Z"
            },
            {
              label: t2("Redo"),
              keystroke: [
                [
                  "CTRL+Y"
                ],
                [
                  "CTRL+SHIFT+Z"
                ]
              ]
            }
          ]
        });
      }
    }
    class UndoUI extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "UndoUI";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor2 = this.editor;
        const locale = editor2.locale;
        const t2 = editor2.t;
        const localizedUndoIcon = locale.uiLanguageDirection == "ltr" ? icons.undo : icons.redo;
        const localizedRedoIcon = locale.uiLanguageDirection == "ltr" ? icons.redo : icons.undo;
        this._addButtonsToFactory("undo", t2("Undo"), "CTRL+Z", localizedUndoIcon);
        this._addButtonsToFactory("redo", t2("Redo"), "CTRL+Y", localizedRedoIcon);
      }
      /**
      * Creates a button for the specified command.
      *
      * @param name Command name.
      * @param label Button label.
      * @param keystroke Command keystroke.
      * @param Icon Source of the icon.
      */
      _addButtonsToFactory(name, label, keystroke, Icon) {
        const editor2 = this.editor;
        editor2.ui.componentFactory.add(name, () => {
          const buttonView = this._createButton(ButtonView, name, label, keystroke, Icon);
          buttonView.set({
            tooltip: true
          });
          return buttonView;
        });
        editor2.ui.componentFactory.add("menuBar:" + name, () => {
          return this._createButton(MenuBarMenuListItemButtonView, name, label, keystroke, Icon);
        });
      }
      /**
      * TODO
      */
      _createButton(ButtonClass, name, label, keystroke, Icon) {
        const editor2 = this.editor;
        const locale = editor2.locale;
        const command = editor2.commands.get(name);
        const view = new ButtonClass(locale);
        view.set({
          label,
          icon: Icon,
          keystroke
        });
        view.bind("isEnabled").to(command, "isEnabled");
        this.listenTo(view, "execute", () => {
          editor2.execute(name);
          editor2.editing.view.focus();
        });
        return view;
      }
    }
    class Undo extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          UndoEditing,
          UndoUI
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "Undo";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class Essentials extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          AccessibilityHelp,
          Clipboard,
          Enter,
          SelectAll,
          ShiftEnter,
          Typing,
          Undo
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "Essentials";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class ParagraphCommand extends Command {
      constructor(editor2) {
        super(editor2);
        this._isEnabledBasedOnSelection = false;
      }
      /**
      * @inheritDoc
      */
      refresh() {
        const model = this.editor.model;
        const document2 = model.document;
        const block2 = first(document2.selection.getSelectedBlocks());
        this.value = !!block2 && block2.is("element", "paragraph");
        this.isEnabled = !!block2 && checkCanBecomeParagraph(block2, model.schema);
      }
      /**
      * Executes the command. All the blocks (see {@link module:engine/model/schema~Schema}) in the selection
      * will be turned to paragraphs.
      *
      * @fires execute
      * @param options Options for the executed command.
      * @param options.selection The selection that the command should be applied to. By default,
      * if not provided, the command is applied to the {@link module:engine/model/document~Document#selection}.
      */
      execute(options = {}) {
        const model = this.editor.model;
        const document2 = model.document;
        const selection = options.selection || document2.selection;
        if (!model.canEditAt(selection)) {
          return;
        }
        model.change((writer) => {
          const blocks = selection.getSelectedBlocks();
          for (const block2 of blocks) {
            if (!block2.is("element", "paragraph") && checkCanBecomeParagraph(block2, model.schema)) {
              writer.rename(block2, "paragraph");
            }
          }
        });
      }
    }
    function checkCanBecomeParagraph(block2, schema) {
      return schema.checkChild(block2.parent, "paragraph") && !schema.isObject(block2);
    }
    class InsertParagraphCommand extends Command {
      constructor(editor2) {
        super(editor2);
        this._isEnabledBasedOnSelection = false;
      }
      /**
      * Executes the command.
      *
      * @param options Options for the executed command.
      * @param options.position The model position at which the new paragraph will be inserted.
      * @param options.attributes Attributes keys and values to set on a inserted paragraph.
      * @fires execute
      */
      execute(options) {
        const model = this.editor.model;
        const attributes = options.attributes;
        let position = options.position;
        if (!model.canEditAt(position)) {
          return;
        }
        model.change((writer) => {
          position = this._findPositionToInsertParagraph(position, writer);
          if (!position) {
            return;
          }
          const paragraph2 = writer.createElement("paragraph");
          if (attributes) {
            model.schema.setAllowedAttributes(paragraph2, attributes, writer);
          }
          model.insertContent(paragraph2, position);
          writer.setSelection(paragraph2, "in");
        });
      }
      /**
      * Returns the best position to insert a new paragraph.
      */
      _findPositionToInsertParagraph(position, writer) {
        const model = this.editor.model;
        if (model.schema.checkChild(position, "paragraph")) {
          return position;
        }
        const allowedParent = model.schema.findAllowedParent(position, "paragraph");
        if (!allowedParent) {
          return null;
        }
        const positionParent = position.parent;
        const isTextAllowed = model.schema.checkChild(positionParent, "$text");
        if (positionParent.isEmpty || isTextAllowed && position.isAtEnd) {
          return model.createPositionAfter(positionParent);
        }
        if (!positionParent.isEmpty && isTextAllowed && position.isAtStart) {
          return model.createPositionBefore(positionParent);
        }
        return writer.split(position, allowedParent).position;
      }
    }
    const _Paragraph = class _Paragraph extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "Paragraph";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor2 = this.editor;
        const model = editor2.model;
        editor2.commands.add("paragraph", new ParagraphCommand(editor2));
        editor2.commands.add("insertParagraph", new InsertParagraphCommand(editor2));
        model.schema.register("paragraph", {
          inheritAllFrom: "$block"
        });
        editor2.conversion.elementToElement({
          model: "paragraph",
          view: "p"
        });
        editor2.conversion.for("upcast").elementToElement({
          model: (viewElement, { writer }) => {
            if (!_Paragraph.paragraphLikeElements.has(viewElement.name)) {
              return null;
            }
            if (viewElement.isEmpty) {
              return null;
            }
            return writer.createElement("paragraph");
          },
          view: /.+/,
          converterPriority: "low"
        });
      }
    };
    /**
    * A list of element names which should be treated by the autoparagraphing algorithms as
    * paragraph-like. This means that e.g. the following content:
    *
    * ```html
    * <h1>Foo</h1>
    * <table>
    *   <tr>
    *     <td>X</td>
    *     <td>
    *       <ul>
    *         <li>Y</li>
    *         <li>Z</li>
    *       </ul>
    *     </td>
    *   </tr>
    * </table>
    * ```
    *
    * contains five paragraph-like elements: `<h1>`, two `<td>`s and two `<li>`s.
    * Hence, if none of the features is going to convert those elements the above content will be automatically handled
    * by the paragraph feature and converted to:
    *
    * ```html
    * <p>Foo</p>
    * <p>X</p>
    * <p>Y</p>
    * <p>Z</p>
    * ```
    *
    * Note: The `<td>` containing two `<li>` elements was ignored as the innermost paragraph-like elements
    * have a priority upon conversion.
    */
    __publicField(_Paragraph, "paragraphLikeElements", /* @__PURE__ */ new Set([
      "blockquote",
      "dd",
      "div",
      "dt",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "li",
      "p",
      "td",
      "th"
    ]));
    let Paragraph = _Paragraph;
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class HeadingCommand extends Command {
      /**
      * Creates an instance of the command.
      *
      * @param editor Editor instance.
      * @param modelElements Names of the element which this command can apply in the model.
      */
      constructor(editor2, modelElements) {
        super(editor2);
        /**
        * Set of defined model's elements names that this command support.
        * See {@link module:heading/headingconfig~HeadingOption}.
        */
        __publicField(this, "modelElements");
        this.modelElements = modelElements;
      }
      /**
      * @inheritDoc
      */
      refresh() {
        const block2 = first(this.editor.model.document.selection.getSelectedBlocks());
        this.value = !!block2 && this.modelElements.includes(block2.name) && block2.name;
        this.isEnabled = !!block2 && this.modelElements.some((heading) => checkCanBecomeHeading(block2, heading, this.editor.model.schema));
      }
      /**
      * Executes the command. Applies the heading to the selected blocks or, if the first selected
      * block is a heading already, turns selected headings (of this level only) to paragraphs.
      *
      * @param options.value Name of the element which this command will apply in the model.
      * @fires execute
      */
      execute(options) {
        const model = this.editor.model;
        const document2 = model.document;
        const modelElement = options.value;
        model.change((writer) => {
          const blocks = Array.from(document2.selection.getSelectedBlocks()).filter((block2) => {
            return checkCanBecomeHeading(block2, modelElement, model.schema);
          });
          for (const block2 of blocks) {
            if (!block2.is("element", modelElement)) {
              writer.rename(block2, modelElement);
            }
          }
        });
      }
    }
    function checkCanBecomeHeading(block2, heading, schema) {
      return schema.checkChild(block2.parent, heading) && !schema.isObject(block2);
    }
    const defaultModelElement = "paragraph";
    class HeadingEditing extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "HeadingEditing";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
      /**
      * @inheritDoc
      */
      constructor(editor2) {
        super(editor2);
        editor2.config.define("heading", {
          options: [
            {
              model: "paragraph",
              title: "Paragraph",
              class: "ck-heading_paragraph"
            },
            {
              model: "heading1",
              view: "h2",
              title: "Heading 1",
              class: "ck-heading_heading1"
            },
            {
              model: "heading2",
              view: "h3",
              title: "Heading 2",
              class: "ck-heading_heading2"
            },
            {
              model: "heading3",
              view: "h4",
              title: "Heading 3",
              class: "ck-heading_heading3"
            }
          ]
        });
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          Paragraph
        ];
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor2 = this.editor;
        const options = editor2.config.get("heading.options");
        const modelElements = [];
        for (const option of options) {
          if (option.model === "paragraph") {
            continue;
          }
          editor2.model.schema.register(option.model, {
            inheritAllFrom: "$block"
          });
          editor2.conversion.elementToElement(option);
          modelElements.push(option.model);
        }
        this._addDefaultH1Conversion(editor2);
        editor2.commands.add("heading", new HeadingCommand(editor2, modelElements));
      }
      /**
      * @inheritDoc
      */
      afterInit() {
        const editor2 = this.editor;
        const enterCommand = editor2.commands.get("enter");
        const options = editor2.config.get("heading.options");
        if (enterCommand) {
          this.listenTo(enterCommand, "afterExecute", (evt, data) => {
            const positionParent = editor2.model.document.selection.getFirstPosition().parent;
            const isHeading = options.some((option) => positionParent.is("element", option.model));
            if (isHeading && !positionParent.is("element", defaultModelElement) && positionParent.childCount === 0) {
              data.writer.rename(positionParent, defaultModelElement);
            }
          });
        }
      }
      /**
      * Adds default conversion for `h1` -> `heading1` with a low priority.
      *
      * @param editor Editor instance on which to add the `h1` conversion.
      */
      _addDefaultH1Conversion(editor2) {
        editor2.conversion.for("upcast").elementToElement({
          model: "heading1",
          view: "h1",
          // With a `low` priority, `paragraph` plugin autoparagraphing mechanism is executed. Make sure
          // this listener is called before it. If not, `h1` will be transformed into a paragraph.
          converterPriority: priorities.low + 1
        });
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function getLocalizedOptions(editor2) {
      const t2 = editor2.t;
      const localizedTitles = {
        "Paragraph": t2("Paragraph"),
        "Heading 1": t2("Heading 1"),
        "Heading 2": t2("Heading 2"),
        "Heading 3": t2("Heading 3"),
        "Heading 4": t2("Heading 4"),
        "Heading 5": t2("Heading 5"),
        "Heading 6": t2("Heading 6")
      };
      return editor2.config.get("heading.options").map((option) => {
        const title = localizedTitles[option.title];
        if (title && title != option.title) {
          option.title = title;
        }
        return option;
      });
    }
    class HeadingUI extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "HeadingUI";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor2 = this.editor;
        const t2 = editor2.t;
        const options = getLocalizedOptions(editor2);
        const defaultTitle = t2("Choose heading");
        const accessibleLabel = t2("Heading");
        editor2.ui.componentFactory.add("heading", (locale) => {
          const titles = {};
          const itemDefinitions = new Collection();
          const headingCommand = editor2.commands.get("heading");
          const paragraphCommand = editor2.commands.get("paragraph");
          const commands = [
            headingCommand
          ];
          for (const option of options) {
            const def = {
              type: "button",
              model: new Model({
                label: option.title,
                class: option.class,
                role: "menuitemradio",
                withText: true
              })
            };
            if (option.model === "paragraph") {
              def.model.bind("isOn").to(paragraphCommand, "value");
              def.model.set("commandName", "paragraph");
              commands.push(paragraphCommand);
            } else {
              def.model.bind("isOn").to(headingCommand, "value", (value) => value === option.model);
              def.model.set({
                commandName: "heading",
                commandValue: option.model
              });
            }
            itemDefinitions.add(def);
            titles[option.model] = option.title;
          }
          const dropdownView = createDropdown(locale);
          addListToDropdown(dropdownView, itemDefinitions, {
            ariaLabel: accessibleLabel,
            role: "menu"
          });
          dropdownView.buttonView.set({
            ariaLabel: accessibleLabel,
            ariaLabelledBy: void 0,
            isOn: false,
            withText: true,
            tooltip: accessibleLabel
          });
          dropdownView.extendTemplate({
            attributes: {
              class: [
                "ck-heading-dropdown"
              ]
            }
          });
          dropdownView.bind("isEnabled").toMany(commands, "isEnabled", (...areEnabled) => {
            return areEnabled.some((isEnabled2) => isEnabled2);
          });
          dropdownView.buttonView.bind("label").to(headingCommand, "value", paragraphCommand, "value", (heading, paragraph2) => {
            const whichModel = paragraph2 ? "paragraph" : heading;
            if (typeof whichModel === "boolean") {
              return defaultTitle;
            }
            if (!titles[whichModel]) {
              return defaultTitle;
            }
            return titles[whichModel];
          });
          dropdownView.buttonView.bind("ariaLabel").to(headingCommand, "value", paragraphCommand, "value", (heading, paragraph2) => {
            const whichModel = paragraph2 ? "paragraph" : heading;
            if (typeof whichModel === "boolean") {
              return accessibleLabel;
            }
            if (!titles[whichModel]) {
              return accessibleLabel;
            }
            return `${titles[whichModel]}, ${accessibleLabel}`;
          });
          this.listenTo(dropdownView, "execute", (evt) => {
            const { commandName, commandValue } = evt.source;
            editor2.execute(commandName, commandValue ? {
              value: commandValue
            } : void 0);
            editor2.editing.view.focus();
          });
          return dropdownView;
        });
        editor2.ui.componentFactory.add("menuBar:heading", (locale) => {
          const menuView = new MenuBarMenuView(locale);
          const headingCommand = editor2.commands.get("heading");
          const paragraphCommand = editor2.commands.get("paragraph");
          const commands = [
            headingCommand
          ];
          const listView = new MenuBarMenuListView(locale);
          menuView.set({
            class: "ck-heading-dropdown"
          });
          listView.set({
            ariaLabel: t2("Heading"),
            role: "menu"
          });
          menuView.buttonView.set({
            label: t2("Heading")
          });
          menuView.panelView.children.add(listView);
          for (const option of options) {
            const listItemView = new MenuBarMenuListItemView(locale, menuView);
            const buttonView = new MenuBarMenuListItemButtonView(locale);
            listItemView.children.add(buttonView);
            listView.items.add(listItemView);
            buttonView.set({
              isToggleable: true,
              label: option.title,
              role: "menuitemradio",
              class: option.class
            });
            buttonView.delegate("execute").to(menuView);
            buttonView.on("execute", () => {
              const commandName = option.model === "paragraph" ? "paragraph" : "heading";
              editor2.execute(commandName, {
                value: option.model
              });
              editor2.editing.view.focus();
            });
            if (option.model === "paragraph") {
              buttonView.bind("isOn").to(paragraphCommand, "value");
              commands.push(paragraphCommand);
            } else {
              buttonView.bind("isOn").to(headingCommand, "value", (value) => value === option.model);
            }
          }
          menuView.bind("isEnabled").toMany(commands, "isEnabled", (...areEnabled) => {
            return areEnabled.some((isEnabled2) => isEnabled2);
          });
          return menuView;
        });
      }
    }
    class Heading extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          HeadingEditing,
          HeadingUI
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "Heading";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class AutomaticDecorators {
      constructor() {
        /**
        * Stores the definition of {@link module:link/linkconfig~LinkDecoratorAutomaticDefinition automatic decorators}.
        * This data is used as a source for a downcast dispatcher to create a proper conversion to output data.
        */
        __publicField(this, "_definitions", /* @__PURE__ */ new Set());
      }
      /**
      * Gives information about the number of decorators stored in the {@link module:link/utils/automaticdecorators~AutomaticDecorators}
      * instance.
      */
      get length() {
        return this._definitions.size;
      }
      /**
      * Adds automatic decorator objects or an array with them to be used during downcasting.
      *
      * @param item A configuration object of automatic rules for decorating links. It might also be an array of such objects.
      */
      add(item) {
        if (Array.isArray(item)) {
          item.forEach((item2) => this._definitions.add(item2));
        } else {
          this._definitions.add(item);
        }
      }
      /**
      * Provides the conversion helper used in the {@link module:engine/conversion/downcasthelpers~DowncastHelpers#add} method.
      *
      * @returns A dispatcher function used as conversion helper in {@link module:engine/conversion/downcasthelpers~DowncastHelpers#add}.
      */
      getDispatcher() {
        return (dispatcher) => {
          dispatcher.on("attribute:linkHref", (evt, data, conversionApi) => {
            if (!conversionApi.consumable.test(data.item, "attribute:linkHref")) {
              return;
            }
            if (!(data.item.is("selection") || conversionApi.schema.isInline(data.item))) {
              return;
            }
            const viewWriter = conversionApi.writer;
            const viewSelection = viewWriter.document.selection;
            for (const item of this._definitions) {
              const viewElement = viewWriter.createAttributeElement("a", item.attributes, {
                priority: 5
              });
              if (item.classes) {
                viewWriter.addClass(item.classes, viewElement);
              }
              for (const key in item.styles) {
                viewWriter.setStyle(key, item.styles[key], viewElement);
              }
              viewWriter.setCustomProperty("link", true, viewElement);
              if (item.callback(data.attributeNewValue)) {
                if (data.item.is("selection")) {
                  viewWriter.wrap(viewSelection.getFirstRange(), viewElement);
                } else {
                  viewWriter.wrap(conversionApi.mapper.toViewRange(data.range), viewElement);
                }
              } else {
                viewWriter.unwrap(conversionApi.mapper.toViewRange(data.range), viewElement);
              }
            }
          }, {
            priority: "high"
          });
        };
      }
      /**
      * Provides the conversion helper used in the {@link module:engine/conversion/downcasthelpers~DowncastHelpers#add} method
      * when linking images.
      *
      * @returns A dispatcher function used as conversion helper in {@link module:engine/conversion/downcasthelpers~DowncastHelpers#add}.
      */
      getDispatcherForLinkedImage() {
        return (dispatcher) => {
          dispatcher.on("attribute:linkHref:imageBlock", (evt, data, { writer, mapper }) => {
            const viewFigure = mapper.toViewElement(data.item);
            const linkInImage = Array.from(viewFigure.getChildren()).find((child) => child.is("element", "a"));
            if (!linkInImage) {
              return;
            }
            for (const item of this._definitions) {
              const attributes = toMap(item.attributes);
              if (item.callback(data.attributeNewValue)) {
                for (const [key, val] of attributes) {
                  if (key === "class") {
                    writer.addClass(val, linkInImage);
                  } else {
                    writer.setAttribute(key, val, linkInImage);
                  }
                }
                if (item.classes) {
                  writer.addClass(item.classes, linkInImage);
                }
                for (const key in item.styles) {
                  writer.setStyle(key, item.styles[key], linkInImage);
                }
              } else {
                for (const [key, val] of attributes) {
                  if (key === "class") {
                    writer.removeClass(val, linkInImage);
                  } else {
                    writer.removeAttribute(key, linkInImage);
                  }
                }
                if (item.classes) {
                  writer.removeClass(item.classes, linkInImage);
                }
                for (const key in item.styles) {
                  writer.removeStyle(key, linkInImage);
                }
              }
            }
          });
        };
      }
    }
    const ATTRIBUTE_WHITESPACES = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g;
    const SAFE_URL_TEMPLATE = "^(?:(?:<protocols>):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))";
    const EMAIL_REG_EXP = /^[\S]+@((?![-_])(?:[-\w\u00a1-\uffff]{0,63}[^-_]\.))+(?:[a-z\u00a1-\uffff]{2,})$/i;
    const PROTOCOL_REG_EXP = /^((\w+:(\/{2,})?)|(\W))/i;
    const DEFAULT_LINK_PROTOCOLS = [
      "https?",
      "ftps?",
      "mailto"
    ];
    const LINK_KEYSTROKE = "Ctrl+K";
    function isLinkElement(node) {
      return node.is("attributeElement") && !!node.getCustomProperty("link");
    }
    function createLinkElement(href, { writer }) {
      const linkElement = writer.createAttributeElement("a", {
        href
      }, {
        priority: 5
      });
      writer.setCustomProperty("link", true, linkElement);
      return linkElement;
    }
    function ensureSafeUrl(url, allowedProtocols = DEFAULT_LINK_PROTOCOLS) {
      const urlString = String(url);
      const protocolsList = allowedProtocols.join("|");
      const customSafeRegex = new RegExp(`${SAFE_URL_TEMPLATE.replace("<protocols>", protocolsList)}`, "i");
      return isSafeUrl(urlString, customSafeRegex) ? urlString : "#";
    }
    function isSafeUrl(url, customRegexp) {
      const normalizedUrl = url.replace(ATTRIBUTE_WHITESPACES, "");
      return !!normalizedUrl.match(customRegexp);
    }
    function getLocalizedDecorators(t2, decorators) {
      const localizedDecoratorsLabels = {
        "Open in a new tab": t2("Open in a new tab"),
        "Downloadable": t2("Downloadable")
      };
      decorators.forEach((decorator) => {
        if ("label" in decorator && localizedDecoratorsLabels[decorator.label]) {
          decorator.label = localizedDecoratorsLabels[decorator.label];
        }
        return decorator;
      });
      return decorators;
    }
    function normalizeDecorators(decorators) {
      const retArray = [];
      if (decorators) {
        for (const [key, value] of Object.entries(decorators)) {
          const decorator = Object.assign({}, value, {
            id: `link${upperFirst(key)}`
          });
          retArray.push(decorator);
        }
      }
      return retArray;
    }
    function isLinkableElement(element, schema) {
      if (!element) {
        return false;
      }
      return schema.checkAttribute(element.name, "linkHref");
    }
    function isEmail(value) {
      return EMAIL_REG_EXP.test(value);
    }
    function addLinkProtocolIfApplicable(link2, defaultProtocol) {
      const protocol2 = isEmail(link2) ? "mailto:" : defaultProtocol;
      const isProtocolNeeded = !!protocol2 && !linkHasProtocol(link2);
      return link2 && isProtocolNeeded ? protocol2 + link2 : link2;
    }
    function linkHasProtocol(link2) {
      return PROTOCOL_REG_EXP.test(link2);
    }
    function openLink(link2) {
      window.open(link2, "_blank", "noopener");
    }
    class LinkCommand extends Command {
      constructor() {
        super(...arguments);
        /**
        * A collection of {@link module:link/utils/manualdecorator~ManualDecorator manual decorators}
        * corresponding to the {@link module:link/linkconfig~LinkConfig#decorators decorator configuration}.
        *
        * You can consider it a model with states of manual decorators added to the currently selected link.
        */
        __publicField(this, "manualDecorators", new Collection());
        /**
        * An instance of the helper that ties together all {@link module:link/linkconfig~LinkDecoratorAutomaticDefinition}
        * that are used by the {@glink features/link link} and the {@glink features/images/images-linking linking images} features.
        */
        __publicField(this, "automaticDecorators", new AutomaticDecorators());
      }
      /**
      * Synchronizes the state of {@link #manualDecorators} with the currently present elements in the model.
      */
      restoreManualDecoratorStates() {
        for (const manualDecorator of this.manualDecorators) {
          manualDecorator.value = this._getDecoratorStateFromModel(manualDecorator.id);
        }
      }
      /**
      * @inheritDoc
      */
      refresh() {
        const model = this.editor.model;
        const selection = model.document.selection;
        const selectedElement = selection.getSelectedElement() || first(selection.getSelectedBlocks());
        if (isLinkableElement(selectedElement, model.schema)) {
          this.value = selectedElement.getAttribute("linkHref");
          this.isEnabled = model.schema.checkAttribute(selectedElement, "linkHref");
        } else {
          this.value = selection.getAttribute("linkHref");
          this.isEnabled = model.schema.checkAttributeInSelection(selection, "linkHref");
        }
        for (const manualDecorator of this.manualDecorators) {
          manualDecorator.value = this._getDecoratorStateFromModel(manualDecorator.id);
        }
      }
      /**
      * Executes the command.
      *
      * When the selection is non-collapsed, the `linkHref` attribute will be applied to nodes inside the selection, but only to
      * those nodes where the `linkHref` attribute is allowed (disallowed nodes will be omitted).
      *
      * When the selection is collapsed and is not inside the text with the `linkHref` attribute, a
      * new {@link module:engine/model/text~Text text node} with the `linkHref` attribute will be inserted in place of the caret, but
      * only if such element is allowed in this place. The `_data` of the inserted text will equal the `href` parameter.
      * The selection will be updated to wrap the just inserted text node.
      *
      * When the selection is collapsed and inside the text with the `linkHref` attribute, the attribute value will be updated.
      *
      * # Decorators and model attribute management
      *
      * There is an optional argument to this command that applies or removes model
      * {@glink framework/architecture/editing-engine#text-attributes text attributes} brought by
      * {@link module:link/utils/manualdecorator~ManualDecorator manual link decorators}.
      *
      * Text attribute names in the model correspond to the entries in the {@link module:link/linkconfig~LinkConfig#decorators
      * configuration}.
      * For every decorator configured, a model text attribute exists with the "link" prefix. For example, a `'linkMyDecorator'` attribute
      * corresponds to `'myDecorator'` in the configuration.
      *
      * To learn more about link decorators, check out the {@link module:link/linkconfig~LinkConfig#decorators `config.link.decorators`}
      * documentation.
      *
      * Here is how to manage decorator attributes with the link command:
      *
      * ```ts
      * const linkCommand = editor.commands.get( 'link' );
      *
      * // Adding a new decorator attribute.
      * linkCommand.execute( 'http://example.com', {
      * 	linkIsExternal: true
      * } );
      *
      * // Removing a decorator attribute from the selection.
      * linkCommand.execute( 'http://example.com', {
      * 	linkIsExternal: false
      * } );
      *
      * // Adding multiple decorator attributes at the same time.
      * linkCommand.execute( 'http://example.com', {
      * 	linkIsExternal: true,
      * 	linkIsDownloadable: true,
      * } );
      *
      * // Removing and adding decorator attributes at the same time.
      * linkCommand.execute( 'http://example.com', {
      * 	linkIsExternal: false,
      * 	linkFoo: true,
      * 	linkIsDownloadable: false,
      * } );
      * ```
      *
      * **Note**: If the decorator attribute name is not specified, its state remains untouched.
      *
      * **Note**: {@link module:link/unlinkcommand~UnlinkCommand#execute `UnlinkCommand#execute()`} removes all
      * decorator attributes.
      *
      * @fires execute
      * @param href Link destination.
      * @param manualDecoratorIds The information about manual decorator attributes to be applied or removed upon execution.
      */
      execute(href, manualDecoratorIds = {}) {
        const model = this.editor.model;
        const selection = model.document.selection;
        const truthyManualDecorators = [];
        const falsyManualDecorators = [];
        for (const name in manualDecoratorIds) {
          if (manualDecoratorIds[name]) {
            truthyManualDecorators.push(name);
          } else {
            falsyManualDecorators.push(name);
          }
        }
        model.change((writer) => {
          if (selection.isCollapsed) {
            const position = selection.getFirstPosition();
            if (selection.hasAttribute("linkHref")) {
              const linkText = extractTextFromSelection(selection);
              let linkRange = findAttributeRange(position, "linkHref", selection.getAttribute("linkHref"), model);
              if (selection.getAttribute("linkHref") === linkText) {
                linkRange = this._updateLinkContent(model, writer, linkRange, href);
              }
              writer.setAttribute("linkHref", href, linkRange);
              truthyManualDecorators.forEach((item) => {
                writer.setAttribute(item, true, linkRange);
              });
              falsyManualDecorators.forEach((item) => {
                writer.removeAttribute(item, linkRange);
              });
              writer.setSelection(writer.createPositionAfter(linkRange.end.nodeBefore));
            } else if (href !== "") {
              const attributes = toMap(selection.getAttributes());
              attributes.set("linkHref", href);
              truthyManualDecorators.forEach((item) => {
                attributes.set(item, true);
              });
              const { end: positionAfter } = model.insertContent(writer.createText(href, attributes), position);
              writer.setSelection(positionAfter);
            }
            [
              "linkHref",
              ...truthyManualDecorators,
              ...falsyManualDecorators
            ].forEach((item) => {
              writer.removeSelectionAttribute(item);
            });
          } else {
            const ranges = model.schema.getValidRanges(selection.getRanges(), "linkHref");
            const allowedRanges = [];
            for (const element of selection.getSelectedBlocks()) {
              if (model.schema.checkAttribute(element, "linkHref")) {
                allowedRanges.push(writer.createRangeOn(element));
              }
            }
            const rangesToUpdate = allowedRanges.slice();
            for (const range2 of ranges) {
              if (this._isRangeToUpdate(range2, allowedRanges)) {
                rangesToUpdate.push(range2);
              }
            }
            for (const range2 of rangesToUpdate) {
              let linkRange = range2;
              if (rangesToUpdate.length === 1) {
                const linkText = extractTextFromSelection(selection);
                if (selection.getAttribute("linkHref") === linkText) {
                  linkRange = this._updateLinkContent(model, writer, range2, href);
                  writer.setSelection(writer.createSelection(linkRange));
                }
              }
              writer.setAttribute("linkHref", href, linkRange);
              truthyManualDecorators.forEach((item) => {
                writer.setAttribute(item, true, linkRange);
              });
              falsyManualDecorators.forEach((item) => {
                writer.removeAttribute(item, linkRange);
              });
            }
          }
        });
      }
      /**
      * Provides information whether a decorator with a given name is present in the currently processed selection.
      *
      * @param decoratorName The name of the manual decorator used in the model
      * @returns The information whether a given decorator is currently present in the selection.
      */
      _getDecoratorStateFromModel(decoratorName) {
        const model = this.editor.model;
        const selection = model.document.selection;
        const selectedElement = selection.getSelectedElement();
        if (isLinkableElement(selectedElement, model.schema)) {
          return selectedElement.getAttribute(decoratorName);
        }
        return selection.getAttribute(decoratorName);
      }
      /**
      * Checks whether specified `range` is inside an element that accepts the `linkHref` attribute.
      *
      * @param range A range to check.
      * @param allowedRanges An array of ranges created on elements where the attribute is accepted.
      */
      _isRangeToUpdate(range2, allowedRanges) {
        for (const allowedRange of allowedRanges) {
          if (allowedRange.containsRange(range2)) {
            return false;
          }
        }
        return true;
      }
      /**
      * Updates selected link with a new value as its content and as its href attribute.
      *
      * @param model Model is need to insert content.
      * @param writer Writer is need to create text element in model.
      * @param range A range where should be inserted content.
      * @param href A link value which should be in the href attribute and in the content.
      */
      _updateLinkContent(model, writer, range2, href) {
        const text2 = writer.createText(href, {
          linkHref: href
        });
        return model.insertContent(text2, range2);
      }
    }
    function extractTextFromSelection(selection) {
      if (selection.isCollapsed) {
        const firstPosition = selection.getFirstPosition();
        return firstPosition.textNode && firstPosition.textNode.data;
      } else {
        const rangeItems = Array.from(selection.getFirstRange().getItems());
        if (rangeItems.length > 1) {
          return null;
        }
        const firstNode = rangeItems[0];
        if (firstNode.is("$text") || firstNode.is("$textProxy")) {
          return firstNode.data;
        }
        return null;
      }
    }
    class UnlinkCommand extends Command {
      /**
      * @inheritDoc
      */
      refresh() {
        const model = this.editor.model;
        const selection = model.document.selection;
        const selectedElement = selection.getSelectedElement();
        if (isLinkableElement(selectedElement, model.schema)) {
          this.isEnabled = model.schema.checkAttribute(selectedElement, "linkHref");
        } else {
          this.isEnabled = model.schema.checkAttributeInSelection(selection, "linkHref");
        }
      }
      /**
      * Executes the command.
      *
      * When the selection is collapsed, it removes the `linkHref` attribute from each node with the same `linkHref` attribute value.
      * When the selection is non-collapsed, it removes the `linkHref` attribute from each node in selected ranges.
      *
      * # Decorators
      *
      * If {@link module:link/linkconfig~LinkConfig#decorators `config.link.decorators`} is specified,
      * all configured decorators are removed together with the `linkHref` attribute.
      *
      * @fires execute
      */
      execute() {
        const editor2 = this.editor;
        const model = this.editor.model;
        const selection = model.document.selection;
        const linkCommand = editor2.commands.get("link");
        model.change((writer) => {
          const rangesToUnlink = selection.isCollapsed ? [
            findAttributeRange(selection.getFirstPosition(), "linkHref", selection.getAttribute("linkHref"), model)
          ] : model.schema.getValidRanges(selection.getRanges(), "linkHref");
          for (const range2 of rangesToUnlink) {
            writer.removeAttribute("linkHref", range2);
            if (linkCommand) {
              for (const manualDecorator of linkCommand.manualDecorators) {
                writer.removeAttribute(manualDecorator.id, range2);
              }
            }
          }
        });
      }
    }
    class ManualDecorator extends (/* @__PURE__ */ ObservableMixin()) {
      /**
      * Creates a new instance of {@link module:link/utils/manualdecorator~ManualDecorator}.
      *
      * @param config.id The name of the attribute used in the model that represents a given manual decorator.
      * For example: `'linkIsExternal'`.
      * @param config.label The label used in the user interface to toggle the manual decorator.
      * @param config.attributes A set of attributes added to output data when the decorator is active for a specific link.
      * Attributes should keep the format of attributes defined in {@link module:engine/view/elementdefinition~ElementDefinition}.
      * @param [config.defaultValue] Controls whether the decorator is "on" by default.
      */
      constructor({ id, label, attributes, classes, styles, defaultValue }) {
        super();
        /**
        * An ID of a manual decorator which is the name of the attribute in the model, for example: 'linkManualDecorator0'.
        */
        __publicField(this, "id");
        /**
        * The default value of manual decorator.
        */
        __publicField(this, "defaultValue");
        /**
        * The label used in the user interface to toggle the manual decorator.
        */
        __publicField(this, "label");
        /**
        * A set of attributes added to downcasted data when the decorator is activated for a specific link.
        * Attributes should be added in a form of attributes defined in {@link module:engine/view/elementdefinition~ElementDefinition}.
        */
        __publicField(this, "attributes");
        /**
        * A set of classes added to downcasted data when the decorator is activated for a specific link.
        * Classes should be added in a form of classes defined in {@link module:engine/view/elementdefinition~ElementDefinition}.
        */
        __publicField(this, "classes");
        /**
        * A set of styles added to downcasted data when the decorator is activated for a specific link.
        * Styles should be added in a form of styles defined in {@link module:engine/view/elementdefinition~ElementDefinition}.
        */
        __publicField(this, "styles");
        this.id = id;
        this.set("value", void 0);
        this.defaultValue = defaultValue;
        this.label = label;
        this.attributes = attributes;
        this.classes = classes;
        this.styles = styles;
      }
      /**
      * Returns {@link module:engine/view/matcher~MatcherPattern} with decorator attributes.
      *
      * @internal
      */
      _createPattern() {
        return {
          attributes: this.attributes,
          classes: this.classes,
          styles: this.styles
        };
      }
    }
    const HIGHLIGHT_CLASS = "ck-link_selected";
    const DECORATOR_AUTOMATIC = "automatic";
    const DECORATOR_MANUAL = "manual";
    const EXTERNAL_LINKS_REGEXP = /^(https?:)?\/\//;
    class LinkEditing extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "LinkEditing";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          TwoStepCaretMovement,
          Input,
          ClipboardPipeline
        ];
      }
      /**
      * @inheritDoc
      */
      constructor(editor2) {
        super(editor2);
        editor2.config.define("link", {
          allowCreatingEmptyLinks: false,
          addTargetToExternalLinks: false
        });
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor2 = this.editor;
        const allowedProtocols = this.editor.config.get("link.allowedProtocols");
        editor2.model.schema.extend("$text", {
          allowAttributes: "linkHref"
        });
        editor2.conversion.for("dataDowncast").attributeToElement({
          model: "linkHref",
          view: createLinkElement
        });
        editor2.conversion.for("editingDowncast").attributeToElement({
          model: "linkHref",
          view: (href, conversionApi) => {
            return createLinkElement(ensureSafeUrl(href, allowedProtocols), conversionApi);
          }
        });
        editor2.conversion.for("upcast").elementToAttribute({
          view: {
            name: "a",
            attributes: {
              href: true
            }
          },
          model: {
            key: "linkHref",
            value: (viewElement) => viewElement.getAttribute("href")
          }
        });
        editor2.commands.add("link", new LinkCommand(editor2));
        editor2.commands.add("unlink", new UnlinkCommand(editor2));
        const linkDecorators = getLocalizedDecorators(editor2.t, normalizeDecorators(editor2.config.get("link.decorators")));
        this._enableAutomaticDecorators(linkDecorators.filter((item) => item.mode === DECORATOR_AUTOMATIC));
        this._enableManualDecorators(linkDecorators.filter((item) => item.mode === DECORATOR_MANUAL));
        const twoStepCaretMovementPlugin = editor2.plugins.get(TwoStepCaretMovement);
        twoStepCaretMovementPlugin.registerAttribute("linkHref");
        inlineHighlight(editor2, "linkHref", "a", HIGHLIGHT_CLASS);
        this._enableLinkOpen();
        this._enableSelectionAttributesFixer();
        this._enableClipboardIntegration();
      }
      /**
      * Processes an array of configured {@link module:link/linkconfig~LinkDecoratorAutomaticDefinition automatic decorators}
      * and registers a {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher downcast dispatcher}
      * for each one of them. Downcast dispatchers are obtained using the
      * {@link module:link/utils/automaticdecorators~AutomaticDecorators#getDispatcher} method.
      *
      * **Note**: This method also activates the automatic external link decorator if enabled with
      * {@link module:link/linkconfig~LinkConfig#addTargetToExternalLinks `config.link.addTargetToExternalLinks`}.
      */
      _enableAutomaticDecorators(automaticDecoratorDefinitions) {
        const editor2 = this.editor;
        const command = editor2.commands.get("link");
        const automaticDecorators = command.automaticDecorators;
        if (editor2.config.get("link.addTargetToExternalLinks")) {
          automaticDecorators.add({
            id: "linkIsExternal",
            mode: DECORATOR_AUTOMATIC,
            callback: (url) => !!url && EXTERNAL_LINKS_REGEXP.test(url),
            attributes: {
              target: "_blank",
              rel: "noopener noreferrer"
            }
          });
        }
        automaticDecorators.add(automaticDecoratorDefinitions);
        if (automaticDecorators.length) {
          editor2.conversion.for("downcast").add(automaticDecorators.getDispatcher());
        }
      }
      /**
      * Processes an array of configured {@link module:link/linkconfig~LinkDecoratorManualDefinition manual decorators},
      * transforms them into {@link module:link/utils/manualdecorator~ManualDecorator} instances and stores them in the
      * {@link module:link/linkcommand~LinkCommand#manualDecorators} collection (a model for manual decorators state).
      *
      * Also registers an {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToElement attribute-to-element}
      * converter for each manual decorator and extends the {@link module:engine/model/schema~Schema model's schema}
      * with adequate model attributes.
      */
      _enableManualDecorators(manualDecoratorDefinitions) {
        if (!manualDecoratorDefinitions.length) {
          return;
        }
        const editor2 = this.editor;
        const command = editor2.commands.get("link");
        const manualDecorators = command.manualDecorators;
        manualDecoratorDefinitions.forEach((decoratorDefinition) => {
          editor2.model.schema.extend("$text", {
            allowAttributes: decoratorDefinition.id
          });
          const decorator = new ManualDecorator(decoratorDefinition);
          manualDecorators.add(decorator);
          editor2.conversion.for("downcast").attributeToElement({
            model: decorator.id,
            view: (manualDecoratorValue, { writer, schema }, { item }) => {
              if (!(item.is("selection") || schema.isInline(item))) {
                return;
              }
              if (manualDecoratorValue) {
                const element = writer.createAttributeElement("a", decorator.attributes, {
                  priority: 5
                });
                if (decorator.classes) {
                  writer.addClass(decorator.classes, element);
                }
                for (const key in decorator.styles) {
                  writer.setStyle(key, decorator.styles[key], element);
                }
                writer.setCustomProperty("link", true, element);
                return element;
              }
            }
          });
          editor2.conversion.for("upcast").elementToAttribute({
            view: {
              name: "a",
              ...decorator._createPattern()
            },
            model: {
              key: decorator.id
            }
          });
        });
      }
      /**
      * Attaches handlers for {@link module:engine/view/document~Document#event:enter} and
      * {@link module:engine/view/document~Document#event:click} to enable link following.
      */
      _enableLinkOpen() {
        const editor2 = this.editor;
        const view = editor2.editing.view;
        const viewDocument = view.document;
        this.listenTo(viewDocument, "click", (evt, data) => {
          const shouldOpen = env.isMac ? data.domEvent.metaKey : data.domEvent.ctrlKey;
          if (!shouldOpen) {
            return;
          }
          let clickedElement = data.domTarget;
          if (clickedElement.tagName.toLowerCase() != "a") {
            clickedElement = clickedElement.closest("a");
          }
          if (!clickedElement) {
            return;
          }
          const url = clickedElement.getAttribute("href");
          if (!url) {
            return;
          }
          evt.stop();
          data.preventDefault();
          openLink(url);
        }, {
          context: "$capture"
        });
        this.listenTo(viewDocument, "keydown", (evt, data) => {
          const linkCommand = editor2.commands.get("link");
          const url = linkCommand.value;
          const shouldOpen = !!url && data.keyCode === keyCodes.enter && data.altKey;
          if (!shouldOpen) {
            return;
          }
          evt.stop();
          openLink(url);
        });
      }
      /**
      * Watches the DocumentSelection attribute changes and removes link decorator attributes when the linkHref attribute is removed.
      *
      * This is to ensure that there is no left-over link decorator attributes on the document selection that is no longer in a link.
      */
      _enableSelectionAttributesFixer() {
        const editor2 = this.editor;
        const model = editor2.model;
        const selection = model.document.selection;
        this.listenTo(selection, "change:attribute", (evt, { attributeKeys }) => {
          if (!attributeKeys.includes("linkHref") || selection.hasAttribute("linkHref")) {
            return;
          }
          model.change((writer) => {
            removeLinkAttributesFromSelection(writer, getLinkAttributesAllowedOnText(model.schema));
          });
        });
      }
      /**
      * Enables URL fixing on pasting.
      */
      _enableClipboardIntegration() {
        const editor2 = this.editor;
        const model = editor2.model;
        const defaultProtocol = this.editor.config.get("link.defaultProtocol");
        if (!defaultProtocol) {
          return;
        }
        this.listenTo(editor2.plugins.get("ClipboardPipeline"), "contentInsertion", (evt, data) => {
          model.change((writer) => {
            const range2 = writer.createRangeIn(data.content);
            for (const item of range2.getItems()) {
              if (item.hasAttribute("linkHref")) {
                const newLink = addLinkProtocolIfApplicable(item.getAttribute("linkHref"), defaultProtocol);
                writer.setAttribute("linkHref", newLink, item);
              }
            }
          });
        });
      }
    }
    function removeLinkAttributesFromSelection(writer, linkAttributes) {
      writer.removeSelectionAttribute("linkHref");
      for (const attribute of linkAttributes) {
        writer.removeSelectionAttribute(attribute);
      }
    }
    function getLinkAttributesAllowedOnText(schema) {
      const textAttributes = schema.getDefinition("$text").allowAttributes;
      return textAttributes.filter((attribute) => attribute.startsWith("link"));
    }
    class LinkFormView extends View {
      /**
      * Creates an instance of the {@link module:link/ui/linkformview~LinkFormView} class.
      *
      * Also see {@link #render}.
      *
      * @param locale The localization services instance.
      * @param linkCommand Reference to {@link module:link/linkcommand~LinkCommand}.
      * @param validators  Form validators used by {@link #isValid}.
      */
      constructor(locale, linkCommand, validators) {
        super(locale);
        /**
        * Tracks information about DOM focus in the form.
        */
        __publicField(this, "focusTracker", new FocusTracker());
        /**
        * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
        */
        __publicField(this, "keystrokes", new KeystrokeHandler());
        /**
        * The URL input view.
        */
        __publicField(this, "urlInputView");
        /**
        * The Save button view.
        */
        __publicField(this, "saveButtonView");
        /**
        * The Cancel button view.
        */
        __publicField(this, "cancelButtonView");
        /**
        * A collection of {@link module:ui/button/switchbuttonview~SwitchButtonView},
        * which corresponds to {@link module:link/linkcommand~LinkCommand#manualDecorators manual decorators}
        * configured in the editor.
        */
        __publicField(this, "_manualDecoratorSwitches");
        /**
        * A collection of child views in the form.
        */
        __publicField(this, "children");
        /**
        * An array of form validators used by {@link #isValid}.
        */
        __publicField(this, "_validators");
        /**
        * A collection of views that can be focused in the form.
        */
        __publicField(this, "_focusables", new ViewCollection());
        /**
        * Helps cycling over {@link #_focusables} in the form.
        */
        __publicField(this, "_focusCycler");
        const t2 = locale.t;
        this._validators = validators;
        this.urlInputView = this._createUrlInput();
        this.saveButtonView = this._createButton(t2("Save"), icons.check, "ck-button-save");
        this.saveButtonView.type = "submit";
        this.cancelButtonView = this._createButton(t2("Cancel"), icons.cancel, "ck-button-cancel", "cancel");
        this._manualDecoratorSwitches = this._createManualDecoratorSwitches(linkCommand);
        this.children = this._createFormChildren(linkCommand.manualDecorators);
        this._focusCycler = new FocusCycler({
          focusables: this._focusables,
          focusTracker: this.focusTracker,
          keystrokeHandler: this.keystrokes,
          actions: {
            // Navigate form fields backwards using the Shift + Tab keystroke.
            focusPrevious: "shift + tab",
            // Navigate form fields forwards using the Tab key.
            focusNext: "tab"
          }
        });
        const classList = [
          "ck",
          "ck-link-form",
          "ck-responsive-form"
        ];
        if (linkCommand.manualDecorators.length) {
          classList.push("ck-link-form_layout-vertical", "ck-vertical-form");
        }
        this.setTemplate({
          tag: "form",
          attributes: {
            class: classList,
            // https://github.com/ckeditor/ckeditor5-link/issues/90
            tabindex: "-1"
          },
          children: this.children
        });
      }
      /**
      * Obtains the state of the {@link module:ui/button/switchbuttonview~SwitchButtonView switch buttons} representing
      * {@link module:link/linkcommand~LinkCommand#manualDecorators manual link decorators}
      * in the {@link module:link/ui/linkformview~LinkFormView}.
      *
      * @returns Key-value pairs, where the key is the name of the decorator and the value is its state.
      */
      getDecoratorSwitchesState() {
        return Array.from(this._manualDecoratorSwitches).reduce((accumulator, switchButton) => {
          accumulator[switchButton.name] = switchButton.isOn;
          return accumulator;
        }, {});
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        submitHandler({
          view: this
        });
        const childViews = [
          this.urlInputView,
          ...this._manualDecoratorSwitches,
          this.saveButtonView,
          this.cancelButtonView
        ];
        childViews.forEach((v2) => {
          this._focusables.add(v2);
          this.focusTracker.add(v2.element);
        });
        this.keystrokes.listenTo(this.element);
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        this.focusTracker.destroy();
        this.keystrokes.destroy();
      }
      /**
      * Focuses the fist {@link #_focusables} in the form.
      */
      focus() {
        this._focusCycler.focusFirst();
      }
      /**
      * Validates the form and returns `false` when some fields are invalid.
      */
      isValid() {
        this.resetFormStatus();
        for (const validator of this._validators) {
          const errorText = validator(this);
          if (errorText) {
            this.urlInputView.errorText = errorText;
            return false;
          }
        }
        return true;
      }
      /**
      * Cleans up the supplementary error and information text of the {@link #urlInputView}
      * bringing them back to the state when the form has been displayed for the first time.
      *
      * See {@link #isValid}.
      */
      resetFormStatus() {
        this.urlInputView.errorText = null;
      }
      /**
      * Creates a labeled input view.
      *
      * @returns Labeled field view instance.
      */
      _createUrlInput() {
        const t2 = this.locale.t;
        const labeledInput = new LabeledFieldView(this.locale, createLabeledInputText);
        labeledInput.fieldView.inputMode = "url";
        labeledInput.label = t2("Link URL");
        return labeledInput;
      }
      /**
      * Creates a button view.
      *
      * @param label The button label.
      * @param icon The button icon.
      * @param className The additional button CSS class name.
      * @param eventName An event name that the `ButtonView#execute` event will be delegated to.
      * @returns The button view instance.
      */
      _createButton(label, icon, className, eventName) {
        const button = new ButtonView(this.locale);
        button.set({
          label,
          icon,
          tooltip: true
        });
        button.extendTemplate({
          attributes: {
            class: className
          }
        });
        if (eventName) {
          button.delegate("execute").to(this, eventName);
        }
        return button;
      }
      /**
      * Populates {@link module:ui/viewcollection~ViewCollection} of {@link module:ui/button/switchbuttonview~SwitchButtonView}
      * made based on {@link module:link/linkcommand~LinkCommand#manualDecorators}.
      *
      * @param linkCommand A reference to the link command.
      * @returns ViewCollection of switch buttons.
      */
      _createManualDecoratorSwitches(linkCommand) {
        const switches = this.createCollection();
        for (const manualDecorator of linkCommand.manualDecorators) {
          const switchButton = new SwitchButtonView(this.locale);
          switchButton.set({
            name: manualDecorator.id,
            label: manualDecorator.label,
            withText: true
          });
          switchButton.bind("isOn").toMany([
            manualDecorator,
            linkCommand
          ], "value", (decoratorValue, commandValue) => {
            return commandValue === void 0 && decoratorValue === void 0 ? !!manualDecorator.defaultValue : !!decoratorValue;
          });
          switchButton.on("execute", () => {
            manualDecorator.set("value", !switchButton.isOn);
          });
          switches.add(switchButton);
        }
        return switches;
      }
      /**
      * Populates the {@link #children} collection of the form.
      *
      * If {@link module:link/linkcommand~LinkCommand#manualDecorators manual decorators} are configured in the editor, it creates an
      * additional `View` wrapping all {@link #_manualDecoratorSwitches} switch buttons corresponding
      * to these decorators.
      *
      * @param manualDecorators A reference to
      * the collection of manual decorators stored in the link command.
      * @returns The children of link form view.
      */
      _createFormChildren(manualDecorators) {
        const children = this.createCollection();
        children.add(this.urlInputView);
        if (manualDecorators.length) {
          const additionalButtonsView = new View();
          additionalButtonsView.setTemplate({
            tag: "ul",
            children: this._manualDecoratorSwitches.map((switchButton) => ({
              tag: "li",
              children: [
                switchButton
              ],
              attributes: {
                class: [
                  "ck",
                  "ck-list__item"
                ]
              }
            })),
            attributes: {
              class: [
                "ck",
                "ck-reset",
                "ck-list"
              ]
            }
          });
          children.add(additionalButtonsView);
        }
        children.add(this.saveButtonView);
        children.add(this.cancelButtonView);
        return children;
      }
      /**
      * The native DOM `value` of the {@link #urlInputView} element.
      *
      * **Note**: Do not confuse it with the {@link module:ui/inputtext/inputtextview~InputTextView#value}
      * which works one way only and may not represent the actual state of the component in the DOM.
      */
      get url() {
        const { element } = this.urlInputView.fieldView;
        if (!element) {
          return null;
        }
        return element.value.trim();
      }
    }
    var unlinkIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184zm4.919 10.562-1.414 1.414a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.061-1.06l1.414 1.414 1.414-1.415a.75.75 0 0 1 1.061 1.061l-1.414 1.414 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414z"/></svg>';
    class LinkActionsView extends View {
      /**
      * @inheritDoc
      */
      constructor(locale, linkConfig = {}) {
        super(locale);
        /**
        * Tracks information about DOM focus in the actions.
        */
        __publicField(this, "focusTracker", new FocusTracker());
        /**
        * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
        */
        __publicField(this, "keystrokes", new KeystrokeHandler());
        /**
        * The href preview view.
        */
        __publicField(this, "previewButtonView");
        /**
        * The unlink button view.
        */
        __publicField(this, "unlinkButtonView");
        /**
        * The edit link button view.
        */
        __publicField(this, "editButtonView");
        /**
        * A collection of views that can be focused in the view.
        */
        __publicField(this, "_focusables", new ViewCollection());
        /**
        * Helps cycling over {@link #_focusables} in the view.
        */
        __publicField(this, "_focusCycler");
        __publicField(this, "_linkConfig");
        const t2 = locale.t;
        this.previewButtonView = this._createPreviewButton();
        this.unlinkButtonView = this._createButton(t2("Unlink"), unlinkIcon, "unlink");
        this.editButtonView = this._createButton(t2("Edit link"), icons.pencil, "edit");
        this.set("href", void 0);
        this._linkConfig = linkConfig;
        this._focusCycler = new FocusCycler({
          focusables: this._focusables,
          focusTracker: this.focusTracker,
          keystrokeHandler: this.keystrokes,
          actions: {
            // Navigate fields backwards using the Shift + Tab keystroke.
            focusPrevious: "shift + tab",
            // Navigate fields forwards using the Tab key.
            focusNext: "tab"
          }
        });
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-link-actions",
              "ck-responsive-form"
            ],
            // https://github.com/ckeditor/ckeditor5-link/issues/90
            tabindex: "-1"
          },
          children: [
            this.previewButtonView,
            this.editButtonView,
            this.unlinkButtonView
          ]
        });
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        const childViews = [
          this.previewButtonView,
          this.editButtonView,
          this.unlinkButtonView
        ];
        childViews.forEach((v2) => {
          this._focusables.add(v2);
          this.focusTracker.add(v2.element);
        });
        this.keystrokes.listenTo(this.element);
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        this.focusTracker.destroy();
        this.keystrokes.destroy();
      }
      /**
      * Focuses the fist {@link #_focusables} in the actions.
      */
      focus() {
        this._focusCycler.focusFirst();
      }
      /**
      * Creates a button view.
      *
      * @param label The button label.
      * @param icon The button icon.
      * @param eventName An event name that the `ButtonView#execute` event will be delegated to.
      * @returns The button view instance.
      */
      _createButton(label, icon, eventName) {
        const button = new ButtonView(this.locale);
        button.set({
          label,
          icon,
          tooltip: true
        });
        button.delegate("execute").to(this, eventName);
        return button;
      }
      /**
      * Creates a link href preview button.
      *
      * @returns The button view instance.
      */
      _createPreviewButton() {
        const button = new ButtonView(this.locale);
        const bind2 = this.bindTemplate;
        const t2 = this.t;
        button.set({
          withText: true,
          tooltip: t2("Open link in new tab")
        });
        button.extendTemplate({
          attributes: {
            class: [
              "ck",
              "ck-link-actions__preview"
            ],
            href: bind2.to("href", (href) => href && ensureSafeUrl(href, this._linkConfig.allowedProtocols)),
            target: "_blank",
            rel: "noopener noreferrer"
          }
        });
        button.bind("label").to(this, "href", (href) => {
          return href || t2("This link has no URL");
        });
        button.bind("isEnabled").to(this, "href", (href) => !!href);
        button.template.tag = "a";
        button.template.eventListeners = {};
        return button;
      }
    }
    var linkIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z"/></svg>';
    const VISUAL_SELECTION_MARKER_NAME = "link-ui";
    class LinkUI extends Plugin {
      constructor() {
        super(...arguments);
        /**
        * The actions view displayed inside of the balloon.
        */
        __publicField(this, "actionsView", null);
        /**
        * The form view displayed inside the balloon.
        */
        __publicField(this, "formView", null);
        /**
        * The contextual balloon plugin instance.
        */
        __publicField(this, "_balloon");
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          ContextualBalloon
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "LinkUI";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor2 = this.editor;
        const t2 = this.editor.t;
        editor2.editing.view.addObserver(ClickObserver);
        this._balloon = editor2.plugins.get(ContextualBalloon);
        this._createToolbarLinkButton();
        this._enableBalloonActivators();
        editor2.conversion.for("editingDowncast").markerToHighlight({
          model: VISUAL_SELECTION_MARKER_NAME,
          view: {
            classes: [
              "ck-fake-link-selection"
            ]
          }
        });
        editor2.conversion.for("editingDowncast").markerToElement({
          model: VISUAL_SELECTION_MARKER_NAME,
          view: (data, { writer }) => {
            if (!data.markerRange.isCollapsed) {
              return null;
            }
            const markerElement = writer.createUIElement("span");
            writer.addClass([
              "ck-fake-link-selection",
              "ck-fake-link-selection_collapsed"
            ], markerElement);
            return markerElement;
          }
        });
        editor2.accessibility.addKeystrokeInfos({
          keystrokes: [
            {
              label: t2("Create link"),
              keystroke: LINK_KEYSTROKE
            },
            {
              label: t2("Move out of a link"),
              keystroke: [
                [
                  "arrowleft",
                  "arrowleft"
                ],
                [
                  "arrowright",
                  "arrowright"
                ]
              ]
            }
          ]
        });
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        if (this.formView) {
          this.formView.destroy();
        }
        if (this.actionsView) {
          this.actionsView.destroy();
        }
      }
      /**
      * Creates views.
      */
      _createViews() {
        this.actionsView = this._createActionsView();
        this.formView = this._createFormView();
        this._enableUserBalloonInteractions();
      }
      /**
      * Creates the {@link module:link/ui/linkactionsview~LinkActionsView} instance.
      */
      _createActionsView() {
        const editor2 = this.editor;
        const actionsView = new LinkActionsView(editor2.locale, editor2.config.get("link"));
        const linkCommand = editor2.commands.get("link");
        const unlinkCommand = editor2.commands.get("unlink");
        actionsView.bind("href").to(linkCommand, "value");
        actionsView.editButtonView.bind("isEnabled").to(linkCommand);
        actionsView.unlinkButtonView.bind("isEnabled").to(unlinkCommand);
        this.listenTo(actionsView, "edit", () => {
          this._addFormView();
        });
        this.listenTo(actionsView, "unlink", () => {
          editor2.execute("unlink");
          this._hideUI();
        });
        actionsView.keystrokes.set("Esc", (data, cancel2) => {
          this._hideUI();
          cancel2();
        });
        actionsView.keystrokes.set(LINK_KEYSTROKE, (data, cancel2) => {
          this._addFormView();
          cancel2();
        });
        return actionsView;
      }
      /**
      * Creates the {@link module:link/ui/linkformview~LinkFormView} instance.
      */
      _createFormView() {
        const editor2 = this.editor;
        const linkCommand = editor2.commands.get("link");
        const defaultProtocol = editor2.config.get("link.defaultProtocol");
        const formView = new (CssTransitionDisablerMixin(LinkFormView))(editor2.locale, linkCommand, getFormValidators(editor2));
        formView.urlInputView.fieldView.bind("value").to(linkCommand, "value");
        formView.urlInputView.bind("isEnabled").to(linkCommand, "isEnabled");
        formView.saveButtonView.bind("isEnabled").to(linkCommand, "isEnabled");
        this.listenTo(formView, "submit", () => {
          if (formView.isValid()) {
            const { value } = formView.urlInputView.fieldView.element;
            const parsedUrl = addLinkProtocolIfApplicable(value, defaultProtocol);
            editor2.execute("link", parsedUrl, formView.getDecoratorSwitchesState());
            this._closeFormView();
          }
        });
        this.listenTo(formView.urlInputView, "change:errorText", () => {
          editor2.ui.update();
        });
        this.listenTo(formView, "cancel", () => {
          this._closeFormView();
        });
        formView.keystrokes.set("Esc", (data, cancel2) => {
          this._closeFormView();
          cancel2();
        });
        return formView;
      }
      /**
      * Creates a toolbar Link button. Clicking this button will show
      * a {@link #_balloon} attached to the selection.
      */
      _createToolbarLinkButton() {
        const editor2 = this.editor;
        editor2.ui.componentFactory.add("link", () => {
          const button = this._createButton(ButtonView);
          button.set({
            tooltip: true
          });
          return button;
        });
        editor2.ui.componentFactory.add("menuBar:link", () => {
          const button = this._createButton(MenuBarMenuListItemButtonView);
          button.set({
            role: "menuitemcheckbox"
          });
          return button;
        });
      }
      /**
      * Creates a button for link command to use either in toolbar or in menu bar.
      */
      _createButton(ButtonClass) {
        const editor2 = this.editor;
        const locale = editor2.locale;
        const command = editor2.commands.get("link");
        const view = new ButtonClass(editor2.locale);
        const t2 = locale.t;
        view.set({
          label: t2("Link"),
          icon: linkIcon,
          keystroke: LINK_KEYSTROKE,
          isToggleable: true
        });
        view.bind("isEnabled").to(command, "isEnabled");
        view.bind("isOn").to(command, "value", (value) => !!value);
        this.listenTo(view, "execute", () => this._showUI(true));
        return view;
      }
      /**
      * Attaches actions that control whether the balloon panel containing the
      * {@link #formView} should be displayed.
      */
      _enableBalloonActivators() {
        const editor2 = this.editor;
        const viewDocument = editor2.editing.view.document;
        this.listenTo(viewDocument, "click", () => {
          const parentLink = this._getSelectedLinkElement();
          if (parentLink) {
            this._showUI();
          }
        });
        editor2.keystrokes.set(LINK_KEYSTROKE, (keyEvtData, cancel2) => {
          cancel2();
          if (editor2.commands.get("link").isEnabled) {
            this._showUI(true);
          }
        });
      }
      /**
      * Attaches actions that control whether the balloon panel containing the
      * {@link #formView} is visible or not.
      */
      _enableUserBalloonInteractions() {
        this.editor.keystrokes.set("Tab", (data, cancel2) => {
          if (this._areActionsVisible && !this.actionsView.focusTracker.isFocused) {
            this.actionsView.focus();
            cancel2();
          }
        }, {
          // Use the high priority because the link UI navigation is more important
          // than other feature's actions, e.g. list indentation.
          // https://github.com/ckeditor/ckeditor5-link/issues/146
          priority: "high"
        });
        this.editor.keystrokes.set("Esc", (data, cancel2) => {
          if (this._isUIVisible) {
            this._hideUI();
            cancel2();
          }
        });
        clickOutsideHandler({
          emitter: this.formView,
          activator: () => this._isUIInPanel,
          contextElements: () => [
            this._balloon.view.element
          ],
          callback: () => this._hideUI()
        });
      }
      /**
      * Adds the {@link #actionsView} to the {@link #_balloon}.
      *
      * @internal
      */
      _addActionsView() {
        if (!this.actionsView) {
          this._createViews();
        }
        if (this._areActionsInPanel) {
          return;
        }
        this._balloon.add({
          view: this.actionsView,
          position: this._getBalloonPositionData()
        });
      }
      /**
      * Adds the {@link #formView} to the {@link #_balloon}.
      */
      _addFormView() {
        if (!this.formView) {
          this._createViews();
        }
        if (this._isFormInPanel) {
          return;
        }
        const editor2 = this.editor;
        const linkCommand = editor2.commands.get("link");
        this.formView.disableCssTransitions();
        this.formView.resetFormStatus();
        this._balloon.add({
          view: this.formView,
          position: this._getBalloonPositionData()
        });
        this.formView.urlInputView.fieldView.value = linkCommand.value || "";
        if (this._balloon.visibleView === this.formView) {
          this.formView.urlInputView.fieldView.select();
        }
        this.formView.enableCssTransitions();
      }
      /**
      * Closes the form view. Decides whether the balloon should be hidden completely or if the action view should be shown. This is
      * decided upon the link command value (which has a value if the document selection is in the link).
      *
      * Additionally, if any {@link module:link/linkconfig~LinkConfig#decorators} are defined in the editor configuration, the state of
      * switch buttons responsible for manual decorator handling is restored.
      */
      _closeFormView() {
        const linkCommand = this.editor.commands.get("link");
        linkCommand.restoreManualDecoratorStates();
        if (linkCommand.value !== void 0) {
          this._removeFormView();
        } else {
          this._hideUI();
        }
      }
      /**
      * Removes the {@link #formView} from the {@link #_balloon}.
      */
      _removeFormView() {
        if (this._isFormInPanel) {
          this.formView.saveButtonView.focus();
          this.formView.urlInputView.fieldView.reset();
          this._balloon.remove(this.formView);
          this.editor.editing.view.focus();
          this._hideFakeVisualSelection();
        }
      }
      /**
      * Shows the correct UI type. It is either {@link #formView} or {@link #actionsView}.
      *
      * @internal
      */
      _showUI(forceVisible = false) {
        if (!this.formView) {
          this._createViews();
        }
        if (!this._getSelectedLinkElement()) {
          this._showFakeVisualSelection();
          this._addActionsView();
          if (forceVisible) {
            this._balloon.showStack("main");
          }
          this._addFormView();
        } else {
          if (this._areActionsVisible) {
            this._addFormView();
          } else {
            this._addActionsView();
          }
          if (forceVisible) {
            this._balloon.showStack("main");
          }
        }
        this._startUpdatingUI();
      }
      /**
      * Removes the {@link #formView} from the {@link #_balloon}.
      *
      * See {@link #_addFormView}, {@link #_addActionsView}.
      */
      _hideUI() {
        if (!this._isUIInPanel) {
          return;
        }
        const editor2 = this.editor;
        this.stopListening(editor2.ui, "update");
        this.stopListening(this._balloon, "change:visibleView");
        editor2.editing.view.focus();
        this._removeFormView();
        this._balloon.remove(this.actionsView);
        this._hideFakeVisualSelection();
      }
      /**
      * Makes the UI react to the {@link module:ui/editorui/editorui~EditorUI#event:update} event to
      * reposition itself when the editor UI should be refreshed.
      *
      * See: {@link #_hideUI} to learn when the UI stops reacting to the `update` event.
      */
      _startUpdatingUI() {
        const editor2 = this.editor;
        const viewDocument = editor2.editing.view.document;
        let prevSelectedLink = this._getSelectedLinkElement();
        let prevSelectionParent = getSelectionParent();
        const update2 = () => {
          const selectedLink = this._getSelectedLinkElement();
          const selectionParent = getSelectionParent();
          if (prevSelectedLink && !selectedLink || !prevSelectedLink && selectionParent !== prevSelectionParent) {
            this._hideUI();
          } else if (this._isUIVisible) {
            this._balloon.updatePosition(this._getBalloonPositionData());
          }
          prevSelectedLink = selectedLink;
          prevSelectionParent = selectionParent;
        };
        function getSelectionParent() {
          return viewDocument.selection.focus.getAncestors().reverse().find((node) => node.is("element"));
        }
        this.listenTo(editor2.ui, "update", update2);
        this.listenTo(this._balloon, "change:visibleView", update2);
      }
      /**
      * Returns `true` when {@link #formView} is in the {@link #_balloon}.
      */
      get _isFormInPanel() {
        return !!this.formView && this._balloon.hasView(this.formView);
      }
      /**
      * Returns `true` when {@link #actionsView} is in the {@link #_balloon}.
      */
      get _areActionsInPanel() {
        return !!this.actionsView && this._balloon.hasView(this.actionsView);
      }
      /**
      * Returns `true` when {@link #actionsView} is in the {@link #_balloon} and it is
      * currently visible.
      */
      get _areActionsVisible() {
        return !!this.actionsView && this._balloon.visibleView === this.actionsView;
      }
      /**
      * Returns `true` when {@link #actionsView} or {@link #formView} is in the {@link #_balloon}.
      */
      get _isUIInPanel() {
        return this._isFormInPanel || this._areActionsInPanel;
      }
      /**
      * Returns `true` when {@link #actionsView} or {@link #formView} is in the {@link #_balloon} and it is
      * currently visible.
      */
      get _isUIVisible() {
        const visibleView = this._balloon.visibleView;
        return !!this.formView && visibleView == this.formView || this._areActionsVisible;
      }
      /**
      * Returns positioning options for the {@link #_balloon}. They control the way the balloon is attached
      * to the target element or selection.
      *
      * If the selection is collapsed and inside a link element, the panel will be attached to the
      * entire link element. Otherwise, it will be attached to the selection.
      */
      _getBalloonPositionData() {
        const view = this.editor.editing.view;
        const model = this.editor.model;
        const viewDocument = view.document;
        let target;
        if (model.markers.has(VISUAL_SELECTION_MARKER_NAME)) {
          const markerViewElements = Array.from(this.editor.editing.mapper.markerNameToElements(VISUAL_SELECTION_MARKER_NAME));
          const newRange = view.createRange(view.createPositionBefore(markerViewElements[0]), view.createPositionAfter(markerViewElements[markerViewElements.length - 1]));
          target = view.domConverter.viewRangeToDom(newRange);
        } else {
          target = () => {
            const targetLink = this._getSelectedLinkElement();
            return targetLink ? (
              // When selection is inside link element, then attach panel to this element.
              view.domConverter.mapViewToDom(targetLink)
            ) : (
              // Otherwise attach panel to the selection.
              view.domConverter.viewRangeToDom(viewDocument.selection.getFirstRange())
            );
          };
        }
        return {
          target
        };
      }
      /**
      * Returns the link {@link module:engine/view/attributeelement~AttributeElement} under
      * the {@link module:engine/view/document~Document editing view's} selection or `null`
      * if there is none.
      *
      * **Note**: For a noncollapsed selection, the link element is returned when **fully**
      * selected and the **only** element within the selection boundaries, or when
      * a linked widget is selected.
      */
      _getSelectedLinkElement() {
        const view = this.editor.editing.view;
        const selection = view.document.selection;
        const selectedElement = selection.getSelectedElement();
        if (selection.isCollapsed || selectedElement && isWidget(selectedElement)) {
          return findLinkElementAncestor(selection.getFirstPosition());
        } else {
          const range2 = selection.getFirstRange().getTrimmed();
          const startLink = findLinkElementAncestor(range2.start);
          const endLink = findLinkElementAncestor(range2.end);
          if (!startLink || startLink != endLink) {
            return null;
          }
          if (view.createRangeIn(startLink).getTrimmed().isEqual(range2)) {
            return startLink;
          } else {
            return null;
          }
        }
      }
      /**
      * Displays a fake visual selection when the contextual balloon is displayed.
      *
      * This adds a 'link-ui' marker into the document that is rendered as a highlight on selected text fragment.
      */
      _showFakeVisualSelection() {
        const model = this.editor.model;
        model.change((writer) => {
          const range2 = model.document.selection.getFirstRange();
          if (model.markers.has(VISUAL_SELECTION_MARKER_NAME)) {
            writer.updateMarker(VISUAL_SELECTION_MARKER_NAME, {
              range: range2
            });
          } else {
            if (range2.start.isAtEnd) {
              const startPosition = range2.start.getLastMatchingPosition(({ item }) => !model.schema.isContent(item), {
                boundaries: range2
              });
              writer.addMarker(VISUAL_SELECTION_MARKER_NAME, {
                usingOperation: false,
                affectsData: false,
                range: writer.createRange(startPosition, range2.end)
              });
            } else {
              writer.addMarker(VISUAL_SELECTION_MARKER_NAME, {
                usingOperation: false,
                affectsData: false,
                range: range2
              });
            }
          }
        });
      }
      /**
      * Hides the fake visual selection created in {@link #_showFakeVisualSelection}.
      */
      _hideFakeVisualSelection() {
        const model = this.editor.model;
        if (model.markers.has(VISUAL_SELECTION_MARKER_NAME)) {
          model.change((writer) => {
            writer.removeMarker(VISUAL_SELECTION_MARKER_NAME);
          });
        }
      }
    }
    function findLinkElementAncestor(position) {
      return position.getAncestors().find((ancestor) => isLinkElement(ancestor)) || null;
    }
    function getFormValidators(editor2) {
      const t2 = editor2.t;
      const allowCreatingEmptyLinks = editor2.config.get("link.allowCreatingEmptyLinks");
      return [
        (form) => {
          if (!allowCreatingEmptyLinks && !form.url.length) {
            return t2("Link URL must not be empty.");
          }
        }
      ];
    }
    const MIN_LINK_LENGTH_WITH_SPACE_AT_END = 4;
    const URL_REG_EXP = new RegExp(
      // Group 1: Line start or after a space.
      "(^|\\s)(((?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(((?!www\\.)|(www\\.))(?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.)+(?:[a-z\\u00a1-\\uffff]{2,63})))(?::\\d{2,5})?(?:[/?#]\\S*)?)|((www.|(\\S+@))((?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.))+(?:[a-z\\u00a1-\\uffff]{2,63})))$",
      "i"
    );
    const URL_GROUP_IN_MATCH = 2;
    class AutoLink extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          Delete,
          LinkEditing
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "AutoLink";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor2 = this.editor;
        const selection = editor2.model.document.selection;
        selection.on("change:range", () => {
          this.isEnabled = !selection.anchor.parent.is("element", "codeBlock");
        });
        this._enableTypingHandling();
      }
      /**
      * @inheritDoc
      */
      afterInit() {
        this._enableEnterHandling();
        this._enableShiftEnterHandling();
        this._enablePasteLinking();
      }
      /**
      * For given position, returns a range that includes the whole link that contains the position.
      *
      * If position is not inside a link, returns `null`.
      */
      _expandLinkRange(model, position) {
        if (position.textNode && position.textNode.hasAttribute("linkHref")) {
          return findAttributeRange(position, "linkHref", position.textNode.getAttribute("linkHref"), model);
        } else {
          return null;
        }
      }
      /**
      * Extends the document selection to includes all links that intersects with given `selectedRange`.
      */
      _selectEntireLinks(writer, selectedRange) {
        const editor2 = this.editor;
        const model = editor2.model;
        const selection = model.document.selection;
        const selStart = selection.getFirstPosition();
        const selEnd = selection.getLastPosition();
        let updatedSelection = selectedRange.getJoined(this._expandLinkRange(model, selStart) || selectedRange);
        if (updatedSelection) {
          updatedSelection = updatedSelection.getJoined(this._expandLinkRange(model, selEnd) || selectedRange);
        }
        if (updatedSelection && (updatedSelection.start.isBefore(selStart) || updatedSelection.end.isAfter(selEnd))) {
          writer.setSelection(updatedSelection);
        }
      }
      /**
      * Enables autolinking on pasting a URL when some content is selected.
      */
      _enablePasteLinking() {
        const editor2 = this.editor;
        const model = editor2.model;
        const selection = model.document.selection;
        const clipboardPipeline = editor2.plugins.get("ClipboardPipeline");
        const linkCommand = editor2.commands.get("link");
        clipboardPipeline.on("inputTransformation", (evt, data) => {
          if (!this.isEnabled || !linkCommand.isEnabled || selection.isCollapsed || data.method !== "paste") {
            return;
          }
          if (selection.rangeCount > 1) {
            return;
          }
          const selectedRange = selection.getFirstRange();
          const newLink = data.dataTransfer.getData("text/plain");
          if (!newLink) {
            return;
          }
          const matches2 = newLink.match(URL_REG_EXP);
          if (matches2 && matches2[2] === newLink) {
            model.change((writer) => {
              this._selectEntireLinks(writer, selectedRange);
              linkCommand.execute(newLink);
            });
            evt.stop();
          }
        }, {
          priority: "high"
        });
      }
      /**
      * Enables autolinking on typing.
      */
      _enableTypingHandling() {
        const editor2 = this.editor;
        const watcher = new TextWatcher(editor2.model, (text2) => {
          if (!isSingleSpaceAtTheEnd(text2)) {
            return;
          }
          const url = getUrlAtTextEnd(text2.substr(0, text2.length - 1));
          if (url) {
            return {
              url
            };
          }
        });
        watcher.on("matched:data", (evt, data) => {
          const { batch, range: range2, url } = data;
          if (!batch.isTyping) {
            return;
          }
          const linkEnd = range2.end.getShiftedBy(-1);
          const linkStart = linkEnd.getShiftedBy(-url.length);
          const linkRange = editor2.model.createRange(linkStart, linkEnd);
          this._applyAutoLink(url, linkRange);
        });
        watcher.bind("isEnabled").to(this);
      }
      /**
      * Enables autolinking on the <kbd>Enter</kbd> key.
      */
      _enableEnterHandling() {
        const editor2 = this.editor;
        const model = editor2.model;
        const enterCommand = editor2.commands.get("enter");
        if (!enterCommand) {
          return;
        }
        enterCommand.on("execute", () => {
          const position = model.document.selection.getFirstPosition();
          if (!position.parent.previousSibling) {
            return;
          }
          const rangeToCheck = model.createRangeIn(position.parent.previousSibling);
          this._checkAndApplyAutoLinkOnRange(rangeToCheck);
        });
      }
      /**
      * Enables autolinking on the <kbd>Shift</kbd>+<kbd>Enter</kbd> keyboard shortcut.
      */
      _enableShiftEnterHandling() {
        const editor2 = this.editor;
        const model = editor2.model;
        const shiftEnterCommand = editor2.commands.get("shiftEnter");
        if (!shiftEnterCommand) {
          return;
        }
        shiftEnterCommand.on("execute", () => {
          const position = model.document.selection.getFirstPosition();
          const rangeToCheck = model.createRange(model.createPositionAt(position.parent, 0), position.getShiftedBy(-1));
          this._checkAndApplyAutoLinkOnRange(rangeToCheck);
        });
      }
      /**
      * Checks if the passed range contains a linkable text.
      */
      _checkAndApplyAutoLinkOnRange(rangeToCheck) {
        const model = this.editor.model;
        const { text: text2, range: range2 } = getLastTextLine(rangeToCheck, model);
        const url = getUrlAtTextEnd(text2);
        if (url) {
          const linkRange = model.createRange(range2.end.getShiftedBy(-url.length), range2.end);
          this._applyAutoLink(url, linkRange);
        }
      }
      /**
      * Applies a link on a given range if the link should be applied.
      *
      * @param url The URL to link.
      * @param range The text range to apply the link attribute to.
      */
      _applyAutoLink(url, range2) {
        const model = this.editor.model;
        const defaultProtocol = this.editor.config.get("link.defaultProtocol");
        const fullUrl = addLinkProtocolIfApplicable(url, defaultProtocol);
        if (!this.isEnabled || !isLinkAllowedOnRange(range2, model) || !linkHasProtocol(fullUrl) || linkIsAlreadySet(range2)) {
          return;
        }
        this._persistAutoLink(fullUrl, range2);
      }
      /**
      * Enqueues autolink changes in the model.
      *
      * @param url The URL to link.
      * @param range The text range to apply the link attribute to.
      */
      _persistAutoLink(url, range2) {
        const model = this.editor.model;
        const deletePlugin = this.editor.plugins.get("Delete");
        model.enqueueChange((writer) => {
          writer.setAttribute("linkHref", url, range2);
          model.enqueueChange(() => {
            deletePlugin.requestUndoOnBackspace();
          });
        });
      }
    }
    function isSingleSpaceAtTheEnd(text2) {
      return text2.length > MIN_LINK_LENGTH_WITH_SPACE_AT_END && text2[text2.length - 1] === " " && text2[text2.length - 2] !== " ";
    }
    function getUrlAtTextEnd(text2) {
      const match = URL_REG_EXP.exec(text2);
      return match ? match[URL_GROUP_IN_MATCH] : null;
    }
    function isLinkAllowedOnRange(range2, model) {
      return model.schema.checkAttributeInSelection(model.createSelection(range2), "linkHref");
    }
    function linkIsAlreadySet(range2) {
      const item = range2.start.nodeAfter;
      return !!item && item.hasAttribute("linkHref");
    }
    class Link extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          LinkEditing,
          LinkUI,
          AutoLink
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "Link";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class ListWalker {
      /**
      * Creates a document list iterator.
      *
      * @param startElement The start list item block element.
      * @param options.direction The iterating direction.
      * @param options.includeSelf Whether start block should be included in the result (if it's matching other criteria).
      * @param options.sameAttributes Additional attributes that must be the same for each block.
      * @param options.sameIndent Whether blocks with the same indent level as the start block should be included
      * in the result.
      * @param options.lowerIndent Whether blocks with a lower indent level than the start block should be included
      * in the result.
      * @param options.higherIndent Whether blocks with a higher indent level than the start block should be included
      * in the result.
      */
      constructor(startElement, options) {
        /**
        * The start list item block element.
        */
        __publicField(this, "_startElement");
        /**
        * The reference indent. Initialized by the indent of the start block.
        */
        __publicField(this, "_referenceIndent");
        /**
        * The iterating direction.
        */
        __publicField(this, "_isForward");
        /**
        * Whether start block should be included in the result (if it's matching other criteria).
        */
        __publicField(this, "_includeSelf");
        /**
        * Additional attributes that must be the same for each block.
        */
        __publicField(this, "_sameAttributes");
        /**
        * Whether blocks with the same indent level as the start block should be included in the result.
        */
        __publicField(this, "_sameIndent");
        /**
        * Whether blocks with a lower indent level than the start block should be included in the result.
        */
        __publicField(this, "_lowerIndent");
        /**
        * Whether blocks with a higher indent level than the start block should be included in the result.
        */
        __publicField(this, "_higherIndent");
        this._startElement = startElement;
        this._referenceIndent = startElement.getAttribute("listIndent");
        this._isForward = options.direction == "forward";
        this._includeSelf = !!options.includeSelf;
        this._sameAttributes = toArray$2(options.sameAttributes || []);
        this._sameIndent = !!options.sameIndent;
        this._lowerIndent = !!options.lowerIndent;
        this._higherIndent = !!options.higherIndent;
      }
      /**
      * Performs only first step of iteration and returns the result.
      *
      * @param startElement The start list item block element.
      * @param options.direction The iterating direction.
      * @param options.includeSelf Whether start block should be included in the result (if it's matching other criteria).
      * @param options.sameAttributes Additional attributes that must be the same for each block.
      * @param options.sameIndent Whether blocks with the same indent level as the start block should be included
      * in the result.
      * @param options.lowerIndent Whether blocks with a lower indent level than the start block should be included
      * in the result.
      * @param options.higherIndent Whether blocks with a higher indent level than the start block should be included
      * in the result.
      */
      static first(startElement, options) {
        const walker = new this(startElement, options);
        const iterator = walker[Symbol.iterator]();
        return first(iterator);
      }
      /**
      * Iterable interface.
      */
      *[Symbol.iterator]() {
        const nestedItems = [];
        for (const { node } of iterateSiblingListBlocks(this._getStartNode(), this._isForward ? "forward" : "backward")) {
          const indent2 = node.getAttribute("listIndent");
          if (indent2 < this._referenceIndent) {
            if (!this._lowerIndent) {
              break;
            }
            this._referenceIndent = indent2;
          } else if (indent2 > this._referenceIndent) {
            if (!this._higherIndent) {
              continue;
            }
            if (!this._isForward) {
              nestedItems.push(node);
              continue;
            }
          } else {
            if (!this._sameIndent) {
              if (this._higherIndent) {
                if (nestedItems.length) {
                  yield* nestedItems;
                  nestedItems.length = 0;
                }
                break;
              }
              continue;
            }
            if (this._sameAttributes.some((attr) => node.getAttribute(attr) !== this._startElement.getAttribute(attr))) {
              break;
            }
          }
          if (nestedItems.length) {
            yield* nestedItems;
            nestedItems.length = 0;
          }
          yield node;
        }
      }
      /**
      * Returns the model element to start iterating.
      */
      _getStartNode() {
        if (this._includeSelf) {
          return this._startElement;
        }
        return this._isForward ? this._startElement.nextSibling : this._startElement.previousSibling;
      }
    }
    function* iterateSiblingListBlocks(node, direction = "forward") {
      const isForward = direction == "forward";
      const previousNodesByIndent = [];
      let previous = null;
      while (isListItemBlock(node)) {
        let previousNodeInList = null;
        if (previous) {
          const nodeIndent = node.getAttribute("listIndent");
          const previousNodeIndent = previous.getAttribute("listIndent");
          if (nodeIndent > previousNodeIndent) {
            previousNodesByIndent[previousNodeIndent] = previous;
          } else if (nodeIndent < previousNodeIndent) {
            previousNodeInList = previousNodesByIndent[nodeIndent];
            previousNodesByIndent.length = nodeIndent;
          } else {
            previousNodeInList = previous;
          }
        }
        yield {
          node,
          previous,
          previousNodeInList
        };
        previous = node;
        node = isForward ? node.nextSibling : node.previousSibling;
      }
    }
    class ListBlocksIterable {
      /**
      * @param listHead The head element of a list.
      */
      constructor(listHead) {
        __publicField(this, "_listHead");
        this._listHead = listHead;
      }
      /**
      * List blocks iterator.
      *
      * Iterates over all blocks of a list.
      */
      [Symbol.iterator]() {
        return iterateSiblingListBlocks(this._listHead, "forward");
      }
    }
    class ListItemUid {
      /**
      * Returns the next ID.
      *
      * @internal
      */
      /* istanbul ignore next: static function definition -- @preserve */
      static next() {
        return uid();
      }
    }
    function isListItemBlock(node) {
      return !!node && node.is("element") && node.hasAttribute("listItemId");
    }
    function getAllListItemBlocks(listItem, options = {}) {
      return [
        ...getListItemBlocks(listItem, {
          ...options,
          direction: "backward"
        }),
        ...getListItemBlocks(listItem, {
          ...options,
          direction: "forward"
        })
      ];
    }
    function getListItemBlocks(listItem, options = {}) {
      const isForward = options.direction == "forward";
      const items = Array.from(new ListWalker(listItem, {
        ...options,
        includeSelf: isForward,
        sameIndent: true,
        sameAttributes: "listItemId"
      }));
      return isForward ? items : items.reverse();
    }
    function getNestedListBlocks(listItem) {
      return Array.from(new ListWalker(listItem, {
        direction: "forward",
        higherIndent: true
      }));
    }
    function getListItems(listItem, options) {
      const backwardBlocks = new ListWalker(listItem, {
        sameIndent: true,
        sameAttributes: "listType",
        ...options
      });
      const forwardBlocks = new ListWalker(listItem, {
        sameIndent: true,
        sameAttributes: "listType",
        includeSelf: true,
        direction: "forward",
        ...options
      });
      return [
        ...Array.from(backwardBlocks).reverse(),
        ...forwardBlocks
      ];
    }
    function isFirstBlockOfListItem(listBlock) {
      const previousSibling = ListWalker.first(listBlock, {
        sameIndent: true,
        sameAttributes: "listItemId"
      });
      if (!previousSibling) {
        return true;
      }
      return false;
    }
    function isLastBlockOfListItem(listBlock) {
      const nextSibling = ListWalker.first(listBlock, {
        direction: "forward",
        sameIndent: true,
        sameAttributes: "listItemId"
      });
      if (!nextSibling) {
        return true;
      }
      return false;
    }
    function expandListBlocksToCompleteItems(blocks, options = {}) {
      blocks = toArray$2(blocks);
      const higherIndent = options.withNested !== false;
      const allBlocks = /* @__PURE__ */ new Set();
      for (const block2 of blocks) {
        for (const itemBlock of getAllListItemBlocks(block2, {
          higherIndent
        })) {
          allBlocks.add(itemBlock);
        }
      }
      return sortBlocks(allBlocks);
    }
    function expandListBlocksToCompleteList(blocks) {
      blocks = toArray$2(blocks);
      const allBlocks = /* @__PURE__ */ new Set();
      for (const block2 of blocks) {
        for (const itemBlock of getListItems(block2)) {
          allBlocks.add(itemBlock);
        }
      }
      return sortBlocks(allBlocks);
    }
    function splitListItemBefore(listBlock, writer) {
      const blocks = getListItemBlocks(listBlock, {
        direction: "forward"
      });
      const id = ListItemUid.next();
      for (const block2 of blocks) {
        writer.setAttribute("listItemId", id, block2);
      }
      return blocks;
    }
    function mergeListItemBefore(listBlock, parentBlock, writer) {
      const attributes = {};
      for (const [key, value] of parentBlock.getAttributes()) {
        if (key.startsWith("list")) {
          attributes[key] = value;
        }
      }
      const blocks = getListItemBlocks(listBlock, {
        direction: "forward"
      });
      for (const block2 of blocks) {
        writer.setAttributes(attributes, block2);
      }
      return blocks;
    }
    function indentBlocks(blocks, writer, { expand, indentBy = 1 } = {}) {
      blocks = toArray$2(blocks);
      const allBlocks = expand ? expandListBlocksToCompleteItems(blocks) : blocks;
      for (const block2 of allBlocks) {
        const blockIndent = block2.getAttribute("listIndent") + indentBy;
        if (blockIndent < 0) {
          removeListAttributes(block2, writer);
        } else {
          writer.setAttribute("listIndent", blockIndent, block2);
        }
      }
      return allBlocks;
    }
    function outdentBlocksWithMerge(blocks, writer) {
      blocks = toArray$2(blocks);
      const allBlocks = expandListBlocksToCompleteItems(blocks);
      const visited = /* @__PURE__ */ new Set();
      const referenceIndent = Math.min(...allBlocks.map((block2) => block2.getAttribute("listIndent")));
      const parentBlocks = /* @__PURE__ */ new Map();
      for (const block2 of allBlocks) {
        parentBlocks.set(block2, ListWalker.first(block2, {
          lowerIndent: true
        }));
      }
      for (const block2 of allBlocks) {
        if (visited.has(block2)) {
          continue;
        }
        visited.add(block2);
        const blockIndent = block2.getAttribute("listIndent") - 1;
        if (blockIndent < 0) {
          removeListAttributes(block2, writer);
          continue;
        }
        if (block2.getAttribute("listIndent") == referenceIndent) {
          const mergedBlocks = mergeListItemIfNotLast(block2, parentBlocks.get(block2), writer);
          for (const mergedBlock of mergedBlocks) {
            visited.add(mergedBlock);
          }
          if (mergedBlocks.length) {
            continue;
          }
        }
        writer.setAttribute("listIndent", blockIndent, block2);
      }
      return sortBlocks(visited);
    }
    function removeListAttributes(blocks, writer) {
      blocks = toArray$2(blocks);
      for (const block2 of blocks) {
        if (block2.is("element", "listItem")) {
          writer.rename(block2, "paragraph");
        }
      }
      for (const block2 of blocks) {
        for (const attributeKey of block2.getAttributeKeys()) {
          if (attributeKey.startsWith("list")) {
            writer.removeAttribute(attributeKey, block2);
          }
        }
      }
      return blocks;
    }
    function isSingleListItem(blocks) {
      if (!blocks.length) {
        return false;
      }
      const firstItemId = blocks[0].getAttribute("listItemId");
      if (!firstItemId) {
        return false;
      }
      return !blocks.some((item) => item.getAttribute("listItemId") != firstItemId);
    }
    function outdentFollowingItems(lastBlock, writer) {
      const changedBlocks = [];
      let currentIndent = Number.POSITIVE_INFINITY;
      for (const { node } of iterateSiblingListBlocks(lastBlock.nextSibling, "forward")) {
        const indent2 = node.getAttribute("listIndent");
        if (indent2 == 0) {
          break;
        }
        if (indent2 < currentIndent) {
          currentIndent = indent2;
        }
        const newIndent = indent2 - currentIndent;
        writer.setAttribute("listIndent", newIndent, node);
        changedBlocks.push(node);
      }
      return changedBlocks;
    }
    function sortBlocks(blocks) {
      return Array.from(blocks).filter((block2) => block2.root.rootName !== "$graveyard").sort((a2, b2) => a2.index - b2.index);
    }
    function getSelectedBlockObject(model) {
      const selectedElement = model.document.selection.getSelectedElement();
      if (!selectedElement) {
        return null;
      }
      if (model.schema.isObject(selectedElement) && model.schema.isBlock(selectedElement)) {
        return selectedElement;
      }
      return null;
    }
    function canBecomeSimpleListItem(block2, schema) {
      return schema.checkChild(block2.parent, "listItem") && schema.checkChild(block2, "$text") && !schema.isObject(block2);
    }
    function isNumberedListType(listType) {
      return listType == "numbered" || listType == "customNumbered";
    }
    function mergeListItemIfNotLast(block2, parentBlock, writer) {
      const parentItemBlocks = getListItemBlocks(parentBlock, {
        direction: "forward"
      });
      if (parentItemBlocks.pop().index > block2.index) {
        return mergeListItemBefore(block2, parentBlock, writer);
      }
      return [];
    }
    class ListIndentCommand extends Command {
      /**
      * Creates an instance of the command.
      *
      * @param editor The editor instance.
      * @param indentDirection The direction of indent. If it is equal to `backward`, the command
      * will outdent a list item.
      */
      constructor(editor2, indentDirection) {
        super(editor2);
        /**
        * Determines by how much the command will change the list item's indent attribute.
        */
        __publicField(this, "_direction");
        this._direction = indentDirection;
      }
      /**
      * @inheritDoc
      */
      refresh() {
        this.isEnabled = this._checkEnabled();
      }
      /**
      * Indents or outdents (depending on the {@link #constructor}'s `indentDirection` parameter) selected list items.
      *
      * @fires execute
      * @fires afterExecute
      */
      execute() {
        const model = this.editor.model;
        const blocks = getSelectedListBlocks(model.document.selection);
        model.change((writer) => {
          const changedBlocks = [];
          if (isSingleListItem(blocks) && !isFirstBlockOfListItem(blocks[0])) {
            if (this._direction == "forward") {
              changedBlocks.push(...indentBlocks(blocks, writer));
            }
            changedBlocks.push(...splitListItemBefore(blocks[0], writer));
          } else {
            if (this._direction == "forward") {
              changedBlocks.push(...indentBlocks(blocks, writer, {
                expand: true
              }));
            } else {
              changedBlocks.push(...outdentBlocksWithMerge(blocks, writer));
            }
          }
          for (const block2 of changedBlocks) {
            if (!block2.hasAttribute("listType")) {
              continue;
            }
            const previousItemBlock = ListWalker.first(block2, {
              sameIndent: true
            });
            if (previousItemBlock) {
              writer.setAttribute("listType", previousItemBlock.getAttribute("listType"), block2);
            }
          }
          this._fireAfterExecute(changedBlocks);
        });
      }
      /**
      * Fires the `afterExecute` event.
      *
      * @param changedBlocks The changed list elements.
      */
      _fireAfterExecute(changedBlocks) {
        this.fire("afterExecute", sortBlocks(new Set(changedBlocks)));
      }
      /**
      * Checks whether the command can be enabled in the current context.
      *
      * @returns Whether the command should be enabled.
      */
      _checkEnabled() {
        let blocks = getSelectedListBlocks(this.editor.model.document.selection);
        let firstBlock = blocks[0];
        if (!firstBlock) {
          return false;
        }
        if (this._direction == "backward") {
          return true;
        }
        if (isSingleListItem(blocks) && !isFirstBlockOfListItem(blocks[0])) {
          return true;
        }
        blocks = expandListBlocksToCompleteItems(blocks);
        firstBlock = blocks[0];
        const siblingItem = ListWalker.first(firstBlock, {
          sameIndent: true
        });
        if (!siblingItem) {
          return false;
        }
        if (siblingItem.getAttribute("listType") == firstBlock.getAttribute("listType")) {
          return true;
        }
        return false;
      }
    }
    function getSelectedListBlocks(selection) {
      const blocks = Array.from(selection.getSelectedBlocks());
      const firstNonListBlockIndex = blocks.findIndex((block2) => !isListItemBlock(block2));
      if (firstNonListBlockIndex != -1) {
        blocks.length = firstNonListBlockIndex;
      }
      return blocks;
    }
    class ListCommand extends Command {
      /**
      * Creates an instance of the command.
      *
      * @param editor The editor instance.
      * @param type List type that will be handled by this command.
      */
      constructor(editor2, type, options = {}) {
        super(editor2);
        /**
        * The type of the list created by the command.
        */
        __publicField(this, "type");
        /**
        * List Walker options that change the range of the list items to be changed when the selection is collapsed within a list item.
        *
        * In a multi-level list, when the selection is collapsed within a list item, instead of changing only the list items of the same list
        * type and current indent level, the entire list structure is changed (all list items at all indent levels of any list type).
        */
        __publicField(this, "_listWalkerOptions");
        this.type = type;
        this._listWalkerOptions = options.multiLevel ? {
          higherIndent: true,
          lowerIndent: true,
          sameAttributes: []
        } : void 0;
      }
      /**
      * @inheritDoc
      */
      refresh() {
        this.value = this._getValue();
        this.isEnabled = this._checkEnabled();
      }
      /**
      * Executes the list command.
      *
      * @fires execute
      * @fires afterExecute
      * @param options Command options.
      * @param options.forceValue If set, it will force the command behavior. If `true`, the command will try to convert the
      * selected items and potentially the neighbor elements to the proper list items. If set to `false` it will convert selected elements
      * to paragraphs. If not set, the command will toggle selected elements to list items or paragraphs, depending on the selection.
      * @param options.additionalAttributes Additional attributes that are set for list items when the command is executed.
      */
      execute(options = {}) {
        const model = this.editor.model;
        const document2 = model.document;
        const selectedBlockObject = getSelectedBlockObject(model);
        const blocks = Array.from(document2.selection.getSelectedBlocks()).filter((block2) => model.schema.checkAttribute(block2, "listType") || canBecomeSimpleListItem(block2, model.schema));
        const turnOff = options.forceValue !== void 0 ? !options.forceValue : this.value;
        model.change((writer) => {
          if (turnOff) {
            const lastBlock = blocks[blocks.length - 1];
            const itemBlocks = getListItemBlocks(lastBlock, {
              direction: "forward"
            });
            const changedBlocks = [];
            if (itemBlocks.length > 1) {
              changedBlocks.push(...splitListItemBefore(itemBlocks[1], writer));
            }
            changedBlocks.push(...removeListAttributes(blocks, writer));
            changedBlocks.push(...outdentFollowingItems(lastBlock, writer));
            this._fireAfterExecute(changedBlocks);
          } else if ((selectedBlockObject || document2.selection.isCollapsed) && isListItemBlock(blocks[0])) {
            const changedBlocks = getListItems(selectedBlockObject || blocks[0], this._listWalkerOptions);
            for (const block2 of changedBlocks) {
              writer.setAttributes({
                ...options.additionalAttributes,
                listType: this.type
              }, block2);
            }
            this._fireAfterExecute(changedBlocks);
          } else {
            const changedBlocks = [];
            for (const block2 of blocks) {
              if (!block2.hasAttribute("listType")) {
                if (!block2.is("element", "listItem") && canBecomeSimpleListItem(block2, model.schema)) {
                  writer.rename(block2, "listItem");
                }
                writer.setAttributes({
                  ...options.additionalAttributes,
                  listIndent: 0,
                  listItemId: ListItemUid.next(),
                  listType: this.type
                }, block2);
                changedBlocks.push(block2);
              } else {
                for (const node of expandListBlocksToCompleteItems(block2, {
                  withNested: false
                })) {
                  if (node.getAttribute("listType") != this.type) {
                    writer.setAttributes({
                      ...options.additionalAttributes,
                      listType: this.type
                    }, node);
                    changedBlocks.push(node);
                  }
                }
              }
            }
            this._fireAfterExecute(changedBlocks);
          }
        });
      }
      /**
      * Fires the `afterExecute` event.
      *
      * @param changedBlocks The changed list elements.
      */
      _fireAfterExecute(changedBlocks) {
        this.fire("afterExecute", sortBlocks(new Set(changedBlocks)));
      }
      /**
      * Checks the command's {@link #value}.
      *
      * @returns The current value.
      */
      _getValue() {
        const selection = this.editor.model.document.selection;
        const blocks = Array.from(selection.getSelectedBlocks());
        if (!blocks.length) {
          return false;
        }
        for (const block2 of blocks) {
          if (block2.getAttribute("listType") != this.type) {
            return false;
          }
        }
        return true;
      }
      /**
      * Checks whether the command can be enabled in the current context.
      *
      * @returns Whether the command should be enabled.
      */
      _checkEnabled() {
        const model = this.editor.model;
        const schema = model.schema;
        const selection = model.document.selection;
        const blocks = Array.from(selection.getSelectedBlocks());
        if (!blocks.length) {
          return false;
        }
        if (this.value) {
          return true;
        }
        for (const block2 of blocks) {
          if (schema.checkAttribute(block2, "listType") || canBecomeSimpleListItem(block2, schema)) {
            return true;
          }
        }
        return false;
      }
    }
    class ListMergeCommand extends Command {
      /**
      * Creates an instance of the command.
      *
      * @param editor The editor instance.
      * @param direction Whether list item should be merged before or after the selected block.
      */
      constructor(editor2, direction) {
        super(editor2);
        /**
        * Whether list item should be merged before or after the selected block.
        */
        __publicField(this, "_direction");
        this._direction = direction;
      }
      /**
      * @inheritDoc
      */
      refresh() {
        this.isEnabled = this._checkEnabled();
      }
      /**
      * Merges list blocks together (depending on the {@link #constructor}'s `direction` parameter).
      *
      * @fires execute
      * @fires afterExecute
      * @param options Command options.
      * @param options.shouldMergeOnBlocksContentLevel When set `true`, merging will be performed together
      * with {@link module:engine/model/model~Model#deleteContent} to get rid of the inline content in the selection or take advantage
      * of the heuristics in `deleteContent()` that helps convert lists into paragraphs in certain cases.
      */
      execute({ shouldMergeOnBlocksContentLevel: shouldMergeOnBlocksContentLevel2 = false } = {}) {
        const model = this.editor.model;
        const selection = model.document.selection;
        const changedBlocks = [];
        model.change((writer) => {
          const { firstElement, lastElement } = this._getMergeSubjectElements(selection, shouldMergeOnBlocksContentLevel2);
          const firstIndent = firstElement.getAttribute("listIndent") || 0;
          const lastIndent = lastElement.getAttribute("listIndent");
          const lastElementId = lastElement.getAttribute("listItemId");
          if (firstIndent != lastIndent) {
            const nestedLastElementBlocks = getNestedListBlocks(lastElement);
            changedBlocks.push(...indentBlocks([
              lastElement,
              ...nestedLastElementBlocks
            ], writer, {
              indentBy: firstIndent - lastIndent,
              // If outdenting, the entire sub-tree that follows must be included.
              expand: firstIndent < lastIndent
            }));
          }
          if (shouldMergeOnBlocksContentLevel2) {
            let sel = selection;
            if (selection.isCollapsed) {
              sel = writer.createSelection(writer.createRange(writer.createPositionAt(firstElement, "end"), writer.createPositionAt(lastElement, 0)));
            }
            model.deleteContent(sel, {
              doNotResetEntireContent: selection.isCollapsed
            });
            const lastElementAfterDelete = sel.getLastPosition().parent;
            const nextSibling = lastElementAfterDelete.nextSibling;
            changedBlocks.push(lastElementAfterDelete);
            if (nextSibling && nextSibling !== lastElement && nextSibling.getAttribute("listItemId") == lastElementId) {
              changedBlocks.push(...mergeListItemBefore(nextSibling, lastElementAfterDelete, writer));
            }
          } else {
            changedBlocks.push(...mergeListItemBefore(lastElement, firstElement, writer));
          }
          this._fireAfterExecute(changedBlocks);
        });
      }
      /**
      * Fires the `afterExecute` event.
      *
      * @param changedBlocks The changed list elements.
      */
      _fireAfterExecute(changedBlocks) {
        this.fire("afterExecute", sortBlocks(new Set(changedBlocks)));
      }
      /**
      * Checks whether the command can be enabled in the current context.
      *
      * @returns Whether the command should be enabled.
      */
      _checkEnabled() {
        const model = this.editor.model;
        const selection = model.document.selection;
        const selectedBlockObject = getSelectedBlockObject(model);
        if (selection.isCollapsed || selectedBlockObject) {
          const positionParent = selectedBlockObject || selection.getFirstPosition().parent;
          if (!isListItemBlock(positionParent)) {
            return false;
          }
          const siblingNode = this._direction == "backward" ? positionParent.previousSibling : positionParent.nextSibling;
          if (!siblingNode) {
            return false;
          }
          if (isSingleListItem([
            positionParent,
            siblingNode
          ])) {
            return false;
          }
        } else {
          const lastPosition = selection.getLastPosition();
          const firstPosition = selection.getFirstPosition();
          if (lastPosition.parent === firstPosition.parent) {
            return false;
          }
          if (!isListItemBlock(lastPosition.parent)) {
            return false;
          }
        }
        return true;
      }
      /**
      * Returns the boundary elements the merge should be executed for. These are not necessarily selection's first
      * and last position parents but sometimes sibling or even further blocks depending on the context.
      *
      * @param selection The selection the merge is executed for.
      * @param shouldMergeOnBlocksContentLevel When `true`, merge is performed together with
      * {@link module:engine/model/model~Model#deleteContent} to remove the inline content within the selection.
      */
      _getMergeSubjectElements(selection, shouldMergeOnBlocksContentLevel2) {
        const model = this.editor.model;
        const selectedBlockObject = getSelectedBlockObject(model);
        let firstElement, lastElement;
        if (selection.isCollapsed || selectedBlockObject) {
          const positionParent = selectedBlockObject || selection.getFirstPosition().parent;
          const isFirstBlock = isFirstBlockOfListItem(positionParent);
          if (this._direction == "backward") {
            lastElement = positionParent;
            if (isFirstBlock && !shouldMergeOnBlocksContentLevel2) {
              firstElement = ListWalker.first(positionParent, {
                sameIndent: true,
                lowerIndent: true
              });
            } else {
              firstElement = positionParent.previousSibling;
            }
          } else {
            firstElement = positionParent;
            lastElement = positionParent.nextSibling;
          }
        } else {
          firstElement = selection.getFirstPosition().parent;
          lastElement = selection.getLastPosition().parent;
        }
        return {
          firstElement,
          lastElement
        };
      }
    }
    class ListSplitCommand extends Command {
      /**
      * Creates an instance of the command.
      *
      * @param editor The editor instance.
      * @param direction Whether list item should be split before or after the selected block.
      */
      constructor(editor2, direction) {
        super(editor2);
        /**
        * Whether list item should be split before or after the selected block.
        */
        __publicField(this, "_direction");
        this._direction = direction;
      }
      /**
      * @inheritDoc
      */
      refresh() {
        this.isEnabled = this._checkEnabled();
      }
      /**
      * Splits the list item at the selection.
      *
      * @fires execute
      * @fires afterExecute
      */
      execute() {
        const editor2 = this.editor;
        editor2.model.change((writer) => {
          const changedBlocks = splitListItemBefore(this._getStartBlock(), writer);
          this._fireAfterExecute(changedBlocks);
        });
      }
      /**
      * Fires the `afterExecute` event.
      *
      * @param changedBlocks The changed list elements.
      */
      _fireAfterExecute(changedBlocks) {
        this.fire("afterExecute", sortBlocks(new Set(changedBlocks)));
      }
      /**
      * Checks whether the command can be enabled in the current context.
      *
      * @returns Whether the command should be enabled.
      */
      _checkEnabled() {
        const selection = this.editor.model.document.selection;
        const block2 = this._getStartBlock();
        return selection.isCollapsed && isListItemBlock(block2) && !isFirstBlockOfListItem(block2);
      }
      /**
      * Returns the model element that is the main focus of the command (according to the current selection and command direction).
      */
      _getStartBlock() {
        const doc = this.editor.model.document;
        const positionParent = doc.selection.getFirstPosition().parent;
        return this._direction == "before" ? positionParent : positionParent.nextSibling;
      }
    }
    class ListUtils extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "ListUtils";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
      /**
      * Expands the given list of selected blocks to include all the items of the lists they're in.
      *
      * @param blocks The list of selected blocks.
      */
      expandListBlocksToCompleteList(blocks) {
        return expandListBlocksToCompleteList(blocks);
      }
      /**
      * Check if the given block is the first in the list item.
      *
      * @param listBlock The list block element.
      */
      isFirstBlockOfListItem(listBlock) {
        return isFirstBlockOfListItem(listBlock);
      }
      /**
      * Returns true if the given model node is a list item block.
      *
      * @param node A model node.
      */
      isListItemBlock(node) {
        return isListItemBlock(node);
      }
      /**
      * Expands the given list of selected blocks to include the leading and tailing blocks of partially selected list items.
      *
      * @param blocks The list of selected blocks.
      * @param options.withNested Whether should include nested list items.
      */
      expandListBlocksToCompleteItems(blocks, options = {}) {
        return expandListBlocksToCompleteItems(blocks, options);
      }
      /**
      * Returns true if listType is of type `numbered` or `customNumbered`.
      */
      isNumberedListType(listType) {
        return isNumberedListType(listType);
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function isListView(viewElement) {
      return viewElement.is("element", "ol") || viewElement.is("element", "ul");
    }
    function isListItemView(viewElement) {
      return viewElement.is("element", "li");
    }
    function getIndent$1(listItem) {
      let indent2 = 0;
      let parent2 = listItem.parent;
      while (parent2) {
        if (isListItemView(parent2)) {
          indent2++;
        } else {
          const previousSibling = parent2.previousSibling;
          if (previousSibling && isListItemView(previousSibling)) {
            indent2++;
          }
        }
        parent2 = parent2.parent;
      }
      return indent2;
    }
    function createListElement(writer, indent2, type, id = getViewElementIdForListType(type, indent2)) {
      return writer.createAttributeElement(getViewElementNameForListType(type), null, {
        priority: 2 * indent2 / 100 - 100,
        id
      });
    }
    function createListItemElement(writer, indent2, id) {
      return writer.createAttributeElement("li", null, {
        priority: (2 * indent2 + 1) / 100 - 100,
        id
      });
    }
    function getViewElementNameForListType(type) {
      return type == "numbered" || type == "customNumbered" ? "ol" : "ul";
    }
    function getViewElementIdForListType(type, indent2) {
      return `list-${type}-${indent2}`;
    }
    function findAndAddListHeadToMap(position, itemToListHead) {
      const previousNode = position.nodeBefore;
      if (!isListItemBlock(previousNode)) {
        const item = position.nodeAfter;
        if (isListItemBlock(item)) {
          itemToListHead.set(item, item);
        }
      } else {
        let listHead = previousNode;
        for (const { node } of iterateSiblingListBlocks(listHead, "backward")) {
          listHead = node;
          if (itemToListHead.has(listHead)) {
            return;
          }
        }
        itemToListHead.set(previousNode, listHead);
      }
    }
    function fixListIndents(listNodes, writer) {
      let maxIndent = 0;
      let prevIndent = -1;
      let fixBy = null;
      let applied = false;
      for (const { node } of listNodes) {
        const itemIndent = node.getAttribute("listIndent");
        if (itemIndent > maxIndent) {
          let newIndent;
          if (fixBy === null) {
            fixBy = itemIndent - maxIndent;
            newIndent = maxIndent;
          } else {
            if (fixBy > itemIndent) {
              fixBy = itemIndent;
            }
            newIndent = itemIndent - fixBy;
          }
          if (newIndent > prevIndent + 1) {
            newIndent = prevIndent + 1;
          }
          writer.setAttribute("listIndent", newIndent, node);
          applied = true;
          prevIndent = newIndent;
        } else {
          fixBy = null;
          maxIndent = itemIndent + 1;
          prevIndent = itemIndent;
        }
      }
      return applied;
    }
    function fixListItemIds(listNodes, seenIds, writer) {
      const visited = /* @__PURE__ */ new Set();
      let applied = false;
      for (const { node } of listNodes) {
        if (visited.has(node)) {
          continue;
        }
        let listType = node.getAttribute("listType");
        let listItemId = node.getAttribute("listItemId");
        if (seenIds.has(listItemId)) {
          listItemId = ListItemUid.next();
        }
        seenIds.add(listItemId);
        if (node.is("element", "listItem")) {
          if (node.getAttribute("listItemId") != listItemId) {
            writer.setAttribute("listItemId", listItemId, node);
            applied = true;
          }
          continue;
        }
        for (const block2 of getListItemBlocks(node, {
          direction: "forward"
        })) {
          visited.add(block2);
          if (block2.getAttribute("listType") != listType) {
            listItemId = ListItemUid.next();
            listType = block2.getAttribute("listType");
          }
          if (block2.getAttribute("listItemId") != listItemId) {
            writer.setAttribute("listItemId", listItemId, block2);
            applied = true;
          }
        }
      }
      return applied;
    }
    function listItemUpcastConverter() {
      return (evt, data, conversionApi) => {
        const { writer, schema } = conversionApi;
        if (!data.modelRange) {
          return;
        }
        const items = Array.from(data.modelRange.getItems({
          shallow: true
        })).filter((item) => schema.checkAttribute(item, "listItemId"));
        if (!items.length) {
          return;
        }
        const listItemId = ListItemUid.next();
        const listIndent = getIndent$1(data.viewItem);
        let listType = data.viewItem.parent && data.viewItem.parent.is("element", "ol") ? "numbered" : "bulleted";
        const firstItemListType = items[0].getAttribute("listType");
        if (firstItemListType) {
          listType = firstItemListType;
        }
        const attributes = {
          listItemId,
          listIndent,
          listType
        };
        for (const item of items) {
          if (!item.hasAttribute("listItemId")) {
            writer.setAttributes(attributes, item);
          }
        }
        if (items.length > 1) {
          if (items[1].getAttribute("listItemId") != attributes.listItemId) {
            conversionApi.keepEmptyElement(items[0]);
          }
        }
      };
    }
    function reconvertItemsOnDataChange(model, editing, attributeNames, listEditing) {
      return () => {
        const changes = model.document.differ.getChanges();
        const itemsToRefresh = [];
        const itemToListHead = /* @__PURE__ */ new Map();
        const changedItems = /* @__PURE__ */ new Set();
        for (const entry of changes) {
          if (entry.type == "insert" && entry.name != "$text") {
            findAndAddListHeadToMap(entry.position, itemToListHead);
            if (!entry.attributes.has("listItemId")) {
              findAndAddListHeadToMap(entry.position.getShiftedBy(entry.length), itemToListHead);
            } else {
              changedItems.add(entry.position.nodeAfter);
            }
          } else if (entry.type == "remove" && entry.attributes.has("listItemId")) {
            findAndAddListHeadToMap(entry.position, itemToListHead);
          } else if (entry.type == "attribute") {
            const item = entry.range.start.nodeAfter;
            if (attributeNames.includes(entry.attributeKey)) {
              findAndAddListHeadToMap(entry.range.start, itemToListHead);
              if (entry.attributeNewValue === null) {
                findAndAddListHeadToMap(entry.range.start.getShiftedBy(1), itemToListHead);
                if (doesItemBlockRequiresRefresh(item)) {
                  itemsToRefresh.push(item);
                }
              } else {
                changedItems.add(item);
              }
            } else if (isListItemBlock(item)) {
              if (doesItemBlockRequiresRefresh(item)) {
                itemsToRefresh.push(item);
              }
            }
          }
        }
        for (const listHead of itemToListHead.values()) {
          itemsToRefresh.push(...collectListItemsToRefresh(listHead, changedItems));
        }
        for (const item of new Set(itemsToRefresh)) {
          editing.reconvertItem(item);
        }
      };
      function collectListItemsToRefresh(listHead, changedItems) {
        const itemsToRefresh = [];
        const visited = /* @__PURE__ */ new Set();
        const stack = [];
        for (const { node, previous } of iterateSiblingListBlocks(listHead, "forward")) {
          if (visited.has(node)) {
            continue;
          }
          const itemIndent = node.getAttribute("listIndent");
          if (previous && itemIndent < previous.getAttribute("listIndent")) {
            stack.length = itemIndent + 1;
          }
          stack[itemIndent] = Object.fromEntries(Array.from(node.getAttributes()).filter(([key]) => attributeNames.includes(key)));
          const blocks = getListItemBlocks(node, {
            direction: "forward"
          });
          for (const block2 of blocks) {
            visited.add(block2);
            if (doesItemBlockRequiresRefresh(block2, blocks)) {
              itemsToRefresh.push(block2);
            } else if (doesItemWrappingRequiresRefresh(block2, stack, changedItems)) {
              itemsToRefresh.push(block2);
            }
          }
        }
        return itemsToRefresh;
      }
      function doesItemBlockRequiresRefresh(item, blocks) {
        const viewElement = editing.mapper.toViewElement(item);
        if (!viewElement) {
          return false;
        }
        const needsRefresh = listEditing.fire("checkElement", {
          modelElement: item,
          viewElement
        });
        if (needsRefresh) {
          return true;
        }
        if (!item.is("element", "paragraph") && !item.is("element", "listItem")) {
          return false;
        }
        const useBogus = shouldUseBogusParagraph(item, attributeNames, blocks);
        if (useBogus && viewElement.is("element", "p")) {
          return true;
        } else if (!useBogus && viewElement.is("element", "span")) {
          return true;
        }
        return false;
      }
      function doesItemWrappingRequiresRefresh(item, stack, changedItems) {
        if (changedItems.has(item)) {
          return false;
        }
        const viewElement = editing.mapper.toViewElement(item);
        let indent2 = stack.length - 1;
        for (let element = viewElement.parent; !element.is("editableElement"); element = element.parent) {
          const isListItemElement = isListItemView(element);
          const isListElement = isListView(element);
          if (!isListElement && !isListItemElement) {
            continue;
          }
          const eventName = `checkAttributes:${isListItemElement ? "item" : "list"}`;
          const needsRefresh = listEditing.fire(eventName, {
            viewElement: element,
            modelAttributes: stack[indent2]
          });
          if (needsRefresh) {
            break;
          }
          if (isListElement) {
            indent2--;
            if (indent2 < 0) {
              return false;
            }
          }
        }
        return true;
      }
    }
    function listItemDowncastConverter(attributeNames, strategies, model, { dataPipeline } = {}) {
      const consumer = createAttributesConsumer(attributeNames);
      return (evt, data, conversionApi) => {
        const { writer, mapper, consumable } = conversionApi;
        const listItem = data.item;
        if (!attributeNames.includes(data.attributeKey)) {
          return;
        }
        if (!consumer(listItem, consumable)) {
          return;
        }
        const viewElement = findMappedViewElement(listItem, mapper, model);
        removeCustomMarkerElements(viewElement, writer, mapper);
        unwrapListItemBlock(viewElement, writer);
        const viewRange = insertCustomMarkerElements(listItem, viewElement, strategies, writer, {
          dataPipeline
        });
        wrapListItemBlock(listItem, viewRange, strategies, writer);
      };
    }
    function listItemDowncastRemoveConverter(schema) {
      return (evt, data, conversionApi) => {
        const { writer, mapper } = conversionApi;
        const elementName = evt.name.split(":")[1];
        if (!schema.checkAttribute(elementName, "listItemId")) {
          return;
        }
        const viewStart = mapper.toViewPosition(data.position);
        const modelEnd = data.position.getShiftedBy(data.length);
        const viewEnd = mapper.toViewPosition(modelEnd, {
          isPhantom: true
        });
        const viewRange = writer.createRange(viewStart, viewEnd).getTrimmed();
        const viewElement = viewRange.end.nodeBefore;
        /* istanbul ignore next -- @preserve */
        if (!viewElement) {
          return;
        }
        removeCustomMarkerElements(viewElement, writer, mapper);
      };
    }
    function bogusParagraphCreator(attributeNames, { dataPipeline } = {}) {
      return (modelElement, { writer }) => {
        if (!shouldUseBogusParagraph(modelElement, attributeNames)) {
          return null;
        }
        if (!dataPipeline) {
          return writer.createContainerElement("span", {
            class: "ck-list-bogus-paragraph"
          });
        }
        const viewElement = writer.createContainerElement("p");
        writer.setCustomProperty("dataPipeline:transparentRendering", true, viewElement);
        return viewElement;
      };
    }
    function findMappedViewElement(element, mapper, model) {
      const modelRange = model.createRangeOn(element);
      const viewRange = mapper.toViewRange(modelRange).getTrimmed();
      return viewRange.end.nodeBefore;
    }
    function createModelToViewPositionMapper(strategies, view) {
      return (evt, data) => {
        if (data.modelPosition.offset > 0) {
          return;
        }
        const positionParent = data.modelPosition.parent;
        if (!isListItemBlock(positionParent)) {
          return;
        }
        if (!strategies.some((strategy) => strategy.scope == "itemMarker" && strategy.canInjectMarkerIntoElement && strategy.canInjectMarkerIntoElement(positionParent))) {
          return;
        }
        const viewElement = data.mapper.toViewElement(positionParent);
        const viewRange = view.createRangeIn(viewElement);
        const viewWalker = viewRange.getWalker();
        let positionAfterLastMarker = viewRange.start;
        for (const { item } of viewWalker) {
          if (item.is("element") && data.mapper.toModelElement(item) || item.is("$textProxy")) {
            break;
          }
          if (item.is("element") && item.getCustomProperty("listItemMarker")) {
            positionAfterLastMarker = view.createPositionAfter(item);
            viewWalker.skip(({ previousPosition }) => !previousPosition.isEqual(positionAfterLastMarker));
          }
        }
        data.viewPosition = positionAfterLastMarker;
      };
    }
    function removeCustomMarkerElements(viewElement, viewWriter, mapper) {
      while (viewElement.parent.is("attributeElement") && viewElement.parent.getCustomProperty("listItemWrapper")) {
        viewWriter.unwrap(viewWriter.createRangeOn(viewElement), viewElement.parent);
      }
      const markersToRemove = [];
      collectMarkersToRemove(viewWriter.createPositionBefore(viewElement).getWalker({
        direction: "backward"
      }));
      collectMarkersToRemove(viewWriter.createRangeIn(viewElement).getWalker());
      for (const marker of markersToRemove) {
        viewWriter.remove(marker);
      }
      function collectMarkersToRemove(viewWalker) {
        for (const { item } of viewWalker) {
          if (item.is("element") && mapper.toModelElement(item)) {
            break;
          }
          if (item.is("element") && item.getCustomProperty("listItemMarker")) {
            markersToRemove.push(item);
          }
        }
      }
    }
    function insertCustomMarkerElements(listItem, viewElement, strategies, writer, { dataPipeline }) {
      let viewRange = writer.createRangeOn(viewElement);
      if (!isFirstBlockOfListItem(listItem)) {
        return viewRange;
      }
      for (const strategy of strategies) {
        if (strategy.scope != "itemMarker") {
          continue;
        }
        const markerElement = strategy.createElement(writer, listItem, {
          dataPipeline
        });
        if (!markerElement) {
          continue;
        }
        writer.setCustomProperty("listItemMarker", true, markerElement);
        if (strategy.canInjectMarkerIntoElement && strategy.canInjectMarkerIntoElement(listItem)) {
          writer.insert(writer.createPositionAt(viewElement, 0), markerElement);
        } else {
          writer.insert(viewRange.start, markerElement);
          viewRange = writer.createRange(writer.createPositionBefore(markerElement), writer.createPositionAfter(viewElement));
        }
        if (!strategy.createWrapperElement || !strategy.canWrapElement) {
          continue;
        }
        const wrapper = strategy.createWrapperElement(writer, listItem, {
          dataPipeline
        });
        writer.setCustomProperty("listItemWrapper", true, wrapper);
        if (strategy.canWrapElement(listItem)) {
          viewRange = writer.wrap(viewRange, wrapper);
        } else {
          viewRange = writer.wrap(writer.createRangeOn(markerElement), wrapper);
          viewRange = writer.createRange(viewRange.start, writer.createPositionAfter(viewElement));
        }
      }
      return viewRange;
    }
    function unwrapListItemBlock(viewElement, viewWriter) {
      let attributeElement = viewElement.parent;
      while (attributeElement.is("attributeElement") && [
        "ul",
        "ol",
        "li"
      ].includes(attributeElement.name)) {
        const parentElement = attributeElement.parent;
        viewWriter.unwrap(viewWriter.createRangeOn(viewElement), attributeElement);
        attributeElement = parentElement;
      }
    }
    function wrapListItemBlock(listItem, viewRange, strategies, writer) {
      if (!listItem.hasAttribute("listIndent")) {
        return;
      }
      const listItemIndent = listItem.getAttribute("listIndent");
      let currentListItem = listItem;
      for (let indent2 = listItemIndent; indent2 >= 0; indent2--) {
        const listItemViewElement = createListItemElement(writer, indent2, currentListItem.getAttribute("listItemId"));
        const listViewElement = createListElement(writer, indent2, currentListItem.getAttribute("listType"));
        for (const strategy of strategies) {
          if ((strategy.scope == "list" || strategy.scope == "item") && currentListItem.hasAttribute(strategy.attributeName)) {
            strategy.setAttributeOnDowncast(writer, currentListItem.getAttribute(strategy.attributeName), strategy.scope == "list" ? listViewElement : listItemViewElement);
          }
        }
        viewRange = writer.wrap(viewRange, listItemViewElement);
        viewRange = writer.wrap(viewRange, listViewElement);
        if (indent2 == 0) {
          break;
        }
        currentListItem = ListWalker.first(currentListItem, {
          lowerIndent: true
        });
        if (!currentListItem) {
          break;
        }
      }
    }
    function createAttributesConsumer(attributeNames) {
      return (node, consumable) => {
        const events = [];
        for (const attributeName of attributeNames) {
          if (node.hasAttribute(attributeName)) {
            events.push(`attribute:${attributeName}`);
          }
        }
        if (!events.every((event) => consumable.test(node, event) !== false)) {
          return false;
        }
        events.forEach((event) => consumable.consume(node, event));
        return true;
      };
    }
    function shouldUseBogusParagraph(item, attributeNames, blocks = getAllListItemBlocks(item)) {
      if (!isListItemBlock(item)) {
        return false;
      }
      for (const attributeKey of item.getAttributeKeys()) {
        if (attributeKey.startsWith("selection:")) {
          continue;
        }
        if (!attributeNames.includes(attributeKey)) {
          return false;
        }
      }
      return blocks.length < 2;
    }
    const LIST_BASE_ATTRIBUTES = [
      "listType",
      "listIndent",
      "listItemId"
    ];
    class ListEditing extends Plugin {
      /**
      * @inheritDoc
      */
      constructor(editor2) {
        super(editor2);
        /**
        * The list of registered downcast strategies.
        */
        __publicField(this, "_downcastStrategies", []);
        editor2.config.define("list.multiBlock", true);
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "ListEditing";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          Enter,
          Delete,
          ListUtils,
          ClipboardPipeline
        ];
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor2 = this.editor;
        const model = editor2.model;
        const multiBlock = editor2.config.get("list.multiBlock");
        if (editor2.plugins.has("LegacyListEditing")) {
          throw new CKEditorError("list-feature-conflict", this, {
            conflictPlugin: "LegacyListEditing"
          });
        }
        model.schema.register("$listItem", {
          allowAttributes: LIST_BASE_ATTRIBUTES
        });
        if (multiBlock) {
          model.schema.extend("$container", {
            allowAttributesOf: "$listItem"
          });
          model.schema.extend("$block", {
            allowAttributesOf: "$listItem"
          });
          model.schema.extend("$blockObject", {
            allowAttributesOf: "$listItem"
          });
        } else {
          model.schema.register("listItem", {
            inheritAllFrom: "$block",
            allowAttributesOf: "$listItem"
          });
        }
        for (const attribute of LIST_BASE_ATTRIBUTES) {
          model.schema.setAttributeProperties(attribute, {
            copyOnReplace: true
          });
        }
        editor2.commands.add("numberedList", new ListCommand(editor2, "numbered"));
        editor2.commands.add("bulletedList", new ListCommand(editor2, "bulleted"));
        editor2.commands.add("customNumberedList", new ListCommand(editor2, "customNumbered", {
          multiLevel: true
        }));
        editor2.commands.add("customBulletedList", new ListCommand(editor2, "customBulleted", {
          multiLevel: true
        }));
        editor2.commands.add("indentList", new ListIndentCommand(editor2, "forward"));
        editor2.commands.add("outdentList", new ListIndentCommand(editor2, "backward"));
        editor2.commands.add("splitListItemBefore", new ListSplitCommand(editor2, "before"));
        editor2.commands.add("splitListItemAfter", new ListSplitCommand(editor2, "after"));
        if (multiBlock) {
          editor2.commands.add("mergeListItemBackward", new ListMergeCommand(editor2, "backward"));
          editor2.commands.add("mergeListItemForward", new ListMergeCommand(editor2, "forward"));
        }
        this._setupDeleteIntegration();
        this._setupEnterIntegration();
        this._setupTabIntegration();
        this._setupClipboardIntegration();
        this._setupAccessibilityIntegration();
      }
      /**
      * @inheritDoc
      */
      afterInit() {
        const editor2 = this.editor;
        const commands = editor2.commands;
        const indent2 = commands.get("indent");
        const outdent2 = commands.get("outdent");
        if (indent2) {
          indent2.registerChildCommand(commands.get("indentList"), {
            priority: "high"
          });
        }
        if (outdent2) {
          outdent2.registerChildCommand(commands.get("outdentList"), {
            priority: "lowest"
          });
        }
        this._setupModelPostFixing();
        this._setupConversion();
      }
      /**
      * Registers a downcast strategy.
      *
      * **Note**: Strategies must be registered in the `Plugin#init()` phase so that it can be applied
      * in the `ListEditing#afterInit()`.
      *
      * @param strategy The downcast strategy to register.
      */
      registerDowncastStrategy(strategy) {
        this._downcastStrategies.push(strategy);
      }
      /**
      * Returns list of model attribute names that should affect downcast conversion.
      */
      getListAttributeNames() {
        return [
          ...LIST_BASE_ATTRIBUTES,
          ...this._downcastStrategies.map((strategy) => strategy.attributeName)
        ];
      }
      /**
      * Attaches the listener to the {@link module:engine/view/document~Document#event:delete} event and handles backspace/delete
      * keys in and around document lists.
      */
      _setupDeleteIntegration() {
        const editor2 = this.editor;
        const mergeBackwardCommand = editor2.commands.get("mergeListItemBackward");
        const mergeForwardCommand = editor2.commands.get("mergeListItemForward");
        this.listenTo(editor2.editing.view.document, "delete", (evt, data) => {
          const selection = editor2.model.document.selection;
          if (getSelectedBlockObject(editor2.model)) {
            return;
          }
          editor2.model.change(() => {
            const firstPosition = selection.getFirstPosition();
            if (selection.isCollapsed && data.direction == "backward") {
              if (!firstPosition.isAtStart) {
                return;
              }
              const positionParent = firstPosition.parent;
              if (!isListItemBlock(positionParent)) {
                return;
              }
              const previousBlock = ListWalker.first(positionParent, {
                sameAttributes: "listType",
                sameIndent: true
              });
              if (!previousBlock && positionParent.getAttribute("listIndent") === 0) {
                if (!isLastBlockOfListItem(positionParent)) {
                  editor2.execute("splitListItemAfter");
                }
                editor2.execute("outdentList");
              } else {
                if (!mergeBackwardCommand || !mergeBackwardCommand.isEnabled) {
                  return;
                }
                mergeBackwardCommand.execute({
                  shouldMergeOnBlocksContentLevel: shouldMergeOnBlocksContentLevel(editor2.model, "backward")
                });
              }
              data.preventDefault();
              evt.stop();
            } else {
              if (selection.isCollapsed && !selection.getLastPosition().isAtEnd) {
                return;
              }
              if (!mergeForwardCommand || !mergeForwardCommand.isEnabled) {
                return;
              }
              mergeForwardCommand.execute({
                shouldMergeOnBlocksContentLevel: shouldMergeOnBlocksContentLevel(editor2.model, "forward")
              });
              data.preventDefault();
              evt.stop();
            }
          });
        }, {
          context: "li"
        });
      }
      /**
      * Attaches a listener to the {@link module:engine/view/document~Document#event:enter} event and handles enter key press
      * in document lists.
      */
      _setupEnterIntegration() {
        const editor2 = this.editor;
        const model = editor2.model;
        const commands = editor2.commands;
        const enterCommand = commands.get("enter");
        this.listenTo(editor2.editing.view.document, "enter", (evt, data) => {
          const doc = model.document;
          const positionParent = doc.selection.getFirstPosition().parent;
          if (doc.selection.isCollapsed && isListItemBlock(positionParent) && positionParent.isEmpty && !data.isSoft) {
            const isFirstBlock = isFirstBlockOfListItem(positionParent);
            const isLastBlock = isLastBlockOfListItem(positionParent);
            if (isFirstBlock && isLastBlock) {
              editor2.execute("outdentList");
              data.preventDefault();
              evt.stop();
            } else if (isFirstBlock && !isLastBlock) {
              editor2.execute("splitListItemAfter");
              data.preventDefault();
              evt.stop();
            } else if (isLastBlock) {
              editor2.execute("splitListItemBefore");
              data.preventDefault();
              evt.stop();
            }
          }
        }, {
          context: "li"
        });
        this.listenTo(enterCommand, "afterExecute", () => {
          const splitCommand = commands.get("splitListItemBefore");
          splitCommand.refresh();
          if (!splitCommand.isEnabled) {
            return;
          }
          const doc = editor2.model.document;
          const positionParent = doc.selection.getLastPosition().parent;
          const listItemBlocks = getAllListItemBlocks(positionParent);
          if (listItemBlocks.length === 2) {
            splitCommand.execute();
          }
        });
      }
      /**
      * Attaches a listener to the {@link module:engine/view/document~Document#event:tab} event and handles tab key and tab+shift keys
      * presses in document lists.
      */
      _setupTabIntegration() {
        const editor2 = this.editor;
        this.listenTo(editor2.editing.view.document, "tab", (evt, data) => {
          const commandName = data.shiftKey ? "outdentList" : "indentList";
          const command = this.editor.commands.get(commandName);
          if (command.isEnabled) {
            editor2.execute(commandName);
            data.stopPropagation();
            data.preventDefault();
            evt.stop();
          }
        }, {
          context: "li"
        });
      }
      /**
      * Registers the conversion helpers for the document-list feature.
      */
      _setupConversion() {
        const editor2 = this.editor;
        const model = editor2.model;
        const attributeNames = this.getListAttributeNames();
        const multiBlock = editor2.config.get("list.multiBlock");
        const elementName = multiBlock ? "paragraph" : "listItem";
        editor2.conversion.for("upcast").elementToElement({
          view: "li",
          model: (viewElement, { writer }) => writer.createElement(elementName, {
            listType: ""
          })
        }).elementToElement({
          view: "p",
          model: (viewElement, { writer }) => {
            if (viewElement.parent && viewElement.parent.is("element", "li")) {
              return writer.createElement(elementName, {
                listType: ""
              });
            }
            return null;
          },
          converterPriority: "high"
        }).add((dispatcher) => {
          dispatcher.on("element:li", listItemUpcastConverter());
        });
        if (!multiBlock) {
          editor2.conversion.for("downcast").elementToElement({
            model: "listItem",
            view: "p"
          });
        }
        editor2.conversion.for("editingDowncast").elementToElement({
          model: elementName,
          view: bogusParagraphCreator(attributeNames),
          converterPriority: "high"
        }).add((dispatcher) => {
          dispatcher.on("attribute", listItemDowncastConverter(attributeNames, this._downcastStrategies, model));
          dispatcher.on("remove", listItemDowncastRemoveConverter(model.schema));
        });
        editor2.conversion.for("dataDowncast").elementToElement({
          model: elementName,
          view: bogusParagraphCreator(attributeNames, {
            dataPipeline: true
          }),
          converterPriority: "high"
        }).add((dispatcher) => {
          dispatcher.on("attribute", listItemDowncastConverter(attributeNames, this._downcastStrategies, model, {
            dataPipeline: true
          }));
        });
        const modelToViewPositionMapper = createModelToViewPositionMapper(this._downcastStrategies, editor2.editing.view);
        editor2.editing.mapper.on("modelToViewPosition", modelToViewPositionMapper);
        editor2.data.mapper.on("modelToViewPosition", modelToViewPositionMapper);
        this.listenTo(model.document, "change:data", reconvertItemsOnDataChange(model, editor2.editing, attributeNames, this), {
          priority: "high"
        });
        this.on("checkAttributes:item", (evt, { viewElement, modelAttributes }) => {
          if (viewElement.id != modelAttributes.listItemId) {
            evt.return = true;
            evt.stop();
          }
        });
        this.on("checkAttributes:list", (evt, { viewElement, modelAttributes }) => {
          if (viewElement.name != getViewElementNameForListType(modelAttributes.listType) || viewElement.id != getViewElementIdForListType(modelAttributes.listType, modelAttributes.listIndent)) {
            evt.return = true;
            evt.stop();
          }
        });
      }
      /**
      * Registers model post-fixers.
      */
      _setupModelPostFixing() {
        const model = this.editor.model;
        const attributeNames = this.getListAttributeNames();
        model.document.registerPostFixer((writer) => modelChangePostFixer$1(model, writer, attributeNames, this));
        this.on("postFixer", (evt, { listNodes, writer }) => {
          evt.return = fixListIndents(listNodes, writer) || evt.return;
        }, {
          priority: "high"
        });
        this.on("postFixer", (evt, { listNodes, writer, seenIds }) => {
          evt.return = fixListItemIds(listNodes, seenIds, writer) || evt.return;
        }, {
          priority: "high"
        });
      }
      /**
      * Integrates the feature with the clipboard via {@link module:engine/model/model~Model#insertContent} and
      * {@link module:engine/model/model~Model#getSelectedContent}.
      */
      _setupClipboardIntegration() {
        const model = this.editor.model;
        const clipboardPipeline = this.editor.plugins.get("ClipboardPipeline");
        this.listenTo(model, "insertContent", createModelIndentPasteFixer(model), {
          priority: "high"
        });
        this.listenTo(clipboardPipeline, "outputTransformation", (evt, data) => {
          model.change((writer) => {
            const allContentChildren = Array.from(data.content.getChildren());
            const lastItem = allContentChildren[allContentChildren.length - 1];
            if (allContentChildren.length > 1 && lastItem.is("element") && lastItem.isEmpty) {
              const contentChildrenExceptLastItem = allContentChildren.slice(0, -1);
              if (contentChildrenExceptLastItem.every(isListItemBlock)) {
                writer.remove(lastItem);
              }
            }
            if (data.method == "copy" || data.method == "cut") {
              const allChildren = Array.from(data.content.getChildren());
              const isSingleListItemSelected = isSingleListItem(allChildren);
              if (isSingleListItemSelected) {
                removeListAttributes(allChildren, writer);
              }
            }
          });
        });
      }
      /**
      * Informs editor accessibility features about keystrokes brought by the plugin.
      */
      _setupAccessibilityIntegration() {
        const editor2 = this.editor;
        const t2 = editor2.t;
        editor2.accessibility.addKeystrokeInfoGroup({
          id: "list",
          label: t2("Keystrokes that can be used in a list"),
          keystrokes: [
            {
              label: t2("Increase list item indent"),
              keystroke: "Tab"
            },
            {
              label: t2("Decrease list item indent"),
              keystroke: "Shift+Tab"
            }
          ]
        });
      }
    }
    function modelChangePostFixer$1(model, writer, attributeNames, listEditing) {
      const changes = model.document.differ.getChanges();
      const itemToListHead = /* @__PURE__ */ new Map();
      const multiBlock = listEditing.editor.config.get("list.multiBlock");
      let applied = false;
      for (const entry of changes) {
        if (entry.type == "insert" && entry.name != "$text") {
          const item = entry.position.nodeAfter;
          if (!model.schema.checkAttribute(item, "listItemId")) {
            for (const attributeName of Array.from(item.getAttributeKeys())) {
              if (attributeNames.includes(attributeName)) {
                writer.removeAttribute(attributeName, item);
                applied = true;
              }
            }
          }
          findAndAddListHeadToMap(entry.position, itemToListHead);
          if (!entry.attributes.has("listItemId")) {
            findAndAddListHeadToMap(entry.position.getShiftedBy(entry.length), itemToListHead);
          }
          for (const { item: innerItem, previousPosition } of model.createRangeIn(item)) {
            if (isListItemBlock(innerItem)) {
              findAndAddListHeadToMap(previousPosition, itemToListHead);
            }
          }
        } else if (entry.type == "remove") {
          findAndAddListHeadToMap(entry.position, itemToListHead);
        } else if (entry.type == "attribute" && attributeNames.includes(entry.attributeKey)) {
          findAndAddListHeadToMap(entry.range.start, itemToListHead);
          if (entry.attributeNewValue === null) {
            findAndAddListHeadToMap(entry.range.start.getShiftedBy(1), itemToListHead);
          }
        }
        if (!multiBlock && entry.type == "attribute" && LIST_BASE_ATTRIBUTES.includes(entry.attributeKey)) {
          const element = entry.range.start.nodeAfter;
          if (entry.attributeNewValue === null && element && element.is("element", "listItem")) {
            writer.rename(element, "paragraph");
            applied = true;
          } else if (entry.attributeOldValue === null && element && element.is("element") && element.name != "listItem") {
            writer.rename(element, "listItem");
            applied = true;
          }
        }
      }
      const seenIds = /* @__PURE__ */ new Set();
      for (const listHead of itemToListHead.values()) {
        applied = listEditing.fire("postFixer", {
          listNodes: new ListBlocksIterable(listHead),
          listHead,
          writer,
          seenIds
        }) || applied;
      }
      return applied;
    }
    function createModelIndentPasteFixer(model) {
      return (evt, [content, selectable]) => {
        const items = content.is("documentFragment") ? Array.from(content.getChildren()) : [
          content
        ];
        if (!items.length) {
          return;
        }
        const selection = selectable ? model.createSelection(selectable) : model.document.selection;
        const position = selection.getFirstPosition();
        let refItem;
        if (isListItemBlock(position.parent)) {
          refItem = position.parent;
        } else if (isListItemBlock(position.nodeBefore)) {
          refItem = position.nodeBefore;
        } else {
          return;
        }
        model.change((writer) => {
          const refType = refItem.getAttribute("listType");
          const refIndent = refItem.getAttribute("listIndent");
          const firstElementIndent = items[0].getAttribute("listIndent") || 0;
          const indentDiff = Math.max(refIndent - firstElementIndent, 0);
          for (const item of items) {
            const isListItem = isListItemBlock(item);
            if (refItem.is("element", "listItem") && item.is("element", "paragraph")) {
              writer.rename(item, "listItem");
            }
            writer.setAttributes({
              listIndent: (isListItem ? item.getAttribute("listIndent") : 0) + indentDiff,
              listItemId: isListItem ? item.getAttribute("listItemId") : ListItemUid.next(),
              listType: refType
            }, item);
          }
        });
      };
    }
    function shouldMergeOnBlocksContentLevel(model, direction) {
      const selection = model.document.selection;
      if (!selection.isCollapsed) {
        return !getSelectedBlockObject(model);
      }
      if (direction === "forward") {
        return true;
      }
      const firstPosition = selection.getFirstPosition();
      const positionParent = firstPosition.parent;
      const previousSibling = positionParent.previousSibling;
      if (model.schema.isObject(previousSibling)) {
        return false;
      }
      if (previousSibling.isEmpty) {
        return true;
      }
      return isSingleListItem([
        positionParent,
        previousSibling
      ]);
    }
    function createUIComponents(editor2, commandName, label, icon) {
      editor2.ui.componentFactory.add(commandName, () => {
        const buttonView = _createButton(ButtonView, editor2, commandName, label, icon);
        buttonView.set({
          tooltip: true,
          isToggleable: true
        });
        return buttonView;
      });
      editor2.ui.componentFactory.add(`menuBar:${commandName}`, () => {
        const buttonView = _createButton(MenuBarMenuListItemButtonView, editor2, commandName, label, icon);
        buttonView.set({
          role: "menuitemcheckbox",
          isToggleable: true
        });
        return buttonView;
      });
    }
    function _createButton(ButtonClass, editor2, commandName, label, icon) {
      const command = editor2.commands.get(commandName);
      const view = new ButtonClass(editor2.locale);
      view.set({
        label,
        icon
      });
      view.bind("isOn", "isEnabled").to(command, "value", "isEnabled");
      view.on("execute", () => {
        editor2.execute(commandName);
        editor2.editing.view.focus();
      });
      return view;
    }
    class ListUI extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "ListUI";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
      /**
      * @inheritDoc
      */
      init() {
        const t2 = this.editor.t;
        if (!this.editor.ui.componentFactory.has("numberedList")) {
          createUIComponents(this.editor, "numberedList", t2("Numbered List"), icons.numberedList);
        }
        if (!this.editor.ui.componentFactory.has("bulletedList")) {
          createUIComponents(this.editor, "bulletedList", t2("Bulleted List"), icons.bulletedList);
        }
      }
    }
    class List extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          ListEditing,
          ListUI
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "List";
      }
      /**
      * @inheritDoc
      */
      static get isOfficialPlugin() {
        return true;
      }
    }
    const LIST_STYLE_TYPES = [
      {
        listStyle: "disc",
        typeAttribute: "disc",
        listType: "bulleted"
      },
      {
        listStyle: "circle",
        typeAttribute: "circle",
        listType: "bulleted"
      },
      {
        listStyle: "square",
        typeAttribute: "square",
        listType: "bulleted"
      },
      {
        listStyle: "decimal",
        typeAttribute: "1",
        listType: "numbered"
      },
      {
        listStyle: "decimal-leading-zero",
        typeAttribute: null,
        listType: "numbered"
      },
      {
        listStyle: "lower-roman",
        typeAttribute: "i",
        listType: "numbered"
      },
      {
        listStyle: "upper-roman",
        typeAttribute: "I",
        listType: "numbered"
      },
      {
        listStyle: "lower-alpha",
        typeAttribute: "a",
        listType: "numbered"
      },
      {
        listStyle: "upper-alpha",
        typeAttribute: "A",
        listType: "numbered"
      },
      {
        listStyle: "lower-latin",
        typeAttribute: "a",
        listType: "numbered"
      },
      {
        listStyle: "upper-latin",
        typeAttribute: "A",
        listType: "numbered"
      }
    ];
    for (const { listStyle, typeAttribute, listType } of LIST_STYLE_TYPES) {
    }
    function getDefaults() {
      return {
        baseUrl: null,
        breaks: false,
        extensions: null,
        gfm: true,
        headerIds: true,
        headerPrefix: "",
        highlight: null,
        langPrefix: "language-",
        mangle: true,
        pedantic: false,
        renderer: null,
        sanitize: false,
        sanitizer: null,
        silent: false,
        smartLists: false,
        smartypants: false,
        tokenizer: null,
        walkTokens: null,
        xhtml: false
      };
    }
    let defaults = getDefaults();
    function changeDefaults(newDefaults) {
      defaults = newDefaults;
    }
    const escapeTest = /[&<>"']/;
    const escapeReplace = /[&<>"']/g;
    const escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
    const escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;
    const escapeReplacements = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    const getEscapeReplacement = (ch) => escapeReplacements[ch];
    function escape(html2, encode2) {
      if (encode2) {
        if (escapeTest.test(html2)) {
          return html2.replace(escapeReplace, getEscapeReplacement);
        }
      } else {
        if (escapeTestNoEncode.test(html2)) {
          return html2.replace(escapeReplaceNoEncode, getEscapeReplacement);
        }
      }
      return html2;
    }
    const unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
    function unescape(html2) {
      return html2.replace(unescapeTest, (_2, n2) => {
        n2 = n2.toLowerCase();
        if (n2 === "colon") return ":";
        if (n2.charAt(0) === "#") {
          return n2.charAt(1) === "x" ? String.fromCharCode(parseInt(n2.substring(2), 16)) : String.fromCharCode(+n2.substring(1));
        }
        return "";
      });
    }
    const caret = /(^|[^\[])\^/g;
    function edit(regex, opt) {
      regex = regex.source || regex;
      opt = opt || "";
      const obj = {
        replace: (name, val) => {
          val = val.source || val;
          val = val.replace(caret, "$1");
          regex = regex.replace(name, val);
          return obj;
        },
        getRegex: () => {
          return new RegExp(regex, opt);
        }
      };
      return obj;
    }
    const nonWordAndColonTest = /[^\w:]/g;
    const originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
    function cleanUrl(sanitize, base, href) {
      if (sanitize) {
        let prot;
        try {
          prot = decodeURIComponent(unescape(href)).replace(nonWordAndColonTest, "").toLowerCase();
        } catch (e2) {
          return null;
        }
        if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) {
          return null;
        }
      }
      if (base && !originIndependentUrl.test(href)) {
        href = resolveUrl$1(base, href);
      }
      try {
        href = encodeURI(href).replace(/%25/g, "%");
      } catch (e2) {
        return null;
      }
      return href;
    }
    const baseUrls = {};
    const justDomain = /^[^:]+:\/*[^/]*$/;
    const protocol = /^([^:]+:)[\s\S]*$/;
    const domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
    function resolveUrl$1(base, href) {
      if (!baseUrls[" " + base]) {
        if (justDomain.test(base)) {
          baseUrls[" " + base] = base + "/";
        } else {
          baseUrls[" " + base] = rtrim(base, "/", true);
        }
      }
      base = baseUrls[" " + base];
      const relativeBase = base.indexOf(":") === -1;
      if (href.substring(0, 2) === "//") {
        if (relativeBase) {
          return href;
        }
        return base.replace(protocol, "$1") + href;
      } else if (href.charAt(0) === "/") {
        if (relativeBase) {
          return href;
        }
        return base.replace(domain, "$1") + href;
      } else {
        return base + href;
      }
    }
    const noopTest = { exec: function noopTest2() {
    } };
    function merge(obj) {
      let i2 = 1, target, key;
      for (; i2 < arguments.length; i2++) {
        target = arguments[i2];
        for (key in target) {
          if (Object.prototype.hasOwnProperty.call(target, key)) {
            obj[key] = target[key];
          }
        }
      }
      return obj;
    }
    function splitCells(tableRow, count2) {
      const row = tableRow.replace(/\|/g, (match, offset2, str) => {
        let escaped = false, curr = offset2;
        while (--curr >= 0 && str[curr] === "\\") escaped = !escaped;
        if (escaped) {
          return "|";
        } else {
          return " |";
        }
      }), cells = row.split(/ \|/);
      let i2 = 0;
      if (!cells[0].trim()) {
        cells.shift();
      }
      if (cells.length > 0 && !cells[cells.length - 1].trim()) {
        cells.pop();
      }
      if (cells.length > count2) {
        cells.splice(count2);
      } else {
        while (cells.length < count2) cells.push("");
      }
      for (; i2 < cells.length; i2++) {
        cells[i2] = cells[i2].trim().replace(/\\\|/g, "|");
      }
      return cells;
    }
    function rtrim(str, c2, invert2) {
      const l2 = str.length;
      if (l2 === 0) {
        return "";
      }
      let suffLen = 0;
      while (suffLen < l2) {
        const currChar = str.charAt(l2 - suffLen - 1);
        if (currChar === c2 && !invert2) {
          suffLen++;
        } else if (currChar !== c2 && invert2) {
          suffLen++;
        } else {
          break;
        }
      }
      return str.substr(0, l2 - suffLen);
    }
    function findClosingBracket(str, b2) {
      if (str.indexOf(b2[1]) === -1) {
        return -1;
      }
      const l2 = str.length;
      let level = 0, i2 = 0;
      for (; i2 < l2; i2++) {
        if (str[i2] === "\\") {
          i2++;
        } else if (str[i2] === b2[0]) {
          level++;
        } else if (str[i2] === b2[1]) {
          level--;
          if (level < 0) {
            return i2;
          }
        }
      }
      return -1;
    }
    function checkSanitizeDeprecation(opt) {
      if (opt && opt.sanitize && !opt.silent) {
        console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
      }
    }
    function repeatString(pattern, count2) {
      if (count2 < 1) {
        return "";
      }
      let result2 = "";
      while (count2 > 1) {
        if (count2 & 1) {
          result2 += pattern;
        }
        count2 >>= 1;
        pattern += pattern;
      }
      return result2 + pattern;
    }
    function outputLink(cap, link2, raw, lexer) {
      const href = link2.href;
      const title = link2.title ? escape(link2.title) : null;
      const text2 = cap[1].replace(/\\([\[\]])/g, "$1");
      if (cap[0].charAt(0) !== "!") {
        lexer.state.inLink = true;
        const token = {
          type: "link",
          raw,
          href,
          title,
          text: text2,
          tokens: lexer.inlineTokens(text2, [])
        };
        lexer.state.inLink = false;
        return token;
      } else {
        return {
          type: "image",
          raw,
          href,
          title,
          text: escape(text2)
        };
      }
    }
    function indentCodeCompensation(raw, text2) {
      const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
      if (matchIndentToCode === null) {
        return text2;
      }
      const indentToCode = matchIndentToCode[1];
      return text2.split("\n").map((node) => {
        const matchIndentInNode = node.match(/^\s+/);
        if (matchIndentInNode === null) {
          return node;
        }
        const [indentInNode] = matchIndentInNode;
        if (indentInNode.length >= indentToCode.length) {
          return node.slice(indentToCode.length);
        }
        return node;
      }).join("\n");
    }
    class Tokenizer {
      constructor(options) {
        this.options = options || defaults;
      }
      space(src) {
        const cap = this.rules.block.newline.exec(src);
        if (cap && cap[0].length > 0) {
          return {
            type: "space",
            raw: cap[0]
          };
        }
      }
      code(src) {
        const cap = this.rules.block.code.exec(src);
        if (cap) {
          const text2 = cap[0].replace(/^ {1,4}/gm, "");
          return {
            type: "code",
            raw: cap[0],
            codeBlockStyle: "indented",
            text: !this.options.pedantic ? rtrim(text2, "\n") : text2
          };
        }
      }
      fences(src) {
        const cap = this.rules.block.fences.exec(src);
        if (cap) {
          const raw = cap[0];
          const text2 = indentCodeCompensation(raw, cap[3] || "");
          return {
            type: "code",
            raw,
            lang: cap[2] ? cap[2].trim() : cap[2],
            text: text2
          };
        }
      }
      heading(src) {
        const cap = this.rules.block.heading.exec(src);
        if (cap) {
          let text2 = cap[2].trim();
          if (/#$/.test(text2)) {
            const trimmed = rtrim(text2, "#");
            if (this.options.pedantic) {
              text2 = trimmed.trim();
            } else if (!trimmed || / $/.test(trimmed)) {
              text2 = trimmed.trim();
            }
          }
          const token = {
            type: "heading",
            raw: cap[0],
            depth: cap[1].length,
            text: text2,
            tokens: []
          };
          this.lexer.inline(token.text, token.tokens);
          return token;
        }
      }
      hr(src) {
        const cap = this.rules.block.hr.exec(src);
        if (cap) {
          return {
            type: "hr",
            raw: cap[0]
          };
        }
      }
      blockquote(src) {
        const cap = this.rules.block.blockquote.exec(src);
        if (cap) {
          const text2 = cap[0].replace(/^ *> ?/gm, "");
          return {
            type: "blockquote",
            raw: cap[0],
            tokens: this.lexer.blockTokens(text2, []),
            text: text2
          };
        }
      }
      list(src) {
        let cap = this.rules.block.list.exec(src);
        if (cap) {
          let raw, istask, ischecked, indent2, i2, blankLine, endsWithBlankLine, line, nextLine, rawLine, itemContents, endEarly;
          let bull = cap[1].trim();
          const isordered = bull.length > 1;
          const list = {
            type: "list",
            raw: "",
            ordered: isordered,
            start: isordered ? +bull.slice(0, -1) : "",
            loose: false,
            items: []
          };
          bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
          if (this.options.pedantic) {
            bull = isordered ? bull : "[*+-]";
          }
          const itemRegex = new RegExp(`^( {0,3}${bull})((?: [^\\n]*)?(?:\\n|$))`);
          while (src) {
            endEarly = false;
            if (!(cap = itemRegex.exec(src))) {
              break;
            }
            if (this.rules.block.hr.test(src)) {
              break;
            }
            raw = cap[0];
            src = src.substring(raw.length);
            line = cap[2].split("\n", 1)[0];
            nextLine = src.split("\n", 1)[0];
            if (this.options.pedantic) {
              indent2 = 2;
              itemContents = line.trimLeft();
            } else {
              indent2 = cap[2].search(/[^ ]/);
              indent2 = indent2 > 4 ? 1 : indent2;
              itemContents = line.slice(indent2);
              indent2 += cap[1].length;
            }
            blankLine = false;
            if (!line && /^ *$/.test(nextLine)) {
              raw += nextLine + "\n";
              src = src.substring(nextLine.length + 1);
              endEarly = true;
            }
            if (!endEarly) {
              const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent2 - 1)}}(?:[*+-]|\\d{1,9}[.)])`);
              while (src) {
                rawLine = src.split("\n", 1)[0];
                line = rawLine;
                if (this.options.pedantic) {
                  line = line.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
                }
                if (nextBulletRegex.test(line)) {
                  break;
                }
                if (line.search(/[^ ]/) >= indent2 || !line.trim()) {
                  itemContents += "\n" + line.slice(indent2);
                } else if (!blankLine) {
                  itemContents += "\n" + line;
                } else {
                  break;
                }
                if (!blankLine && !line.trim()) {
                  blankLine = true;
                }
                raw += rawLine + "\n";
                src = src.substring(rawLine.length + 1);
              }
            }
            if (!list.loose) {
              if (endsWithBlankLine) {
                list.loose = true;
              } else if (/\n *\n *$/.test(raw)) {
                endsWithBlankLine = true;
              }
            }
            if (this.options.gfm) {
              istask = /^\[[ xX]\] /.exec(itemContents);
              if (istask) {
                ischecked = istask[0] !== "[ ] ";
                itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
              }
            }
            list.items.push({
              type: "list_item",
              raw,
              task: !!istask,
              checked: ischecked,
              loose: false,
              text: itemContents
            });
            list.raw += raw;
          }
          list.items[list.items.length - 1].raw = raw.trimRight();
          list.items[list.items.length - 1].text = itemContents.trimRight();
          list.raw = list.raw.trimRight();
          const l2 = list.items.length;
          for (i2 = 0; i2 < l2; i2++) {
            this.lexer.state.top = false;
            list.items[i2].tokens = this.lexer.blockTokens(list.items[i2].text, []);
            const spacers = list.items[i2].tokens.filter((t2) => t2.type === "space");
            const hasMultipleLineBreaks = spacers.every((t2) => {
              const chars = t2.raw.split("");
              let lineBreaks = 0;
              for (const char of chars) {
                if (char === "\n") {
                  lineBreaks += 1;
                }
                if (lineBreaks > 1) {
                  return true;
                }
              }
              return false;
            });
            if (!list.loose && spacers.length && hasMultipleLineBreaks) {
              list.loose = true;
              list.items[i2].loose = true;
            }
          }
          return list;
        }
      }
      html(src) {
        const cap = this.rules.block.html.exec(src);
        if (cap) {
          const token = {
            type: "html",
            raw: cap[0],
            pre: !this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"),
            text: cap[0]
          };
          if (this.options.sanitize) {
            token.type = "paragraph";
            token.text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]);
            token.tokens = [];
            this.lexer.inline(token.text, token.tokens);
          }
          return token;
        }
      }
      def(src) {
        const cap = this.rules.block.def.exec(src);
        if (cap) {
          if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);
          const tag = cap[1].toLowerCase().replace(/\s+/g, " ");
          return {
            type: "def",
            tag,
            raw: cap[0],
            href: cap[2],
            title: cap[3]
          };
        }
      }
      table(src) {
        const cap = this.rules.block.table.exec(src);
        if (cap) {
          const item = {
            type: "table",
            header: splitCells(cap[1]).map((c2) => {
              return { text: c2 };
            }),
            align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
            rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : []
          };
          if (item.header.length === item.align.length) {
            item.raw = cap[0];
            let l2 = item.align.length;
            let i2, j2, k2, row;
            for (i2 = 0; i2 < l2; i2++) {
              if (/^ *-+: *$/.test(item.align[i2])) {
                item.align[i2] = "right";
              } else if (/^ *:-+: *$/.test(item.align[i2])) {
                item.align[i2] = "center";
              } else if (/^ *:-+ *$/.test(item.align[i2])) {
                item.align[i2] = "left";
              } else {
                item.align[i2] = null;
              }
            }
            l2 = item.rows.length;
            for (i2 = 0; i2 < l2; i2++) {
              item.rows[i2] = splitCells(item.rows[i2], item.header.length).map((c2) => {
                return { text: c2 };
              });
            }
            l2 = item.header.length;
            for (j2 = 0; j2 < l2; j2++) {
              item.header[j2].tokens = [];
              this.lexer.inlineTokens(item.header[j2].text, item.header[j2].tokens);
            }
            l2 = item.rows.length;
            for (j2 = 0; j2 < l2; j2++) {
              row = item.rows[j2];
              for (k2 = 0; k2 < row.length; k2++) {
                row[k2].tokens = [];
                this.lexer.inlineTokens(row[k2].text, row[k2].tokens);
              }
            }
            return item;
          }
        }
      }
      lheading(src) {
        const cap = this.rules.block.lheading.exec(src);
        if (cap) {
          const token = {
            type: "heading",
            raw: cap[0],
            depth: cap[2].charAt(0) === "=" ? 1 : 2,
            text: cap[1],
            tokens: []
          };
          this.lexer.inline(token.text, token.tokens);
          return token;
        }
      }
      paragraph(src) {
        const cap = this.rules.block.paragraph.exec(src);
        if (cap) {
          const token = {
            type: "paragraph",
            raw: cap[0],
            text: cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1],
            tokens: []
          };
          this.lexer.inline(token.text, token.tokens);
          return token;
        }
      }
      text(src) {
        const cap = this.rules.block.text.exec(src);
        if (cap) {
          const token = {
            type: "text",
            raw: cap[0],
            text: cap[0],
            tokens: []
          };
          this.lexer.inline(token.text, token.tokens);
          return token;
        }
      }
      escape(src) {
        const cap = this.rules.inline.escape.exec(src);
        if (cap) {
          return {
            type: "escape",
            raw: cap[0],
            text: escape(cap[1])
          };
        }
      }
      tag(src) {
        const cap = this.rules.inline.tag.exec(src);
        if (cap) {
          if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
            this.lexer.state.inLink = true;
          } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
            this.lexer.state.inLink = false;
          }
          if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            this.lexer.state.inRawBlock = true;
          } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            this.lexer.state.inRawBlock = false;
          }
          return {
            type: this.options.sanitize ? "text" : "html",
            raw: cap[0],
            inLink: this.lexer.state.inLink,
            inRawBlock: this.lexer.state.inRawBlock,
            text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0]
          };
        }
      }
      link(src) {
        const cap = this.rules.inline.link.exec(src);
        if (cap) {
          const trimmedUrl = cap[2].trim();
          if (!this.options.pedantic && /^</.test(trimmedUrl)) {
            if (!/>$/.test(trimmedUrl)) {
              return;
            }
            const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
            if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
              return;
            }
          } else {
            const lastParenIndex = findClosingBracket(cap[2], "()");
            if (lastParenIndex > -1) {
              const start2 = cap[0].indexOf("!") === 0 ? 5 : 4;
              const linkLen = start2 + cap[1].length + lastParenIndex;
              cap[2] = cap[2].substring(0, lastParenIndex);
              cap[0] = cap[0].substring(0, linkLen).trim();
              cap[3] = "";
            }
          }
          let href = cap[2];
          let title = "";
          if (this.options.pedantic) {
            const link2 = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
            if (link2) {
              href = link2[1];
              title = link2[3];
            }
          } else {
            title = cap[3] ? cap[3].slice(1, -1) : "";
          }
          href = href.trim();
          if (/^</.test(href)) {
            if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
              href = href.slice(1);
            } else {
              href = href.slice(1, -1);
            }
          }
          return outputLink(cap, {
            href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
            title: title ? title.replace(this.rules.inline._escapes, "$1") : title
          }, cap[0], this.lexer);
        }
      }
      reflink(src, links) {
        let cap;
        if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
          let link2 = (cap[2] || cap[1]).replace(/\s+/g, " ");
          link2 = links[link2.toLowerCase()];
          if (!link2 || !link2.href) {
            const text2 = cap[0].charAt(0);
            return {
              type: "text",
              raw: text2,
              text: text2
            };
          }
          return outputLink(cap, link2, cap[0], this.lexer);
        }
      }
      emStrong(src, maskedSrc, prevChar = "") {
        let match = this.rules.inline.emStrong.lDelim.exec(src);
        if (!match) return;
        if (match[3] && prevChar.match(/[\p{L}\p{N}]/u)) return;
        const nextChar = match[1] || match[2] || "";
        if (!nextChar || nextChar && (prevChar === "" || this.rules.inline.punctuation.exec(prevChar))) {
          const lLength = match[0].length - 1;
          let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
          const endReg = match[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
          endReg.lastIndex = 0;
          maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
          while ((match = endReg.exec(maskedSrc)) != null) {
            rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
            if (!rDelim) continue;
            rLength = rDelim.length;
            if (match[3] || match[4]) {
              delimTotal += rLength;
              continue;
            } else if (match[5] || match[6]) {
              if (lLength % 3 && !((lLength + rLength) % 3)) {
                midDelimTotal += rLength;
                continue;
              }
            }
            delimTotal -= rLength;
            if (delimTotal > 0) continue;
            rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
            if (Math.min(lLength, rLength) % 2) {
              const text3 = src.slice(1, lLength + match.index + rLength);
              return {
                type: "em",
                raw: src.slice(0, lLength + match.index + rLength + 1),
                text: text3,
                tokens: this.lexer.inlineTokens(text3, [])
              };
            }
            const text2 = src.slice(2, lLength + match.index + rLength - 1);
            return {
              type: "strong",
              raw: src.slice(0, lLength + match.index + rLength + 1),
              text: text2,
              tokens: this.lexer.inlineTokens(text2, [])
            };
          }
        }
      }
      codespan(src) {
        const cap = this.rules.inline.code.exec(src);
        if (cap) {
          let text2 = cap[2].replace(/\n/g, " ");
          const hasNonSpaceChars = /[^ ]/.test(text2);
          const hasSpaceCharsOnBothEnds = /^ /.test(text2) && / $/.test(text2);
          if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
            text2 = text2.substring(1, text2.length - 1);
          }
          text2 = escape(text2, true);
          return {
            type: "codespan",
            raw: cap[0],
            text: text2
          };
        }
      }
      br(src) {
        const cap = this.rules.inline.br.exec(src);
        if (cap) {
          return {
            type: "br",
            raw: cap[0]
          };
        }
      }
      del(src) {
        const cap = this.rules.inline.del.exec(src);
        if (cap) {
          return {
            type: "del",
            raw: cap[0],
            text: cap[2],
            tokens: this.lexer.inlineTokens(cap[2], [])
          };
        }
      }
      autolink(src, mangle2) {
        const cap = this.rules.inline.autolink.exec(src);
        if (cap) {
          let text2, href;
          if (cap[2] === "@") {
            text2 = escape(this.options.mangle ? mangle2(cap[1]) : cap[1]);
            href = "mailto:" + text2;
          } else {
            text2 = escape(cap[1]);
            href = text2;
          }
          return {
            type: "link",
            raw: cap[0],
            text: text2,
            href,
            tokens: [
              {
                type: "text",
                raw: text2,
                text: text2
              }
            ]
          };
        }
      }
      url(src, mangle2) {
        let cap;
        if (cap = this.rules.inline.url.exec(src)) {
          let text2, href;
          if (cap[2] === "@") {
            text2 = escape(this.options.mangle ? mangle2(cap[0]) : cap[0]);
            href = "mailto:" + text2;
          } else {
            let prevCapZero;
            do {
              prevCapZero = cap[0];
              cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
            } while (prevCapZero !== cap[0]);
            text2 = escape(cap[0]);
            if (cap[1] === "www.") {
              href = "http://" + text2;
            } else {
              href = text2;
            }
          }
          return {
            type: "link",
            raw: cap[0],
            text: text2,
            href,
            tokens: [
              {
                type: "text",
                raw: text2,
                text: text2
              }
            ]
          };
        }
      }
      inlineText(src, smartypants2) {
        const cap = this.rules.inline.text.exec(src);
        if (cap) {
          let text2;
          if (this.lexer.state.inRawBlock) {
            text2 = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];
          } else {
            text2 = escape(this.options.smartypants ? smartypants2(cap[0]) : cap[0]);
          }
          return {
            type: "text",
            raw: cap[0],
            text: text2
          };
        }
      }
    }
    const block = {
      newline: /^(?: *(?:\n|$))+/,
      code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
      fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
      hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
      heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
      blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
      list: /^( {0,3}bull)( [^\n]+?)?(?:\n|$)/,
      html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
      def: /^ {0,3}\[(label)\]: *(?:\n *)?<?([^\s>]+)>?(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
      table: noopTest,
      lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
      // regex template, placeholders will be replaced according to different paragraph
      // interruption rules of commonmark and the original markdown spec:
      _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
      text: /^[^\n]+/
    };
    block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
    block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
    block.def = edit(block.def).replace("label", block._label).replace("title", block._title).getRegex();
    block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
    block.listItemStart = edit(/^( *)(bull) */).replace("bull", block.bullet).getRegex();
    block.list = edit(block.list).replace(/bull/g, block.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block.def.source + ")").getRegex();
    block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
    block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
    block.html = edit(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
    block.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
    block.blockquote = edit(block.blockquote).replace("paragraph", block.paragraph).getRegex();
    block.normal = merge({}, block);
    block.gfm = merge({}, block.normal, {
      table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
      // Cells
    });
    block.gfm.table = edit(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
    block.gfm.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", block.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
    block.pedantic = merge({}, block.normal, {
      html: edit(
        `^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`
      ).replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
      def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
      heading: /^(#{1,6})(.*)(?:\n+|$)/,
      fences: noopTest,
      // fences not supported
      paragraph: edit(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
    });
    const inline = {
      escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
      autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
      url: noopTest,
      tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
      // CDATA section
      link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
      reflink: /^!?\[(label)\]\[(ref)\]/,
      nolink: /^!?\[(ref)\](?:\[\])?/,
      reflinkSearch: "reflink|nolink(?!\\()",
      emStrong: {
        lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
        //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
        //        () Skip orphan delim inside strong    (1) #***                (2) a***#, a***                   (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a
        rDelimAst: /^[^_*]*?\_\_[^_*]*?\*[^_*]*?(?=\_\_)|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/,
        rDelimUnd: /^[^_*]*?\*\*[^_*]*?\_[^_*]*?(?=\*\*)|[punct*](\_+)(?=[\s]|$)|[^punct*_\s](\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
        // ^- Not allowed for _
      },
      code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
      br: /^( {2,}|\\)\n(?!\s*$)/,
      del: noopTest,
      text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
      punctuation: /^([\spunctuation])/
    };
    inline._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";
    inline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();
    inline.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
    inline.escapedEmSt = /\\\*|\\_/g;
    inline._comment = edit(block._comment).replace("(?:-->|$)", "-->").getRegex();
    inline.emStrong.lDelim = edit(inline.emStrong.lDelim).replace(/punct/g, inline._punctuation).getRegex();
    inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, "g").replace(/punct/g, inline._punctuation).getRegex();
    inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, "g").replace(/punct/g, inline._punctuation).getRegex();
    inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
    inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
    inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
    inline.autolink = edit(inline.autolink).replace("scheme", inline._scheme).replace("email", inline._email).getRegex();
    inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
    inline.tag = edit(inline.tag).replace("comment", inline._comment).replace("attribute", inline._attribute).getRegex();
    inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
    inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
    inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
    inline.link = edit(inline.link).replace("label", inline._label).replace("href", inline._href).replace("title", inline._title).getRegex();
    inline.reflink = edit(inline.reflink).replace("label", inline._label).replace("ref", block._label).getRegex();
    inline.nolink = edit(inline.nolink).replace("ref", block._label).getRegex();
    inline.reflinkSearch = edit(inline.reflinkSearch, "g").replace("reflink", inline.reflink).replace("nolink", inline.nolink).getRegex();
    inline.normal = merge({}, inline);
    inline.pedantic = merge({}, inline.normal, {
      strong: {
        start: /^__|\*\*/,
        middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
        endAst: /\*\*(?!\*)/g,
        endUnd: /__(?!_)/g
      },
      em: {
        start: /^_|\*/,
        middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
        endAst: /\*(?!\*)/g,
        endUnd: /_(?!_)/g
      },
      link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", inline._label).getRegex(),
      reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline._label).getRegex()
    });
    inline.gfm = merge({}, inline.normal, {
      escape: edit(inline.escape).replace("])", "~|])").getRegex(),
      _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
      url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
      _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
      del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
      text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
    });
    inline.gfm.url = edit(inline.gfm.url, "i").replace("email", inline.gfm._extended_email).getRegex();
    inline.breaks = merge({}, inline.gfm, {
      br: edit(inline.br).replace("{2,}", "*").getRegex(),
      text: edit(inline.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
    });
    function smartypants(text2) {
      return text2.replace(/---/g, "").replace(/--/g, "").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1").replace(/'/g, "").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1").replace(/"/g, "").replace(/\.{3}/g, "");
    }
    function mangle(text2) {
      let out = "", i2, ch;
      const l2 = text2.length;
      for (i2 = 0; i2 < l2; i2++) {
        ch = text2.charCodeAt(i2);
        if (Math.random() > 0.5) {
          ch = "x" + ch.toString(16);
        }
        out += "&#" + ch + ";";
      }
      return out;
    }
    class Lexer {
      constructor(options) {
        this.tokens = [];
        this.tokens.links = /* @__PURE__ */ Object.create(null);
        this.options = options || defaults;
        this.options.tokenizer = this.options.tokenizer || new Tokenizer();
        this.tokenizer = this.options.tokenizer;
        this.tokenizer.options = this.options;
        this.tokenizer.lexer = this;
        this.inlineQueue = [];
        this.state = {
          inLink: false,
          inRawBlock: false,
          top: true
        };
        const rules = {
          block: block.normal,
          inline: inline.normal
        };
        if (this.options.pedantic) {
          rules.block = block.pedantic;
          rules.inline = inline.pedantic;
        } else if (this.options.gfm) {
          rules.block = block.gfm;
          if (this.options.breaks) {
            rules.inline = inline.breaks;
          } else {
            rules.inline = inline.gfm;
          }
        }
        this.tokenizer.rules = rules;
      }
      /**
       * Expose Rules
       */
      static get rules() {
        return {
          block,
          inline
        };
      }
      /**
       * Static Lex Method
       */
      static lex(src, options) {
        const lexer = new Lexer(options);
        return lexer.lex(src);
      }
      /**
       * Static Lex Inline Method
       */
      static lexInline(src, options) {
        const lexer = new Lexer(options);
        return lexer.inlineTokens(src);
      }
      /**
       * Preprocessing
       */
      lex(src) {
        src = src.replace(/\r\n|\r/g, "\n").replace(/\t/g, "    ");
        this.blockTokens(src, this.tokens);
        let next;
        while (next = this.inlineQueue.shift()) {
          this.inlineTokens(next.src, next.tokens);
        }
        return this.tokens;
      }
      /**
       * Lexing
       */
      blockTokens(src, tokens = []) {
        if (this.options.pedantic) {
          src = src.replace(/^ +$/gm, "");
        }
        let token, lastToken, cutSrc, lastParagraphClipped;
        while (src) {
          if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {
            if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              return true;
            }
            return false;
          })) {
            continue;
          }
          if (token = this.tokenizer.space(src)) {
            src = src.substring(token.raw.length);
            if (token.raw.length === 1 && tokens.length > 0) {
              tokens[tokens.length - 1].raw += "\n";
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.code(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.fences(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.heading(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.hr(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.blockquote(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.list(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.html(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.def(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.raw;
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else if (!this.tokens.links[token.tag]) {
              this.tokens.links[token.tag] = {
                href: token.href,
                title: token.title
              };
            }
            continue;
          }
          if (token = this.tokenizer.table(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.lheading(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          cutSrc = src;
          if (this.options.extensions && this.options.extensions.startBlock) {
            let startIndex = Infinity;
            const tempSrc = src.slice(1);
            let tempStart;
            this.options.extensions.startBlock.forEach(function(getStartIndex) {
              tempStart = getStartIndex.call({ lexer: this }, tempSrc);
              if (typeof tempStart === "number" && tempStart >= 0) {
                startIndex = Math.min(startIndex, tempStart);
              }
            });
            if (startIndex < Infinity && startIndex >= 0) {
              cutSrc = src.substring(0, startIndex + 1);
            }
          }
          if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
            lastToken = tokens[tokens.length - 1];
            if (lastParagraphClipped && lastToken.type === "paragraph") {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
              this.inlineQueue.pop();
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            lastParagraphClipped = cutSrc.length !== src.length;
            src = src.substring(token.raw.length);
            continue;
          }
          if (token = this.tokenizer.text(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === "text") {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
              this.inlineQueue.pop();
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (src) {
            const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }
        this.state.top = true;
        return tokens;
      }
      inline(src, tokens) {
        this.inlineQueue.push({ src, tokens });
      }
      /**
       * Lexing/Compiling
       */
      inlineTokens(src, tokens = []) {
        let token, lastToken, cutSrc;
        let maskedSrc = src;
        let match;
        let keepPrevChar, prevChar;
        if (this.tokens.links) {
          const links = Object.keys(this.tokens.links);
          if (links.length > 0) {
            while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
              if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
                maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
              }
            }
          }
        }
        while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
          maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
        }
        while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
          maskedSrc = maskedSrc.slice(0, match.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
        }
        while (src) {
          if (!keepPrevChar) {
            prevChar = "";
          }
          keepPrevChar = false;
          if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {
            if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              return true;
            }
            return false;
          })) {
            continue;
          }
          if (token = this.tokenizer.escape(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.tag(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && token.type === "text" && lastToken.type === "text") {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.link(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.reflink(src, this.tokens.links)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && token.type === "text" && lastToken.type === "text") {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.codespan(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.br(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.del(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.autolink(src, mangle)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          cutSrc = src;
          if (this.options.extensions && this.options.extensions.startInline) {
            let startIndex = Infinity;
            const tempSrc = src.slice(1);
            let tempStart;
            this.options.extensions.startInline.forEach(function(getStartIndex) {
              tempStart = getStartIndex.call({ lexer: this }, tempSrc);
              if (typeof tempStart === "number" && tempStart >= 0) {
                startIndex = Math.min(startIndex, tempStart);
              }
            });
            if (startIndex < Infinity && startIndex >= 0) {
              cutSrc = src.substring(0, startIndex + 1);
            }
          }
          if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {
            src = src.substring(token.raw.length);
            if (token.raw.slice(-1) !== "_") {
              prevChar = token.raw.slice(-1);
            }
            keepPrevChar = true;
            lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === "text") {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (src) {
            const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }
        return tokens;
      }
    }
    class Renderer {
      constructor(options) {
        this.options = options || defaults;
      }
      code(code, infostring, escaped) {
        const lang2 = (infostring || "").match(/\S*/)[0];
        if (this.options.highlight) {
          const out = this.options.highlight(code, lang2);
          if (out != null && out !== code) {
            escaped = true;
            code = out;
          }
        }
        code = code.replace(/\n$/, "") + "\n";
        if (!lang2) {
          return "<pre><code>" + (escaped ? code : escape(code, true)) + "</code></pre>\n";
        }
        return '<pre><code class="' + this.options.langPrefix + escape(lang2, true) + '">' + (escaped ? code : escape(code, true)) + "</code></pre>\n";
      }
      blockquote(quote2) {
        return "<blockquote>\n" + quote2 + "</blockquote>\n";
      }
      html(html2) {
        return html2;
      }
      heading(text2, level, raw, slugger) {
        if (this.options.headerIds) {
          return "<h" + level + ' id="' + this.options.headerPrefix + slugger.slug(raw) + '">' + text2 + "</h" + level + ">\n";
        }
        return "<h" + level + ">" + text2 + "</h" + level + ">\n";
      }
      hr() {
        return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
      }
      list(body, ordered, start2) {
        const type = ordered ? "ol" : "ul", startatt = ordered && start2 !== 1 ? ' start="' + start2 + '"' : "";
        return "<" + type + startatt + ">\n" + body + "</" + type + ">\n";
      }
      listitem(text2) {
        return "<li>" + text2 + "</li>\n";
      }
      checkbox(checked) {
        return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
      }
      paragraph(text2) {
        return "<p>" + text2 + "</p>\n";
      }
      table(header, body) {
        if (body) body = "<tbody>" + body + "</tbody>";
        return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
      }
      tablerow(content) {
        return "<tr>\n" + content + "</tr>\n";
      }
      tablecell(content, flags) {
        const type = flags.header ? "th" : "td";
        const tag = flags.align ? "<" + type + ' align="' + flags.align + '">' : "<" + type + ">";
        return tag + content + "</" + type + ">\n";
      }
      // span level renderer
      strong(text2) {
        return "<strong>" + text2 + "</strong>";
      }
      em(text2) {
        return "<em>" + text2 + "</em>";
      }
      codespan(text2) {
        return "<code>" + text2 + "</code>";
      }
      br() {
        return this.options.xhtml ? "<br/>" : "<br>";
      }
      del(text2) {
        return "<del>" + text2 + "</del>";
      }
      link(href, title, text2) {
        href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
        if (href === null) {
          return text2;
        }
        let out = '<a href="' + escape(href) + '"';
        if (title) {
          out += ' title="' + title + '"';
        }
        out += ">" + text2 + "</a>";
        return out;
      }
      image(href, title, text2) {
        href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
        if (href === null) {
          return text2;
        }
        let out = '<img src="' + href + '" alt="' + text2 + '"';
        if (title) {
          out += ' title="' + title + '"';
        }
        out += this.options.xhtml ? "/>" : ">";
        return out;
      }
      text(text2) {
        return text2;
      }
    }
    class TextRenderer {
      // no need for block level renderers
      strong(text2) {
        return text2;
      }
      em(text2) {
        return text2;
      }
      codespan(text2) {
        return text2;
      }
      del(text2) {
        return text2;
      }
      html(text2) {
        return text2;
      }
      text(text2) {
        return text2;
      }
      link(href, title, text2) {
        return "" + text2;
      }
      image(href, title, text2) {
        return "" + text2;
      }
      br() {
        return "";
      }
    }
    class Slugger {
      constructor() {
        this.seen = {};
      }
      serialize(value) {
        return value.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
      }
      /**
       * Finds the next safe (unique) slug to use
       */
      getNextSafeSlug(originalSlug, isDryRun) {
        let slug = originalSlug;
        let occurenceAccumulator = 0;
        if (this.seen.hasOwnProperty(slug)) {
          occurenceAccumulator = this.seen[originalSlug];
          do {
            occurenceAccumulator++;
            slug = originalSlug + "-" + occurenceAccumulator;
          } while (this.seen.hasOwnProperty(slug));
        }
        if (!isDryRun) {
          this.seen[originalSlug] = occurenceAccumulator;
          this.seen[slug] = 0;
        }
        return slug;
      }
      /**
       * Convert string to unique id
       * @param {object} options
       * @param {boolean} options.dryrun Generates the next unique slug without updating the internal accumulator.
       */
      slug(value, options = {}) {
        const slug = this.serialize(value);
        return this.getNextSafeSlug(slug, options.dryrun);
      }
    }
    class Parser {
      constructor(options) {
        this.options = options || defaults;
        this.options.renderer = this.options.renderer || new Renderer();
        this.renderer = this.options.renderer;
        this.renderer.options = this.options;
        this.textRenderer = new TextRenderer();
        this.slugger = new Slugger();
      }
      /**
       * Static Parse Method
       */
      static parse(tokens, options) {
        const parser = new Parser(options);
        return parser.parse(tokens);
      }
      /**
       * Static Parse Inline Method
       */
      static parseInline(tokens, options) {
        const parser = new Parser(options);
        return parser.parseInline(tokens);
      }
      /**
       * Parse Loop
       */
      parse(tokens, top2 = true) {
        let out = "", i2, j2, k2, l2, l3, row, cell, header, body, token, ordered, start2, loose, itemBody, item, checked, task, checkbox2, ret;
        const l4 = tokens.length;
        for (i2 = 0; i2 < l4; i2++) {
          token = tokens[i2];
          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
            ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
            if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(token.type)) {
              out += ret || "";
              continue;
            }
          }
          switch (token.type) {
            case "space": {
              continue;
            }
            case "hr": {
              out += this.renderer.hr();
              continue;
            }
            case "heading": {
              out += this.renderer.heading(
                this.parseInline(token.tokens),
                token.depth,
                unescape(this.parseInline(token.tokens, this.textRenderer)),
                this.slugger
              );
              continue;
            }
            case "code": {
              out += this.renderer.code(
                token.text,
                token.lang,
                token.escaped
              );
              continue;
            }
            case "table": {
              header = "";
              cell = "";
              l2 = token.header.length;
              for (j2 = 0; j2 < l2; j2++) {
                cell += this.renderer.tablecell(
                  this.parseInline(token.header[j2].tokens),
                  { header: true, align: token.align[j2] }
                );
              }
              header += this.renderer.tablerow(cell);
              body = "";
              l2 = token.rows.length;
              for (j2 = 0; j2 < l2; j2++) {
                row = token.rows[j2];
                cell = "";
                l3 = row.length;
                for (k2 = 0; k2 < l3; k2++) {
                  cell += this.renderer.tablecell(
                    this.parseInline(row[k2].tokens),
                    { header: false, align: token.align[k2] }
                  );
                }
                body += this.renderer.tablerow(cell);
              }
              out += this.renderer.table(header, body);
              continue;
            }
            case "blockquote": {
              body = this.parse(token.tokens);
              out += this.renderer.blockquote(body);
              continue;
            }
            case "list": {
              ordered = token.ordered;
              start2 = token.start;
              loose = token.loose;
              l2 = token.items.length;
              body = "";
              for (j2 = 0; j2 < l2; j2++) {
                item = token.items[j2];
                checked = item.checked;
                task = item.task;
                itemBody = "";
                if (item.task) {
                  checkbox2 = this.renderer.checkbox(checked);
                  if (loose) {
                    if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
                      item.tokens[0].text = checkbox2 + " " + item.tokens[0].text;
                      if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                        item.tokens[0].tokens[0].text = checkbox2 + " " + item.tokens[0].tokens[0].text;
                      }
                    } else {
                      item.tokens.unshift({
                        type: "text",
                        text: checkbox2
                      });
                    }
                  } else {
                    itemBody += checkbox2;
                  }
                }
                itemBody += this.parse(item.tokens, loose);
                body += this.renderer.listitem(itemBody, task, checked);
              }
              out += this.renderer.list(body, ordered, start2);
              continue;
            }
            case "html": {
              out += this.renderer.html(token.text);
              continue;
            }
            case "paragraph": {
              out += this.renderer.paragraph(this.parseInline(token.tokens));
              continue;
            }
            case "text": {
              body = token.tokens ? this.parseInline(token.tokens) : token.text;
              while (i2 + 1 < l4 && tokens[i2 + 1].type === "text") {
                token = tokens[++i2];
                body += "\n" + (token.tokens ? this.parseInline(token.tokens) : token.text);
              }
              out += top2 ? this.renderer.paragraph(body) : body;
              continue;
            }
            default: {
              const errMsg = 'Token with "' + token.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
          }
        }
        return out;
      }
      /**
       * Parse Inline Tokens
       */
      parseInline(tokens, renderer) {
        renderer = renderer || this.renderer;
        let out = "", i2, token, ret;
        const l2 = tokens.length;
        for (i2 = 0; i2 < l2; i2++) {
          token = tokens[i2];
          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
            ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
            if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token.type)) {
              out += ret || "";
              continue;
            }
          }
          switch (token.type) {
            case "escape": {
              out += renderer.text(token.text);
              break;
            }
            case "html": {
              out += renderer.html(token.text);
              break;
            }
            case "link": {
              out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
              break;
            }
            case "image": {
              out += renderer.image(token.href, token.title, token.text);
              break;
            }
            case "strong": {
              out += renderer.strong(this.parseInline(token.tokens, renderer));
              break;
            }
            case "em": {
              out += renderer.em(this.parseInline(token.tokens, renderer));
              break;
            }
            case "codespan": {
              out += renderer.codespan(token.text);
              break;
            }
            case "br": {
              out += renderer.br();
              break;
            }
            case "del": {
              out += renderer.del(this.parseInline(token.tokens, renderer));
              break;
            }
            case "text": {
              out += renderer.text(token.text);
              break;
            }
            default: {
              const errMsg = 'Token with "' + token.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
          }
        }
        return out;
      }
    }
    function marked(src, opt, callback) {
      if (typeof src === "undefined" || src === null) {
        throw new Error("marked(): input parameter is undefined or null");
      }
      if (typeof src !== "string") {
        throw new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
      }
      if (typeof opt === "function") {
        callback = opt;
        opt = null;
      }
      opt = merge({}, marked.defaults, opt || {});
      checkSanitizeDeprecation(opt);
      if (callback) {
        const highlight = opt.highlight;
        let tokens;
        try {
          tokens = Lexer.lex(src, opt);
        } catch (e2) {
          return callback(e2);
        }
        const done = function(err) {
          let out;
          if (!err) {
            try {
              if (opt.walkTokens) {
                marked.walkTokens(tokens, opt.walkTokens);
              }
              out = Parser.parse(tokens, opt);
            } catch (e2) {
              err = e2;
            }
          }
          opt.highlight = highlight;
          return err ? callback(err) : callback(null, out);
        };
        if (!highlight || highlight.length < 3) {
          return done();
        }
        delete opt.highlight;
        if (!tokens.length) return done();
        let pending = 0;
        marked.walkTokens(tokens, function(token) {
          if (token.type === "code") {
            pending++;
            setTimeout(() => {
              highlight(token.text, token.lang, function(err, code) {
                if (err) {
                  return done(err);
                }
                if (code != null && code !== token.text) {
                  token.text = code;
                  token.escaped = true;
                }
                pending--;
                if (pending === 0) {
                  done();
                }
              });
            }, 0);
          }
        });
        if (pending === 0) {
          done();
        }
        return;
      }
      try {
        const tokens = Lexer.lex(src, opt);
        if (opt.walkTokens) {
          marked.walkTokens(tokens, opt.walkTokens);
        }
        return Parser.parse(tokens, opt);
      } catch (e2) {
        e2.message += "\nPlease report this to https://github.com/markedjs/marked.";
        if (opt.silent) {
          return "<p>An error occurred:</p><pre>" + escape(e2.message + "", true) + "</pre>";
        }
        throw e2;
      }
    }
    marked.options = marked.setOptions = function(opt) {
      merge(marked.defaults, opt);
      changeDefaults(marked.defaults);
      return marked;
    };
    marked.getDefaults = getDefaults;
    marked.defaults = defaults;
    marked.use = function(...args) {
      const opts = merge({}, ...args);
      const extensions = marked.defaults.extensions || { renderers: {}, childTokens: {} };
      let hasExtensions;
      args.forEach((pack) => {
        if (pack.extensions) {
          hasExtensions = true;
          pack.extensions.forEach((ext) => {
            if (!ext.name) {
              throw new Error("extension name required");
            }
            if (ext.renderer) {
              const prevRenderer = extensions.renderers ? extensions.renderers[ext.name] : null;
              if (prevRenderer) {
                extensions.renderers[ext.name] = function(...args2) {
                  let ret = ext.renderer.apply(this, args2);
                  if (ret === false) {
                    ret = prevRenderer.apply(this, args2);
                  }
                  return ret;
                };
              } else {
                extensions.renderers[ext.name] = ext.renderer;
              }
            }
            if (ext.tokenizer) {
              if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
                throw new Error("extension level must be 'block' or 'inline'");
              }
              if (extensions[ext.level]) {
                extensions[ext.level].unshift(ext.tokenizer);
              } else {
                extensions[ext.level] = [ext.tokenizer];
              }
              if (ext.start) {
                if (ext.level === "block") {
                  if (extensions.startBlock) {
                    extensions.startBlock.push(ext.start);
                  } else {
                    extensions.startBlock = [ext.start];
                  }
                } else if (ext.level === "inline") {
                  if (extensions.startInline) {
                    extensions.startInline.push(ext.start);
                  } else {
                    extensions.startInline = [ext.start];
                  }
                }
              }
            }
            if (ext.childTokens) {
              extensions.childTokens[ext.name] = ext.childTokens;
            }
          });
        }
        if (pack.renderer) {
          const renderer = marked.defaults.renderer || new Renderer();
          for (const prop in pack.renderer) {
            const prevRenderer = renderer[prop];
            renderer[prop] = (...args2) => {
              let ret = pack.renderer[prop].apply(renderer, args2);
              if (ret === false) {
                ret = prevRenderer.apply(renderer, args2);
              }
              return ret;
            };
          }
          opts.renderer = renderer;
        }
        if (pack.tokenizer) {
          const tokenizer = marked.defaults.tokenizer || new Tokenizer();
          for (const prop in pack.tokenizer) {
            const prevTokenizer = tokenizer[prop];
            tokenizer[prop] = (...args2) => {
              let ret = pack.tokenizer[prop].apply(tokenizer, args2);
              if (ret === false) {
                ret = prevTokenizer.apply(tokenizer, args2);
              }
              return ret;
            };
          }
          opts.tokenizer = tokenizer;
        }
        if (pack.walkTokens) {
          const walkTokens = marked.defaults.walkTokens;
          opts.walkTokens = function(token) {
            pack.walkTokens.call(this, token);
            if (walkTokens) {
              walkTokens.call(this, token);
            }
          };
        }
        if (hasExtensions) {
          opts.extensions = extensions;
        }
        marked.setOptions(opts);
      });
    };
    marked.walkTokens = function(tokens, callback) {
      for (const token of tokens) {
        callback.call(marked, token);
        switch (token.type) {
          case "table": {
            for (const cell of token.header) {
              marked.walkTokens(cell.tokens, callback);
            }
            for (const row of token.rows) {
              for (const cell of row) {
                marked.walkTokens(cell.tokens, callback);
              }
            }
            break;
          }
          case "list": {
            marked.walkTokens(token.items, callback);
            break;
          }
          default: {
            if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) {
              marked.defaults.extensions.childTokens[token.type].forEach(function(childTokens) {
                marked.walkTokens(token[childTokens], callback);
              });
            } else if (token.tokens) {
              marked.walkTokens(token.tokens, callback);
            }
          }
        }
      }
    };
    marked.parseInline = function(src, opt) {
      if (typeof src === "undefined" || src === null) {
        throw new Error("marked.parseInline(): input parameter is undefined or null");
      }
      if (typeof src !== "string") {
        throw new Error("marked.parseInline(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
      }
      opt = merge({}, marked.defaults, opt || {});
      checkSanitizeDeprecation(opt);
      try {
        const tokens = Lexer.lexInline(src, opt);
        if (opt.walkTokens) {
          marked.walkTokens(tokens, opt.walkTokens);
        }
        return Parser.parseInline(tokens, opt);
      } catch (e2) {
        e2.message += "\nPlease report this to https://github.com/markedjs/marked.";
        if (opt.silent) {
          return "<p>An error occurred:</p><pre>" + escape(e2.message + "", true) + "</pre>";
        }
        throw e2;
      }
    };
    marked.Parser = Parser;
    marked.parser = Parser.parse;
    marked.Renderer = Renderer;
    marked.TextRenderer = TextRenderer;
    marked.Lexer = Lexer;
    marked.lexer = Lexer.lex;
    marked.Tokenizer = Tokenizer;
    marked.Slugger = Slugger;
    marked.parse = marked;
    marked.options;
    marked.setOptions;
    marked.use;
    marked.walkTokens;
    marked.parseInline;
    Parser.parse;
    Lexer.lex;
    var root = typeof window !== "undefined" ? window : {};
    function canParseHTMLNatively() {
      var Parser2 = root.DOMParser;
      var canParse = false;
      try {
        if (new Parser2().parseFromString("", "text/html")) {
          canParse = true;
        }
      } catch (e2) {
      }
      return canParse;
    }
    function createHTMLParser() {
      var Parser2 = function() {
      };
      {
        if (shouldUseActiveX()) {
          Parser2.prototype.parseFromString = function(string2) {
            var doc = new window.ActiveXObject("htmlfile");
            doc.designMode = "on";
            doc.open();
            doc.write(string2);
            doc.close();
            return doc;
          };
        } else {
          Parser2.prototype.parseFromString = function(string2) {
            var doc = document.implementation.createHTMLDocument("");
            doc.open();
            doc.write(string2);
            doc.close();
            return doc;
          };
        }
      }
      return Parser2;
    }
    function shouldUseActiveX() {
      var useActiveX = false;
      try {
        document.implementation.createHTMLDocument("").open();
      } catch (e2) {
        if (root.ActiveXObject) useActiveX = true;
      }
      return useActiveX;
    }
    canParseHTMLNatively() ? root.DOMParser : createHTMLParser();
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    [
      keyCodes.arrowup,
      keyCodes.arrowdown,
      keyCodes.esc
    ];
    [
      keyCodes.enter,
      keyCodes.tab
    ];
    var ckeditor = { exports: {} };
    const require$$0 = /* @__PURE__ */ getAugmentedNamespace(vue_esmBundler);
    const require$$1 = /* @__PURE__ */ getAugmentedNamespace(lodash);
    /*!
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md.
     */
    (function(module2, exports2) {
      !function(e2, t2) {
        module2.exports = t2(require$$0, require$$1);
      }(self, (e2, t2) => (() => {
        var i2 = { 76: (e3) => {
          e3.exports = t2;
        }, 380: (t3) => {
          t3.exports = e2;
        } }, o2 = {};
        function n2(e3) {
          var t3 = o2[e3];
          if (void 0 !== t3) return t3.exports;
          var a3 = o2[e3] = { exports: {} };
          return i2[e3](a3, a3.exports, n2), a3.exports;
        }
        n2.d = (e3, t3) => {
          for (var i3 in t3) n2.o(t3, i3) && !n2.o(e3, i3) && Object.defineProperty(e3, i3, { enumerable: true, get: t3[i3] });
        }, n2.o = (e3, t3) => Object.prototype.hasOwnProperty.call(e3, t3);
        var a2 = {};
        return (() => {
          n2.d(a2, { default: () => o3 });
          var e3 = n2(380), t3 = n2(76);
          const i3 = (0, e3.defineComponent)({ name: "Ckeditor", model: { prop: "modelValue", event: "update:modelValue" }, props: { editor: { type: Function, required: true }, config: { type: Object, default: () => ({}) }, modelValue: { type: String, default: "" }, tagName: { type: String, default: "div" }, disabled: { type: Boolean, default: false }, disableTwoWayDataBinding: { type: Boolean, default: false } }, emits: ["ready", "destroy", "blur", "focus", "input", "update:modelValue"], data: () => ({ instance: null, lastEditorData: null }), watch: { modelValue(e4) {
            this.instance && e4 !== this.lastEditorData && this.instance.data.set(e4);
          }, disabled(e4) {
            e4 ? this.instance.enableReadOnlyMode("Integration Sample") : this.instance.disableReadOnlyMode("Integration Sample");
          } }, created() {
            const { CKEDITOR_VERSION: e4 } = window;
            if (!e4) return console.warn('Cannot find the "CKEDITOR_VERSION" in the "window" scope.');
            const [t4] = e4.split(".").map(Number);
            t4 >= 42 || e4.startsWith("0.0.0") || console.warn("The <CKEditor> component requires using CKEditor 5 in version 42+ or nightly build.");
          }, mounted() {
            const t4 = Object.assign({}, this.config);
            this.modelValue && (t4.initialData = this.modelValue), this.editor.create(this.$el, t4).then((i4) => {
              this.instance = (0, e3.markRaw)(i4), this.setUpEditorEvents(), this.modelValue !== t4.initialData && i4.data.set(this.modelValue), this.disabled && i4.enableReadOnlyMode("Integration Sample"), this.$emit("ready", i4);
            }).catch((e4) => {
              console.error(e4);
            });
          }, beforeUnmount() {
            this.instance && (this.instance.destroy(), this.instance = null), this.$emit("destroy", this.instance);
          }, methods: { setUpEditorEvents() {
            const e4 = this.instance, i4 = (0, t3.debounce)((t4) => {
              if (this.disableTwoWayDataBinding) return;
              const i5 = this.lastEditorData = e4.data.get();
              this.$emit("update:modelValue", i5, t4, e4), this.$emit("input", i5, t4, e4);
            }, 300, { leading: true });
            e4.model.document.on("change:data", i4), e4.editing.view.document.on("focus", (t4) => {
              this.$emit("focus", t4, e4);
            }), e4.editing.view.document.on("blur", (t4) => {
              this.$emit("blur", t4, e4);
            });
          } }, render() {
            return (0, e3.h)(this.tagName);
          } });
          if (!e3.version || !e3.version.startsWith("3.")) throw new Error("The CKEditor plugin works only with Vue 3+. For more information, please refer to https://ckeditor.com/docs/ckeditor5/latest/builds/guides/integration/frameworks/vuejs-v3.html");
          const o3 = { install(e4) {
            e4.component("Ckeditor", i3);
          }, component: i3 };
        })(), a2 = a2.default;
      })());
    })(ckeditor);
    var ckeditorExports = ckeditor.exports;
    const CKEditor = /* @__PURE__ */ getDefaultExportFromCjs(ckeditorExports);
    const _sfc_main$W = {
      components: {
        ckeditor: CKEditor.component
      },
      data() {
        return {
          editor: ClassicEditor,
          editorData: null,
          editorConfig: {
            plugins: [
              Essentials,
              Paragraph,
              Undo,
              // mandatory plugins (seems not to work without them)
              Italic,
              Bold,
              Link,
              List,
              Heading
            ],
            toolbar: ["heading", "|", "bold", "italic", "link", "bulletedList"],
            heading: {
              options: [
                { model: "paragraph", title: "Paragraph", class: "ck-heading_paragraph" },
                { model: "heading2", view: "h2", title: "Heading", class: "ck-heading_heading2" }
              ]
            }
          }
        };
      }
    };
    function _sfc_render$W(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_ckeditor = resolveComponent("ckeditor");
      return openBlock(), createBlock(_component_ckeditor, {
        editor: $data.editor,
        "model-value": $data.editorData,
        config: $data.editorConfig
      }, null, 8, ["editor", "model-value", "config"]);
    }
    const editor = /* @__PURE__ */ _export_sfc(_sfc_main$W, [["render", _sfc_render$W], ["__file", "/var/www/html/vendor/andreamarelli/modular-forms/src/resources/assets/js/inputs/text-editor.vue"]]);
    function useDataStatus(component_data) {
      const NOT_APPLICABLE_KEY = "not_applicable";
      const NOT_AVAILABLE_KEY = "not_available";
      const not_applicable = ref(false);
      const not_available = ref(false);
      const enable_not_applicable = unref(component_data.enable_not_applicable);
      const records = unref(component_data.records);
      const empty_record = unref(component_data.empty_record);
      const isNotApplicable = computed(() => {
        return not_applicable.value;
      });
      const isNotAvailable = computed(() => {
        return not_available.value;
      });
      function refreshDataStatus() {
        if (enable_not_applicable) {
          let record = records[0];
          record = Object.assign({}, record);
          if (NOT_APPLICABLE_KEY in record) {
            not_applicable.value = record[NOT_APPLICABLE_KEY] === true;
            not_available.value = record[NOT_AVAILABLE_KEY] === true;
          }
        }
      }
      function toggleDataStatus(toggle_key) {
        if (toggle_key === NOT_APPLICABLE_KEY) {
          not_applicable.value = !not_applicable.value;
          return updateRecords(NOT_APPLICABLE_KEY, not_applicable.value);
        } else if (toggle_key === NOT_AVAILABLE_KEY) {
          not_available.value = !not_available.value;
          return updateRecords(NOT_AVAILABLE_KEY, not_available.value);
        }
      }
      function updateRecords(toggle_key, toggle_value) {
        records.forEach(function(item, index) {
          if (index === 0) {
            records[index] = Object.assign({}, empty_record);
            records[index][toggle_key] = toggle_value === true ? true : null;
          } else {
            delete records[index];
          }
        });
      }
      return { refreshDataStatus, isNotApplicable, isNotAvailable, toggleDataStatus };
    }
    function useArrangeRecords(component_data) {
      const module_type = component_data.module_type;
      const groups = component_data.groups;
      const group_key_field = component_data.group_key_field;
      const accordion_title_field = component_data.accordion_title_field;
      const records = unref(component_data.records);
      const empty_record = unref(component_data.empty_record);
      const custom_methods = component_data.custom_methods;
      function accordionTitle(index) {
        let group_key = records[index][group_key_field] || null;
        let title_index = indexInGroup(index, group_key) + 1;
        let title = null;
        if (typeof custom_methods.accordionTitle === "function") {
          title = custom_methods.accordionTitle(records, index, accordion_title_field);
        } else {
          title = toRaw(records[index][accordion_title_field]) || "";
        }
        return title_index + " - " + title;
      }
      function recordIsInGroup(record, group_key) {
        if (!record) return false;
        if (module_type.includes("GROUP_")) {
          return record[group_key_field] === group_key;
        }
        return true;
      }
      function numRecordsInGroup(group_key) {
        if (module_type.includes("GROUP_")) {
          return records.filter((record) => record[group_key_field] === group_key).length;
        }
        return records.length;
      }
      function indexInGroup(index, group_key) {
        if (module_type.includes("GROUP_")) {
          let group_index = 0;
          records.forEach((record, i2) => {
            if (record[group_key_field] === group_key && i2 <= index) {
              group_index++;
            }
          });
          return group_index - 1;
        }
        return index;
      }
      function ensureAteLeastOneRecordPerGroup() {
        if (module_type.includes("GROUP_")) {
          let used_groups = records.map((record) => record[group_key_field]);
          let missing_groups = Object.keys(groups).filter((n2) => !used_groups.includes(n2));
          missing_groups.forEach((group_key) => {
            addItem(group_key);
          });
        }
      }
      function addItem(group_key = null) {
        let new_empty_record = JSON.parse(JSON.stringify(toRaw(empty_record)));
        if (module_type.includes("GROUP_")) {
          new_empty_record[group_key_field] = group_key;
        }
        records.push(new_empty_record);
      }
      function deleteItem(index, event) {
        let num_records = module_type.includes("GROUP_") ? numRecordsInGroup(records[index][group_key_field]) : records.length;
        if (num_records > 1) {
          records.splice(index, 1);
        } else {
          let new_empty_record = JSON.parse(JSON.stringify(empty_record));
          if (module_type.includes("GROUP_")) {
            new_empty_record[group_key_field] = records[index][group_key_field];
          }
          records[index] = new_empty_record;
        }
      }
      return {
        accordionTitle,
        recordIsInGroup,
        numRecordsInGroup,
        ensureAteLeastOneRecordPerGroup,
        addItem,
        deleteItem
      };
    }
    function useSave(component_data) {
      let records = component_data.records;
      let records_backup = component_data.records_backup;
      const status = component_data.status;
      const form_id = component_data.form_id;
      const module_key = component_data.module_key;
      const action_url = component_data.action_url;
      let error_messages = ref([]);
      const refreshDataStatus = component_data.refreshDataStatus;
      const ensureAteLeastOneRecordPerGroup = component_data.ensureAteLeastOneRecordPerGroup;
      function replaceRecords(newRecords) {
        records.forEach(function(record, index) {
          delete records[index];
        });
        newRecords.forEach(function(record, index) {
          records[index] = JSON.parse(JSON.stringify(newRecords[index]));
        });
      }
      function replaceRecordsBackup(newRecords) {
        records_backup.forEach(function(record, index) {
          delete records_backup[index];
        });
        newRecords.forEach(function(record, index) {
          records_backup[index] = JSON.parse(JSON.stringify(newRecords[index]));
        });
      }
      function resetModule() {
        replaceRecords(component_data.records_backup);
        refreshDataStatus();
        ensureAteLeastOneRecordPerGroup();
        nextTick().then(() => {
          status.value = "idle";
          component_data.emitter.emit("moduleReset", { module_key });
        });
      }
      function saveModule() {
        status.value = "saving";
        let data = {
          records_json: window.ModularForms.Helpers.Payload.encode(Object.values(records)),
          form_id,
          module_key
        };
        if (form_id !== null) {
          data._method = "PATCH";
        }
        fetch(action_url, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRF-Token": window.Laravel.csrfToken
          },
          body: JSON.stringify(data)
        }).then((response) => response.json()).then(function(data2) {
          if (data2.status === "success") {
            if (form_id == null) {
              window.location.href = data2.edit_url;
            } else {
              replaceRecords(data2.records);
              replaceRecordsBackup(data2.records);
              refreshDataStatus();
              ensureAteLeastOneRecordPerGroup();
              component_data.last_update = component_data.last_update || { "date": null };
              component_data.last_update.date = data2.last_update.date;
              if (window.Laravel.FormErrors) {
                window.Laravel.FormErrors.refreshErrors(data2.form_errors);
              }
              nextTick().then(() => {
                status.value = "saved";
                component_data.emitter.emit("moduleSaved", data2);
              });
            }
          } else if (data2.status === "validation_error") {
            setErrorStatus(data2);
          }
        }).catch(function(error) {
          setErrorStatus(error);
          component_data.emitter.emit("moduleFail", { module_key, error });
        });
      }
      function setErrorStatus(data) {
        status.value = "error";
        error_messages.value = [];
        if (data.hasOwnProperty("errors")) {
          Object.keys(data["errors"]).forEach(function(field) {
            data["errors"][field].forEach(function(message) {
              error_messages.value.push(message);
            });
          });
        }
      }
      return {
        resetModule,
        saveModule,
        error_messages
      };
    }
    function useCalc(component_data) {
      const records = unref(component_data.records);
      const groups = component_data.groups;
      const group_key_field = component_data.group_key_field;
      function calculateAverage(field, group = null) {
        let sum2 = 0;
        let count2 = 0;
        records.forEach(function(item) {
          if ((group == null || item[group_key_field] === group) && item[field] !== null && item[field] !== -99 && item[field] !== "-99") {
            sum2 += parseInt(item[field]);
            count2++;
          }
        });
        return count2 > 0 ? (sum2 / count2).toFixed(2) : 0;
      }
      function calculateGroupsAverages(field) {
        let averages = [];
        Object.keys(groups).forEach(function(group) {
          averages[group] = calculateAverage(field, group);
        });
        return averages;
      }
      function sumColumn(field, group = null) {
        let sum2 = 0;
        records.forEach(function(item) {
          if ((group == null || item[group_key_field] === group) && item[field] !== null && item[field] !== "") {
            sum2 += parseInt(item[field]);
          }
        });
        return sum2 === 0 ? null : sum2;
      }
      function sumColumnFloat(field, group = null) {
        let sum2 = 0;
        let tmp = null;
        let pos = null;
        records.forEach(function(item) {
          if ((group == null || item[group_key_field] === group) && item[field] !== null && item[field] !== "") {
            tmp = item[field];
            pos = item[field].toString().indexOf(",");
            if (pos !== -1) {
              tmp = tmp.replace(",", ".");
            }
            sum2 += parseFloat(tmp);
          }
        });
        sum2 = sum2 === 0 ? null : sum2;
        if (sum2 !== null) {
          if (!Number.isInteger(sum2)) {
            sum2 = sum2.toFixed(2);
          }
        }
        return sum2;
      }
      return {
        calculateAverage,
        calculateGroupsAverages,
        sumColumn,
        sumColumnFloat
      };
    }
    class Module {
      constructor(input_data = {}, custom_props = {}) {
        let _this = this;
        const options = {
          name: input_data.module_key,
          props: {
            module_key: String,
            module_type: String,
            common_fields: Object,
            groups: Object,
            group_key_field: String,
            predefined_values: Object,
            max_rows: Number,
            accordion_title_field: String,
            empty_record: Object,
            records: Object,
            last_update: {
              type: Object,
              default: () => {
                return {
                  user: null,
                  date: null
                };
              }
            },
            action: String,
            form_id: Number,
            enable_not_applicable: Boolean,
            warning_on_save: String,
            action_url: String,
            ...custom_props
          },
          setup(props, context) {
            return _this.setupApp(props, input_data);
          }
        };
        return this.createApp(options, input_data);
      }
      setupApp(props, input_data, custom_methods = {}) {
        const moduleContainer = document.querySelector("#module_" + props.module_key);
        const emitter = mitt();
        let records = reactive(props.records);
        let records_backup = JSON.parse(JSON.stringify(toRaw(records)));
        let status = ref("init");
        let empty_record = props.empty_record;
        let last_update = props.last_update;
        Object.keys(empty_record).forEach(function(key) {
          if (props.common_fields.map((f2) => f2["name"]).includes(key)) {
            empty_record[key] = records[0][key];
          }
        });
        const {
          accordionTitle,
          recordIsInGroup,
          numRecordsInGroup,
          ensureAteLeastOneRecordPerGroup,
          addItem,
          deleteItem
        } = useArrangeRecords({
          module_type: unref(props.module_type),
          groups: unref(props.groups),
          group_key_field: unref(props.group_key_field),
          accordion_title_field: unref(props.accordion_title_field),
          records: unref(records),
          empty_record: unref(empty_record),
          custom_methods
        });
        const { refreshDataStatus, isNotApplicable, isNotAvailable, toggleDataStatus } = useDataStatus({
          enable_not_applicable: props.enable_not_applicable,
          empty_record,
          records
        });
        const {
          resetModule,
          saveModule,
          error_messages
        } = useSave({
          records,
          records_backup,
          status,
          last_update,
          form_id: unref(props.form_id),
          module_key: unref(props.module_key),
          action_url: props.action_url,
          refreshDataStatus,
          ensureAteLeastOneRecordPerGroup,
          emitter
        });
        const { calculateAverage, calculateGroupsAverages, sumColumn, sumColumnFloat } = useCalc({
          records,
          groups: unref(props.groups),
          group_key_field: unref(props.group_key_field)
        });
        refreshDataStatus();
        ensureAteLeastOneRecordPerGroup();
        watch(records, (value) => {
          syncCommonFields();
          if (status.value !== "init") {
            if (status.value !== "changed") {
              status.value = "changed";
              emitter.emit("moduleIsChanged", { module_key: props.module_key });
            }
            emitter.emit("moduleChanged", { module_key: props.module_key, records: value });
          }
        });
        onMounted(() => {
          setPredefinedAsDisabled();
          status.value = "idle";
          emitter.emit("moduleMounted", { module_key: props.module_key });
        });
        function setPredefinedAsDisabled() {
          records.forEach((record, i2) => {
            if (typeof record.__predefined !== "undefined" && record.__predefined === true && props.predefined_values !== null) {
              let input = moduleContainer.querySelector("[id$=_" + i2 + "_" + props.predefined_values["field"] + "]");
              if (input) {
                input.setAttribute("readonly", "readonly");
                input.classList.add("field-disabled");
              }
            }
          });
        }
        function syncCommonFields() {
          props.common_fields.forEach((field) => {
            let value = records[0][field["name"]];
            records.forEach(function(item, index) {
              records[index][field["name"]] = value;
            });
          });
        }
        function toggleNotApplicable() {
          toggleDataStatus("not_applicable");
        }
        function toggleNotAvailable() {
          toggleDataStatus("not_available");
        }
        return {
          status,
          records,
          last_update,
          error_messages,
          emitter,
          // objects from or related to composables
          isNotApplicable,
          isNotAvailable,
          toggleNotAvailable,
          toggleNotApplicable,
          saveModule,
          resetModule,
          recordIsInGroup,
          numRecordsInGroup,
          accordionTitle,
          addItem,
          deleteItem,
          calculateAverage,
          calculateGroupsAverages,
          sumColumn,
          sumColumnFloat,
          // TODO: remove
          records_backup
        };
      }
      createApp(options, input_data) {
        return createApp(options, input_data).component("tooltip", tooltip).component("dialogBox", dialogBox).component("simpleText", simpleText).component("simpleTextarea", simpleTextarea).component("simpleUrl", simpleUrl).component("simpleEmail", simpleEmail).component("simplePassword", simplePassword).component("rating", rating).component("dropdown", dropdown).component("simpleDate", simpleDate).component("simpleNumeric", simpleNumeric).component("toggle", toggle).component("checkbox", checkbox).component("selector-species_animal", selectorSpeciesAnimal).component("upload", uploadFile).component("textEditor", editor);
      }
    }
    const Accordion = {
      CLASS_NAME_SHOWING: "showing",
      CLASS_NAME_SHOW: "show",
      toggle(evt) {
        let clicked_accordion_item = evt.target.closest(".accordion-item");
        let accordion = clicked_accordion_item.closest(".accordion");
        let is_current_clicked_item_active = clicked_accordion_item.classList.contains(this.CLASS_NAME_SHOW);
        let accordion_items = accordion.querySelectorAll(".accordion-item");
        accordion_items.forEach((item) => {
          this.close(item);
        });
        if (is_current_clicked_item_active) {
          this.close(clicked_accordion_item);
        } else {
          this.open(clicked_accordion_item);
        }
      },
      open(item) {
        let item_body = item.querySelector(".accordion-item-body");
        item_body.style.maxHeight = item_body.scrollHeight + "px";
        item.classList.add(this.CLASS_NAME_SHOWING);
        setTimeout(() => {
          item.classList.add(this.CLASS_NAME_SHOW);
          item.classList.remove(this.CLASS_NAME_SHOWING);
        }, 500);
      },
      close(item) {
        item.querySelector(".accordion-item-body").style.maxHeight = null;
        item.classList.remove(this.CLASS_NAME_SHOW);
      }
    };
    window.Laravel = window.Laravel || {};
    window.ModularForms = {};
    window.ModularFormsVendor = window.ModularFormsVendor || {};
    window.ModularForms.Helpers = window.ModularForms.Helpers || {};
    window.ModularForms.Components = window.ModularForms.Components || {};
    window.ModularForms.Helpers.Locale = Locale$1;
    window.ModularForms.Helpers.Animation = Animation;
    window.ModularForms.Helpers.Common = Common;
    window.ModularForms.Helpers.Cookie = Cookie;
    window.ModularForms.Helpers.Payload = Payload;
    window.ModularForms.Components.selectorDialog = selectorDialog;
    window.ModularForms.Apps = window.ModularForms.Apps || {};
    window.ModularForms.Apps.Base = Base;
    window.ModularForms.Apps.FormList = FormList;
    window.ModularForms.Apps.FormErrors = FormErrors;
    window.ModularForms.Apps.Module = Module;
    window.ModularForms.Accordion = Accordion;
    const BiopamaWDPA = {
      base_layer: "mapbox://styles/jamesdavy/cjw25laqe0y311dqulwkvnfoc",
      addWdpaLayer(map2, wdpa_ids = null, color = null) {
        map2.addSource("geospatial_jrc", {
          type: "vector",
          tiles: [
            "https://geospatial.jrc.ec.europa.eu/geoserver/gwc/service/wmts?layer=marxan:wdpa_latest_biopama&tilematrixset=EPSG:900913&Service=WMTS&Request=GetTile&Version=1.0.0&Format=application/x-protobuf;type=mapbox-vector&TileMatrix=EPSG:900913:{z}&TILECOL={x}&TILEROW={y}"
          ],
          "tileSize": 512,
          "scheme": "xyz"
        });
        color = color || [
          "match",
          ["get", "marine"],
          ["0"],
          "rgba(141, 191, 79, 0.7)",
          "rgba(104, 156, 150, 0.7)"
        ];
        map2.addLayer({
          "id": "biopama_wdpa",
          "type": "fill",
          "source": "geospatial_jrc",
          "source-layer": "wdpa_latest_biopama",
          "minzoom": 2,
          "paint": {
            "fill-color": color
          }
        });
        if (wdpa_ids !== null) {
          wdpa_ids = typeof wdpa_ids === "string" ? wdpa_ids.split(",") : wdpa_ids;
          wdpa_ids = wdpa_ids.map(function(item) {
            return parseInt(item);
          });
          map2.setFilter("biopama_wdpa", ["in", "wdpaid"].concat(wdpa_ids));
        }
      }
    };
    const _sfc_main$V = {
      __name: "progress_bar",
      props: {
        value: {
          type: [Number, String],
          default: () => 0
        },
        color: {
          type: String,
          default: () => ""
        },
        additional_label: {
          type: String,
          default: () => ""
        },
        digit: {
          type: Number,
          default: () => 2
        },
        negative: {
          type: Boolean,
          default: false
        }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const props = __props;
        const style = computed(() => {
          return "width: " + Math.abs(props.value).toFixed(props.digit) + "%; background-color: " + props.color + " !important;";
        });
        const __returned__ = { props, style, computed };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$H = { class: "progress-bar" };
    const _hoisted_2$z = {
      key: 1,
      class: "label"
    };
    function _sfc_render$V(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", _hoisted_1$H, [
        $props.value !== null ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(["bar", { "float-right": $props.negative }]),
          style: normalizeStyle($setup.style)
        }, null, 6)) : createCommentVNode("", true),
        $props.value !== null ? (openBlock(), createElementBlock("div", _hoisted_2$z, toDisplayString($props.value) + "% " + toDisplayString($props.additional_label), 1)) : createCommentVNode("", true)
      ]);
    }
    const progress_bar = /* @__PURE__ */ _export_sfc(_sfc_main$V, [["render", _sfc_render$V], ["__scopeId", "data-v-420937fa"], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/templates/progress_bar.vue"]]);
    const _sfc_main$U = {
      __name: "imet_score_bar",
      props: {
        value: {
          type: [String, Number],
          default: 0
        },
        color: {
          type: String,
          default: "#ccc"
        },
        showLimits: {
          type: Boolean,
          default: true
        },
        min: {
          type: Number,
          default: 0
        },
        max: {
          type: Number,
          default: 100
        }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const props = __props;
        const score_value = computed(() => {
          if (props.value === null) return null;
          return typeof props.value === "number" ? props.value.toFixed(1) : parseFloat(props.value).toFixed(1);
        });
        const negative = computed(() => {
          return props.value < 0 || props.min < 0;
        });
        const __returned__ = { props, score_value, negative, computed, progress_bar };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$G = { class: "score-bar text-2xs" };
    const _hoisted_2$y = {
      key: 0,
      class: "score-bar__limit-left"
    };
    const _hoisted_3$r = {
      key: 1,
      class: "score-bar__limit-right"
    };
    function _sfc_render$U(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", _hoisted_1$G, [
        $props.showLimits && $props.min !== null ? (openBlock(), createElementBlock("div", _hoisted_2$y, toDisplayString($props.min) + "%", 1)) : createCommentVNode("", true),
        createVNode($setup["progress_bar"], {
          value: $setup.score_value,
          color: $props.color,
          negative: $setup.negative
        }, null, 8, ["value", "color", "negative"]),
        $props.showLimits && $props.max !== null ? (openBlock(), createElementBlock("div", _hoisted_3$r, toDisplayString($props.max) + "%", 1)) : createCommentVNode("", true)
      ]);
    }
    const imetScoreBar = /* @__PURE__ */ _export_sfc(_sfc_main$U, [["render", _sfc_render$U], ["__scopeId", "data-v-6f11f8bd"], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/templates/imet_score_bar.vue"]]);
    const _sfc_main$T = {
      __name: "imet_radar",
      props: {
        width: {
          type: Number,
          default: 180
        },
        height: {
          type: Number,
          default: 180
        },
        values: {
          type: Object,
          default: () => {
          }
        }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const props = __props;
        const radar = ref(null);
        const radar_options = computed(() => {
          let values2 = [];
          let labels = [];
          Object.entries(props.values).reverse().forEach(function([key, value]) {
            values2.push(value);
            labels.push({ name: key.replace(" ", "\n"), max: 100 });
          });
          return {
            tooltip: {
              trigger: "axis"
            },
            radar: {
              indicator: labels,
              radius: "65%",
              startAngle: 150,
              axisName: {
                color: "#111",
                padding: [0, 0]
              }
            },
            series: [
              {
                type: "radar",
                data: [
                  {
                    value: values2,
                    itemStyle: {
                      color: "#7CB5EC"
                    },
                    areaStyle: {
                      color: "#7CB5EC",
                      opacity: 0.4
                    },
                    symbolSize: 6,
                    name: "imet_radar",
                    label: {
                      fontWeight: "bold",
                      color: "#222",
                      show: true,
                      formatter: function(params) {
                        return params.value;
                      }
                    }
                  }
                ]
              }
            ]
          };
        });
        onMounted(() => {
          draw_chart();
        });
        watch(() => props.values, () => {
          draw_chart();
        });
        function draw_chart() {
          if (Object.keys(props.values).length > 1) {
            init(radar.value).setOption(radar_options.value);
          }
        }
        const __returned__ = { props, radar, radar_options, draw_chart, get echarts() {
          return echarts;
        }, computed, ref, onMounted, watch };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    function _sfc_render$T(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        ref: "radar",
        style: normalizeStyle("width:" + $props.width + "px; height: " + $props.height + "px;")
      }, null, 4);
    }
    const imet_radar = /* @__PURE__ */ _export_sfc(_sfc_main$T, [["render", _sfc_render$T], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/templates/imet_radar.vue"]]);
    const _sfc_main$S = {
      __name: "multiple-files-upload",
      props: {
        uploadUrl: {
          type: String,
          default: null
        },
        backUrl: {
          type: String,
          default: null
        }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const props = __props;
        const Locale2 = window.ModularForms.Helpers.Locale;
        const files_added = ref(0);
        const files_uploaded = ref(0);
        const formatTypes = ["application/json", "application/zip"];
        const dropzoneComponent = ref(null);
        const dropZoneOptions = {
          url: props.uploadUrl,
          previewTemplate: `<div class="dropzone-file-list text-sm">
            <div class="file-row">
                <div class="file-details">
                    <div class="name" data-dz-name></div>
                    <div class="size" data-dz-size></div>
                    <div class="dz-remove" data-dz-remove></div>
                    <div class="progress">
                        <div class="progress-bar total-progress" style="width:0;" data-dz-uploadprogress></div>
                    </div>
                </div>
            </div>
        </div>`,
          // previewTemplate:
          //     `<div class="files text-sm">
          //         <div class="file-row dz-preview dz-file-preview">
          //             <div class="dz-details">
          //                 <div class="dz-filename"><span data-dz-name></span></div>
          //                 <div class="dz-size" data-dz-size></div>
          //             </div>
          //             <div class="dz-progress"><span class="dz-upload" data-dz-uploadprogress></span></div>
          //             <div class="dz-success-mark"><span></span></div>
          //             <div class="dz-error-mark"><span></span></div>
          //             <div class="dz-error-message"><span data-dz-errormessage></span></div>
          //         </div>
          //     </div>`,
          params(files, xhr, chunk2) {
            return {
              _token: window.Laravel.csrfToken
            };
          },
          addRemoveLinks: true,
          clickable: true,
          maxFiles: 20,
          maxFilesize: 150,
          timeout: 1e5,
          acceptedFiles: ".json,.zip",
          autoProcessQueue: true,
          dictDefaultMessage: Locale2.getLabel("modular-forms::common.upload.dict_default_message"),
          dictFallbackMessage: Locale2.getLabel("modular-forms::common.upload.dict_fallback_message"),
          dictFallbackText: Locale2.getLabel("modular-forms::common.upload.dict_fallback_text"),
          dictFileTooBig: Locale2.getLabel("modular-forms::common.upload.dict_file_too_big"),
          dictInvalidFileType: Locale2.getLabel("modular-forms::common.upload.dict_invalid_file_type"),
          dictResponseError: Locale2.getLabel("modular-forms::common.upload.dict_response_error"),
          dictCancelUpload: Locale2.getLabel("modular-forms::common.upload.dict_cancel_upload"),
          dictUploadCanceled: Locale2.getLabel("modular-forms::common.upload.dict_upload_canceled"),
          dictRemoveFile: Locale2.getLabel("modular-forms::common.upload.dict_remove_file"),
          dictMaxFilesExceeded: Locale2.getLabel("modular-forms::common.upload.dictMaxFilesExceeded")
        };
        function progressBarConfiguration(file, label, color = "blue", width = "100%") {
          const selector = file.previewTemplate.querySelector(".total-progress.progress-bar");
          selector.innerHTML = label;
          selector.style.backgroundColor = color;
          selector.style.color = "white";
          selector.style.width = width;
        }
        function fileAdded(file) {
          files_added.value++;
        }
        function uploadError(file, message) {
          files_uploaded.value++;
          let errorMessage = Locale2.getLabel("modular-forms::common.upload.upload_error");
          if (message["message"]) {
            errorMessage += message["message"];
          } else if (!formatTypes.includes(file.type)) {
            errorMessage = Locale2.getLabel("modular-forms::common.upload.not_valid_format");
          } else {
            errorMessage += message;
          }
          progressBarConfiguration(file, errorMessage, "red", "100%");
        }
        function processing(file) {
          progressBarConfiguration(file, Locale2.getLabel("modular-forms::common.upload.uploading"));
        }
        function uploadedSuccessfully(file, response) {
          files_uploaded.value++;
          let message = Locale2.getLabel("modular-forms::common.upload.uploaded");
          if (response.length > 1) {
            let filesDidNotUploaded = 0;
            response.forEach((r2) => {
              if (r2.status !== "error") {
                filesDidNotUploaded++;
              }
            });
            const totalFiles = response.length;
            message += Locale2.getLabel("modular-forms::common.upload.not_all_imported").replace("{{filesDidNotUploaded}}", filesDidNotUploaded).replace("{{totalFiles}}", totalFiles);
          }
          progressBarConfiguration(file, message, "green");
        }
        const __returned__ = { props, Locale: Locale2, files_added, files_uploaded, formatTypes, dropzoneComponent, dropZoneOptions, progressBarConfiguration, fileAdded, uploadError, processing, uploadedSuccessfully, ref, get vueDropzone() {
          return vueDropzone;
        } };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$F = { class: "dropzone-custom-content" };
    const _hoisted_2$x = { class: "dropzone-custom-title" };
    const _hoisted_3$q = ["href"];
    function _sfc_render$S(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode($setup["vueDropzone"], {
          ref: "dropzoneComponent",
          id: "dropzone",
          options: $setup.dropZoneOptions,
          useCustomSlot: true,
          onVdropzoneError: $setup.uploadError,
          onVdropzoneProcessing: $setup.processing,
          onVdropzoneSuccess: $setup.uploadedSuccessfully,
          onVdropzoneFileAdded: $setup.fileAdded
        }, {
          default: withCtx(() => [
            createBaseVNode("div", _hoisted_1$F, [
              createBaseVNode("h3", _hoisted_2$x, toDisplayString($setup.Locale.getLabel("modular-forms::common.upload.multiple_files_description")), 1)
            ])
          ]),
          _: 1
        }, 512),
        withDirectives(createBaseVNode("a", {
          class: "btn-nav",
          href: $props.backUrl
        }, toDisplayString($setup.Locale.getLabel("modular-forms::common.go_back")), 9, _hoisted_3$q), [
          [vShow, $setup.files_added > 0 && $setup.files_added === $setup.files_uploaded]
        ])
      ], 64);
    }
    const multipleFilesUpload = /* @__PURE__ */ _export_sfc(_sfc_main$S, [["render", _sfc_render$S], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/inputs/multiple-files-upload.vue"]]);
    const marineIcon = "/build/assets/fish-PuECKpUO.png";
    const terrestrialIcon = "/build/assets/tree-1D_APfEu.png";
    const TERRESTRIAL_AND_MARINE = "terrestrial_and_marine";
    const TERRESTRIAL = "terrestrial";
    const MARINE = "marine";
    const _sfc_main$R = {
      __name: "scope_icon",
      props: {
        scope: {
          type: String,
          default: null
        }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const Locale2 = window.ModularForms.Helpers.Locale;
        const props = __props;
        const __returned__ = { Locale: Locale2, props, TERRESTRIAL_AND_MARINE, TERRESTRIAL, MARINE, get marineIcon() {
          return marineIcon;
        }, get terrestrialIcon() {
          return terrestrialIcon;
        } };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$E = ["src"];
    const _hoisted_2$w = ["src"];
    function _sfc_render$R(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_tooltip = resolveComponent("tooltip");
      return openBlock(), createElementBlock(Fragment, null, [
        $props.scope === $setup.TERRESTRIAL_AND_MARINE || $props.scope === $setup.TERRESTRIAL ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createBaseVNode("img", {
            style: { "height": "28px" },
            src: $setup.terrestrialIcon,
            class: "inline mr-2"
          }, null, 8, _hoisted_1$E),
          createVNode(_component_tooltip, null, {
            default: withCtx(() => [
              createTextVNode(toDisplayString($setup.Locale.getLabel("imet-core::common.terrestrial")), 1)
            ]),
            _: 1
          })
        ], 64)) : createCommentVNode("", true),
        $props.scope === $setup.TERRESTRIAL_AND_MARINE || $props.scope === $setup.MARINE ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          createBaseVNode("img", {
            style: { "height": "28px" },
            src: $setup.marineIcon,
            class: "inline mr-2"
          }, null, 8, _hoisted_2$w),
          createVNode(_component_tooltip, null, {
            default: withCtx(() => [
              createTextVNode(toDisplayString($setup.Locale.getLabel("imet-core::common.marine")), 1)
            ]),
            _: 1
          })
        ], 64)) : createCommentVNode("", true)
      ], 64);
    }
    const scopeIcon = /* @__PURE__ */ _export_sfc(_sfc_main$R, [["render", _sfc_render$R], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/templates/scope_icon.vue"]]);
    class BaseImet extends Base {
      constructor(options, input_data) {
        return super(options, input_data).component("imet_score_bar", imetScoreBar).component("imet_radar", imet_radar).component("multiple-files-upload", multipleFilesUpload).component("scope-icon", scopeIcon);
      }
    }
    const _sfc_main$Q = {
      __name: "imet_encoders_responsibles",
      props: {
        max_visible: {
          type: Number,
          default: 4
        },
        items: {
          type: [String, Object],
          default: () => {
            return {
              "internal": [],
              "external": [],
              "encoders": []
            };
          }
        }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const Locale2 = window.ModularForms.Helpers.Locale;
        const showHidden = ref(false);
        const props = __props;
        const total_count = computed(() => {
          return props.items["internal"].length + props.items["external"].length + props.items["encoders"].length;
        });
        const to_be_shown = computed(() => {
          let items = {
            "internal": [],
            "external": [],
            "encoders": []
          };
          let current_shown = 0;
          Object.values(props.items["internal"]).forEach(function(item) {
            if (current_shown < props.max_visible || showHidden.value) {
              if (item["Name"] !== null) {
                items["internal"].push(item);
              }
            }
            current_shown++;
          });
          Object.values(props.items["external"]).forEach(function(item) {
            if (current_shown < props.max_visible || showHidden.value) {
              if (item["Name"] !== null) {
                items["external"].push(item);
              }
            }
            current_shown++;
          });
          Object.values(props.items["encoders"]).forEach(function(item) {
            if (current_shown < props.max_visible || showHidden.value) {
              if (item["name"] !== null && item["name"].trim() !== "") {
                items["encoders"].push(item);
              }
            }
            current_shown++;
          });
          return items;
        });
        function toggleShown() {
          showHidden.value = !showHidden.value;
        }
        const __returned__ = { Locale: Locale2, showHidden, props, total_count, to_be_shown, toggleShown, computed, ref };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$D = { class: "imet_responsible" };
    const _hoisted_2$v = { key: 0 };
    const _hoisted_3$p = { key: 0 };
    const _hoisted_4$k = { key: 1 };
    const _hoisted_5$j = { key: 0 };
    const _hoisted_6$e = { key: 2 };
    const _hoisted_7$b = { key: 0 };
    function _sfc_render$Q(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", _hoisted_1$D, [
        $setup.to_be_shown["internal"].length > 0 ? (openBlock(), createElementBlock("div", _hoisted_2$v, [
          createBaseVNode("b", null, toDisplayString($setup.Locale.getLabel("imet-core::common.responsible_internal")), 1),
          _cache[0] || (_cache[0] = createTextVNode(":")),
          _cache[1] || (_cache[1] = createBaseVNode("br", null, null, -1)),
          createBaseVNode("ul", null, [
            (openBlock(true), createElementBlock(Fragment, null, renderList($setup.to_be_shown["internal"], (resp) => {
              return openBlock(), createElementBlock("li", null, [
                createTextVNode(toDisplayString(resp["Name"]) + " ", 1),
                resp["Institution"] ? (openBlock(), createElementBlock("span", _hoisted_3$p, [
                  createBaseVNode("i", null, "(" + toDisplayString(resp["Institution"]) + ")", 1)
                ])) : createCommentVNode("", true)
              ]);
            }), 256))
          ])
        ])) : createCommentVNode("", true),
        $setup.to_be_shown["external"].length > 0 ? (openBlock(), createElementBlock("div", _hoisted_4$k, [
          createBaseVNode("b", null, toDisplayString($setup.Locale.getLabel("imet-core::common.responsible_external")), 1),
          _cache[2] || (_cache[2] = createTextVNode(": ")),
          createBaseVNode("ul", null, [
            (openBlock(true), createElementBlock(Fragment, null, renderList($setup.to_be_shown["external"], (resp) => {
              return openBlock(), createElementBlock("li", null, [
                createTextVNode(toDisplayString(resp["Name"]) + " ", 1),
                resp["Institution"] ? (openBlock(), createElementBlock("span", _hoisted_5$j, [
                  createBaseVNode("i", null, "(" + toDisplayString(resp["Institution"]) + ")", 1)
                ])) : createCommentVNode("", true)
              ]);
            }), 256))
          ])
        ])) : createCommentVNode("", true),
        $setup.to_be_shown["encoders"].length > 0 ? (openBlock(), createElementBlock("div", _hoisted_6$e, [
          createBaseVNode("b", null, toDisplayString($setup.Locale.getLabel("imet-core::common.encoders")), 1),
          _cache[3] || (_cache[3] = createTextVNode(": ")),
          createBaseVNode("ul", null, [
            (openBlock(true), createElementBlock(Fragment, null, renderList($setup.to_be_shown["encoders"], (resp) => {
              return openBlock(), createElementBlock("li", null, [
                createTextVNode(toDisplayString(resp["name"]) + " ", 1),
                resp["institution"] ? (openBlock(), createElementBlock("span", _hoisted_7$b, [
                  createBaseVNode("i", null, "(" + toDisplayString(resp["institution"]) + ")", 1)
                ])) : createCommentVNode("", true)
              ]);
            }), 256))
          ])
        ])) : createCommentVNode("", true),
        $setup.total_count > $props.max_visible && !$setup.showHidden ? (openBlock(), createElementBlock("button", {
          key: 3,
          class: "btn-nav small",
          onClick: $setup.toggleShown
        }, [
          _cache[4] || (_cache[4] = createBaseVNode("i", { class: "fas fa-plus-square" }, null, -1)),
          createTextVNode(" " + toDisplayString($setup.Locale.getLabel("modular-forms::common.view_all")), 1)
        ])) : createCommentVNode("", true),
        $setup.showHidden ? (openBlock(), createElementBlock("button", {
          key: 4,
          class: "btn-nav small",
          onClick: $setup.toggleShown
        }, [
          _cache[5] || (_cache[5] = createBaseVNode("i", { class: "fas fa-minus-square" }, null, -1)),
          createTextVNode(" " + toDisplayString($setup.Locale.getLabel("modular-forms::common.hide")), 1)
        ])) : createCommentVNode("", true)
      ]);
    }
    const imetEncodersResponsibles = /* @__PURE__ */ _export_sfc(_sfc_main$Q, [["render", _sfc_render$Q], ["__scopeId", "data-v-2aa7151e"], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/templates/imet_encoders_responsibles.vue"]]);
    class FormListImet extends FormList {
      constructor(options, input_data) {
        return super(options, input_data).component("imet_encoders_responsibles", imetEncodersResponsibles).component("imet_radar", imet_radar);
      }
    }
    const _sfc_main$P = {
      __name: "selector-wdpa",
      props: /* @__PURE__ */ mergeModels({
        id: {
          type: String,
          default: null
        },
        searchUrl: {
          type: String,
          default: null
        },
        labelUrl: {
          type: String,
          default: null
        },
        multiple: {
          type: Boolean,
          default: false
        }
      }, {
        "modelValue": {},
        "modelModifiers": {}
      }),
      emits: ["update:modelValue"],
      setup(__props, { expose: __expose }) {
        __expose();
        const selectorDialog2 = window.ModularForms.Components.selectorDialog;
        const Locale2 = window.ModularForms.Helpers.Locale;
        const props = __props;
        const selectorDialogComponent = ref(null);
        provide("setLabel", setLabel);
        provide("setValue", setValue);
        const inputValue = useModel(__props, "modelValue");
        function setLabel(item) {
          return item == null ? void 0 : item.name;
        }
        function setValue(item) {
          return item == null ? void 0 : item.wdpa_id;
        }
        const __returned__ = { selectorDialog: selectorDialog2, Locale: Locale2, props, selectorDialogComponent, inputValue, setLabel, setValue, ref, provide, onBeforeMount, onMounted };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$C = { class: "result_left" };
    const _hoisted_2$u = ["href"];
    function _sfc_render$P(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createBlock($setup["selectorDialog"], {
        modelValue: $setup.inputValue,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.inputValue = $event),
        "parent-id": $props.id,
        "search-url": $props.searchUrl,
        "label-url": $props.labelUrl,
        multiple: $props.multiple,
        "with-id": true,
        ref: "selectorDialogComponent"
      }, {
        searchResultHeader: withCtx(() => [
          createBaseVNode("th", null, toDisplayString($setup.Locale.getLabel("imet-core::common.name")), 1),
          createBaseVNode("th", null, toDisplayString($setup.Locale.getLabel("imet-core::common.protected_area.wdpa_id", 1)), 1),
          createBaseVNode("th", null, toDisplayString($setup.Locale.getLabel("imet-core::common.country")), 1),
          createBaseVNode("th", null, toDisplayString($setup.Locale.getLabel("imet-core::common.protected_area.iucn_category")), 1)
        ]),
        searchResultItem: withCtx(({ item }) => [
          createBaseVNode("td", null, [
            createBaseVNode("span", _hoisted_1$C, [
              createBaseVNode("b", null, toDisplayString(item.name), 1)
            ])
          ]),
          createBaseVNode("td", null, [
            item.wdpa_id !== null ? (openBlock(), createElementBlock("a", {
              key: 0,
              target: "_blank",
              href: "https://www.protectedplanet.net/" + item.wdpa_id
            }, toDisplayString(item.wdpa_id), 9, _hoisted_2$u)) : createCommentVNode("", true)
          ]),
          createBaseVNode("td", null, toDisplayString(item.country_name), 1),
          createBaseVNode("td", null, toDisplayString(item.iucn_category), 1)
        ]),
        _: 1
      }, 8, ["modelValue", "parent-id", "search-url", "label-url", "multiple"]);
    }
    const selectorWdpa = /* @__PURE__ */ _export_sfc(_sfc_main$P, [["render", _sfc_render$P], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/inputs/selector-wdpa.vue"]]);
    class ModuleImet extends Module {
      constructor(input_data = {}, custom_props = {}) {
        return super(input_data, custom_props).component("selector-wdpa", selectorWdpa).component("scope-icon", scopeIcon).component("imet_score_bar", imetScoreBar);
      }
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        const Locale2 = window.ModularForms.Helpers.Locale;
        setup_obj.emitter.on("moduleSaved", (data) => {
          if (window.AssessmentScores) {
            window.AssessmentScores.refresh_scores();
          }
        });
        function hasRecordsToEvaluate(criteria_field, group_key) {
          group_key = group_key || null;
          if (group_key == null) {
            return setup_obj.records.length !== 0 && setup_obj.records[0][criteria_field] !== null;
          } else {
            let records_in_group = setup_obj.records.filter((record) => record[props.group_key_field] === group_key);
            return records_in_group.length !== 0 && records_in_group[0][criteria_field] !== null;
          }
        }
        function key_element_label(value) {
          if (value !== null) {
            if (isTaxonomy(value)) {
              return getScientificName(value);
            } else if (isHabitat(value)) {
              return getHabitatLabel(value);
            }
          }
          return value;
        }
        function isTaxonomy(value) {
          return (value.match(/\|/g) || []).length === 5;
        }
        function getScientificName(value) {
          let taxonomy = value.split("|");
          return taxonomy[4] + " " + taxonomy[5];
        }
        function isHabitat(value) {
          return !Locale2.getLabel("imet-core::v2_lists.Habitats." + value).includes("::v2_lists");
        }
        function getHabitatLabel(value) {
          return Locale2.getLabel("imet-core::v2_lists.Habitats." + value);
        }
        return {
          ...setup_obj,
          key_element_label,
          hasRecordsToEvaluate
        };
      }
      createApp(options, input_data) {
        return super.createApp(options, input_data);
      }
    }
    var isVue2 = false;
    function set(target, key, val) {
      if (Array.isArray(target)) {
        target.length = Math.max(target.length, key);
        target.splice(key, 1, val);
        return val;
      }
      target[key] = val;
      return val;
    }
    function del(target, key) {
      if (Array.isArray(target)) {
        target.splice(key, 1);
        return;
      }
      delete target[key];
    }
    function getDevtoolsGlobalHook() {
      return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
    }
    function getTarget() {
      return typeof navigator !== "undefined" && typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : {};
    }
    const isProxyAvailable = typeof Proxy === "function";
    const HOOK_SETUP = "devtools-plugin:setup";
    const HOOK_PLUGIN_SETTINGS_SET = "plugin:settings:set";
    let supported;
    let perf;
    function isPerformanceSupported() {
      var _a2;
      if (supported !== void 0) {
        return supported;
      }
      if (typeof window !== "undefined" && window.performance) {
        supported = true;
        perf = window.performance;
      } else if (typeof globalThis !== "undefined" && ((_a2 = globalThis.perf_hooks) === null || _a2 === void 0 ? void 0 : _a2.performance)) {
        supported = true;
        perf = globalThis.perf_hooks.performance;
      } else {
        supported = false;
      }
      return supported;
    }
    function now() {
      return isPerformanceSupported() ? perf.now() : Date.now();
    }
    class ApiProxy {
      constructor(plugin, hook) {
        this.target = null;
        this.targetQueue = [];
        this.onQueue = [];
        this.plugin = plugin;
        this.hook = hook;
        const defaultSettings = {};
        if (plugin.settings) {
          for (const id in plugin.settings) {
            const item = plugin.settings[id];
            defaultSettings[id] = item.defaultValue;
          }
        }
        const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;
        let currentSettings = Object.assign({}, defaultSettings);
        try {
          const raw = localStorage.getItem(localSettingsSaveId);
          const data = JSON.parse(raw);
          Object.assign(currentSettings, data);
        } catch (e2) {
        }
        this.fallbacks = {
          getSettings() {
            return currentSettings;
          },
          setSettings(value) {
            try {
              localStorage.setItem(localSettingsSaveId, JSON.stringify(value));
            } catch (e2) {
            }
            currentSettings = value;
          },
          now() {
            return now();
          }
        };
        if (hook) {
          hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {
            if (pluginId === this.plugin.id) {
              this.fallbacks.setSettings(value);
            }
          });
        }
        this.proxiedOn = new Proxy({}, {
          get: (_target, prop) => {
            if (this.target) {
              return this.target.on[prop];
            } else {
              return (...args) => {
                this.onQueue.push({
                  method: prop,
                  args
                });
              };
            }
          }
        });
        this.proxiedTarget = new Proxy({}, {
          get: (_target, prop) => {
            if (this.target) {
              return this.target[prop];
            } else if (prop === "on") {
              return this.proxiedOn;
            } else if (Object.keys(this.fallbacks).includes(prop)) {
              return (...args) => {
                this.targetQueue.push({
                  method: prop,
                  args,
                  resolve: () => {
                  }
                });
                return this.fallbacks[prop](...args);
              };
            } else {
              return (...args) => {
                return new Promise((resolve) => {
                  this.targetQueue.push({
                    method: prop,
                    args,
                    resolve
                  });
                });
              };
            }
          }
        });
      }
      async setRealTarget(target) {
        this.target = target;
        for (const item of this.onQueue) {
          this.target.on[item.method](...item.args);
        }
        for (const item of this.targetQueue) {
          item.resolve(await this.target[item.method](...item.args));
        }
      }
    }
    function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
      const descriptor = pluginDescriptor;
      const target = getTarget();
      const hook = getDevtoolsGlobalHook();
      const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;
      if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
        hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);
      } else {
        const proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;
        const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
        list.push({
          pluginDescriptor: descriptor,
          setupFn,
          proxy
        });
        if (proxy) {
          setupFn(proxy.proxiedTarget);
        }
      }
    }
    /*!
     * pinia v2.2.6
     * (c) 2024 Eduardo San Martin Morote
     * @license MIT
     */
    let activePinia;
    const setActivePinia = (pinia) => activePinia = pinia;
    const piniaSymbol = Symbol("pinia");
    function isPlainObject$1(o2) {
      return o2 && typeof o2 === "object" && Object.prototype.toString.call(o2) === "[object Object]" && typeof o2.toJSON !== "function";
    }
    var MutationType;
    (function(MutationType2) {
      MutationType2["direct"] = "direct";
      MutationType2["patchObject"] = "patch object";
      MutationType2["patchFunction"] = "patch function";
    })(MutationType || (MutationType = {}));
    const IS_CLIENT = typeof window !== "undefined";
    const _global$1 = /* @__PURE__ */ (() => typeof window === "object" && window.window === window ? window : typeof self === "object" && self.self === self ? self : typeof global === "object" && global.global === global ? global : typeof globalThis === "object" ? globalThis : { HTMLElement: null })();
    function bom(blob, { autoBom = false } = {}) {
      if (autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
        return new Blob([String.fromCharCode(65279), blob], { type: blob.type });
      }
      return blob;
    }
    function download(url, name, opts) {
      const xhr = new XMLHttpRequest();
      xhr.open("GET", url);
      xhr.responseType = "blob";
      xhr.onload = function() {
        saveAs(xhr.response, name, opts);
      };
      xhr.onerror = function() {
        console.error("could not download file");
      };
      xhr.send();
    }
    function corsEnabled(url) {
      const xhr = new XMLHttpRequest();
      xhr.open("HEAD", url, false);
      try {
        xhr.send();
      } catch (e2) {
      }
      return xhr.status >= 200 && xhr.status <= 299;
    }
    function click(node) {
      try {
        node.dispatchEvent(new MouseEvent("click"));
      } catch (e2) {
        const evt = document.createEvent("MouseEvents");
        evt.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null);
        node.dispatchEvent(evt);
      }
    }
    const _navigator = typeof navigator === "object" ? navigator : { userAgent: "" };
    const isMacOSWebView = /* @__PURE__ */ (() => /Macintosh/.test(_navigator.userAgent) && /AppleWebKit/.test(_navigator.userAgent) && !/Safari/.test(_navigator.userAgent))();
    const saveAs = !IS_CLIENT ? () => {
    } : (
      // Use download attribute first if possible (#193 Lumia mobile) unless this is a macOS WebView or mini program
      typeof HTMLAnchorElement !== "undefined" && "download" in HTMLAnchorElement.prototype && !isMacOSWebView ? downloadSaveAs : (
        // Use msSaveOrOpenBlob as a second approach
        "msSaveOrOpenBlob" in _navigator ? msSaveAs : (
          // Fallback to using FileReader and a popup
          fileSaverSaveAs
        )
      )
    );
    function downloadSaveAs(blob, name = "download", opts) {
      const a2 = document.createElement("a");
      a2.download = name;
      a2.rel = "noopener";
      if (typeof blob === "string") {
        a2.href = blob;
        if (a2.origin !== location.origin) {
          if (corsEnabled(a2.href)) {
            download(blob, name, opts);
          } else {
            a2.target = "_blank";
            click(a2);
          }
        } else {
          click(a2);
        }
      } else {
        a2.href = URL.createObjectURL(blob);
        setTimeout(function() {
          URL.revokeObjectURL(a2.href);
        }, 4e4);
        setTimeout(function() {
          click(a2);
        }, 0);
      }
    }
    function msSaveAs(blob, name = "download", opts) {
      if (typeof blob === "string") {
        if (corsEnabled(blob)) {
          download(blob, name, opts);
        } else {
          const a2 = document.createElement("a");
          a2.href = blob;
          a2.target = "_blank";
          setTimeout(function() {
            click(a2);
          });
        }
      } else {
        navigator.msSaveOrOpenBlob(bom(blob, opts), name);
      }
    }
    function fileSaverSaveAs(blob, name, opts, popup) {
      popup = popup || open("", "_blank");
      if (popup) {
        popup.document.title = popup.document.body.innerText = "downloading...";
      }
      if (typeof blob === "string")
        return download(blob, name, opts);
      const force = blob.type === "application/octet-stream";
      const isSafari2 = /constructor/i.test(String(_global$1.HTMLElement)) || "safari" in _global$1;
      const isChromeIOS = /CriOS\/[\d]+/.test(navigator.userAgent);
      if ((isChromeIOS || force && isSafari2 || isMacOSWebView) && typeof FileReader !== "undefined") {
        const reader = new FileReader();
        reader.onloadend = function() {
          let url = reader.result;
          if (typeof url !== "string") {
            popup = null;
            throw new Error("Wrong reader.result type");
          }
          url = isChromeIOS ? url : url.replace(/^data:[^;]*;/, "data:attachment/file;");
          if (popup) {
            popup.location.href = url;
          } else {
            location.assign(url);
          }
          popup = null;
        };
        reader.readAsDataURL(blob);
      } else {
        const url = URL.createObjectURL(blob);
        if (popup)
          popup.location.assign(url);
        else
          location.href = url;
        popup = null;
        setTimeout(function() {
          URL.revokeObjectURL(url);
        }, 4e4);
      }
    }
    function toastMessage(message, type) {
      const piniaMessage = " " + message;
      if (typeof __VUE_DEVTOOLS_TOAST__ === "function") {
        __VUE_DEVTOOLS_TOAST__(piniaMessage, type);
      } else if (type === "error") {
        console.error(piniaMessage);
      } else if (type === "warn") {
        console.warn(piniaMessage);
      } else {
        console.log(piniaMessage);
      }
    }
    function isPinia(o2) {
      return "_a" in o2 && "install" in o2;
    }
    function checkClipboardAccess() {
      if (!("clipboard" in navigator)) {
        toastMessage(`Your browser doesn't support the Clipboard API`, "error");
        return true;
      }
    }
    function checkNotFocusedError(error) {
      if (error instanceof Error && error.message.toLowerCase().includes("document is not focused")) {
        toastMessage('You need to activate the "Emulate a focused page" setting in the "Rendering" panel of devtools.', "warn");
        return true;
      }
      return false;
    }
    async function actionGlobalCopyState(pinia) {
      if (checkClipboardAccess())
        return;
      try {
        await navigator.clipboard.writeText(JSON.stringify(pinia.state.value));
        toastMessage("Global state copied to clipboard.");
      } catch (error) {
        if (checkNotFocusedError(error))
          return;
        toastMessage(`Failed to serialize the state. Check the console for more details.`, "error");
        console.error(error);
      }
    }
    async function actionGlobalPasteState(pinia) {
      if (checkClipboardAccess())
        return;
      try {
        loadStoresState(pinia, JSON.parse(await navigator.clipboard.readText()));
        toastMessage("Global state pasted from clipboard.");
      } catch (error) {
        if (checkNotFocusedError(error))
          return;
        toastMessage(`Failed to deserialize the state from clipboard. Check the console for more details.`, "error");
        console.error(error);
      }
    }
    async function actionGlobalSaveState(pinia) {
      try {
        saveAs(new Blob([JSON.stringify(pinia.state.value)], {
          type: "text/plain;charset=utf-8"
        }), "pinia-state.json");
      } catch (error) {
        toastMessage(`Failed to export the state as JSON. Check the console for more details.`, "error");
        console.error(error);
      }
    }
    let fileInput;
    function getFileOpener() {
      if (!fileInput) {
        fileInput = document.createElement("input");
        fileInput.type = "file";
        fileInput.accept = ".json";
      }
      function openFile() {
        return new Promise((resolve, reject2) => {
          fileInput.onchange = async () => {
            const files = fileInput.files;
            if (!files)
              return resolve(null);
            const file = files.item(0);
            if (!file)
              return resolve(null);
            return resolve({ text: await file.text(), file });
          };
          fileInput.oncancel = () => resolve(null);
          fileInput.onerror = reject2;
          fileInput.click();
        });
      }
      return openFile;
    }
    async function actionGlobalOpenStateFile(pinia) {
      try {
        const open2 = getFileOpener();
        const result2 = await open2();
        if (!result2)
          return;
        const { text: text2, file } = result2;
        loadStoresState(pinia, JSON.parse(text2));
        toastMessage(`Global state imported from "${file.name}".`);
      } catch (error) {
        toastMessage(`Failed to import the state from JSON. Check the console for more details.`, "error");
        console.error(error);
      }
    }
    function loadStoresState(pinia, state) {
      for (const key in state) {
        const storeState = pinia.state.value[key];
        if (storeState) {
          Object.assign(storeState, state[key]);
        } else {
          pinia.state.value[key] = state[key];
        }
      }
    }
    function formatDisplay(display) {
      return {
        _custom: {
          display
        }
      };
    }
    const PINIA_ROOT_LABEL = " Pinia (root)";
    const PINIA_ROOT_ID = "_root";
    function formatStoreForInspectorTree(store) {
      return isPinia(store) ? {
        id: PINIA_ROOT_ID,
        label: PINIA_ROOT_LABEL
      } : {
        id: store.$id,
        label: store.$id
      };
    }
    function formatStoreForInspectorState(store) {
      if (isPinia(store)) {
        const storeNames = Array.from(store._s.keys());
        const storeMap = store._s;
        const state2 = {
          state: storeNames.map((storeId) => ({
            editable: true,
            key: storeId,
            value: store.state.value[storeId]
          })),
          getters: storeNames.filter((id) => storeMap.get(id)._getters).map((id) => {
            const store2 = storeMap.get(id);
            return {
              editable: false,
              key: id,
              value: store2._getters.reduce((getters, key) => {
                getters[key] = store2[key];
                return getters;
              }, {})
            };
          })
        };
        return state2;
      }
      const state = {
        state: Object.keys(store.$state).map((key) => ({
          editable: true,
          key,
          value: store.$state[key]
        }))
      };
      if (store._getters && store._getters.length) {
        state.getters = store._getters.map((getterName) => ({
          editable: false,
          key: getterName,
          value: store[getterName]
        }));
      }
      if (store._customProperties.size) {
        state.customProperties = Array.from(store._customProperties).map((key) => ({
          editable: true,
          key,
          value: store[key]
        }));
      }
      return state;
    }
    function formatEventData(events) {
      if (!events)
        return {};
      if (Array.isArray(events)) {
        return events.reduce((data, event) => {
          data.keys.push(event.key);
          data.operations.push(event.type);
          data.oldValue[event.key] = event.oldValue;
          data.newValue[event.key] = event.newValue;
          return data;
        }, {
          oldValue: {},
          keys: [],
          operations: [],
          newValue: {}
        });
      } else {
        return {
          operation: formatDisplay(events.type),
          key: formatDisplay(events.key),
          oldValue: events.oldValue,
          newValue: events.newValue
        };
      }
    }
    function formatMutationType(type) {
      switch (type) {
        case MutationType.direct:
          return "mutation";
        case MutationType.patchFunction:
          return "$patch";
        case MutationType.patchObject:
          return "$patch";
        default:
          return "unknown";
      }
    }
    let isTimelineActive = true;
    const componentStateTypes = [];
    const MUTATIONS_LAYER_ID = "pinia:mutations";
    const INSPECTOR_ID = "pinia";
    const { assign: assign$1 } = Object;
    const getStoreType = (id) => " " + id;
    function registerPiniaDevtools(app, pinia) {
      setupDevtoolsPlugin({
        id: "dev.esm.pinia",
        label: "Pinia ",
        logo: "https://pinia.vuejs.org/logo.svg",
        packageName: "pinia",
        homepage: "https://pinia.vuejs.org",
        componentStateTypes,
        app
      }, (api) => {
        if (typeof api.now !== "function") {
          toastMessage("You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.");
        }
        api.addTimelineLayer({
          id: MUTATIONS_LAYER_ID,
          label: `Pinia `,
          color: 15064968
        });
        api.addInspector({
          id: INSPECTOR_ID,
          label: "Pinia ",
          icon: "storage",
          treeFilterPlaceholder: "Search stores",
          actions: [
            {
              icon: "content_copy",
              action: () => {
                actionGlobalCopyState(pinia);
              },
              tooltip: "Serialize and copy the state"
            },
            {
              icon: "content_paste",
              action: async () => {
                await actionGlobalPasteState(pinia);
                api.sendInspectorTree(INSPECTOR_ID);
                api.sendInspectorState(INSPECTOR_ID);
              },
              tooltip: "Replace the state with the content of your clipboard"
            },
            {
              icon: "save",
              action: () => {
                actionGlobalSaveState(pinia);
              },
              tooltip: "Save the state as a JSON file"
            },
            {
              icon: "folder_open",
              action: async () => {
                await actionGlobalOpenStateFile(pinia);
                api.sendInspectorTree(INSPECTOR_ID);
                api.sendInspectorState(INSPECTOR_ID);
              },
              tooltip: "Import the state from a JSON file"
            }
          ],
          nodeActions: [
            {
              icon: "restore",
              tooltip: 'Reset the state (with "$reset")',
              action: (nodeId) => {
                const store = pinia._s.get(nodeId);
                if (!store) {
                  toastMessage(`Cannot reset "${nodeId}" store because it wasn't found.`, "warn");
                } else if (typeof store.$reset !== "function") {
                  toastMessage(`Cannot reset "${nodeId}" store because it doesn't have a "$reset" method implemented.`, "warn");
                } else {
                  store.$reset();
                  toastMessage(`Store "${nodeId}" reset.`);
                }
              }
            }
          ]
        });
        api.on.inspectComponent((payload, ctx) => {
          const proxy = payload.componentInstance && payload.componentInstance.proxy;
          if (proxy && proxy._pStores) {
            const piniaStores = payload.componentInstance.proxy._pStores;
            Object.values(piniaStores).forEach((store) => {
              payload.instanceData.state.push({
                type: getStoreType(store.$id),
                key: "state",
                editable: true,
                value: store._isOptionsAPI ? {
                  _custom: {
                    value: toRaw(store.$state),
                    actions: [
                      {
                        icon: "restore",
                        tooltip: "Reset the state of this store",
                        action: () => store.$reset()
                      }
                    ]
                  }
                } : (
                  // NOTE: workaround to unwrap transferred refs
                  Object.keys(store.$state).reduce((state, key) => {
                    state[key] = store.$state[key];
                    return state;
                  }, {})
                )
              });
              if (store._getters && store._getters.length) {
                payload.instanceData.state.push({
                  type: getStoreType(store.$id),
                  key: "getters",
                  editable: false,
                  value: store._getters.reduce((getters, key) => {
                    try {
                      getters[key] = store[key];
                    } catch (error) {
                      getters[key] = error;
                    }
                    return getters;
                  }, {})
                });
              }
            });
          }
        });
        api.on.getInspectorTree((payload) => {
          if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
            let stores = [pinia];
            stores = stores.concat(Array.from(pinia._s.values()));
            payload.rootNodes = (payload.filter ? stores.filter((store) => "$id" in store ? store.$id.toLowerCase().includes(payload.filter.toLowerCase()) : PINIA_ROOT_LABEL.toLowerCase().includes(payload.filter.toLowerCase())) : stores).map(formatStoreForInspectorTree);
          }
        });
        globalThis.$pinia = pinia;
        api.on.getInspectorState((payload) => {
          if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
            const inspectedStore = payload.nodeId === PINIA_ROOT_ID ? pinia : pinia._s.get(payload.nodeId);
            if (!inspectedStore) {
              return;
            }
            if (inspectedStore) {
              if (payload.nodeId !== PINIA_ROOT_ID)
                globalThis.$store = toRaw(inspectedStore);
              payload.state = formatStoreForInspectorState(inspectedStore);
            }
          }
        });
        api.on.editInspectorState((payload, ctx) => {
          if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
            const inspectedStore = payload.nodeId === PINIA_ROOT_ID ? pinia : pinia._s.get(payload.nodeId);
            if (!inspectedStore) {
              return toastMessage(`store "${payload.nodeId}" not found`, "error");
            }
            const { path } = payload;
            if (!isPinia(inspectedStore)) {
              if (path.length !== 1 || !inspectedStore._customProperties.has(path[0]) || path[0] in inspectedStore.$state) {
                path.unshift("$state");
              }
            } else {
              path.unshift("state");
            }
            isTimelineActive = false;
            payload.set(inspectedStore, path, payload.state.value);
            isTimelineActive = true;
          }
        });
        api.on.editComponentState((payload) => {
          if (payload.type.startsWith("")) {
            const storeId = payload.type.replace(/^\s*/, "");
            const store = pinia._s.get(storeId);
            if (!store) {
              return toastMessage(`store "${storeId}" not found`, "error");
            }
            const { path } = payload;
            if (path[0] !== "state") {
              return toastMessage(`Invalid path for store "${storeId}":
${path}
Only state can be modified.`);
            }
            path[0] = "$state";
            isTimelineActive = false;
            payload.set(store, path, payload.state.value);
            isTimelineActive = true;
          }
        });
      });
    }
    function addStoreToDevtools(app, store) {
      if (!componentStateTypes.includes(getStoreType(store.$id))) {
        componentStateTypes.push(getStoreType(store.$id));
      }
      setupDevtoolsPlugin({
        id: "dev.esm.pinia",
        label: "Pinia ",
        logo: "https://pinia.vuejs.org/logo.svg",
        packageName: "pinia",
        homepage: "https://pinia.vuejs.org",
        componentStateTypes,
        app,
        settings: {
          logStoreChanges: {
            label: "Notify about new/deleted stores",
            type: "boolean",
            defaultValue: true
          }
          // useEmojis: {
          //   label: 'Use emojis in messages ',
          //   type: 'boolean',
          //   defaultValue: true,
          // },
        }
      }, (api) => {
        const now2 = typeof api.now === "function" ? api.now.bind(api) : Date.now;
        store.$onAction(({ after: after2, onError, name, args }) => {
          const groupId = runningActionId++;
          api.addTimelineEvent({
            layerId: MUTATIONS_LAYER_ID,
            event: {
              time: now2(),
              title: " " + name,
              subtitle: "start",
              data: {
                store: formatDisplay(store.$id),
                action: formatDisplay(name),
                args
              },
              groupId
            }
          });
          after2((result2) => {
            activeAction = void 0;
            api.addTimelineEvent({
              layerId: MUTATIONS_LAYER_ID,
              event: {
                time: now2(),
                title: " " + name,
                subtitle: "end",
                data: {
                  store: formatDisplay(store.$id),
                  action: formatDisplay(name),
                  args,
                  result: result2
                },
                groupId
              }
            });
          });
          onError((error) => {
            activeAction = void 0;
            api.addTimelineEvent({
              layerId: MUTATIONS_LAYER_ID,
              event: {
                time: now2(),
                logType: "error",
                title: " " + name,
                subtitle: "end",
                data: {
                  store: formatDisplay(store.$id),
                  action: formatDisplay(name),
                  args,
                  error
                },
                groupId
              }
            });
          });
        }, true);
        store._customProperties.forEach((name) => {
          watch(() => unref(store[name]), (newValue, oldValue) => {
            api.notifyComponentUpdate();
            api.sendInspectorState(INSPECTOR_ID);
            if (isTimelineActive) {
              api.addTimelineEvent({
                layerId: MUTATIONS_LAYER_ID,
                event: {
                  time: now2(),
                  title: "Change",
                  subtitle: name,
                  data: {
                    newValue,
                    oldValue
                  },
                  groupId: activeAction
                }
              });
            }
          }, { deep: true });
        });
        store.$subscribe(({ events, type }, state) => {
          api.notifyComponentUpdate();
          api.sendInspectorState(INSPECTOR_ID);
          if (!isTimelineActive)
            return;
          const eventData = {
            time: now2(),
            title: formatMutationType(type),
            data: assign$1({ store: formatDisplay(store.$id) }, formatEventData(events)),
            groupId: activeAction
          };
          if (type === MutationType.patchFunction) {
            eventData.subtitle = "";
          } else if (type === MutationType.patchObject) {
            eventData.subtitle = "";
          } else if (events && !Array.isArray(events)) {
            eventData.subtitle = events.type;
          }
          if (events) {
            eventData.data["rawEvent(s)"] = {
              _custom: {
                display: "DebuggerEvent",
                type: "object",
                tooltip: "raw DebuggerEvent[]",
                value: events
              }
            };
          }
          api.addTimelineEvent({
            layerId: MUTATIONS_LAYER_ID,
            event: eventData
          });
        }, { detached: true, flush: "sync" });
        const hotUpdate = store._hotUpdate;
        store._hotUpdate = markRaw((newStore) => {
          hotUpdate(newStore);
          api.addTimelineEvent({
            layerId: MUTATIONS_LAYER_ID,
            event: {
              time: now2(),
              title: " " + store.$id,
              subtitle: "HMR update",
              data: {
                store: formatDisplay(store.$id),
                info: formatDisplay(`HMR update`)
              }
            }
          });
          api.notifyComponentUpdate();
          api.sendInspectorTree(INSPECTOR_ID);
          api.sendInspectorState(INSPECTOR_ID);
        });
        const { $dispose } = store;
        store.$dispose = () => {
          $dispose();
          api.notifyComponentUpdate();
          api.sendInspectorTree(INSPECTOR_ID);
          api.sendInspectorState(INSPECTOR_ID);
          api.getSettings().logStoreChanges && toastMessage(`Disposed "${store.$id}" store `);
        };
        api.notifyComponentUpdate();
        api.sendInspectorTree(INSPECTOR_ID);
        api.sendInspectorState(INSPECTOR_ID);
        api.getSettings().logStoreChanges && toastMessage(`"${store.$id}" store installed `);
      });
    }
    let runningActionId = 0;
    let activeAction;
    function patchActionForGrouping(store, actionNames, wrapWithProxy) {
      const actions = actionNames.reduce((storeActions, actionName) => {
        storeActions[actionName] = toRaw(store)[actionName];
        return storeActions;
      }, {});
      for (const actionName in actions) {
        store[actionName] = function() {
          const _actionId = runningActionId;
          const trackedStore = wrapWithProxy ? new Proxy(store, {
            get(...args) {
              activeAction = _actionId;
              return Reflect.get(...args);
            },
            set(...args) {
              activeAction = _actionId;
              return Reflect.set(...args);
            }
          }) : store;
          activeAction = _actionId;
          const retValue = actions[actionName].apply(trackedStore, arguments);
          activeAction = void 0;
          return retValue;
        };
      }
    }
    function devtoolsPlugin({ app, store, options }) {
      if (store.$id.startsWith("__hot:")) {
        return;
      }
      store._isOptionsAPI = !!options.state;
      if (!store._p._testing) {
        patchActionForGrouping(store, Object.keys(options.actions), store._isOptionsAPI);
        const originalHotUpdate = store._hotUpdate;
        toRaw(store)._hotUpdate = function(newStore) {
          originalHotUpdate.apply(this, arguments);
          patchActionForGrouping(store, Object.keys(newStore._hmrPayload.actions), !!store._isOptionsAPI);
        };
      }
      addStoreToDevtools(
        app,
        // FIXME: is there a way to allow the assignment from Store<Id, S, G, A> to StoreGeneric?
        store
      );
    }
    function createPinia() {
      const scope = effectScope(true);
      const state = scope.run(() => ref({}));
      let _p2 = [];
      let toBeInstalled = [];
      const pinia = markRaw({
        install(app) {
          setActivePinia(pinia);
          {
            pinia._a = app;
            app.provide(piniaSymbol, pinia);
            app.config.globalProperties.$pinia = pinia;
            if (IS_CLIENT) {
              registerPiniaDevtools(app, pinia);
            }
            toBeInstalled.forEach((plugin) => _p2.push(plugin));
            toBeInstalled = [];
          }
        },
        use(plugin) {
          if (!this._a && !isVue2) {
            toBeInstalled.push(plugin);
          } else {
            _p2.push(plugin);
          }
          return this;
        },
        _p: _p2,
        // it's actually undefined here
        // @ts-expect-error
        _a: null,
        _e: scope,
        _s: /* @__PURE__ */ new Map(),
        state
      });
      if (typeof Proxy !== "undefined") {
        pinia.use(devtoolsPlugin);
      }
      return pinia;
    }
    function patchObject(newState, oldState) {
      for (const key in oldState) {
        const subPatch = oldState[key];
        if (!(key in newState)) {
          continue;
        }
        const targetValue = newState[key];
        if (isPlainObject$1(targetValue) && isPlainObject$1(subPatch) && !isRef(subPatch) && !isReactive(subPatch)) {
          newState[key] = patchObject(targetValue, subPatch);
        } else {
          {
            newState[key] = subPatch;
          }
        }
      }
      return newState;
    }
    const noop$1 = () => {
    };
    function addSubscription(subscriptions, callback, detached, onCleanup = noop$1) {
      subscriptions.push(callback);
      const removeSubscription = () => {
        const idx = subscriptions.indexOf(callback);
        if (idx > -1) {
          subscriptions.splice(idx, 1);
          onCleanup();
        }
      };
      if (!detached && getCurrentScope()) {
        onScopeDispose(removeSubscription);
      }
      return removeSubscription;
    }
    function triggerSubscriptions(subscriptions, ...args) {
      subscriptions.slice().forEach((callback) => {
        callback(...args);
      });
    }
    const fallbackRunWithContext = (fn2) => fn2();
    const ACTION_MARKER = Symbol();
    const ACTION_NAME = Symbol();
    function mergeReactiveObjects(target, patchToApply) {
      if (target instanceof Map && patchToApply instanceof Map) {
        patchToApply.forEach((value, key) => target.set(key, value));
      } else if (target instanceof Set && patchToApply instanceof Set) {
        patchToApply.forEach(target.add, target);
      }
      for (const key in patchToApply) {
        if (!patchToApply.hasOwnProperty(key))
          continue;
        const subPatch = patchToApply[key];
        const targetValue = target[key];
        if (isPlainObject$1(targetValue) && isPlainObject$1(subPatch) && target.hasOwnProperty(key) && !isRef(subPatch) && !isReactive(subPatch)) {
          target[key] = mergeReactiveObjects(targetValue, subPatch);
        } else {
          target[key] = subPatch;
        }
      }
      return target;
    }
    const skipHydrateSymbol = Symbol("pinia:skipHydration");
    function shouldHydrate(obj) {
      return !isPlainObject$1(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
    }
    const { assign } = Object;
    function isComputed(o2) {
      return !!(isRef(o2) && o2.effect);
    }
    function createOptionsStore(id, options, pinia, hot) {
      const { state, actions, getters } = options;
      const initialState = pinia.state.value[id];
      let store;
      function setup() {
        if (!initialState && !hot) {
          {
            pinia.state.value[id] = state ? state() : {};
          }
        }
        const localState = hot ? (
          // use ref() to unwrap refs inside state TODO: check if this is still necessary
          toRefs(ref(state ? state() : {}).value)
        ) : toRefs(pinia.state.value[id]);
        return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
          if (name in localState) {
            console.warn(`[]: A getter cannot have the same name as another state property. Rename one of them. Found with "${name}" in store "${id}".`);
          }
          computedGetters[name] = markRaw(computed(() => {
            setActivePinia(pinia);
            const store2 = pinia._s.get(id);
            return getters[name].call(store2, store2);
          }));
          return computedGetters;
        }, {}));
      }
      store = createSetupStore(id, setup, options, pinia, hot, true);
      return store;
    }
    function createSetupStore($id, setup, options = {}, pinia, hot, isOptionsStore) {
      let scope;
      const optionsForPlugin = assign({ actions: {} }, options);
      if (!pinia._e.active) {
        throw new Error("Pinia destroyed");
      }
      const $subscribeOptions = { deep: true };
      {
        $subscribeOptions.onTrigger = (event) => {
          if (isListening) {
            debuggerEvents = event;
          } else if (isListening == false && !store._hotUpdating) {
            if (Array.isArray(debuggerEvents)) {
              debuggerEvents.push(event);
            } else {
              console.error(" debuggerEvents should be an array. This is most likely an internal Pinia bug.");
            }
          }
        };
      }
      let isListening;
      let isSyncListening;
      let subscriptions = [];
      let actionSubscriptions = [];
      let debuggerEvents;
      const initialState = pinia.state.value[$id];
      if (!isOptionsStore && !initialState && !hot) {
        {
          pinia.state.value[$id] = {};
        }
      }
      const hotState = ref({});
      let activeListener;
      function $patch(partialStateOrMutator) {
        let subscriptionMutation;
        isListening = isSyncListening = false;
        {
          debuggerEvents = [];
        }
        if (typeof partialStateOrMutator === "function") {
          partialStateOrMutator(pinia.state.value[$id]);
          subscriptionMutation = {
            type: MutationType.patchFunction,
            storeId: $id,
            events: debuggerEvents
          };
        } else {
          mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);
          subscriptionMutation = {
            type: MutationType.patchObject,
            payload: partialStateOrMutator,
            storeId: $id,
            events: debuggerEvents
          };
        }
        const myListenerId = activeListener = Symbol();
        nextTick().then(() => {
          if (activeListener === myListenerId) {
            isListening = true;
          }
        });
        isSyncListening = true;
        triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);
      }
      const $reset = isOptionsStore ? function $reset2() {
        const { state } = options;
        const newState = state ? state() : {};
        this.$patch(($state) => {
          assign($state, newState);
        });
      } : (
        /* istanbul ignore next */
        () => {
          throw new Error(`: Store "${$id}" is built using the setup syntax and does not implement $reset().`);
        }
      );
      function $dispose() {
        scope.stop();
        subscriptions = [];
        actionSubscriptions = [];
        pinia._s.delete($id);
      }
      const action = (fn2, name = "") => {
        if (ACTION_MARKER in fn2) {
          fn2[ACTION_NAME] = name;
          return fn2;
        }
        const wrappedAction = function() {
          setActivePinia(pinia);
          const args = Array.from(arguments);
          const afterCallbackList = [];
          const onErrorCallbackList = [];
          function after2(callback) {
            afterCallbackList.push(callback);
          }
          function onError(callback) {
            onErrorCallbackList.push(callback);
          }
          triggerSubscriptions(actionSubscriptions, {
            args,
            name: wrappedAction[ACTION_NAME],
            store,
            after: after2,
            onError
          });
          let ret;
          try {
            ret = fn2.apply(this && this.$id === $id ? this : store, args);
          } catch (error) {
            triggerSubscriptions(onErrorCallbackList, error);
            throw error;
          }
          if (ret instanceof Promise) {
            return ret.then((value) => {
              triggerSubscriptions(afterCallbackList, value);
              return value;
            }).catch((error) => {
              triggerSubscriptions(onErrorCallbackList, error);
              return Promise.reject(error);
            });
          }
          triggerSubscriptions(afterCallbackList, ret);
          return ret;
        };
        wrappedAction[ACTION_MARKER] = true;
        wrappedAction[ACTION_NAME] = name;
        return wrappedAction;
      };
      const _hmrPayload = /* @__PURE__ */ markRaw({
        actions: {},
        getters: {},
        state: [],
        hotState
      });
      const partialStore = {
        _p: pinia,
        // _s: scope,
        $id,
        $onAction: addSubscription.bind(null, actionSubscriptions),
        $patch,
        $reset,
        $subscribe(callback, options2 = {}) {
          const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
          const stopWatcher = scope.run(() => watch(() => pinia.state.value[$id], (state) => {
            if (options2.flush === "sync" ? isSyncListening : isListening) {
              callback({
                storeId: $id,
                type: MutationType.direct,
                events: debuggerEvents
              }, state);
            }
          }, assign({}, $subscribeOptions, options2)));
          return removeSubscription;
        },
        $dispose
      };
      const store = reactive(assign(
        {
          _hmrPayload,
          _customProperties: markRaw(/* @__PURE__ */ new Set())
          // devtools custom properties
        },
        partialStore
        // must be added later
        // setupStore
      ));
      pinia._s.set($id, store);
      const runWithContext = pinia._a && pinia._a.runWithContext || fallbackRunWithContext;
      const setupStore = runWithContext(() => pinia._e.run(() => (scope = effectScope()).run(() => setup({ action }))));
      for (const key in setupStore) {
        const prop = setupStore[key];
        if (isRef(prop) && !isComputed(prop) || isReactive(prop)) {
          if (hot) {
            set(hotState.value, key, toRef(setupStore, key));
          } else if (!isOptionsStore) {
            if (initialState && shouldHydrate(prop)) {
              if (isRef(prop)) {
                prop.value = initialState[key];
              } else {
                mergeReactiveObjects(prop, initialState[key]);
              }
            }
            {
              pinia.state.value[$id][key] = prop;
            }
          }
          {
            _hmrPayload.state.push(key);
          }
        } else if (typeof prop === "function") {
          const actionValue = hot ? prop : action(prop, key);
          {
            setupStore[key] = actionValue;
          }
          {
            _hmrPayload.actions[key] = prop;
          }
          optionsForPlugin.actions[key] = prop;
        } else {
          if (isComputed(prop)) {
            _hmrPayload.getters[key] = isOptionsStore ? (
              // @ts-expect-error
              options.getters[key]
            ) : prop;
            if (IS_CLIENT) {
              const getters = setupStore._getters || // @ts-expect-error: same
              (setupStore._getters = markRaw([]));
              getters.push(key);
            }
          }
        }
      }
      {
        assign(store, setupStore);
        assign(toRaw(store), setupStore);
      }
      Object.defineProperty(store, "$state", {
        get: () => hot ? hotState.value : pinia.state.value[$id],
        set: (state) => {
          if (hot) {
            throw new Error("cannot set hotState");
          }
          $patch(($state) => {
            assign($state, state);
          });
        }
      });
      {
        store._hotUpdate = markRaw((newStore) => {
          store._hotUpdating = true;
          newStore._hmrPayload.state.forEach((stateKey) => {
            if (stateKey in store.$state) {
              const newStateTarget = newStore.$state[stateKey];
              const oldStateSource = store.$state[stateKey];
              if (typeof newStateTarget === "object" && isPlainObject$1(newStateTarget) && isPlainObject$1(oldStateSource)) {
                patchObject(newStateTarget, oldStateSource);
              } else {
                newStore.$state[stateKey] = oldStateSource;
              }
            }
            set(store, stateKey, toRef(newStore.$state, stateKey));
          });
          Object.keys(store.$state).forEach((stateKey) => {
            if (!(stateKey in newStore.$state)) {
              del(store, stateKey);
            }
          });
          isListening = false;
          isSyncListening = false;
          pinia.state.value[$id] = toRef(newStore._hmrPayload, "hotState");
          isSyncListening = true;
          nextTick().then(() => {
            isListening = true;
          });
          for (const actionName in newStore._hmrPayload.actions) {
            const actionFn = newStore[actionName];
            set(store, actionName, action(actionFn, actionName));
          }
          for (const getterName in newStore._hmrPayload.getters) {
            const getter = newStore._hmrPayload.getters[getterName];
            const getterValue = isOptionsStore ? (
              // special handling of options api
              computed(() => {
                setActivePinia(pinia);
                return getter.call(store, store);
              })
            ) : getter;
            set(store, getterName, getterValue);
          }
          Object.keys(store._hmrPayload.getters).forEach((key) => {
            if (!(key in newStore._hmrPayload.getters)) {
              del(store, key);
            }
          });
          Object.keys(store._hmrPayload.actions).forEach((key) => {
            if (!(key in newStore._hmrPayload.actions)) {
              del(store, key);
            }
          });
          store._hmrPayload = newStore._hmrPayload;
          store._getters = newStore._getters;
          store._hotUpdating = false;
        });
      }
      if (IS_CLIENT) {
        const nonEnumerable = {
          writable: true,
          configurable: true,
          // avoid warning on devtools trying to display this property
          enumerable: false
        };
        ["_p", "_hmrPayload", "_getters", "_customProperties"].forEach((p2) => {
          Object.defineProperty(store, p2, assign({ value: store[p2] }, nonEnumerable));
        });
      }
      pinia._p.forEach((extender) => {
        if (IS_CLIENT) {
          const extensions = scope.run(() => extender({
            store,
            app: pinia._a,
            pinia,
            options: optionsForPlugin
          }));
          Object.keys(extensions || {}).forEach((key) => store._customProperties.add(key));
          assign(store, extensions);
        } else {
          assign(store, scope.run(() => extender({
            store,
            app: pinia._a,
            pinia,
            options: optionsForPlugin
          })));
        }
      });
      if (store.$state && typeof store.$state === "object" && typeof store.$state.constructor === "function" && !store.$state.constructor.toString().includes("[native code]")) {
        console.warn(`[]: The "state" must be a plain object. It cannot be
	state: () => new MyClass()
Found in store "${store.$id}".`);
      }
      if (initialState && isOptionsStore && options.hydrate) {
        options.hydrate(store.$state, initialState);
      }
      isListening = true;
      isSyncListening = true;
      return store;
    }
    /*! #__NO_SIDE_EFFECTS__ */
    // @__NO_SIDE_EFFECTS__
    function defineStore(idOrOptions, setup, setupOptions) {
      let id;
      let options;
      const isSetupStore = typeof setup === "function";
      {
        id = idOrOptions;
        options = isSetupStore ? setupOptions : setup;
      }
      function useStore(pinia, hot) {
        const hasContext = hasInjectionContext();
        pinia = // in test mode, ignore the argument provided as we can always retrieve a
        // pinia instance with getActivePinia()
        pinia || (hasContext ? inject(piniaSymbol, null) : null);
        if (pinia)
          setActivePinia(pinia);
        if (!activePinia) {
          throw new Error(`[]: "getActivePinia()" was called but there was no active Pinia. Are you trying to use a store before calling "app.use(pinia)"?
See https://pinia.vuejs.org/core-concepts/outside-component-usage.html for help.
This will fail in production.`);
        }
        pinia = activePinia;
        if (!pinia._s.has(id)) {
          if (isSetupStore) {
            createSetupStore(id, setup, options, pinia);
          } else {
            createOptionsStore(id, options, pinia);
          }
          {
            useStore._pinia = pinia;
          }
        }
        const store = pinia._s.get(id);
        if (hot) {
          const hotId = "__hot:" + id;
          const newStore = isSetupStore ? createSetupStore(hotId, setup, options, pinia, true) : createOptionsStore(hotId, assign({}, options), pinia, true);
          hot._hotUpdate(newStore);
          delete pinia.state.value[hotId];
          pinia._s.delete(hotId);
        }
        if (IS_CLIENT) {
          const currentInstance = getCurrentInstance();
          if (currentInstance && currentInstance.proxy && // avoid adding stores that are just built for hot module replacement
          !hot) {
            const vm = currentInstance.proxy;
            const cache2 = "_pStores" in vm ? vm._pStores : vm._pStores = {};
            cache2[id] = store;
          }
        }
        return store;
      }
      useStore.$id = id;
      return useStore;
    }
    function storeToRefs(store) {
      {
        const rawStore = toRaw(store);
        const refs = {};
        for (const key in rawStore) {
          const value = rawStore[key];
          if (isRef(value) || isReactive(value)) {
            refs[key] = // ---
            toRef(store, key);
          }
        }
        return refs;
      }
    }
    const _sfc_main$O = {
      __name: "imet_score_row",
      props: {
        value: {
          type: [String, Number],
          default: null
        },
        code: {
          type: String,
          default: null
        },
        label: {
          type: String,
          default: null
        },
        color: {
          type: String,
          default: "#aaa"
        },
        histogram_type: {
          type: String,
          default: "0_to_100_full_width"
        },
        isHeader: {
          type: Boolean,
          default: false
        },
        shortLabel: {
          type: Boolean,
          default: false
        }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const props = __props;
        const grid_according_to_histogram_type = computed(() => {
          if (props.histogram_type === "0_to_100") {
            return "display: grid; grid-template-columns: calc(50% - 40px)  calc(50% + 40px);";
          } else if (props.histogram_type === "minus100_to_0") {
            return "display: grid; grid-template-columns: calc(50% + 40px)  calc(50% - 40px);";
          } else if (props.histogram_type === "minus100_to_100") {
            return "display: grid; grid-template-columns: 50% 50%;";
          } else {
            return "";
          }
        });
        function format(value) {
          if (value === null) return null;
          return typeof value === "number" ? value.toFixed(1) : parseFloat(value).toFixed(1);
        }
        const __returned__ = { props, grid_according_to_histogram_type, format, computed, imet_score_bar: imetScoreBar };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$B = {
      key: 0,
      class: "histogram-row__code text-center font-bold"
    };
    const _hoisted_2$t = { class: "histogram-row__value text-right font-bold" };
    function _sfc_render$O(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["histogram-row", { "border-b border-gray-400 pb-2 mb-2": $props.isHeader }])
      }, [
        !$props.isHeader && $props.code != null ? (openBlock(), createElementBlock("div", _hoisted_1$B, toDisplayString($props.code), 1)) : createCommentVNode("", true),
        createBaseVNode("div", {
          class: normalizeClass(["histogram-row__title text-left", { "text-xl font-bold text-primary-600": $props.isHeader, "short": $props.shortLabel || $props.isHeader }])
        }, toDisplayString($props.label), 3),
        createBaseVNode("div", _hoisted_2$t, toDisplayString($setup.format($props.value)), 1),
        createBaseVNode("div", {
          class: "histogram-row__progress-bar text-2xs pl-4",
          style: normalizeStyle($setup.grid_according_to_histogram_type)
        }, [
          $props.histogram_type === "0_to_100_full_width" ? (openBlock(), createBlock($setup["imet_score_bar"], {
            key: 0,
            value: $setup.format($props.value),
            color: $props.color
          }, null, 8, ["value", "color"])) : $props.histogram_type === "0_to_100" ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            _cache[0] || (_cache[0] = createBaseVNode("div", { class: "histogram-row__progress-bar__spacer" }, null, -1)),
            createVNode($setup["imet_score_bar"], {
              value: $setup.format($props.value),
              color: $props.color
            }, null, 8, ["value", "color"])
          ], 64)) : $props.histogram_type === "minus100_to_0" ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
            createVNode($setup["imet_score_bar"], {
              value: $setup.format($props.value),
              color: $props.color,
              min: -100,
              max: 0
            }, null, 8, ["value", "color"]),
            _cache[1] || (_cache[1] = createBaseVNode("div", { class: "histogram-row__progress-bar__spacer" }, null, -1))
          ], 64)) : $props.histogram_type === "minus100_to_100" ? (openBlock(), createElementBlock(Fragment, { key: 3 }, [
            createVNode($setup["imet_score_bar"], {
              value: $setup.format($props.value) < 0 ? $setup.format($props.value) : null,
              color: $props.color,
              min: -100,
              max: null
            }, null, 8, ["value", "color"]),
            createVNode($setup["imet_score_bar"], {
              value: $setup.format($props.value) > 0 ? $setup.format($props.value) : null,
              color: $props.color,
              min: null,
              max: 100
            }, null, 8, ["value", "color"])
          ], 64)) : createCommentVNode("", true)
        ], 4)
      ], 2);
    }
    const imet_score_row = /* @__PURE__ */ _export_sfc(_sfc_main$O, [["render", _sfc_render$O], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/templates/imet_score_row.vue"]]);
    const _sfc_main$N = {
      __name: "imet_process_radar",
      props: {
        values: {
          type: Object,
          default: () => {
          }
        },
        labels: {
          type: Object,
          default: () => {
          }
        }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const props = __props;
        const radar = ref(null);
        const radar_options = computed(() => {
          let values2 = Object.values(props.values).reverse();
          let labels = Object.keys(props.values).reverse().map((item) => {
            return { name: props.labels[item], max: 100 };
          });
          return {
            tooltip: {
              trigger: "axis"
            },
            radar: {
              indicator: labels,
              radius: "65%",
              startAngle: 150,
              axisName: {
                color: "#111",
                padding: [0, 0]
              }
            },
            series: [
              {
                type: "radar",
                data: [
                  {
                    value: values2,
                    itemStyle: {
                      color: "#7CB5EC"
                    },
                    areaStyle: {
                      color: "#7CB5EC",
                      opacity: 0.4
                    },
                    symbolSize: 6,
                    name: "imet_radar",
                    label: {
                      fontWeight: "bold",
                      color: "#222",
                      show: true,
                      formatter: function(params) {
                        return params.value;
                      }
                    }
                  }
                ]
              }
            ]
          };
        });
        onMounted(() => {
          draw_chart();
        });
        watch(() => props.values, () => {
          draw_chart();
        });
        function draw_chart() {
          if (Object.keys(props.values).length > 1) {
            init(radar.value).setOption(radar_options.value);
          }
        }
        const __returned__ = { props, radar, radar_options, draw_chart, get echarts() {
          return echarts;
        }, computed, ref, onMounted, watch };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$A = {
      ref: "radar",
      class: "imet_process_radar",
      style: { "height": "250px" }
    };
    function _sfc_render$N(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", _hoisted_1$A, null, 512);
    }
    const imet_process_radar = /* @__PURE__ */ _export_sfc(_sfc_main$N, [["render", _sfc_render$N], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/templates/imet_process_radar.vue"]]);
    const _sfc_main$M = {
      __name: "imet_scores",
      props: {
        current_step: {
          type: String,
          default: null
        },
        version: {
          type: String,
          default: null
        },
        labels: {
          type: Object,
          default: () => {
          }
        },
        render_radar: {
          type: Boolean,
          default: null
        },
        store: null
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const props = __props;
        const { api_data } = storeToRefs(props.store);
        const score_properties = {
          "v1&2": {
            "context": {
              "indexes": ["C1", "C2", "C3"],
              "histogram_types": ["0_to_100", "minus100_to_100", "minus100_to_0"],
              "color": "#FFFF00"
            },
            "planning": {
              "indexes": ["P1", "P2", "P3", "P4", "P5", "P6"],
              "color": "#BFBFBF"
            },
            "inputs": {
              "indexes": ["I1", "I2", "I3", "I4", "I5"],
              "color": "#FFC000"
            },
            "process": {
              "indexes": [
                "PR1",
                "PR2",
                "PR3",
                "PR4",
                "PR5",
                "PR6",
                "PR7",
                "PR8",
                "PR9",
                "PR10",
                "PR11",
                "PR12",
                "PR13",
                "PR14",
                "PR15",
                "PR16",
                "PR17",
                "PR18",
                "PR19"
              ],
              "color": "#00B0F0"
            },
            "outputs": {
              "indexes": ["OP1", "OP2", "OP3", "OP4"],
              "color": "#92D050"
            },
            "outcomes": {
              "indexes": ["OC1", "OC2", "OC3"],
              "histogram_types": ["0_to_100", "minus100_to_0", "minus100_to_0"],
              "color": "#00B050"
            }
          },
          "oecm": {
            "context": {
              "indexes": ["C1", "C2", "C3", "C4"],
              "histogram_types": ["0_to_100", "minus100_to_100", "minus100_to_0", "0_to_100"],
              "color": "#FFFF00"
            },
            "planning": {
              "indexes": ["P1", "P2", "P3", "P4", "P5", "P6"],
              "color": "#BFBFBF"
            },
            "inputs": {
              "indexes": ["I1", "I2", "I3", "I4", "I5"],
              "color": "#FFC000"
            },
            "process": {
              "indexes": ["PR1", "PR2", "PR3", "PR4", "PR5", "PR6", "PR7", "PR8", "PR9", "PR10", "PR11", "PR12"],
              "color": "#00B0F0"
            },
            "outputs": {
              "indexes": ["OP1", "OP2"],
              "color": "#92D050"
            },
            "outcomes": {
              "indexes": ["OC1", "OC2", "OC3"],
              "histogram_types": ["0_to_100", "0_to_100", "minus100_to_100"],
              "color": "#00B050"
            }
          }
        };
        const properties = computed(() => {
          return props.version === "oecm" ? score_properties[props.version] : score_properties["v1&2"];
        });
        const radar_values = computed(() => {
          let radar_values2 = {};
          Object.keys(properties.value).forEach(function(step) {
            let label = props.labels[step];
            radar_values2[label] = api_data.value["scores"][step].avg_indicator || null;
          });
          return radar_values2;
        });
        function histogram_type(step_key, idx) {
          return properties.value[step_key].hasOwnProperty("histogram_types") ? properties.value[step_key].histogram_types[idx] : "0_to_100_full_width";
        }
        const __returned__ = { props, api_data, score_properties, properties, radar_values, histogram_type, computed, ref, onMounted, defineComponent, createVNode, render, get storeToRefs() {
          return storeToRefs;
        }, imet_score_row, imet_process_radar, imet_radar };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$z = { class: "flex w-full flex-row items-center" };
    const _hoisted_2$s = { class: "grow" };
    const _hoisted_3$o = { key: 0 };
    const _hoisted_4$j = {
      key: 0,
      class: "mt-4"
    };
    const _hoisted_5$i = {
      key: 1,
      class: "mt-4"
    };
    function _sfc_render$M(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock(Fragment, null, [
        createBaseVNode("div", _hoisted_1$z, [
          createBaseVNode("div", _hoisted_2$s, [
            (openBlock(true), createElementBlock(Fragment, null, renderList($setup.properties, (step_props, step_key) => {
              return openBlock(), createElementBlock("div", { key: step_key }, [
                createVNode($setup["imet_score_row"], {
                  label: $props.labels[step_key],
                  value: $setup.api_data["scores"][step_key].avg_indicator,
                  color: step_props.color,
                  "short-label": true
                }, null, 8, ["label", "value", "color"])
              ]);
            }), 128))
          ]),
          $setup.props.render_radar ? (openBlock(), createElementBlock("div", _hoisted_3$o, [
            createVNode($setup["imet_radar"], {
              values: $setup.radar_values,
              width: 380,
              height: 250
            }, null, 8, ["values"])
          ])) : createCommentVNode("", true)
        ]),
        (openBlock(true), createElementBlock(Fragment, null, renderList($setup.properties, (step_props, step_key) => {
          return openBlock(), createElementBlock(Fragment, null, [
            $props.current_step === step_key || $props.current_step === "management_effectiveness" ? (openBlock(), createElementBlock("div", {
              class: "mb-10",
              key: step_key
            }, [
              createVNode($setup["imet_score_row"], {
                label: $props.labels[step_key],
                value: $setup.api_data["scores"][step_key].avg_indicator,
                color: step_props.color,
                "is-header": true
              }, null, 8, ["label", "value", "color"]),
              (openBlock(true), createElementBlock(Fragment, null, renderList(step_props.indexes, (index, idx) => {
                return openBlock(), createElementBlock("div", { key: index }, [
                  createVNode($setup["imet_score_row"], {
                    label: $props.labels[index],
                    code: index,
                    value: $setup.api_data["scores"][step_key][index],
                    histogram_type: $setup.histogram_type(step_key, idx),
                    color: step_props.color
                  }, null, 8, ["label", "code", "value", "histogram_type", "color"])
                ]);
              }), 128)),
              step_key === "context" && $props.version !== "oecm" ? (openBlock(), createElementBlock("div", _hoisted_4$j, [
                (openBlock(), createElementBlock(Fragment, null, renderList(["C11", "C12", "C13", "C14", "C15"], (ctx_key) => {
                  return createVNode($setup["imet_score_row"], {
                    key: ctx_key,
                    label: $props.labels[ctx_key],
                    code: ctx_key,
                    value: $setup.api_data["scores"]["context"][ctx_key],
                    histogram_type: "0_to_100",
                    color: step_props.color
                  }, null, 8, ["label", "code", "value", "color"]);
                }), 64))
              ])) : step_key === "process" && $props.version !== "oecm" ? (openBlock(), createElementBlock("div", _hoisted_5$i, [
                createVNode($setup["imet_process_radar"], {
                  values: [
                    $setup.api_data["scores"]["process"]["PRA"],
                    $setup.api_data["scores"]["process"]["PRB"],
                    $setup.api_data["scores"]["process"]["PRC"],
                    $setup.api_data["scores"]["process"]["PRD"],
                    $setup.api_data["scores"]["process"]["PRE"],
                    $setup.api_data["scores"]["process"]["PRF"]
                  ],
                  labels: [
                    $props.labels["PRA"],
                    $props.labels["PRB"],
                    $props.labels["PRC"],
                    $props.labels["PRD"],
                    $props.labels["PRE"],
                    $props.labels["PRF"]
                  ]
                }, null, 8, ["values", "labels"])
              ])) : createCommentVNode("", true)
            ])) : createCommentVNode("", true)
          ], 64);
        }), 256))
      ], 64);
    }
    const imetScores = /* @__PURE__ */ _export_sfc(_sfc_main$M, [["render", _sfc_render$M], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/templates/imet_scores.vue"]]);
    const useScoreStore = /* @__PURE__ */ defineStore("score", {
      state: () => ({
        api: {}
      }),
      getters: {
        api_data: (state) => state.api
      },
      actions: {
        init(api) {
          this.api = api;
        },
        refresh() {
          let _this = this;
          let url = this.api.version === "oecm" ? window.Routes.scores_oecm : window.Routes.scores;
          url = url.replace("__id__", this.api.form_id);
          fetch(url, {
            method: "GET",
            headers: {
              "Content-Type": "application/json",
              "X-CSRF-Token": window.Laravel.csrfToken
            }
          }).then((response) => response.json()).then(function(data) {
            _this.api = data;
          });
        }
      }
    });
    class AssessmentScores {
      constructor(input_data = {}) {
        const options = {
          name: "AssessmentScores",
          props: {
            api_data: {
              type: Object,
              default: () => input_data.api_data
            }
          },
          setup(props, context) {
            const store = useScoreStore();
            store.init(props.api_data);
            function refresh_scores() {
              store.refresh();
            }
            return {
              refresh_scores,
              store
            };
          }
        };
        return createApp(options, input_data).component("imet_scores", imetScores).use(createPinia());
      }
    }
    const _sfc_main$L = {
      __name: "action-button-cookie",
      props: {
        event: {
          type: String,
          default: ""
        },
        className: {
          type: String,
          default: "btn-nav float-left"
        },
        label: {
          type: String,
          default: "Submit"
        }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const props = __props;
        const emitter = inject("emitter");
        const selected2 = inject("selected");
        onMounted(() => {
          emitter.on("store_cookie_and_value", (name, values2) => {
            store_to_cookie_by_id_and_value(name, values2);
          });
        });
        function store_to_cookie_by_id_and_value(cookieName, data_values = null) {
          if (data_values === null) {
            data_values = selected2.value;
          }
          if (data_values.length > 0) {
            const cookie = get_cookie();
            if (cookie) {
              const cookie_arr = cookie.split("=");
              const cookie_items = JSON.parse(cookie_arr[1]);
              const merge_values = [...cookie_items, ...data_values];
              const total = merge_values.reduce((arr, item) => {
                if (Array.isArray(arr)) {
                  return arr.some((a2) => a2.id == item.id) ? arr : [...arr, item];
                }
                return arr.id === item.id ? [arr] : [arr, item];
              });
              window.ModularForms.Helpers.Cookie.create(cookie[0], JSON.stringify(total));
            } else {
              window.ModularForms.Helpers.Cookie.create(cookieName, JSON.stringify(data_values));
            }
            emitter.emit("update_cloud_tags");
          }
        }
        function get_cookie(cookieName) {
          return window.ModularForms.Helpers.Cookie.getByName(cookieName);
        }
        const __returned__ = { props, emitter, selected: selected2, store_to_cookie_by_id_and_value, get_cookie, inject, onMounted };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    function _sfc_render$L(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("button", {
        class: normalizeClass($props.className),
        onClick: _cache[0] || (_cache[0] = ($event) => $setup.store_to_cookie_by_id_and_value("analysis"))
      }, toDisplayString($props.label), 3);
    }
    const actionButtonCookie = /* @__PURE__ */ _export_sfc(_sfc_main$L, [["render", _sfc_render$L], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/scaling_up_analysis/components/action-button-cookie.vue"]]);
    const _sfc_main$K = {
      __name: "label-cloud",
      props: {
        sourceOfData: {
          type: String,
          default: "cookie"
        },
        cookieName: {
          type: String,
          default: ""
        },
        fieldId: {
          type: String,
          default: "id"
        },
        url: {
          type: String,
          default: ""
        },
        labelScalingUp: {
          type: String,
          default: "Scaling up analysis"
        },
        labelRemoveAll: {
          type: String,
          default: "Remove all"
        }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const props = __props;
        const selections = ref([]);
        const ids = ref([]);
        const emitter = inject("emitter");
        onMounted(() => {
          parse_cookie_data();
          emitter.on("update_cloud_tags", (data) => {
            if (is_cookie()) {
              parse_cookie_data();
            }
          });
          emitter.on("remove_values", () => {
            if (is_cookie()) {
              clear_all();
            }
          });
          emitter.on("scaling_up", () => {
            ids.value = selections.value.map((selection) => selection[props.fieldId]).join(",");
            props.url.replace("__items__", ids.value);
            window.location.href = props.url;
          });
        });
        function is_cookie() {
          return props.sourceOfData === "cookie";
        }
        function get_raw_values() {
          if (is_cookie()) {
            const cookie = window.ModularForms.Helpers.Cookie.getByName(props.cookieName);
            if (cookie) {
              const data = cookie.split("=");
              return JSON.parse(data[1]);
            }
          }
          return null;
        }
        function has_selected() {
          var _a2;
          if ((_a2 = selections.value) == null ? void 0 : _a2.length) {
            return selections.value.length > 1;
          }
          return false;
        }
        function scaling_up() {
          ids.value = selections.value.map((selection) => selection[props.fieldId]).join(",");
          window.location.href = props.url.replace("__items__", ids.value);
        }
        function get_values() {
          return get_raw_values();
        }
        function parse_cookie_data() {
          selections.value = get_values();
        }
        function remove_item(item) {
          var _a2;
          selections.value = (_a2 = selections.value) == null ? void 0 : _a2.filter((selection) => {
            return selection[props.fieldId] !== item[props.fieldId];
          });
          update2();
        }
        function clear_all() {
          selections.value = [];
          if (is_cookie()) {
            window.ModularForms.Helpers.Cookie.delete(props.cookieName);
          }
        }
        function update2() {
          if (is_cookie()) {
            const updated_values = JSON.stringify([...selections.value]);
            window.ModularForms.Helpers.Cookie.update(props.cookieName, updated_values);
          }
        }
        const __returned__ = { props, selections, ids, emitter, is_cookie, get_raw_values, has_selected, scaling_up, get_values, parse_cookie_data, remove_item, clear_all, update: update2, ref, onMounted, inject };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$y = { class: "vue-cloud flex flex-col" };
    const _hoisted_2$r = {
      key: 0,
      class: "flex flex-row justify-center gap-4"
    };
    const _hoisted_3$n = { class: "m-4 flex flex-row justify-center gap-4" };
    const _hoisted_4$i = ["onClick"];
    const _hoisted_5$h = { class: "p-2 bg-yellow-100 rounded border border-yellow-200" };
    function _sfc_render$K(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_action_button = resolveComponent("action_button");
      return openBlock(), createElementBlock("div", _hoisted_1$y, [
        $setup.has_selected() ? (openBlock(), createElementBlock("div", _hoisted_2$r, [
          createBaseVNode("button", {
            class: "btn-nav",
            onClick: $setup.scaling_up
          }, toDisplayString($setup.props.labelScalingUp), 1),
          createVNode(_component_action_button, {
            "class-name": "btn-nav red",
            click: $setup.clear_all,
            label: $setup.props.labelRemoveAll,
            event: "remove_values",
            emitter: $setup.emitter
          }, null, 8, ["label", "emitter"])
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_3$n, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($setup.selections, (selection) => {
            return openBlock(), createElementBlock("div", {
              class: "",
              key: selection.id,
              onClick: ($event) => $setup.remove_item(selection)
            }, [
              createBaseVNode("div", _hoisted_5$h, [
                createBaseVNode("strong", null, toDisplayString(selection.value), 1),
                _cache[0] || (_cache[0] = createBaseVNode("button", { type: "button" }, [
                  createBaseVNode("span", { "aria-hidden": "true" }, "")
                ], -1))
              ])
            ], 8, _hoisted_4$i);
          }), 128))
        ])
      ]);
    }
    const LabelCloud = /* @__PURE__ */ _export_sfc(_sfc_main$K, [["render", _sfc_render$K], ["__scopeId", "data-v-29abde70"], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/scaling_up_analysis/components/label-cloud.vue"]]);
    const _sfc_main$J = {
      __name: "action-button",
      props: {
        event: {
          type: String,
          default: ""
        },
        className: {
          type: String,
          default: "btn-nav float-left"
        },
        label: {
          type: String,
          default: "Submit"
        }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const props = __props;
        const data = ref([]);
        const isEnabled2 = ref(false);
        const emitter = inject("emitter");
        onMounted(() => {
          emitter.on("actionData", (data2) => {
            eventFunction(data2);
          });
        });
        function eventFunction(value) {
          data.value = value;
          isEnabled2.value = true;
        }
        function resetValues() {
          isEnabled2.value = false;
          data.value = [];
        }
        function action() {
          if (props.event) {
            emitter.emit(props.event);
            resetValues();
          }
        }
        const __returned__ = { props, data, isEnabled: isEnabled2, emitter, eventFunction, resetValues, action, inject, onMounted, ref };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    function _sfc_render$J(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("button", {
        class: normalizeClass($props.className),
        onClick: $setup.action
      }, toDisplayString($props.label), 3);
    }
    const actionButton = /* @__PURE__ */ _export_sfc(_sfc_main$J, [["render", _sfc_render$J], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/scaling_up_analysis/components/action-button.vue"]]);
    class ScalingList {
      constructor(input_data = {}) {
        const options = {
          name: "ScalingList",
          setup() {
            const selected2 = ref([]);
            const are_checked_all = ref(false);
            const emitter = mitt();
            provide("emitter", emitter);
            provide("selected", selected2);
            const is_checked = (id) => {
              return selected2.value.some((item) => parseInt(item.id) === id);
            };
            function clearSelections() {
              selected2.value = [];
              are_checked_all.value = false;
            }
            function retrieve_check_boxes() {
              return [...document.querySelectorAll(".vue-checkboxes")].slice(1);
            }
            function check_all() {
              if (!are_checked_all.value) {
                const checkboxes_list = retrieve_check_boxes();
                for (const key in checkboxes_list) {
                  const check_box = checkboxes_list[key];
                  const exist = is_checked(parseInt(check_box.defaultValue));
                  if (!exist) {
                    selected2.value.push({
                      id: check_box.defaultValue,
                      value: check_box.getAttribute("data-name")
                    });
                  }
                }
                are_checked_all.value = true;
              } else {
                clearSelections();
              }
            }
            const selectValueByIdAndValue = (id, value) => {
              if (is_checked(parseInt(id))) {
                selected2.value = selected2.value.filter((item) => parseInt(item.id) !== parseInt(id));
              } else {
                selected2.value.push({ id, value });
              }
            };
            const add_all = () => {
              input_data.listItems.forEach(function(item) {
                selectValueByIdAndValue(item.id, item.value);
              });
              emitter.emit("store_cookie_and_value", "analysis", JSON.stringify(selected2.value));
              selected2.value = [];
            };
            const is_value_included = (value) => {
              return selected2.value.some((item) => parseInt(item.id) === parseInt(value));
            };
            const sortList = (list) => {
              return list.sort((a2, b2) => {
                return a2.name.localeCompare(b2.name);
              });
            };
            return {
              emitter,
              selected: selected2,
              is_checked,
              check_all,
              are_checked_all,
              selectValueByIdAndValue,
              add_all,
              is_value_included,
              sortList
            };
          }
        };
        const app = createApp(
          options || {},
          input_data || {}
        );
        app.component("action_button", actionButton);
        app.component("action_button_cookie", actionButtonCookie);
        app.component("label_cloud", LabelCloud);
        app.component("imet_encoders_responsibles", imetEncodersResponsibles);
        app.component("imet_radar", imet_radar);
        return app;
      }
    }
    const _sfc_main$I = {
      __name: "general_info",
      props: {
        values: {
          type: [Array, Object],
          default: () => {
          }
        }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const stores = inject("stores");
        const props = __props;
        const info = reactive({
          countries: null,
          network: null,
          categories: null,
          total_surface_protected_areas: null,
          total_surface_area_of_landscape_protected_areas: null,
          agencies: null,
          eco_regions: null,
          local_vision: null,
          local_mission: null,
          local_objective: null,
          landscapes: null,
          values_network: null
        });
        function init2(response) {
          Object.entries(info).forEach((object2) => {
            var _a2, _b2, _c2, _d2;
            if (Array.isArray((_a2 = response.general_info) == null ? void 0 : _a2[object2[0]])) {
              info[object2[0]] = (_c2 = (_b2 = response.general_info) == null ? void 0 : _b2[object2[0]]) == null ? void 0 : _c2.filter((i2) => i2).join(", ");
            } else {
              info[object2[0]] = (_d2 = response.general_info) == null ? void 0 : _d2[object2[0]];
            }
          });
        }
        onMounted(() => {
          init2(props.values);
        });
        const __returned__ = { stores, props, info, init: init2, ref, reactive, onMounted, inject };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$x = { id: "general-elements" };
    const _hoisted_2$q = { class: "max-w-12xl m-auto" };
    const _hoisted_3$m = { class: "strong text-left" };
    const _hoisted_4$h = { class: "text-left" };
    const _hoisted_5$g = { class: "strong text-left" };
    const _hoisted_6$d = { class: "text-left" };
    const _hoisted_7$a = { class: "strong text-left" };
    const _hoisted_8$7 = { class: "text-left" };
    const _hoisted_9$6 = { class: "strong text-left" };
    const _hoisted_10$4 = { class: "text-left" };
    const _hoisted_11$4 = { class: "strong text-left" };
    const _hoisted_12$3 = { class: "text-left" };
    const _hoisted_13$3 = { class: "strong text-left" };
    const _hoisted_14$3 = { class: "text-left" };
    const _hoisted_15$3 = { class: "strong text-left" };
    const _hoisted_16$3 = { class: "text-left" };
    function _sfc_render$I(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", _hoisted_1$x, [
        createBaseVNode("table", _hoisted_2$q, [
          createBaseVNode("tbody", null, [
            createBaseVNode("tr", null, [
              createBaseVNode("td", null, [
                createBaseVNode("div", _hoisted_3$m, toDisplayString($setup.stores.BaseStore.localization("imet-core::analysis_report.general_info.country")) + ": ", 1)
              ]),
              createBaseVNode("td", null, [
                createBaseVNode("div", _hoisted_4$h, toDisplayString($setup.info.countries), 1)
              ])
            ]),
            createBaseVNode("tr", null, [
              createBaseVNode("td", null, [
                createBaseVNode("div", _hoisted_5$g, toDisplayString($setup.stores.BaseStore.localization("imet-core::analysis_report.general_info.network")) + ": ", 1)
              ]),
              createBaseVNode("td", null, [
                createBaseVNode("div", _hoisted_6$d, toDisplayString($setup.info.network), 1)
              ])
            ]),
            createBaseVNode("tr", null, [
              createBaseVNode("td", null, [
                createBaseVNode("div", _hoisted_7$a, toDisplayString($setup.stores.BaseStore.localization("imet-core::analysis_report.general_info.total_surface_protected")) + ": ", 1)
              ]),
              createBaseVNode("td", null, [
                createBaseVNode("div", _hoisted_8$7, toDisplayString($setup.info.total_surface_protected_areas) + " [km2] ", 1)
              ])
            ]),
            createBaseVNode("tr", null, [
              createBaseVNode("td", null, [
                createBaseVNode("div", _hoisted_9$6, toDisplayString($setup.stores.BaseStore.localization("imet-core::analysis_report.general_info.ecoregions")) + ": ", 1)
              ]),
              createBaseVNode("td", null, [
                createBaseVNode("div", _hoisted_10$4, toDisplayString($setup.info.eco_regions), 1)
              ])
            ]),
            createBaseVNode("tr", null, [
              createBaseVNode("td", null, [
                createBaseVNode("div", _hoisted_11$4, toDisplayString($setup.stores.BaseStore.localization("imet-core::analysis_report.general_info.vision")) + ": ", 1)
              ]),
              createBaseVNode("td", null, [
                createBaseVNode("div", _hoisted_12$3, toDisplayString($setup.info.local_vision), 1)
              ])
            ]),
            createBaseVNode("tr", null, [
              createBaseVNode("td", null, [
                createBaseVNode("div", _hoisted_13$3, toDisplayString($setup.stores.BaseStore.localization("imet-core::analysis_report.general_info.mission")) + ": ", 1)
              ]),
              createBaseVNode("td", null, [
                createBaseVNode("div", _hoisted_14$3, toDisplayString($setup.info.local_mission), 1)
              ])
            ]),
            createBaseVNode("tr", null, [
              createBaseVNode("td", null, [
                createBaseVNode("div", _hoisted_15$3, toDisplayString($setup.stores.BaseStore.localization("imet-core::analysis_report.general_info.objectives")) + ": ", 1)
              ]),
              createBaseVNode("td", null, [
                createBaseVNode("div", _hoisted_16$3, toDisplayString($setup.info.local_objective), 1)
              ])
            ])
          ])
        ])
      ]);
    }
    const generalInfo = /* @__PURE__ */ _export_sfc(_sfc_main$I, [["render", _sfc_render$I], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/scaling_up_analysis/components/general_info.vue"]]);
    const _sfc_main$H = {
      name: "elements",
      props: {
        values: {
          type: [Array, Object],
          default: () => {
          }
        },
        show_element: {
          type: Boolean,
          default: false
        },
        comment_title: {
          type: String,
          default: ""
        },
        title: {
          type: String,
          default: ""
        }
      }
    };
    const _hoisted_1$w = { class: "mt-5" };
    const _hoisted_2$p = { class: "strong" };
    const _hoisted_3$l = { class: "strong" };
    function _sfc_render$H(_ctx, _cache, $props, $setup, $data, $options) {
      return withDirectives((openBlock(), createElementBlock("div", _hoisted_1$w, [
        createBaseVNode("div", _hoisted_2$p, toDisplayString($props.title), 1),
        renderSlot(_ctx.$slots, "default"),
        (openBlock(true), createElementBlock(Fragment, null, renderList($props.values, (list, index) => {
          return openBlock(), createElementBlock("div", {
            class: "mt-3 ml-3",
            id: "collapse-habitats",
            key: index
          }, [
            createBaseVNode("div", _hoisted_3$l, toDisplayString(index), 1),
            createBaseVNode("ul", null, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(list[0], (item, k2) => {
                return openBlock(), createElementBlock("li", { key: k2 }, toDisplayString(item), 1);
              }), 128))
            ])
          ]);
        }), 128))
      ], 512)), [
        [vShow, $props.show_element]
      ]);
    }
    const elements = /* @__PURE__ */ _export_sfc(_sfc_main$H, [["render", _sfc_render$H], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/scaling_up_analysis/components/management_context/elements.vue"]]);
    function useResize(component_data) {
      component_data.chart || ref(null);
      const emitter = component_data.emitter;
      function handleResize(echartObject) {
        echartObject.resize();
      }
      function initResize(echartObject) {
        save_data(echartObject);
        const resize_event = () => handleResize(echartObject);
        window.addEventListener("resize", resize_event);
      }
      function save_data(charContainer) {
        if (charContainer) {
          emitter.on("save_data", (value) => {
            const { comments, image_src, attr, func: func2 } = value;
            if (charContainer) {
              const value2 = charContainer.getDataURL({
                pixelRatio: 2,
                backgroundColor: "#fff"
              });
              func2(value2, attr);
            }
          });
        }
      }
      onBeforeUnmount(() => {
        window.removeEventListener("resize", handleResize);
      });
      return { initResize, save_data, handleResize };
    }
    function useBar(component_data) {
      const zoom = component_data.zoom;
      const colors = component_data.colors;
      const fields = component_data.fields;
      function has_zoom() {
        if (zoom) {
          return {
            dataZoom: [
              {
                show: true,
                start: 0,
                end: 100
              }
            ]
          };
        }
        return {};
      }
      function get_colors() {
        if (colors === null) {
          return {};
        }
        return { colors };
      }
      function field_name() {
        return fields.map((field) => {
          return field;
        });
      }
      return {
        has_zoom,
        get_colors,
        field_name
      };
    }
    const common = {
      width: {
        type: String,
        default: "100%"
      },
      height: {
        type: String,
        default: "500px"
      },
      values: {
        type: [Array, Object],
        default: () => {
        }
      },
      colors: {
        type: [Array, Object],
        default: null
      },
      axis_dimensions_x: {
        type: Object,
        default: () => {
        }
      },
      axis_dimensions_y: {
        type: Object,
        default: () => {
        }
      },
      title: {
        type: String,
        default: ""
      }
    };
    const commonProps$2 = {
      fields: {
        type: Array,
        default: () => {
        }
      },
      rotate: {
        type: Number,
        default: 0
      },
      zoom: {
        type: Boolean,
        default: false
      },
      series_data: {
        type: Object,
        default: () => {
        }
      },
      title_data: {
        type: String,
        default: ""
      }
    };
    const _sfc_main$G = {
      __name: "imet_bar_chart",
      props: {
        ...common,
        ...commonProps$2,
        computedObject: {
          type: Object,
          default: null
        }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const chartContainer = ref(null);
        const emitter = inject("emitter");
        const props = __props;
        const { has_zoom, field_name, get_colors } = useBar({
          fields: props.fields,
          colors: props.colors,
          zoom: props.zoom
        });
        const { initResize } = useResize({
          emitter
        });
        const computedJSON = props.computedObject ?? {
          ...get_colors(),
          legend: {
            show: true,
            padding: [35, 0, 0, 0]
          },
          title: {
            text: props.title,
            left: "center"
          },
          tooltip: {
            trigger: "axis",
            axisPointer: {
              type: "shadow"
            }
          },
          xAxis: {
            type: "category",
            data: field_name(),
            axisLabel: {
              rotate: props.rotate,
              interval: 0
            },
            ...props.axis_dimensions_x
          },
          yAxis: {
            type: "value",
            realtimeSort: true,
            minInterval: 1,
            ...props.axis_dimensions_y
          },
          grid: {
            left: "3%",
            right: "4%",
            bottom: "3%",
            containLabel: true
          },
          series: [{
            data: props.values,
            type: "bar",
            name: props.title_data,
            ...props.series_data
          }],
          ...has_zoom()
        };
        const bar_options = computed(
          () => {
            return computedJSON;
          }
        );
        onMounted(() => {
          if (props.values.length > 0) {
            draw_chart();
          }
        });
        function draw_chart() {
          if (props.values.length > 0) {
            let echartObject = init(chartContainer.value);
            echartObject.setOption(bar_options.value);
            initResize(echartObject);
          }
        }
        const __returned__ = { chartContainer, emitter, props, has_zoom, field_name, get_colors, initResize, computedJSON, bar_options, draw_chart, get echarts() {
          return echarts;
        }, inject, ref, computed, onMounted, watch, get useResize() {
          return useResize;
        }, get useBar() {
          return useBar;
        }, get common() {
          return common;
        }, get commonProps() {
          return commonProps$2;
        } };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    function _sfc_render$G(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        ref: "chartContainer",
        class: "bar",
        style: normalizeStyle("width:" + _ctx.width + "; min-height: " + _ctx.height + ";")
      }, null, 4);
    }
    const imetBarChart = /* @__PURE__ */ _export_sfc(_sfc_main$G, [["render", _sfc_render$G], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/templates/imet_bar_chart.vue"]]);
    const _sfc_main$F = {
      __name: "management_context",
      props: {
        values: {
          type: [Array, Object],
          default: () => {
          }
        }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const props = __props;
        const stores = inject("stores");
        const Locale2 = window.Locale;
        const data = reactive({
          Locale: Locale2,
          show_species: false,
          show_habitats: false,
          show_climate: false,
          show_ecosystem: false,
          show_threats: false,
          species: [],
          climate_change: [],
          ecosystem_services: [],
          habitats: [],
          threats: [],
          items: [],
          species_statistics_group0: [],
          show_group0: true,
          show_group1: true,
          species_statistics_group1: [],
          habitats_statistics: [],
          climate_change_statistics: [],
          show_bar_climate: false,
          show_bar_habitats: false,
          show_bar_ecosystem_services: false,
          show_bar_threats: false,
          ecosystem_services_statistics: [],
          threats_statistics: []
        });
        onMounted(
          () => {
            const {
              species,
              climate_change,
              ecosystem_services,
              habitats,
              threats,
              species_statistics,
              habitats_statistics,
              climate_change_statistics,
              ecosystem_services_statistics,
              threats_statistics
            } = props.values;
            data.species = species;
            data.climate_change = climate_change;
            data.ecosystem_services = ecosystem_services;
            data.habitats = habitats;
            data.threats = threats;
            const group0 = Object.entries(species_statistics.group0);
            const group1 = Object.entries(species_statistics.group1);
            data.show_group0 = group0.length;
            data.show_group1 = group1.length;
            data.species_statistics_group0 = Object.fromEntries(group0);
            data.species_statistics_group1 = Object.fromEntries(group1);
            data.climate_change_statistics = climate_change_statistics;
            data.habitats_statistics = habitats_statistics;
            data.ecosystem_services_statistics = ecosystem_services_statistics;
            data.threats_statistics = threats_statistics;
          }
        );
        function remove_parenthesis_words(string2) {
          let words2 = [];
          string2.forEach(function(item) {
            words2.push(item.replace(/ *\([^)]*\) */g, ""));
          });
          words2.forEach(function(item, index) {
            if (item.length > 10) {
              words2[index] = item.replace(/ /g, "\n") + " ";
            }
          });
          return words2;
        }
        function show_specific_species(key) {
          return data.species[key].length;
        }
        function toggle_species(section) {
          data["show_" + section] = !data["show_" + section];
        }
        function species_count(value) {
          const species = data.species_statistics[value];
          return species > 1 ? ` (${species})` : "";
        }
        const __returned__ = { props, stores, Locale: Locale2, data, remove_parenthesis_words, show_specific_species, toggle_species, species_count, elements, imet_bar_chart: imetBarChart, ref, onMounted, inject, reactive };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$v = {
      key: 0,
      id: "species"
    };
    const _hoisted_2$o = {
      key: 0,
      class: "mb-3"
    };
    const _hoisted_3$k = {
      key: 0,
      class: "mb-3"
    };
    const _hoisted_4$g = {
      key: 0,
      id: "habitats"
    };
    const _hoisted_5$f = {
      key: 0,
      class: "mb-3"
    };
    const _hoisted_6$c = {
      key: 0,
      id: "climate_change"
    };
    const _hoisted_7$9 = {
      key: 0,
      class: "mb-3"
    };
    const _hoisted_8$6 = {
      key: 0,
      id: "ecosystem_services"
    };
    const _hoisted_9$5 = { class: "mb-3" };
    const _hoisted_10$3 = {
      key: 0,
      id: "threats"
    };
    const _hoisted_11$3 = { class: "mb-3" };
    function _sfc_render$F(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_container_actions = resolveComponent("container_actions");
      return openBlock(), createElementBlock("div", null, [
        createBaseVNode("div", null, [
          createBaseVNode("h5", {
            onClick: _cache[0] || (_cache[0] = ($event) => $setup.toggle_species("species"))
          }, [
            createBaseVNode("span", {
              class: normalizeClass(["fas fa-fw", { "fa-caret-up": !$setup.data.show_species, "fa-caret-down": $setup.data.show_species }])
            }, null, 2),
            createTextVNode(" " + toDisplayString($setup.stores.BaseStore.localization("imet-core::analysis_report.management_context.key_species")), 1)
          ]),
          createVNode(_component_container_actions, {
            data: $setup.data.species,
            name: "species",
            comment_title: $setup.stores.BaseStore.localization("imet-core::analysis_report.management_context.comments_plants_species"),
            event_image: "save_entire_block_as_image",
            exclude_elements: ""
          }, {
            default: withCtx((species_data) => [
              $setup.data.show_species ? (openBlock(), createElementBlock("div", _hoisted_1$v, [
                createVNode($setup["elements"], {
                  values: species_data.props.group0,
                  title: $setup.stores.BaseStore.localization("imet-core::analysis_report.management_context.animal_species"),
                  comment_title: $setup.stores.BaseStore.localization("imet-core::analysis_report.management_context.comments_animal_species"),
                  show_element: $setup.data.show_species
                }, {
                  default: withCtx(() => [
                    $setup.data.show_species && $setup.data.show_group0 ? (openBlock(), createElementBlock("div", _hoisted_2$o, [
                      createVNode($setup["imet_bar_chart"], {
                        fields: $setup.remove_parenthesis_words(Object.keys($setup.data.species_statistics_group0)),
                        title_data: $setup.stores.BaseStore.localization("imet-core::analysis_report.management_context.animal_species_chart"),
                        title: $setup.stores.BaseStore.localization("imet-core::analysis_report.management_context.occurrences_species"),
                        rotate: 0,
                        zoom: true,
                        values: Object.values($setup.data.species_statistics_group0)
                      }, null, 8, ["fields", "title_data", "title", "values"])
                    ])) : createCommentVNode("", true)
                  ]),
                  _: 2
                }, 1032, ["values", "title", "comment_title", "show_element"]),
                createVNode($setup["elements"], {
                  values: species_data.props.group1,
                  title: $setup.stores.BaseStore.localization("imet-core::analysis_report.management_context.plants_species"),
                  show_element: $setup.data.show_species
                }, {
                  default: withCtx(() => [
                    $setup.data.show_species && $setup.data.show_group1 ? (openBlock(), createElementBlock("div", _hoisted_3$k, [
                      createVNode($setup["imet_bar_chart"], {
                        fields: $setup.remove_parenthesis_words(Object.keys($setup.data.species_statistics_group1)),
                        title_data: $setup.stores.BaseStore.localization("imet-core::analysis_report.management_context.plant_species_chart"),
                        title: $setup.stores.BaseStore.localization("imet-core::analysis_report.management_context.occurrences_plants"),
                        rotate: 0,
                        zoom: true,
                        values: Object.values($setup.data.species_statistics_group1)
                      }, null, 8, ["fields", "title_data", "title", "values"])
                    ])) : createCommentVNode("", true)
                  ]),
                  _: 2
                }, 1032, ["values", "title", "show_element"])
              ])) : createCommentVNode("", true)
            ]),
            _: 1
          }, 8, ["data", "comment_title"])
        ]),
        createBaseVNode("div", null, [
          createBaseVNode("h5", {
            onClick: _cache[1] || (_cache[1] = ($event) => $setup.toggle_species("habitats"))
          }, [
            createBaseVNode("span", {
              class: normalizeClass(["fas fa-fw", { "fa-caret-up": !$setup.data.show_habitats, "fa-caret-down": $setup.data.show_habitats }])
            }, null, 2),
            createTextVNode(" " + toDisplayString($setup.stores.BaseStore.localization("imet-core::analysis_report.management_context.terrestrial_marine_habitats")), 1)
          ]),
          createVNode(_component_container_actions, {
            data: $setup.data.habitats,
            name: "habitats",
            event_image: "save_entire_block_as_image",
            comment_title: $setup.stores.BaseStore.localization("imet-core::analysis_report.management_context.comments_terrestrial"),
            exclude_elements: ""
          }, {
            default: withCtx((habitats_data) => [
              $setup.data.show_habitats ? (openBlock(), createElementBlock("div", _hoisted_4$g, [
                createVNode($setup["elements"], {
                  values: habitats_data.props,
                  show_element: $setup.data.show_habitats
                }, {
                  default: withCtx(() => [
                    $setup.data.show_habitats ? (openBlock(), createElementBlock("div", _hoisted_5$f, [
                      createVNode($setup["imet_bar_chart"], {
                        fields: $setup.remove_parenthesis_words(Object.keys($setup.data.habitats_statistics)),
                        title_data: $setup.stores.BaseStore.localization("imet-core::analysis_report.management_context.habitats_chart"),
                        title: $setup.stores.BaseStore.localization("imet-core::analysis_report.management_context.occurrences_habitats"),
                        rotate: 0,
                        zoom: true,
                        values: Object.values($setup.data.habitats_statistics)
                      }, null, 8, ["fields", "title_data", "title", "values"])
                    ])) : createCommentVNode("", true)
                  ]),
                  _: 2
                }, 1032, ["values", "show_element"])
              ])) : createCommentVNode("", true)
            ]),
            _: 1
          }, 8, ["data", "comment_title"])
        ]),
        createBaseVNode("div", null, [
          createBaseVNode("div", {
            onClick: _cache[2] || (_cache[2] = ($event) => $setup.toggle_species("climate"))
          }, [
            createBaseVNode("h5", null, [
              createBaseVNode("span", {
                class: normalizeClass(["fas fa-fw", { "fa-caret-up": !$setup.data.show_climate, "fa-caret-down": $setup.data.show_climate }])
              }, null, 2),
              createTextVNode(" " + toDisplayString($setup.stores.BaseStore.localization("imet-core::analysis_report.management_context.climate_change")), 1)
            ])
          ]),
          createVNode(_component_container_actions, {
            data: $setup.data.climate_change,
            name: "climate_change",
            event_image: "save_entire_block_as_image",
            comment_title: $setup.stores.BaseStore.localization("imet-core::analysis_report.management_context.comments_climate"),
            exclude_elements: ""
          }, {
            default: withCtx((climate_change_data) => [
              $setup.data.show_climate ? (openBlock(), createElementBlock("div", _hoisted_6$c, [
                createVNode($setup["elements"], {
                  values: climate_change_data.props,
                  show_element: $setup.data.show_climate
                }, {
                  default: withCtx(() => [
                    $setup.data.show_climate ? (openBlock(), createElementBlock("div", _hoisted_7$9, [
                      createVNode($setup["imet_bar_chart"], {
                        fields: $setup.remove_parenthesis_words(Object.keys($setup.data.climate_change_statistics)),
                        title_data: $setup.stores.BaseStore.localization("imet-core::analysis_report.management_context.values_sensitive_chart"),
                        title: $setup.stores.BaseStore.localization("imet-core::analysis_report.management_context.occurrences_climate"),
                        rotate: 0,
                        zoom: true,
                        values: Object.values($setup.data.climate_change_statistics)
                      }, null, 8, ["fields", "title_data", "title", "values"])
                    ])) : createCommentVNode("", true)
                  ]),
                  _: 2
                }, 1032, ["values", "show_element"])
              ])) : createCommentVNode("", true)
            ]),
            _: 1
          }, 8, ["data", "comment_title"])
        ]),
        createBaseVNode("div", null, [
          createBaseVNode("div", {
            onClick: _cache[3] || (_cache[3] = ($event) => $setup.toggle_species("ecosystem"))
          }, [
            createBaseVNode("h5", null, [
              createBaseVNode("span", {
                class: normalizeClass(["fas fa-fw", { "fa-caret-up": !$setup.data.show_ecosystem, "fa-caret-down": $setup.data.show_ecosystem }])
              }, null, 2),
              createTextVNode(" " + toDisplayString($setup.stores.BaseStore.localization("imet-core::analysis_report.management_context.ecosystem_services")), 1)
            ])
          ]),
          createVNode(_component_container_actions, {
            data: $setup.data.ecosystem_services,
            name: "ecosystem_services",
            event_image: "save_entire_block_as_image",
            comment_title: $setup.stores.BaseStore.localization("imet-core::analysis_report.management_context.comments_ecosystem"),
            exclude_elements: ""
          }, {
            default: withCtx((ecosystem_services_data) => [
              $setup.data.show_ecosystem ? (openBlock(), createElementBlock("div", _hoisted_8$6, [
                createVNode($setup["elements"], {
                  values: ecosystem_services_data.props,
                  show_element: $setup.data.show_ecosystem
                }, {
                  default: withCtx(() => [
                    createBaseVNode("div", _hoisted_9$5, [
                      createVNode($setup["imet_bar_chart"], {
                        fields: $setup.remove_parenthesis_words(Object.keys($setup.data.ecosystem_services_statistics)),
                        title_data: $setup.stores.BaseStore.localization("imet-core::analysis_report.management_context.ecosystem_services_chart"),
                        title: $setup.stores.BaseStore.localization("imet-core::analysis_report.management_context.occurrences_ecosystem_services"),
                        rotate: 0,
                        zoom: true,
                        values: Object.values($setup.data.ecosystem_services_statistics)
                      }, null, 8, ["fields", "title_data", "title", "values"])
                    ])
                  ]),
                  _: 2
                }, 1032, ["values", "show_element"])
              ])) : createCommentVNode("", true)
            ]),
            _: 1
          }, 8, ["data", "comment_title"])
        ]),
        createBaseVNode("div", null, [
          createBaseVNode("div", {
            onClick: _cache[4] || (_cache[4] = ($event) => $setup.toggle_species("threats"))
          }, [
            createBaseVNode("h5", null, [
              createBaseVNode("span", {
                class: normalizeClass(["fas fa-fw", { "fa-caret-up": !$setup.data.show_threats, "fa-caret-down": $setup.data.show_threats }])
              }, null, 2),
              createTextVNode(" " + toDisplayString($setup.stores.BaseStore.localization("imet-core::analysis_report.management_context.label_threats")), 1)
            ])
          ]),
          createVNode(_component_container_actions, {
            data: $setup.data.threats,
            name: "threats",
            event_image: "save_entire_block_as_image",
            comment_title: $setup.stores.BaseStore.localization("imet-core::analysis_report.management_context.comments_threats"),
            exclude_elements: ""
          }, {
            default: withCtx((threats_data) => [
              $setup.data.show_threats ? (openBlock(), createElementBlock("div", _hoisted_10$3, [
                createVNode($setup["elements"], {
                  values: threats_data.props,
                  show_element: $setup.data.show_threats
                }, {
                  default: withCtx(() => [
                    createBaseVNode("div", _hoisted_11$3, [
                      createVNode($setup["imet_bar_chart"], {
                        fields: $setup.remove_parenthesis_words(Object.keys($setup.data.threats_statistics)),
                        title: $setup.stores.BaseStore.localization("imet-core::analysis_report.management_context.occurrences_threats"),
                        title_data: $setup.stores.BaseStore.localization("imet-core::analysis_report.management_context.threats_charts"),
                        rotate: 0,
                        zoom: true,
                        values: Object.values($setup.data.threats_statistics)
                      }, null, 8, ["fields", "title", "title_data", "values"])
                    ])
                  ]),
                  _: 2
                }, 1032, ["values", "show_element"])
              ])) : createCommentVNode("", true)
            ]),
            _: 1
          }, 8, ["data", "comment_title"])
        ])
      ]);
    }
    const managementContext = /* @__PURE__ */ _export_sfc(_sfc_main$F, [["render", _sfc_render$F], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/scaling_up_analysis/components/management_context.vue"]]);
    const _sfc_main$E = {
      __name: "drop_drag_area",
      props: {
        drop_id: {
          type: Number,
          default: 0
        },
        visible: {
          type: Boolean,
          default: true
        },
        color: {
          type: String,
          default: "#f8f9fa"
        }
      },
      emits: ["drop-element"],
      setup(__props, { expose: __expose, emit: __emit }) {
        __expose();
        const emit = __emit;
        const props = __props;
        const onDrop = (evt) => {
          emit("drop-element", evt, props.drop_id);
        };
        const __returned__ = { emit, props, onDrop, inject };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    function _sfc_render$E(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        style: normalizeStyle("background-color:" + $props.color),
        class: "drop-zones d-grid gap-1 rounded",
        onDrop: _cache[0] || (_cache[0] = ($event) => $setup.onDrop($event)),
        onDragover: _cache[1] || (_cache[1] = withModifiers(() => {
        }, ["prevent"])),
        onDragenter: _cache[2] || (_cache[2] = withModifiers(() => {
        }, ["prevent"]))
      }, [
        renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ], 36);
    }
    const drop_drag_area = /* @__PURE__ */ _export_sfc(_sfc_main$E, [["render", _sfc_render$E], ["__scopeId", "data-v-0367b2c5"], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/scaling_up_analysis/components/drag_and_drop/drop_drag_area.vue"]]);
    const _sfc_main$D = {
      __name: "draggable_item",
      props: {
        item: {
          type: Object,
          default: () => ({})
        },
        is_removable: {
          type: Boolean,
          default: true
        },
        item_class: {
          type: String,
          default: "default-zone-element"
        },
        remove_event: {
          type: String,
          default: "remove-element"
        }
      },
      emits: ["drop-item-area", "drag-over", "drag-element", "drag-end", "remove-element"],
      setup(__props, { expose: __expose, emit: __emit }) {
        __expose();
        const emitter = inject("emitter");
        const props = __props;
        const emit = __emit;
        const onDrop = (evt, item) => {
          const itemID = evt.dataTransfer.getData("itemID");
          emit("drop-item-area", evt, itemID);
        };
        const dragOver = (evt, item) => {
          emit("drag-over", evt, item);
        };
        const startDrag = (evt, item) => {
          evt.dataTransfer.effectAllowed = "move";
          evt.dataTransfer.setData("itemID", item.id);
          emit("drag-element", evt, item);
        };
        const removeItem = (evt, item) => {
          emit(props.remove_event, evt, item);
        };
        const __returned__ = { emitter, props, emit, onDrop, dragOver, startDrag, removeItem, inject };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$u = ["id"];
    function _sfc_render$D(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        id: $props.item.id,
        class: normalizeClass(["item_class", "default-zone-element"]),
        draggable: "true",
        onDrop: _cache[1] || (_cache[1] = ($event) => $setup.onDrop($event, $props.item)),
        onDragstart: _cache[2] || (_cache[2] = ($event) => $setup.startDrag($event, $props.item)),
        onDragover: _cache[3] || (_cache[3] = ($event) => $setup.dragOver($event, $props.item))
      }, [
        _cache[4] || (_cache[4] = createBaseVNode("i", { class: "fa-solid fa-grip-vertical mr-2 cursor-grab" }, null, -1)),
        renderSlot(_ctx.$slots, "default", {}, void 0, true),
        createBaseVNode("span", null, toDisplayString($props.item.name), 1),
        $props.is_removable ? (openBlock(), createElementBlock("i", {
          key: 0,
          class: "fa fa-times ml-2",
          "aria-hidden": "true",
          onClick: _cache[0] || (_cache[0] = ($event) => $setup.removeItem(_ctx.evt, $props.item.id))
        })) : createCommentVNode("", true)
      ], 40, _hoisted_1$u);
    }
    const draggable_item = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["render", _sfc_render$D], ["__scopeId", "data-v-010a90de"], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/scaling_up_analysis/components/drag_and_drop/draggable_item.vue"]]);
    const func_to_call = "get_grouping_analysis";
    const _sfc_main$C = {
      __name: "grouping",
      props: {
        values: {
          type: [Object, Array],
          default: () => {
          }
        },
        country_events: {
          type: [Array, Object],
          default: () => {
          }
        },
        number_of_drop_zones: {
          type: Number,
          default: 1
        }
      },
      emits: ["incoming-data"],
      setup(__props, { expose: __expose, emit: __emit }) {
        __expose();
        const stores = inject("stores");
        const emit = __emit;
        const trigger_incoming_data = ref(null);
        const colors = ["#5470c6", "#91cc75", "#fac858", "#ee6666", "#73c0de", "#3ba272", "#fc8452", "#9a60b4", "#ea7ccc"];
        const data = reactive({
          list: [],
          countriesList: [],
          list_of_components: [],
          show_selected_legend: false,
          type: null
        });
        const props = __props;
        const default_list = computed(() => {
          return data.list.filter((item) => item.list === null);
        });
        onMounted(() => {
          data.list = Object.entries(props.values).map((i2) => {
            data.countriesList.push(i2[1].Country_name.name);
            return {
              id: i2[1].FormID,
              name: i2[1].name,
              "list": null,
              country: i2[1].Country_name.name,
              input_visible: false
            };
          });
          data.list.sort((a2, b2) => a2.name.localeCompare(b2.name));
          data.countriesList = [...new Set(data.countriesList)];
          init_components();
        });
        function show_diagrams(type = "radar", params = null) {
          data.type = type;
          const render2 = data.list.some((item) => item.list !== null);
          if (render2) {
            trigger_incoming_data.value = {
              parameters: data.list.filter((item) => item.list !== null).map((item) => {
                let group = data.list_of_components.find((comp) => comp.id === item.list);
                return { id: item.id, group: item.list, name: group.name, color: group.color };
              }),
              func: params ? params.func : func_to_call
            };
            data.show_selected_legend = true;
          }
        }
        function init_components() {
          data.list_of_components = Array.from({ length: props.number_of_drop_zones }, (_2, id) => ({
            id: id + 1,
            color: colors[id],
            name: "Group " + (id + 1),
            input_visible: false
          }));
        }
        function remove_component_from_list(id) {
          data.list_of_components = data.list_of_components.filter((comp, index) => comp.id !== id);
          reset_list_items(id);
        }
        function edit_component_name(id) {
          data.list_of_components.find((comp) => comp.id === id).input_visible = true;
        }
        function save_component_name(id) {
          const name = document.getElementById("item-" + id).value;
          data.list_of_components = data.list_of_components.map((comp) => {
            if (comp.id === id) {
              comp.name = name;
            }
            comp.input_visible = false;
            return comp;
          });
        }
        function list_items(id = null) {
          return data.list.filter((item) => item.list === id);
        }
        function reset_list_items(id) {
          data.list.map((item) => {
            if (item.list === id) {
              item.list = null;
              item.by_country = null;
            }
            return item;
          });
        }
        const start_drag = (evt, item) => {
          evt.dataTransfer.dropEffect = "move";
          evt.dataTransfer.effectAllowed = "move";
          evt.dataTransfer.setData("itemID", item.id);
        };
        function on_drop(evt, id) {
          const itemID = evt.dataTransfer.getData("itemID");
          const item = data.list.find((item2) => item2.id == itemID);
          item.list = id;
        }
        function remove_from_list(id) {
          const item = data.list.find((item2) => item2.id == id);
          item.list = null;
          item.by_country = null;
        }
        function add_group(name = null) {
          const components_length = data.list_of_components.length;
          const group_name = name ?? `${stores.BaseStore.localization("imet-core::analysis_report.grouping.group")} ${components_length + 1}`;
          const length = !components_length ? 1 : Math.max(...data.list_of_components.map((i2) => i2.id)) + 1;
          data.list_of_components.push({ id: length, color: colors[length - 1], name: group_name, input_visible: false });
          data.list_of_components.sort((a2, b2) => {
            return a2.name.localeCompare(b2.name);
          });
        }
        function reset() {
          data.list.map((item) => {
            item.list = null;
            item.by_country = null;
            return item;
          });
          stores.BaseStore.toggle_country_enabled();
          data.list_of_components = [];
          add_group();
          add_group();
          data.show_selected_legend = false;
        }
        function add_by_country() {
          data.list_of_components = [];
          let boards = data.list_of_components.length;
          const countries = data.countriesList.length;
          stores.BaseStore.toggle_country_enabled();
          data.list.map((item) => {
            const index = data.countriesList.indexOf(item.country);
            item.list = index + 1;
            item.by_country = true;
            return item;
          });
          while (countries > boards) {
            add_group(data.countriesList[boards]);
            boards++;
          }
        }
        const __returned__ = { stores, emit, trigger_incoming_data, colors, func_to_call, data, props, default_list, show_diagrams, init_components, remove_component_from_list, edit_component_name, save_component_name, list_items, reset_list_items, start_drag, on_drop, remove_from_list, add_group, reset, add_by_country, drop_drag_area, draggable_item, onMounted, reactive, computed, inject, ref };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$t = { id: "js-grouping-action-buttons" };
    const _hoisted_2$n = { class: "mb-2" };
    const _hoisted_3$j = {
      class: "flex flex-row justify-center dropzone-areas",
      id: "dropzone-areas"
    };
    const _hoisted_4$f = {
      class: "text-center mb-4 py-1 px-2 font-bold",
      style: { "background": "rgba(255,255,255,0.7)" }
    };
    const _hoisted_5$e = {
      key: 0,
      class: "text-center"
    };
    const _hoisted_6$b = ["id", "value"];
    const _hoisted_7$8 = {
      key: 1,
      class: "text-center"
    };
    const _hoisted_8$5 = ["onClick"];
    const _hoisted_9$4 = ["onClick"];
    const _hoisted_10$2 = ["onClick"];
    const _hoisted_11$2 = {
      class: "flex flex-row gap-1 justify-center mb-5",
      id: "js-render-buttons"
    };
    const _hoisted_12$2 = { key: 0 };
    const _hoisted_13$2 = {
      key: 0,
      class: "list-head"
    };
    const _hoisted_14$2 = {
      key: 1,
      class: "list-head"
    };
    const _hoisted_15$2 = {
      id: "render_image",
      class: "mt-3"
    };
    const _hoisted_16$2 = {
      key: 0,
      class: "flex flex-row justify-center gap-2"
    };
    const _hoisted_17$2 = ["innerHTML"];
    function _sfc_render$C(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_tooltip = resolveComponent("tooltip");
      return openBlock(), createElementBlock("div", null, [
        createBaseVNode("div", _hoisted_1$t, [
          createBaseVNode("div", _hoisted_2$n, [
            createBaseVNode("button", {
              type: "button",
              class: "btn-nav mb-1 mr-1",
              onClick: $setup.add_by_country
            }, toDisplayString($setup.stores.BaseStore.localization("imet-core::analysis_report.grouping.add_country")), 1),
            createBaseVNode("button", {
              type: "button",
              class: "btn-nav red mb-1 mr-1",
              onClick: $setup.reset
            }, toDisplayString($setup.stores.BaseStore.localization("imet-core::analysis_report.grouping.reset")), 1),
            $setup.data.list_of_components.length < $setup.data.list.length ? (openBlock(), createElementBlock("button", {
              key: 0,
              type: "button",
              onClick: _cache[0] || (_cache[0] = ($event) => $setup.add_group()),
              class: "btn-nav blue mb-1"
            }, [
              _cache[6] || (_cache[6] = createBaseVNode("i", {
                class: "fa fa-plus",
                "aria-hidden": "true"
              }, null, -1)),
              createTextVNode(" " + toDisplayString($setup.stores.BaseStore.localization("imet-core::analysis_report.grouping.add_group")), 1)
            ])) : createCommentVNode("", true)
          ])
        ]),
        createBaseVNode("div", {
          class: "start-zone flex flex-row gap-4",
          id: "start-zone",
          onDrop: _cache[1] || (_cache[1] = ($event) => $setup.on_drop($event, null)),
          onDragover: _cache[2] || (_cache[2] = withModifiers(() => {
          }, ["prevent"])),
          onDragenter: _cache[3] || (_cache[3] = withModifiers(() => {
          }, ["prevent"]))
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($setup.default_list, (item, index) => {
            return openBlock(), createElementBlock("div", {
              class: "default-zone-element",
              key: index
            }, [
              createVNode($setup["draggable_item"], {
                is_removable: false,
                item,
                item_class: "default-zone-element"
              }, null, 8, ["item"])
            ]);
          }), 128))
        ], 32),
        createBaseVNode("div", _hoisted_3$j, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($setup.data.list_of_components, (i2, index) => {
            return openBlock(), createElementBlock("div", {
              class: "ml-1",
              key: index
            }, [
              (openBlock(), createBlock($setup["drop_drag_area"], {
                onDragElement: $setup.start_drag,
                onRemoveElement: $setup.remove_from_list,
                onDropElement: $setup.on_drop,
                drop_id: i2.id,
                key: i2.id,
                color: i2.color
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", _hoisted_4$f, [
                    i2.input_visible ? (openBlock(), createElementBlock("span", _hoisted_5$e, [
                      createBaseVNode("input", {
                        type: "text",
                        id: "item-" + i2.id,
                        value: i2.name,
                        maxlength: "25",
                        size: "15"
                      }, null, 8, _hoisted_6$b)
                    ])) : createCommentVNode("", true),
                    !i2.input_visible ? (openBlock(), createElementBlock("span", _hoisted_7$8, toDisplayString(i2.name), 1)) : createCommentVNode("", true),
                    !i2.input_visible ? (openBlock(), createElementBlock("i", {
                      key: 2,
                      class: "fa fa-pen",
                      "aria-hidden": "true",
                      onClick: ($event) => $setup.edit_component_name(i2.id)
                    }, null, 8, _hoisted_8$5)) : createCommentVNode("", true),
                    i2.input_visible ? (openBlock(), createElementBlock("i", {
                      key: 3,
                      class: "fa fa-save",
                      "aria-hidden": "true",
                      onClick: ($event) => $setup.save_component_name(i2.id)
                    }, null, 8, _hoisted_9$4)) : createCommentVNode("", true),
                    createBaseVNode("i", {
                      class: "fa fa-trash",
                      "aria-hidden": "true",
                      onClick: ($event) => $setup.remove_component_from_list(i2.id)
                    }, null, 8, _hoisted_10$2)
                  ]),
                  (openBlock(true), createElementBlock(Fragment, null, renderList($setup.list_items(i2.id), (item, index2) => {
                    return openBlock(), createElementBlock("div", { key: index2 }, [
                      createVNode($setup["draggable_item"], { item }, null, 8, ["item"])
                    ]);
                  }), 128))
                ]),
                _: 2
              }, 1032, ["drop_id", "color"]))
            ]);
          }), 128))
        ]),
        createBaseVNode("div", _hoisted_11$2, [
          createBaseVNode("button", {
            type: "button",
            onClick: _cache[4] || (_cache[4] = ($event) => $setup.show_diagrams("radar")),
            class: "btn-nav"
          }, toDisplayString($setup.stores.BaseStore.localization("imet-core::analysis_report.grouping.render_radar")), 1),
          createBaseVNode("button", {
            type: "button",
            onClick: _cache[5] || (_cache[5] = ($event) => $setup.show_diagrams("scatter", { func: "get_scatter_grouping_analysis" })),
            class: "btn-nav"
          }, toDisplayString($setup.stores.BaseStore.localization("imet-core::analysis_report.grouping.render_scatter")), 1)
        ]),
        $setup.data.show_selected_legend ? (openBlock(), createElementBlock("div", _hoisted_12$2, [
          $setup.data.type === "scatter" ? (openBlock(), createElementBlock("div", _hoisted_13$2, [
            createTextVNode(toDisplayString($setup.stores.BaseStore.localization("imet-core::analysis_report.grouping.scatter_plot")) + " ", 1),
            _cache[7] || (_cache[7] = createBaseVNode("button", { class: "btn-nav small blue" }, [
              createBaseVNode("span", { class: "fas fa-fw fa-info-circle" })
            ], -1)),
            createVNode(_component_tooltip, null, {
              default: withCtx(() => [
                createTextVNode(toDisplayString($setup.stores.BaseStore.localization("imet-core::analysis_report.guidance.info.group_scatter")), 1)
              ]),
              _: 1
            })
          ])) : $setup.data.type === "radar" ? (openBlock(), createElementBlock("div", _hoisted_14$2, [
            createTextVNode(toDisplayString($setup.stores.BaseStore.localization("imet-core::analysis_report.grouping.radar")) + " ", 1),
            _cache[8] || (_cache[8] = createBaseVNode("button", { class: "btn-nav small blue" }, [
              createBaseVNode("span", { class: "fas fa-fw fa-info-circle" })
            ], -1)),
            createVNode(_component_tooltip, null, {
              default: withCtx(() => [
                createTextVNode(toDisplayString($setup.stores.BaseStore.localization("imet-core::analysis_report.guidance.info.group_radar")), 1)
              ]),
              _: 1
            })
          ])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_15$2, [
          $setup.data.show_selected_legend ? (openBlock(), createElementBlock("div", _hoisted_16$2, [
            (openBlock(true), createElementBlock(Fragment, null, renderList($setup.data.list_of_components, (i2, index) => {
              return openBlock(), createElementBlock("div", {
                class: "legend_radars",
                key: index
              }, [
                createBaseVNode("div", {
                  style: normalizeStyle("background-color:" + i2.color),
                  class: "text-center py-1 px-2 font-bold"
                }, toDisplayString(i2.name), 5),
                (openBlock(true), createElementBlock(Fragment, null, renderList($setup.list_items(i2.id), (item, index2) => {
                  return openBlock(), createElementBlock("div", {
                    class: "bg-white border border-gray-100 py-1 px-2",
                    key: index2,
                    innerHTML: item.name
                  }, null, 8, _hoisted_17$2);
                }), 128))
              ]);
            }), 128))
          ])) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, "default", { trigger_incoming_data: $setup.trigger_incoming_data }, void 0, true)
        ])
      ]);
    }
    const grouping = /* @__PURE__ */ _export_sfc(_sfc_main$C, [["render", _sfc_render$C], ["__scopeId", "data-v-d9cda725"], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/scaling_up_analysis/components/grouping.vue"]]);
    const _sfc_main$B = {
      __name: "text_editor",
      props: {
        value: { type: String, default: "" },
        save_data: { type: Boolean, default: false },
        event_id: { type: String, default: "save_comments" }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const props = __props;
        const emitter = inject("emitter");
        const ckeditor2 = CKEditor.component;
        const editor2 = ClassicEditor;
        const editorData = ref("");
        const editorConfig = {
          plugins: [
            Essentials,
            Paragraph,
            Undo,
            // mandatory plugins (seems not to work without them)
            Italic,
            Bold,
            Link,
            List,
            Heading
          ],
          toolbar: ["heading", "|", "bold", "italic", "link", "bulletedList"],
          heading: {
            options: [
              { model: "paragraph", title: "Paragraph", class: "ck-heading_paragraph" },
              { model: "heading2", view: "h2", title: "Heading", class: "ck-heading_heading2" }
            ]
          }
        };
        watch(() => props.value, (newValue) => {
          if (newValue !== editorData.value) {
            editorData.value = newValue;
          }
        });
        onMounted(() => {
          emitter.on("save_comments", (func2, attr) => {
            func2(editorData.value || "", attr);
          });
        });
        const onEditorInput = (value) => {
          editorData.value = value;
        };
        const __returned__ = { props, emitter, ckeditor: ckeditor2, editor: editor2, editorData, editorConfig, onEditorInput, ref, watch, inject, onMounted, get ClassicEditor() {
          return ClassicEditor;
        }, get Essentials() {
          return Essentials;
        }, get Paragraph() {
          return Paragraph;
        }, get Undo() {
          return Undo;
        }, get Bold() {
          return Bold;
        }, get Italic() {
          return Italic;
        }, get Link() {
          return Link;
        }, get List() {
          return List;
        }, get Heading() {
          return Heading;
        }, get CKEditor() {
          return CKEditor;
        } };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$s = { class: "text-editor-edit" };
    const _hoisted_2$m = ["innerHTML"];
    function _sfc_render$B(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", null, [
        createBaseVNode("div", _hoisted_1$s, [
          createVNode($setup["ckeditor"], {
            editor: $setup.editor,
            modelValue: $setup.editorData,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.editorData = $event),
            config: $setup.editorConfig,
            onInput: $setup.onEditorInput
          }, null, 8, ["editor", "modelValue"])
        ]),
        createBaseVNode("div", {
          class: "text-editor-print",
          innerHTML: $setup.editorData
        }, null, 8, _hoisted_2$m)
      ]);
    }
    const textEditor = /* @__PURE__ */ _export_sfc(_sfc_main$B, [["render", _sfc_render$B], ["__scopeId", "data-v-d5a03537"], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/scaling_up_analysis/components/text_editor.vue"]]);
    const _sfc_main$A = {
      __name: "map_view",
      props: {
        form_ids: {
          type: String,
          default: () => {
          }
        },
        url: {
          type: String,
          default: ""
        }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const stores = inject("stores");
        const props = __props;
        const no_internet_connection = ref(false);
        const error_message = ref("");
        onMounted(async () => {
          await loadMap();
        });
        const retrieveWdpaIDs = async () => {
          return fetch(props.url, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-CSRF-Token": window.Laravel.csrfToken
            },
            body: JSON.stringify({
              func: "get_wdpas_by_form_id",
              parameter: props.form_ids.split(","),
              scaling_id: stores.BaseStore.scaling_up_id
            })
          }).then((response) => response.json()).then((data) => Object.values(data).map((item) => item.wdpa_id)).catch((error) => {
            console.log(error);
            return null;
          });
        };
        const loadMap = async () => {
          const wdpa_ids = await retrieveWdpaIDs();
          if (wdpa_ids) {
            const report_map = new window.mapboxgl.Map({
              container: `map-load`,
              style: BiopamaWDPA.base_layer,
              center: [30, 0],
              zoom: 4,
              minZoom: 2,
              maxZoom: 12,
              preserveDrawingBuffer: true,
              attributionControl: false
            });
            report_map.on("error", (error) => {
              if (typeof error.isSourceLoaded === "undefined") {
                no_internet_connection.value = true;
                error_message.value = stores.BaseStore.localization("imet-core::analysis_report.error_connection");
              }
            });
            report_map.on("load", function() {
              BiopamaWDPA.addWdpaLayer(report_map, wdpa_ids, "rgba(255, 0, 0, 0.7)");
            });
          }
        };
        const __returned__ = { stores, props, no_internet_connection, error_message, retrieveWdpaIDs, loadMap, inject, ref, onMounted, get BiopamaWDPA() {
          return BiopamaWDPA;
        } };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$r = {
      id: "maps",
      class: "align-items-center"
    };
    const _hoisted_2$l = {
      key: 0,
      style: { "width": "100%", "height": "700px" }
    };
    const _hoisted_3$i = {
      key: 1,
      class: "dopa_not_available"
    };
    function _sfc_render$A(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", _hoisted_1$r, [
        !$setup.no_internet_connection ? (openBlock(), createElementBlock("div", _hoisted_2$l, _cache[0] || (_cache[0] = [
          createBaseVNode("div", {
            id: "map-load",
            class: "ml-3",
            style: { "width": "100%", "height": "650px" }
          }, null, -1)
        ]))) : (openBlock(), createElementBlock("div", _hoisted_3$i, toDisplayString($setup.error_message), 1))
      ]);
    }
    const mapView = /* @__PURE__ */ _export_sfc(_sfc_main$A, [["render", _sfc_render$A], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/scaling_up_analysis/components/map_view.vue"]]);
    class DBStorage {
      constructor() {
      }
      async ajax_request(url, params, method2 = "POST") {
        return fetch(url, {
          method: method2,
          headers: {
            "Content-Type": "application/json",
            "X-CSRF-Token": window.Laravel.csrfToken
          },
          body: JSON.stringify(params)
        }).then((response) => response.json()).then(function(data) {
          return data;
        }).catch(function(error) {
          console.log(error);
          return null;
        });
      }
      async save(value) {
        return await this.ajax_request(window.Routes.scaling_up_basket_add, { value });
      }
      async retrieve(id) {
        return await this.ajax_request(window.Routes.scaling_up_basket_get, { id });
      }
      async all(id) {
        return await this.ajax_request(window.Routes.scaling_up_basket_all, { id });
      }
      delete_item_child(key, id) {
        const children = JSON.parse(window.localStorage.getItem(key));
        const not_deleted_items = children.filter((child, key2) => key2 !== id);
        window.localStorage.setItem(key, JSON.stringify(not_deleted_items));
        return this.retrieve(key);
      }
      async delete(id) {
        return await this.ajax_request(window.Routes.scaling_up_basket_delete.replace("__id__", id), null, "DELETE");
      }
      async clear(id) {
        return await this.ajax_request(window.Routes.scaling_up_basket_clear, { id });
      }
    }
    const storage = new DBStorage();
    class BasketStore {
      constructor(args) {
        this.scaling_up_id = args.scaling_up_id;
        this.init();
      }
      init() {
      }
      async save(values2) {
        values2.scaling_up_id = this.scaling_up_id;
        return await storage.save(values2);
      }
      // delete_item(id){
      //     return storage.delete_item_child(id);
      // }
      delete(id) {
        return storage.delete(id);
      }
      retrieve(id) {
        return storage.retrieve(id);
      }
      retrieve_all() {
        return storage.all(this.scaling_up_id);
      }
      clear() {
        return storage.clear(this.scaling_up_id);
      }
      get_scaling_up_id() {
        return this.scaling_up_id;
      }
      get_local_storage_images_key() {
        return `basket`;
      }
    }
    const _sfc_main$z = {
      __name: "preview_template",
      props: {
        scaling_up_id: {
          type: [String, Number],
          default: ""
        }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const props = __props;
        const items = ref([]);
        const pixelsPage = ref(0);
        const images = ref([]);
        onMounted(async () => {
          await printElement();
        });
        watch(images.value, (val, oldVal) => {
          if (val.length === items.length) {
            isHeightEnough();
          }
        }, { deep: true });
        function imageLoaded(id) {
          images.value.push(id);
        }
        function isHeightEnough() {
          items.value.forEach((item, id) => {
            const img = document.getElementById(`${id}`);
            pixelsPage.value += img.height;
            if (pixelsPage.value > 1200 && pixelsPage.value < 1500) {
              const div = document.getElementById("image-content" + id);
              div.className = "content";
              pixelsPage.value = 0;
            } else if (pixelsPage.value > 1500) {
              const div = document.getElementById("image-content" + (id - 1));
              div.className = "content";
              pixelsPage.value = 0;
            }
          });
        }
        async function printElement() {
          const BasketStore$1 = new BasketStore({ scaling_up_id: props.scaling_up_id });
          const all = await BasketStore$1.retrieve_all();
          all.forEach((item) => {
            items.value.push("/" + item.item);
          });
        }
        const __returned__ = { props, items, pixelsPage, images, imageLoaded, isHeightEnough, printElement, ref, watch, onMounted, get basket_store() {
          return BasketStore;
        } };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$q = ["id"];
    const _hoisted_2$k = ["onLoad", "src", "id"];
    function _sfc_render$z(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", null, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($setup.items, (item, idx) => {
          return openBlock(), createElementBlock("div", {
            class: "img-fluid",
            id: "image-content" + idx,
            key: idx
          }, [
            createBaseVNode("div", null, [
              createBaseVNode("img", {
                onLoad: ($event) => $setup.imageLoaded(idx),
                src: item,
                id: idx
              }, null, 40, _hoisted_2$k)
            ])
          ], 8, _hoisted_1$q);
        }), 128))
      ]);
    }
    const previewTemplate = /* @__PURE__ */ _export_sfc(_sfc_main$z, [["render", _sfc_render$z], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/scaling_up_analysis/components/preview_template.vue"]]);
    function useAjax(component_data) {
      let event_parameters = {};
      let func_parameter = {};
      let url_parameter = {};
      let data = ref({});
      let loaded_once = ref(false);
      let error_returned = ref(false);
      let timeout = ref(false);
      let error_wrong = false;
      let is_loaded = true;
      const url = component_data.url || "";
      const parameters = component_data.parameters || "";
      const func2 = component_data.func || null;
      const method2 = component_data.method || "Post";
      const lazy_load_parameters = component_data.lazy_load_parameters || false;
      component_data.loaded_at_once || true;
      const stores = component_data.stores || null;
      const success_func = component_data.success || null;
      const error_func = component_data.error || null;
      async function init2() {
        if (loaded_once.value === false) {
          initialize_values();
          await load_procedure();
        }
      }
      function initialize_values() {
        event_parameters = !Array.isArray(parameters) ? parameters.split(",").filter((item) => item.trim() !== "") : parameters;
        func_parameter = func2;
        url_parameter = url;
      }
      async function on_event_load(parameters2 = {}) {
        event_parameters = parameters2.parameters ?? parameters2;
        func_parameter = parameters2.func ?? func2;
        url_parameter = parameters2.url ?? url;
        await retrieve_data();
      }
      async function load_procedure() {
        if (!func_parameter) {
          return null;
        }
        if (lazy_load_parameters) ;
        else {
          await retrieve_data();
        }
      }
      function parameters_man() {
        return event_parameters;
      }
      function conclude(response) {
        is_loaded = false;
        loaded_once.value = true;
      }
      async function retrieve_data() {
        is_loaded = true;
        error_wrong = false;
        const fetchOptions = {
          method: method2,
          headers: {
            "Content-Type": "application/json",
            "X-CSRF-Token": window.Laravel.csrfToken
          }
        };
        if (method2 !== "GET") {
          fetchOptions.body = JSON.stringify({
            func: func_parameter,
            parameter: parameters_man(),
            scaling_id: stores.BaseStore.get_scaling_up()
          });
        } else {
          url_parameter = url_parameter + "?func=" + func_parameter + "&parameter=" + parameters + "&scaling_id=" + stores.BaseStore.get_scaling_up();
        }
        fetch(url_parameter, fetchOptions).then((response) => response.json()).then(function(response) {
          data.value = response;
          conclude();
          success_func(response, false);
        }).catch(function(response) {
          error_func(response);
          conclude();
        });
        return data;
      }
      return {
        loaded_once,
        init: init2,
        is_loaded,
        data,
        error_returned,
        timeout,
        error_wrong,
        on_event_load,
        initialize_values
      };
    }
    const commonProps$1 = {
      loaded_at_once: {
        type: Boolean,
        default: false
      },
      url: {
        type: String,
        default: ""
      },
      method: {
        type: String,
        default: "POST"
      },
      parameters: {
        type: Array,
        default: []
      },
      func: {
        type: String,
        default: ""
      },
      show_menu: {
        type: Boolean,
        default: false
      },
      title: {
        type: String,
        default: ""
      }
    };
    const _sfc_main$y = {
      __name: "container",
      props: {
        ...commonProps$1,
        on_load: {
          type: Boolean,
          default: true
        },
        load_container: {
          type: Boolean,
          default: true
        },
        on_load_even: {
          type: String,
          default: null
        },
        trigger_incoming_data: {
          type: Object,
          default: null
        },
        randomKeyEvent: {
          type: String,
          default: ""
        }
      },
      setup(__props, { expose: __expose }) {
        var _a2;
        __expose();
        const show_loader = ref(false);
        const timeout = ref(false);
        const error_returned = ref(false);
        const error_wrong = ref(false);
        const data = ref([]);
        const props = __props;
        const stores = inject("stores");
        const emitter = inject("emitter");
        const component_data = {
          func: props.func,
          url: props.url,
          method: props.method,
          on_load: props.on_load,
          loaded_at_once: props.loaded_at_once,
          parameters: Array.isArray(props.parameters) ? (_a2 = props.parameters) == null ? void 0 : _a2.slice(0, -1) : props.parameters,
          stores,
          trigger_incoming_data: props.trigger_incoming_data,
          success,
          error
        };
        let { init: init2, on_event_load } = useAjax(component_data);
        watch(() => props.loaded_at_once, async (newVal) => {
          if (newVal) {
            show_loader.value = true;
            try {
              await init2();
            } catch (error2) {
              console.error(error2);
              show_loader.value = false;
            } finally {
            }
          }
        }, { deep: true });
        watch(() => props.trigger_incoming_data, async (newVal) => {
          if (newVal) {
            show_loader.value = true;
            try {
              await on_event_load(newVal);
            } catch (error2) {
              console.error(error2);
              show_loader.value = false;
            } finally {
            }
          }
        }, { deep: true });
        onMounted(async () => {
          if (props.loaded_at_once === true) {
            show_loader.value = true;
            try {
              await init2();
            } catch (error2) {
              console.error(error2);
              show_loader.value = false;
            } finally {
            }
          }
        });
        function success(response, loader = false) {
          show_loader.value = loader;
          if (response.status === false) {
            timeout.value = true;
            return;
          }
          if (typeof response === "object") {
            data.value = response.data;
            if (props.on_load_even !== null) {
              emitter.on("component_loaded");
            }
          } else {
            error_returned.value = true;
          }
        }
        function error(response) {
          show_loader.value = false;
          if (!response.response)
            error_wrong.value = true;
          else if (response.status === false) {
            timeout.value = true;
          } else if (response.code === "ECONNABORTED")
            timeout.value = true;
          else if (response.response.status === 500)
            error_wrong.value = true;
        }
        const __returned__ = { show_loader, timeout, error_returned, error_wrong, data, props, stores, emitter, component_data, get init() {
          return init2;
        }, set init(v2) {
          init2 = v2;
        }, get on_event_load() {
          return on_event_load;
        }, set on_event_load(v2) {
          on_event_load = v2;
        }, success, error, onMounted, watch, inject, ref, get useAjax() {
          return useAjax;
        }, get commonProps() {
          return commonProps$1;
        } };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$p = { key: 0 };
    const _hoisted_2$j = { key: 1 };
    const _hoisted_3$h = ["innerHTML"];
    const _hoisted_4$e = ["innerHTML"];
    const _hoisted_5$d = ["innerHTML"];
    const _hoisted_6$a = {
      key: 3,
      class: "container-menu"
    };
    function _sfc_render$y(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", null, [
        $setup.show_loader ? (openBlock(), createElementBlock("div", _hoisted_1$p, _cache[0] || (_cache[0] = [
          createBaseVNode("i", { class: "fa fa-spinner fa-spin text-primary-800" }, null, -1),
          createBaseVNode("span", { class: "sr-only" }, "Loading...", -1)
        ]))) : (openBlock(), createElementBlock("div", _hoisted_2$j, [
          $setup.error_returned ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "dopa_not_available",
            innerHTML: $setup.stores.BaseStore.localization("entities.dopa_not_available")
          }, null, 8, _hoisted_3$h)) : $setup.timeout ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: "dopa_not_available",
            innerHTML: $setup.stores.BaseStore.localization("entities.dopa_not_available")
          }, null, 8, _hoisted_4$e)) : $setup.error_wrong ? (openBlock(), createElementBlock("div", {
            key: 2,
            class: "dopa_not_available",
            innerHTML: $setup.stores.BaseStore.localization("imet-core::analysis_report.error_wrong")
          }, null, 8, _hoisted_5$d)) : (openBlock(), createElementBlock("div", _hoisted_6$a, [
            renderSlot(_ctx.$slots, "default", { props: $setup.data })
          ]))
        ]))
      ]);
    }
    const container = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["render", _sfc_render$y], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/scaling_up_analysis/components/containers/container.vue"]]);
    const _sfc_main$x = {
      __name: "container_view",
      props: {
        element: {
          type: String,
          default: ""
        },
        on_load: {
          type: Boolean,
          default: true
        },
        load_container: {
          type: Boolean,
          default: true
        },
        on_load_even: {
          type: String,
          default: null
        },
        show_menu: {
          type: Boolean,
          default: false
        },
        title: {
          type: String,
          default: ""
        },
        info_label: {
          type: String,
          default: ""
        },
        event_name: {
          type: String,
          default: ""
        }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const stores = inject("stores");
        const emitter = inject("emitter");
        const data = reactive({
          show_view: false,
          loaded_once: false,
          show_loader: false
        });
        const props = __props;
        onMounted(() => {
          emitter.on(props.event_name, () => {
            data.show_view = true;
          });
        });
        async function toggle_view() {
          data.show_view = !data.show_view;
        }
        const __returned__ = { stores, emitter, data, props, toggle_view, onMounted, inject, reactive };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$o = { id: "menu-header-header-main" };
    const _hoisted_2$i = { class: "list-head" };
    const _hoisted_3$g = { key: 0 };
    const _hoisted_4$d = { key: 1 };
    const _hoisted_5$c = ["innerHTML"];
    const _hoisted_6$9 = ["innerHTML"];
    const _hoisted_7$7 = ["innerHTML"];
    const _hoisted_8$4 = {
      key: 3,
      class: "container-menu"
    };
    function _sfc_render$x(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_guidance = resolveComponent("guidance");
      return openBlock(), createElementBlock("div", null, [
        createBaseVNode("div", {
          class: "",
          onClick: _cache[0] || (_cache[0] = ($event) => $setup.toggle_view())
        }, [
          createBaseVNode("div", _hoisted_1$o, [
            createBaseVNode("div", _hoisted_2$i, [
              createBaseVNode("span", {
                class: normalizeClass(["fas fa-fw", { "fa-plus": !$setup.data.show_view, "fa-minus": $setup.data.show_view }])
              }, null, 2),
              createTextVNode(" " + toDisplayString($props.title), 1)
            ])
          ])
        ]),
        withDirectives(createBaseVNode("div", null, [
          $setup.data.show_loader ? (openBlock(), createElementBlock("div", _hoisted_3$g, _cache[1] || (_cache[1] = [
            createBaseVNode("i", { class: "fa fa-spinner fa-spin fa-2x text-primary-800" }, null, -1),
            createBaseVNode("span", { class: "sr-only" }, "Loading...", -1)
          ]))) : (openBlock(), createElementBlock("div", _hoisted_4$d, [
            _ctx.error_returned ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "dopa_not_available",
              innerHTML: $setup.stores.BaseStore.localization("entities.dopa_not_available")
            }, null, 8, _hoisted_5$c)) : _ctx.timeout ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: "dopa_not_available",
              innerHTML: $setup.stores.BaseStore.localization("entities.dopa_not_available")
            }, null, 8, _hoisted_6$9)) : _ctx.error_wrong ? (openBlock(), createElementBlock("div", {
              key: 2,
              class: "dopa_not_available",
              innerHTML: $setup.stores.BaseStore.localization("imet-core::analysis_report.error_wrong")
            }, null, 8, _hoisted_7$7)) : (openBlock(), createElementBlock("div", _hoisted_8$4, [
              createVNode(_component_guidance, { label: $props.info_label }, null, 8, ["label"]),
              renderSlot(_ctx.$slots, "default", { props: $setup.data })
            ]))
          ]))
        ], 512), [
          [vShow, $setup.data.show_view]
        ])
      ]);
    }
    const containerView = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["render", _sfc_render$x], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/scaling_up_analysis/components/containers/container_view.vue"]]);
    const _sfc_main$w = {
      __name: "container_analysis_management_cycle",
      props: {
        ...commonProps$1,
        info_label: {
          type: String,
          default: ""
        },
        parent_class_name: {
          type: String,
          default: "list-key-numbers"
        },
        class_name: {
          type: String,
          default: "list-head"
        },
        items: {
          type: Object,
          default: null
        },
        type: {
          type: String,
          default: ""
        }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const props = __props;
        const stores = inject("stores");
        const emitter = inject("emitter");
        const show_loader = ref(false);
        const timeout = ref(false);
        const error_returned = ref(false);
        const error_wrong = ref(false);
        const data = reactive({
          values: {},
          show_view: false,
          loaded_once: false,
          parameters: [],
          randomKeyEvent: null
        });
        data.randomKeyEvent = Math.random().toString(36).substring(7);
        const component_data = {
          func: props.func,
          url: props.url,
          method: props.method,
          on_load: props.on_load,
          loaded_at_once: props.loaded_at_once,
          parameters: props.parameters,
          stores,
          success
        };
        let { on_event_load } = useAjax(component_data);
        onMounted(async () => {
          await init2();
        });
        async function init2() {
          emitter.on(`apply_filter_${data.randomKeyEvent}`, async (parameters) => {
            show_loader.value = true;
            const params = [...parameters.split(","), props.type];
            data.parameters = params;
            await on_event_load(data.parameters);
          });
        }
        function success(response, loader = false) {
          show_loader.value = loader;
          error_returned.value = false;
          if (response.status === false) {
            timeout.value = true;
            return;
          }
          if (typeof response === "object") {
            data.values = response.data;
          } else {
            error_returned.value = true;
          }
        }
        function toggle_view() {
          data.show_view = !data.show_view;
        }
        const __returned__ = { props, stores, emitter, show_loader, timeout, error_returned, error_wrong, data, component_data, get on_event_load() {
          return on_event_load;
        }, set on_event_load(v2) {
          on_event_load = v2;
        }, init: init2, success, toggle_view, ref, inject, reactive, onMounted, get useAjax() {
          return useAjax;
        }, get commonProps() {
          return commonProps$1;
        } };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$n = { class: "mb-2" };
    const _hoisted_2$h = { key: 0 };
    const _hoisted_3$f = { key: 1 };
    const _hoisted_4$c = ["innerHTML"];
    const _hoisted_5$b = ["innerHTML"];
    const _hoisted_6$8 = ["innerHTML"];
    const _hoisted_7$6 = {
      key: 3,
      class: "container-menu mt-3"
    };
    const _hoisted_8$3 = { class: "text-right mt-3" };
    const _hoisted_9$3 = ["innerHTML"];
    function _sfc_render$w(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_guidance = resolveComponent("guidance");
      const _component_checkboxes_list = resolveComponent("checkboxes_list");
      return openBlock(), createElementBlock("div", null, [
        createBaseVNode("div", {
          onClick: _cache[0] || (_cache[0] = ($event) => $setup.toggle_view())
        }, [
          createBaseVNode("div", {
            id: "menu-header-header-main",
            class: normalizeClass($props.parent_class_name + " horizontal")
          }, [
            createBaseVNode("div", {
              class: normalizeClass($props.class_name)
            }, [
              createBaseVNode("span", {
                class: normalizeClass(["fas fa-fw", { "fa-plus": !$setup.data.show_view, "fa-minus": $setup.data.show_view }])
              }, null, 2),
              createTextVNode(" " + toDisplayString(_ctx.title), 1)
            ], 2)
          ], 2)
        ]),
        withDirectives(createBaseVNode("div", _hoisted_1$n, [
          createVNode(_component_guidance, {
            label: $setup.props.info_label
          }, null, 8, ["label"]),
          createVNode(_component_checkboxes_list, {
            items: $props.items,
            event: `apply_filter_${$setup.data.randomKeyEvent}`,
            class: "p-2"
          }, null, 8, ["items", "event"]),
          $setup.show_loader ? (openBlock(), createElementBlock("div", _hoisted_2$h, _cache[2] || (_cache[2] = [
            createBaseVNode("i", { class: "fa fa-spinner fa-spin text-primary-800" }, null, -1),
            createBaseVNode("span", { class: "sr-only" }, "Loading...", -1)
          ]))) : (openBlock(), createElementBlock("div", _hoisted_3$f, [
            $setup.error_returned ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "dopa_not_available mt-3",
              innerHTML: $setup.stores.BaseStore.localization("entities.dopa_not_available")
            }, null, 8, _hoisted_4$c)) : $setup.timeout ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: "dopa_not_available mt-3",
              innerHTML: $setup.stores.BaseStore.localization("entities.dopa_not_available")
            }, null, 8, _hoisted_5$b)) : $setup.error_wrong ? (openBlock(), createElementBlock("div", {
              key: 2,
              class: "dopa_not_available mt-3",
              innerHTML: $setup.stores.BaseStore.localization("imet-core::analysis_report.error_wrong")
            }, null, 8, _hoisted_6$8)) : Object.entries($setup.data.values).length > 0 ? (openBlock(), createElementBlock("div", _hoisted_7$6, [
              renderSlot(_ctx.$slots, "default", { props: $setup.data })
            ])) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_8$3, [
              createBaseVNode("div", {
                class: "btn-nav red",
                onClick: _cache[1] || (_cache[1] = ($event) => $setup.toggle_view()),
                innerHTML: $setup.stores.BaseStore.localization("imet-core::analysis_report.close")
              }, null, 8, _hoisted_9$3)
            ])
          ]))
        ], 512), [
          [vShow, $setup.data.show_view]
        ])
      ]);
    }
    const containerAnalysisManagementCycle = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["render", _sfc_render$w], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/scaling_up_analysis/components/containers/container_analysis_management_cycle.vue"]]);
    const _sfc_main$v = {
      __name: "container_section",
      props: {
        name: {
          type: String,
          default: ""
        },
        title: {
          type: String,
          default: ""
        },
        code: {
          type: String,
          default: ""
        },
        info_label: {
          type: String,
          default: ""
        },
        event_name: {
          type: String,
          default: ""
        }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const stores = inject("stores");
        const config2 = inject("config");
        const emitter = inject("emitter");
        const props = __props;
        const data = ref({
          values: {},
          show_view: false,
          loaded_once: false,
          config: config2,
          stores
        });
        onMounted(() => {
          emitter.on(props.event_name, () => {
            data.value.show_view = true;
          });
        });
        function code_is_visible() {
          return props.code.length;
        }
        async function toggle_view() {
          data.value.show_view = !data.value.show_view;
        }
        function is_visible(values2) {
          return Object.keys(values2).length;
        }
        const __returned__ = { stores, config: config2, emitter, props, data, code_is_visible, toggle_view, is_visible, inject, onMounted, ref };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$m = ["id"];
    const _hoisted_2$g = { class: "module-header" };
    const _hoisted_3$e = {
      key: 0,
      class: "module-code text-center"
    };
    const _hoisted_4$b = { class: "module-body bg-white scaling_up_module_container_body" };
    const _hoisted_5$a = { class: "text-right mt-3" };
    const _hoisted_6$7 = ["innerHTML"];
    function _sfc_render$v(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_guidance = resolveComponent("guidance");
      return openBlock(), createElementBlock("div", {
        class: "module-container",
        id: $props.name
      }, [
        createBaseVNode("div", _hoisted_2$g, [
          $setup.code_is_visible() ? (openBlock(), createElementBlock("div", _hoisted_3$e, toDisplayString($props.code), 1)) : createCommentVNode("", true),
          createBaseVNode("div", {
            class: "module-title",
            onClick: _cache[0] || (_cache[0] = ($event) => $setup.toggle_view())
          }, [
            createBaseVNode("span", {
              class: normalizeClass(["fas fa-fw carrot", { "fa-caret-up": !$setup.data.show_view, "fa-caret-down": $setup.data.show_view }])
            }, null, 2),
            createTextVNode(" " + toDisplayString($props.title), 1)
          ])
        ]),
        withDirectives(createVNode(_component_guidance, {
          label: $setup.props.info_label
        }, null, 8, ["label"]), [
          [vShow, $setup.data.show_view]
        ]),
        withDirectives(createBaseVNode("div", _hoisted_4$b, [
          renderSlot(_ctx.$slots, "default", { props: $setup.data }),
          createBaseVNode("div", _hoisted_5$a, [
            createBaseVNode("div", {
              class: "btn-nav red",
              onClick: _cache[1] || (_cache[1] = ($event) => $setup.toggle_view()),
              innerHTML: $setup.stores.BaseStore.localization("imet-core::analysis_report.close")
            }, null, 8, _hoisted_6$7)
          ])
        ], 512), [
          [vShow, $setup.data.show_view]
        ])
      ], 8, _hoisted_1$m);
    }
    const containerSection = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["render", _sfc_render$v], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/scaling_up_analysis/components/containers/container_section.vue"]]);
    const _sfc_main$u = {
      __name: "container_upper_lower_radars",
      props: {
        width: {
          type: Number,
          default: 180
        },
        height: {
          type: Number,
          default: 180
        },
        indicators: {
          type: [Array, Object],
          default: () => {
          }
        },
        show_legends: {
          type: Boolean,
          default: false
        },
        single: {
          type: Boolean,
          default: true
        },
        showOnlyScaling: {
          type: Boolean,
          default: false
        },
        unselect_legends_on_load: {
          type: Boolean,
          default: false
        },
        radar: {
          type: [Array, Object],
          default: () => {
          }
        },
        refresh_average: {
          type: Boolean,
          default: false
        }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const props = __props;
        const values2 = ref([]);
        const data = ref({});
        const margin = ref("0px");
        const columns = [
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.protected_area.protected_area"),
            "field": "name"
          },
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.context"),
            "field": "context"
          },
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.planning"),
            "field": "planning"
          },
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.inputs"),
            "field": "inputs"
          },
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.process"),
            "field": "process"
          },
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.outputs"),
            "field": "outputs"
          },
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.outcomes"),
            "field": "outcomes"
          }
        ];
        onMounted(() => {
          const data2 = {
            "Average": props.radar["Average"],
            "lower limit": { ...props.radar["lower limit"] },
            "upper limit": { ...props.radar["upper limit"] }
          };
          const entries = Object.entries(props.radar);
          if (entries.length > 0) {
            props.margin = 22 * entries.length;
          }
          entries.forEach(([key, value]) => {
            if (!["Average", "lower limit", "upper limit"].includes(key)) {
              const item = { ...data2 };
              item[key] = value;
              values2.value.unshift(
                item
              );
            }
          });
        });
        const __returned__ = { props, values: values2, data, margin, columns, ref, onMounted, inject };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$l = ["id"];
    const _hoisted_2$f = ["id"];
    function _sfc_render$u(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_scaling_radar = resolveComponent("scaling_radar");
      const _component_datatable_interact_with_radar = resolveComponent("datatable_interact_with_radar");
      const _component_container_actions = resolveComponent("container_actions");
      return openBlock(), createElementBlock("div", {
        style: normalizeStyle("margin-top: -" + $setup.margin + "px")
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($setup.values, (radar, index) => {
          return openBlock(), createElementBlock("div", {
            id: "radar" + index,
            key: index
          }, [
            createVNode(_component_container_actions, {
              data: radar,
              name: "radar" + index,
              event_image: "save_entire_block_as_image"
            }, {
              default: withCtx((data_elements) => [
                createBaseVNode("div", {
                  class: "w-full",
                  id: "upper_lower_" + index
                }, [
                  (openBlock(), createBlock(_component_scaling_radar, {
                    class: "col-sm",
                    width: $props.width,
                    height: $props.height,
                    single: $props.single,
                    unselect_legends_on_load: $props.unselect_legends_on_load,
                    show_legends: $props.show_legends,
                    values: data_elements.props,
                    indicators: $props.indicators,
                    event_key: "up_" + index,
                    refresh_average: false,
                    key: "asd_" + index
                  }, null, 8, ["width", "height", "single", "unselect_legends_on_load", "show_legends", "values", "indicators", "event_key"]))
                ], 8, _hoisted_2$f),
                createVNode(_component_datatable_interact_with_radar, {
                  values_with_indicators_keys: true,
                  refresh_average: false,
                  values: data_elements.props,
                  columns: $setup.columns,
                  event_key: "up_" + index
                }, null, 8, ["values", "event_key"])
              ]),
              _: 2
            }, 1032, ["data", "name"])
          ], 8, _hoisted_1$l);
        }), 128))
      ], 4);
    }
    const containerUpperLowerRadars = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["render", _sfc_render$u], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/scaling_up_analysis/components/containers/container_upper_lower_radars.vue"]]);
    const WOFF = "application/font-woff";
    const JPEG = "image/jpeg";
    const mimes = {
      woff: WOFF,
      woff2: WOFF,
      ttf: "application/font-truetype",
      eot: "application/vnd.ms-fontobject",
      png: "image/png",
      jpg: JPEG,
      jpeg: JPEG,
      gif: "image/gif",
      tiff: "image/tiff",
      svg: "image/svg+xml",
      webp: "image/webp"
    };
    function getExtension(url) {
      const match = /\.([^./]*?)$/g.exec(url);
      return match ? match[1] : "";
    }
    function getMimeType(url) {
      const extension = getExtension(url).toLowerCase();
      return mimes[extension] || "";
    }
    function getContentFromDataUrl(dataURL) {
      return dataURL.split(/,/)[1];
    }
    function isDataUrl(url) {
      return url.search(/^(data:)/) !== -1;
    }
    function makeDataUrl(content, mimeType) {
      return `data:${mimeType};base64,${content}`;
    }
    async function fetchAsDataURL(url, init2, process2) {
      const res = await fetch(url, init2);
      if (res.status === 404) {
        throw new Error(`Resource "${res.url}" not found`);
      }
      const blob = await res.blob();
      return new Promise((resolve, reject2) => {
        const reader = new FileReader();
        reader.onerror = reject2;
        reader.onloadend = () => {
          try {
            resolve(process2({ res, result: reader.result }));
          } catch (error) {
            reject2(error);
          }
        };
        reader.readAsDataURL(blob);
      });
    }
    const cache = {};
    function getCacheKey(url, contentType, includeQueryParams) {
      let key = url.replace(/\?.*/, "");
      if (includeQueryParams) {
        key = url;
      }
      if (/ttf|otf|eot|woff2?/i.test(key)) {
        key = key.replace(/.*\//, "");
      }
      return contentType ? `[${contentType}]${key}` : key;
    }
    async function resourceToDataURL(resourceUrl, contentType, options) {
      const cacheKey = getCacheKey(resourceUrl, contentType, options.includeQueryParams);
      if (cache[cacheKey] != null) {
        return cache[cacheKey];
      }
      if (options.cacheBust) {
        resourceUrl += (/\?/.test(resourceUrl) ? "&" : "?") + (/* @__PURE__ */ new Date()).getTime();
      }
      let dataURL;
      try {
        const content = await fetchAsDataURL(resourceUrl, options.fetchRequestInit, ({ res, result: result2 }) => {
          if (!contentType) {
            contentType = res.headers.get("Content-Type") || "";
          }
          return getContentFromDataUrl(result2);
        });
        dataURL = makeDataUrl(content, contentType);
      } catch (error) {
        dataURL = options.imagePlaceholder || "";
        let msg = `Failed to fetch resource: ${resourceUrl}`;
        if (error) {
          msg = typeof error === "string" ? error : error.message;
        }
        if (msg) {
          console.warn(msg);
        }
      }
      cache[cacheKey] = dataURL;
      return dataURL;
    }
    function resolveUrl(url, baseUrl) {
      if (url.match(/^[a-z]+:\/\//i)) {
        return url;
      }
      if (url.match(/^\/\//)) {
        return window.location.protocol + url;
      }
      if (url.match(/^[a-z]+:/i)) {
        return url;
      }
      const doc = document.implementation.createHTMLDocument();
      const base = doc.createElement("base");
      const a2 = doc.createElement("a");
      doc.head.appendChild(base);
      doc.body.appendChild(a2);
      if (baseUrl) {
        base.href = baseUrl;
      }
      a2.href = url;
      return a2.href;
    }
    const uuid = /* @__PURE__ */ (() => {
      let counter = 0;
      const random2 = () => (
        // eslint-disable-next-line no-bitwise
        `0000${(Math.random() * 36 ** 4 << 0).toString(36)}`.slice(-4)
      );
      return () => {
        counter += 1;
        return `u${random2()}${counter}`;
      };
    })();
    function toArray(arrayLike) {
      const arr = [];
      for (let i2 = 0, l2 = arrayLike.length; i2 < l2; i2++) {
        arr.push(arrayLike[i2]);
      }
      return arr;
    }
    function px(node, styleProperty) {
      const win = node.ownerDocument.defaultView || window;
      const val = win.getComputedStyle(node).getPropertyValue(styleProperty);
      return val ? parseFloat(val.replace("px", "")) : 0;
    }
    function getNodeWidth(node) {
      const leftBorder = px(node, "border-left-width");
      const rightBorder = px(node, "border-right-width");
      return node.clientWidth + leftBorder + rightBorder;
    }
    function getNodeHeight(node) {
      const topBorder = px(node, "border-top-width");
      const bottomBorder = px(node, "border-bottom-width");
      return node.clientHeight + topBorder + bottomBorder;
    }
    function getImageSize(targetNode, options = {}) {
      const width = options.width || getNodeWidth(targetNode);
      const height = options.height || getNodeHeight(targetNode);
      return { width, height };
    }
    function getPixelRatio() {
      let ratio;
      let FINAL_PROCESS;
      try {
        FINAL_PROCESS = process;
      } catch (e2) {
      }
      const val = FINAL_PROCESS && FINAL_PROCESS.env ? FINAL_PROCESS.env.devicePixelRatio : null;
      if (val) {
        ratio = parseInt(val, 10);
        if (Number.isNaN(ratio)) {
          ratio = 1;
        }
      }
      return ratio || window.devicePixelRatio || 1;
    }
    const canvasDimensionLimit = 16384;
    function checkCanvasDimensions(canvas) {
      if (canvas.width > canvasDimensionLimit || canvas.height > canvasDimensionLimit) {
        if (canvas.width > canvasDimensionLimit && canvas.height > canvasDimensionLimit) {
          if (canvas.width > canvas.height) {
            canvas.height *= canvasDimensionLimit / canvas.width;
            canvas.width = canvasDimensionLimit;
          } else {
            canvas.width *= canvasDimensionLimit / canvas.height;
            canvas.height = canvasDimensionLimit;
          }
        } else if (canvas.width > canvasDimensionLimit) {
          canvas.height *= canvasDimensionLimit / canvas.width;
          canvas.width = canvasDimensionLimit;
        } else {
          canvas.width *= canvasDimensionLimit / canvas.height;
          canvas.height = canvasDimensionLimit;
        }
      }
    }
    function createImage(url) {
      return new Promise((resolve, reject2) => {
        const img = new Image();
        img.decode = () => resolve(img);
        img.onload = () => resolve(img);
        img.onerror = reject2;
        img.crossOrigin = "anonymous";
        img.decoding = "async";
        img.src = url;
      });
    }
    async function svgToDataURL(svg) {
      return Promise.resolve().then(() => new XMLSerializer().serializeToString(svg)).then(encodeURIComponent).then((html2) => `data:image/svg+xml;charset=utf-8,${html2}`);
    }
    async function nodeToDataURL(node, width, height) {
      const xmlns = "http://www.w3.org/2000/svg";
      const svg = document.createElementNS(xmlns, "svg");
      const foreignObject = document.createElementNS(xmlns, "foreignObject");
      svg.setAttribute("width", `${width}`);
      svg.setAttribute("height", `${height}`);
      svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
      foreignObject.setAttribute("width", "100%");
      foreignObject.setAttribute("height", "100%");
      foreignObject.setAttribute("x", "0");
      foreignObject.setAttribute("y", "0");
      foreignObject.setAttribute("externalResourcesRequired", "true");
      svg.appendChild(foreignObject);
      foreignObject.appendChild(node);
      return svgToDataURL(svg);
    }
    function formatCSSText(style) {
      const content = style.getPropertyValue("content");
      return `${style.cssText} content: '${content.replace(/'|"/g, "")}';`;
    }
    function formatCSSProperties(style) {
      return toArray(style).map((name) => {
        const value = style.getPropertyValue(name);
        const priority = style.getPropertyPriority(name);
        return `${name}: ${value}${priority ? " !important" : ""};`;
      }).join(" ");
    }
    function getPseudoElementStyle(className, pseudo, style) {
      const selector = `.${className}:${pseudo}`;
      const cssText = style.cssText ? formatCSSText(style) : formatCSSProperties(style);
      return document.createTextNode(`${selector}{${cssText}}`);
    }
    function clonePseudoElement(nativeNode, clonedNode, pseudo) {
      const style = window.getComputedStyle(nativeNode, pseudo);
      const content = style.getPropertyValue("content");
      if (content === "" || content === "none") {
        return;
      }
      const className = uuid();
      try {
        clonedNode.className = `${clonedNode.className} ${className}`;
      } catch (err) {
        return;
      }
      const styleElement = document.createElement("style");
      styleElement.appendChild(getPseudoElementStyle(className, pseudo, style));
      clonedNode.appendChild(styleElement);
    }
    function clonePseudoElements(nativeNode, clonedNode) {
      clonePseudoElement(nativeNode, clonedNode, ":before");
      clonePseudoElement(nativeNode, clonedNode, ":after");
    }
    async function cloneCanvasElement(canvas) {
      const dataURL = canvas.toDataURL();
      if (dataURL === "data:,") {
        return canvas.cloneNode(false);
      }
      return createImage(dataURL);
    }
    async function cloneVideoElement(video, options) {
      const poster = video.poster;
      const contentType = getMimeType(poster);
      const dataURL = await resourceToDataURL(poster, contentType, options);
      return createImage(dataURL);
    }
    async function cloneSingleNode(node, options) {
      if (node instanceof HTMLCanvasElement) {
        return cloneCanvasElement(node);
      }
      if (node instanceof HTMLVideoElement && node.poster) {
        return cloneVideoElement(node, options);
      }
      return node.cloneNode(false);
    }
    const isSlotElement = (node) => node.tagName != null && node.tagName.toUpperCase() === "SLOT";
    async function cloneChildren(nativeNode, clonedNode, options) {
      var _a2;
      const children = isSlotElement(nativeNode) && nativeNode.assignedNodes ? toArray(nativeNode.assignedNodes()) : toArray(((_a2 = nativeNode.shadowRoot) !== null && _a2 !== void 0 ? _a2 : nativeNode).childNodes);
      if (children.length === 0 || nativeNode instanceof HTMLVideoElement) {
        return clonedNode;
      }
      await children.reduce((deferred, child) => deferred.then(() => cloneNode(child, options)).then((clonedChild) => {
        if (clonedChild) {
          clonedNode.appendChild(clonedChild);
        }
      }), Promise.resolve());
      return clonedNode;
    }
    function cloneCSSStyle(nativeNode, clonedNode) {
      const targetStyle = clonedNode.style;
      if (!targetStyle) {
        return;
      }
      const sourceStyle = window.getComputedStyle(nativeNode);
      if (sourceStyle.cssText) {
        targetStyle.cssText = sourceStyle.cssText;
        targetStyle.transformOrigin = sourceStyle.transformOrigin;
      } else {
        toArray(sourceStyle).forEach((name) => {
          let value = sourceStyle.getPropertyValue(name);
          if (name === "font-size" && value.endsWith("px")) {
            const reducedFont = Math.floor(parseFloat(value.substring(0, value.length - 2))) - 0.1;
            value = `${reducedFont}px`;
          }
          targetStyle.setProperty(name, value, sourceStyle.getPropertyPriority(name));
        });
      }
    }
    function cloneInputValue(nativeNode, clonedNode) {
      if (nativeNode instanceof HTMLTextAreaElement) {
        clonedNode.innerHTML = nativeNode.value;
      }
      if (nativeNode instanceof HTMLInputElement) {
        clonedNode.setAttribute("value", nativeNode.value);
      }
    }
    function cloneSelectValue(nativeNode, clonedNode) {
      if (nativeNode instanceof HTMLSelectElement) {
        const clonedSelect = clonedNode;
        const selectedOption = Array.from(clonedSelect.children).find((child) => nativeNode.value === child.getAttribute("value"));
        if (selectedOption) {
          selectedOption.setAttribute("selected", "");
        }
      }
    }
    function decorate(nativeNode, clonedNode) {
      if (clonedNode instanceof Element) {
        cloneCSSStyle(nativeNode, clonedNode);
        clonePseudoElements(nativeNode, clonedNode);
        cloneInputValue(nativeNode, clonedNode);
        cloneSelectValue(nativeNode, clonedNode);
      }
      return clonedNode;
    }
    async function ensureSVGSymbols(clone2, options) {
      const uses = clone2.querySelectorAll ? clone2.querySelectorAll("use") : [];
      if (uses.length === 0) {
        return clone2;
      }
      const processedDefs = {};
      for (let i2 = 0; i2 < uses.length; i2++) {
        const use = uses[i2];
        const id = use.getAttribute("xlink:href");
        if (id) {
          const exist = clone2.querySelector(id);
          const definition = document.querySelector(id);
          if (!exist && definition && !processedDefs[id]) {
            processedDefs[id] = await cloneNode(definition, options, true);
          }
        }
      }
      const nodes = Object.values(processedDefs);
      if (nodes.length) {
        const ns = "http://www.w3.org/1999/xhtml";
        const svg = document.createElementNS(ns, "svg");
        svg.setAttribute("xmlns", ns);
        svg.style.position = "absolute";
        svg.style.width = "0";
        svg.style.height = "0";
        svg.style.overflow = "hidden";
        svg.style.display = "none";
        const defs = document.createElementNS(ns, "defs");
        svg.appendChild(defs);
        for (let i2 = 0; i2 < nodes.length; i2++) {
          defs.appendChild(nodes[i2]);
        }
        clone2.appendChild(svg);
      }
      return clone2;
    }
    async function cloneNode(node, options, isRoot) {
      if (!isRoot && options.filter && !options.filter(node)) {
        return null;
      }
      return Promise.resolve(node).then((clonedNode) => cloneSingleNode(clonedNode, options)).then((clonedNode) => cloneChildren(node, clonedNode, options)).then((clonedNode) => decorate(node, clonedNode)).then((clonedNode) => ensureSVGSymbols(clonedNode, options));
    }
    const URL_REGEX = /url\((['"]?)([^'"]+?)\1\)/g;
    const URL_WITH_FORMAT_REGEX = /url\([^)]+\)\s*format\((["']?)([^"']+)\1\)/g;
    const FONT_SRC_REGEX = /src:\s*(?:url\([^)]+\)\s*format\([^)]+\)[,;]\s*)+/g;
    function toRegex(url) {
      const escaped = url.replace(/([.*+?^${}()|\[\]\/\\])/g, "\\$1");
      return new RegExp(`(url\\(['"]?)(${escaped})(['"]?\\))`, "g");
    }
    function parseURLs(cssText) {
      const urls = [];
      cssText.replace(URL_REGEX, (raw, quotation, url) => {
        urls.push(url);
        return raw;
      });
      return urls.filter((url) => !isDataUrl(url));
    }
    async function embed(cssText, resourceURL, baseURL, options, getContentFromUrl) {
      try {
        const resolvedURL = baseURL ? resolveUrl(resourceURL, baseURL) : resourceURL;
        const contentType = getMimeType(resourceURL);
        let dataURL;
        if (getContentFromUrl) ;
        else {
          dataURL = await resourceToDataURL(resolvedURL, contentType, options);
        }
        return cssText.replace(toRegex(resourceURL), `$1${dataURL}$3`);
      } catch (error) {
      }
      return cssText;
    }
    function filterPreferredFontFormat(str, { preferredFontFormat }) {
      return !preferredFontFormat ? str : str.replace(FONT_SRC_REGEX, (match) => {
        while (true) {
          const [src, , format] = URL_WITH_FORMAT_REGEX.exec(match) || [];
          if (!format) {
            return "";
          }
          if (format === preferredFontFormat) {
            return `src: ${src};`;
          }
        }
      });
    }
    function shouldEmbed(url) {
      return url.search(URL_REGEX) !== -1;
    }
    async function embedResources(cssText, baseUrl, options) {
      if (!shouldEmbed(cssText)) {
        return cssText;
      }
      const filteredCSSText = filterPreferredFontFormat(cssText, options);
      const urls = parseURLs(filteredCSSText);
      return urls.reduce((deferred, url) => deferred.then((css) => embed(css, url, baseUrl, options)), Promise.resolve(filteredCSSText));
    }
    async function embedBackground(clonedNode, options) {
      var _a2;
      const background = (_a2 = clonedNode.style) === null || _a2 === void 0 ? void 0 : _a2.getPropertyValue("background");
      if (background) {
        const cssString = await embedResources(background, null, options);
        clonedNode.style.setProperty("background", cssString, clonedNode.style.getPropertyPriority("background"));
      }
    }
    async function embedImageNode(clonedNode, options) {
      if (!(clonedNode instanceof HTMLImageElement && !isDataUrl(clonedNode.src)) && !(clonedNode instanceof SVGImageElement && !isDataUrl(clonedNode.href.baseVal))) {
        return;
      }
      const url = clonedNode instanceof HTMLImageElement ? clonedNode.src : clonedNode.href.baseVal;
      const dataURL = await resourceToDataURL(url, getMimeType(url), options);
      await new Promise((resolve, reject2) => {
        clonedNode.onload = resolve;
        clonedNode.onerror = reject2;
        const image2 = clonedNode;
        if (image2.decode) {
          image2.decode = resolve;
        }
        if (clonedNode instanceof HTMLImageElement) {
          clonedNode.srcset = "";
          clonedNode.src = dataURL;
        } else {
          clonedNode.href.baseVal = dataURL;
        }
      });
    }
    async function embedChildren(clonedNode, options) {
      const children = toArray(clonedNode.childNodes);
      const deferreds = children.map((child) => embedImages(child, options));
      await Promise.all(deferreds).then(() => clonedNode);
    }
    async function embedImages(clonedNode, options) {
      if (clonedNode instanceof Element) {
        await embedBackground(clonedNode, options);
        await embedImageNode(clonedNode, options);
        await embedChildren(clonedNode, options);
      }
    }
    function applyStyle(node, options) {
      const { style } = node;
      if (options.backgroundColor) {
        style.backgroundColor = options.backgroundColor;
      }
      if (options.width) {
        style.width = `${options.width}px`;
      }
      if (options.height) {
        style.height = `${options.height}px`;
      }
      const manual = options.style;
      if (manual != null) {
        Object.keys(manual).forEach((key) => {
          style[key] = manual[key];
        });
      }
      return node;
    }
    const cssFetchCache = {};
    async function fetchCSS(url) {
      let cache2 = cssFetchCache[url];
      if (cache2 != null) {
        return cache2;
      }
      const res = await fetch(url);
      const cssText = await res.text();
      cache2 = { url, cssText };
      cssFetchCache[url] = cache2;
      return cache2;
    }
    async function embedFonts(data, options) {
      let cssText = data.cssText;
      const regexUrl = /url\(["']?([^"')]+)["']?\)/g;
      const fontLocs = cssText.match(/url\([^)]+\)/g) || [];
      const loadFonts = fontLocs.map(async (loc) => {
        let url = loc.replace(regexUrl, "$1");
        if (!url.startsWith("https://")) {
          url = new URL(url, data.url).href;
        }
        return fetchAsDataURL(url, options.fetchRequestInit, ({ result: result2 }) => {
          cssText = cssText.replace(loc, `url(${result2})`);
          return [loc, result2];
        });
      });
      return Promise.all(loadFonts).then(() => cssText);
    }
    function parseCSS(source) {
      if (source == null) {
        return [];
      }
      const result2 = [];
      const commentsRegex = /(\/\*[\s\S]*?\*\/)/gi;
      let cssText = source.replace(commentsRegex, "");
      const keyframesRegex = new RegExp("((@.*?keyframes [\\s\\S]*?){([\\s\\S]*?}\\s*?)})", "gi");
      while (true) {
        const matches2 = keyframesRegex.exec(cssText);
        if (matches2 === null) {
          break;
        }
        result2.push(matches2[0]);
      }
      cssText = cssText.replace(keyframesRegex, "");
      const importRegex = /@import[\s\S]*?url\([^)]*\)[\s\S]*?;/gi;
      const combinedCSSRegex = "((\\s*?(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*?@media[\\s\\S]*?){([\\s\\S]*?)}\\s*?})|(([\\s\\S]*?){([\\s\\S]*?)})";
      const unifiedRegex = new RegExp(combinedCSSRegex, "gi");
      while (true) {
        let matches2 = importRegex.exec(cssText);
        if (matches2 === null) {
          matches2 = unifiedRegex.exec(cssText);
          if (matches2 === null) {
            break;
          } else {
            importRegex.lastIndex = unifiedRegex.lastIndex;
          }
        } else {
          unifiedRegex.lastIndex = importRegex.lastIndex;
        }
        result2.push(matches2[0]);
      }
      return result2;
    }
    async function getCSSRules(styleSheets, options) {
      const ret = [];
      const deferreds = [];
      styleSheets.forEach((sheet) => {
        if ("cssRules" in sheet) {
          try {
            toArray(sheet.cssRules || []).forEach((item, index) => {
              if (item.type === CSSRule.IMPORT_RULE) {
                let importIndex = index + 1;
                const url = item.href;
                const deferred = fetchCSS(url).then((metadata) => embedFonts(metadata, options)).then((cssText) => parseCSS(cssText).forEach((rule) => {
                  try {
                    sheet.insertRule(rule, rule.startsWith("@import") ? importIndex += 1 : sheet.cssRules.length);
                  } catch (error) {
                    console.error("Error inserting rule from remote css", {
                      rule,
                      error
                    });
                  }
                })).catch((e2) => {
                  console.error("Error loading remote css", e2.toString());
                });
                deferreds.push(deferred);
              }
            });
          } catch (e2) {
            const inline2 = styleSheets.find((a2) => a2.href == null) || document.styleSheets[0];
            if (sheet.href != null) {
              deferreds.push(fetchCSS(sheet.href).then((metadata) => embedFonts(metadata, options)).then((cssText) => parseCSS(cssText).forEach((rule) => {
                inline2.insertRule(rule, sheet.cssRules.length);
              })).catch((err) => {
                console.error("Error loading remote stylesheet", err.toString());
              }));
            }
            console.error("Error inlining remote css file", e2.toString());
          }
        }
      });
      return Promise.all(deferreds).then(() => {
        styleSheets.forEach((sheet) => {
          if ("cssRules" in sheet) {
            try {
              toArray(sheet.cssRules || []).forEach((item) => {
                ret.push(item);
              });
            } catch (e2) {
              console.error(`Error while reading CSS rules from ${sheet.href}`, e2.toString());
            }
          }
        });
        return ret;
      });
    }
    function getWebFontRules(cssRules) {
      return cssRules.filter((rule) => rule.type === CSSRule.FONT_FACE_RULE).filter((rule) => shouldEmbed(rule.style.getPropertyValue("src")));
    }
    async function parseWebFontRules(node, options) {
      if (node.ownerDocument == null) {
        throw new Error("Provided element is not within a Document");
      }
      const styleSheets = toArray(node.ownerDocument.styleSheets);
      const cssRules = await getCSSRules(styleSheets, options);
      return getWebFontRules(cssRules);
    }
    async function getWebFontCSS(node, options) {
      const rules = await parseWebFontRules(node, options);
      const cssTexts = await Promise.all(rules.map((rule) => {
        const baseUrl = rule.parentStyleSheet ? rule.parentStyleSheet.href : null;
        return embedResources(rule.cssText, baseUrl, options);
      }));
      return cssTexts.join("\n");
    }
    async function embedWebFonts(clonedNode, options) {
      const cssText = options.fontEmbedCSS != null ? options.fontEmbedCSS : options.skipFonts ? null : await getWebFontCSS(clonedNode, options);
      if (cssText) {
        const styleNode = document.createElement("style");
        const sytleContent = document.createTextNode(cssText);
        styleNode.appendChild(sytleContent);
        if (clonedNode.firstChild) {
          clonedNode.insertBefore(styleNode, clonedNode.firstChild);
        } else {
          clonedNode.appendChild(styleNode);
        }
      }
    }
    async function toSvg(node, options = {}) {
      const { width, height } = getImageSize(node, options);
      const clonedNode = await cloneNode(node, options, true);
      await embedWebFonts(clonedNode, options);
      await embedImages(clonedNode, options);
      applyStyle(clonedNode, options);
      const datauri = await nodeToDataURL(clonedNode, width, height);
      return datauri;
    }
    async function toCanvas(node, options = {}) {
      const { width, height } = getImageSize(node, options);
      const svg = await toSvg(node, options);
      const img = await createImage(svg);
      const canvas = document.createElement("canvas");
      const context = canvas.getContext("2d");
      const ratio = options.pixelRatio || getPixelRatio();
      const canvasWidth = options.canvasWidth || width;
      const canvasHeight = options.canvasHeight || height;
      canvas.width = canvasWidth * ratio;
      canvas.height = canvasHeight * ratio;
      if (!options.skipAutoScale) {
        checkCanvasDimensions(canvas);
      }
      canvas.style.width = `${canvasWidth}`;
      canvas.style.height = `${canvasHeight}`;
      if (options.backgroundColor) {
        context.fillStyle = options.backgroundColor;
        context.fillRect(0, 0, canvas.width, canvas.height);
      }
      context.drawImage(img, 0, 0, canvas.width, canvas.height);
      return canvas;
    }
    async function toPng(node, options = {}) {
      const canvas = await toCanvas(node, options);
      return canvas.toDataURL();
    }
    function useHtmlToImage(props, emit) {
      const randomElement = ref("");
      function createRandomElement() {
        if (!props.element) {
          randomElement.value = `elem_${Math.floor(Math.random() * 1e3)}`;
        } else {
          randomElement.value = props.element;
        }
      }
      function showEditor(element) {
        const block2 = element.querySelectorAll(".text-editor-edit");
        block2.forEach((i2) => i2.style.display = "block");
        const none = element.querySelectorAll(".text-editor-print");
        none.forEach((i2) => i2.style.display = "none");
      }
      function hideEditor(element) {
        const block2 = element.querySelectorAll(".text-editor-edit");
        block2.forEach((i2) => i2.style.display = "none");
        const none = element.querySelectorAll(".text-editor-print");
        none.forEach((i2) => {
          if (i2.innerText.length > 0) {
            i2.style.display = "block";
          }
        });
      }
      async function htmlToImageFunc(func2, attr, size2 = 1024) {
        const element = document.getElementById(randomElement.value);
        element.classList.add("bg-white");
        showHideExcludedElements();
        hideEditor(element);
        toPng(element, {
          canvasWidth: element.clientWidth ?? size2,
          filter: (node) => {
            const classNames = node == null ? void 0 : node.className;
            node == null ? void 0 : node.id;
            if (typeof classNames !== "string") {
              return true;
            }
            const exclude = ["add_item", "carrot", "generic-comments", "exclude-element", "dropzone-areas", "js-smallMenu", "guidance"];
            return !exclude.some((val) => classNames.includes(val));
          }
        }).then(async function(dataUrl) {
          func2(dataUrl, attr);
        }).catch((error) => {
          console.error(error);
        }).finally(() => {
          showEditor(element);
          showHideExcludedElements("block");
        });
      }
      function showHideExcludedElements(action = "none") {
        if (props.exclude_elements.length > 0) {
          const excludeElements = props.exclude_elements.split(",");
          excludeElements.length > 0 && excludeElements.forEach((el) => {
            const element = document.getElementById(el);
            element.style.display = action;
          });
        }
      }
      onMounted(() => {
        createRandomElement();
        emit.on("save_entire_block_as_image" + props.event_id, async (values2) => {
          await htmlToImageFunc(values2.func, values2.attr);
        });
      });
      return {
        htmlToImageFunc
      };
    }
    const _sfc_main$t = {
      __name: "html_to_image",
      props: {
        element: {
          type: String,
          default: ""
        },
        exclude_elements: {
          type: String,
          default: null
        },
        event_id: {
          type: String,
          default: "save_image"
        }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const props = __props;
        const emitter = inject("emitter");
        const {
          htmlToImage
        } = useHtmlToImage(props, emitter);
        const __returned__ = { props, emitter, htmlToImage, inject, get useHtmlToImage() {
          return useHtmlToImage;
        } };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    function _sfc_render$t(_ctx, _cache, $props, $setup, $data, $options) {
      return null;
    }
    const html_to_image = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["render", _sfc_render$t], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/scaling_up_analysis/tools/html_to_image.vue"]]);
    const _sfc_main$s = {
      __name: "container_actions",
      props: {
        name: {
          type: String,
          default: ""
        },
        exclude_elements: {
          type: String,
          default: ""
        },
        event_image: {
          type: String,
          default: "save_image"
        },
        event_data: {
          type: String,
          default: "save_data"
        },
        comment_title: {
          type: String,
          default: null
        },
        data: {
          type: [Object, Array],
          default: () => {
          }
        },
        show_comments: {
          type: Boolean,
          default: true
        }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const stores = inject("stores");
        const emitter = inject("emitter");
        let get_data = ref(false);
        let loading = ref(false);
        let title = ref("");
        const uniqueEventId = Math.random().toString(36).substring(2, 15);
        let values2 = reactive({
          func: null,
          attr: null
        });
        const image_src = ref(null);
        const comment = ref(null);
        const props = __props;
        onMounted(() => {
          if (props.comment_title === null) {
            title.value = stores.BaseStore.localization("imet-core::analysis_report.comments");
          } else {
            title.value = props.comment_title;
          }
        });
        watch([image_src, comment], async ([newA, newB], [prevA, prevB]) => {
          if (newA && (props.show_comments && newB != null || !props.show_comments)) {
            const item = await stores.BasketStore.save({ image_src: newA, comment: newB });
            emitter.emit("add-section-template", item);
            resetRefs();
          }
        }, { immediate: true });
        function resetRefs() {
          image_src.value = null;
          loading.value = false;
        }
        function add2(val, attr) {
          if (attr === "image_src") {
            image_src.value = val;
          } else {
            comment.value = val;
          }
        }
        function save() {
          try {
            loading.value = true;
            values2 = {
              func: add2,
              attr: "image_src"
            };
            comment.value = "comments";
            if (props.event_image === "save_image") {
              emitter.emit("save_data" + uniqueEventId, values2);
            } else {
              emitter.emit("save_entire_block_as_image" + uniqueEventId, values2);
            }
          } catch (error) {
            console.error("Error occurred while emitting save_data event:", error);
            loading.value = false;
          }
          emitter.emit("save_comments" + uniqueEventId, add2, "comment");
        }
        const __returned__ = { stores, emitter, get get_data() {
          return get_data;
        }, set get_data(v2) {
          get_data = v2;
        }, get loading() {
          return loading;
        }, set loading(v2) {
          loading = v2;
        }, get title() {
          return title;
        }, set title(v2) {
          title = v2;
        }, uniqueEventId, get values() {
          return values2;
        }, set values(v2) {
          values2 = v2;
        }, image_src, comment, props, resetRefs, add: add2, save, html_to_image, onMounted, watch, inject, ref, reactive };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$k = ["id"];
    const _hoisted_2$e = { class: "mb-2 mt-1" };
    const _hoisted_3$d = { class: "mb-2 mt-2" };
    const _hoisted_4$a = {
      key: 0,
      class: "mt-3 text-black-50 font-bold generic-comments"
    };
    const _hoisted_5$9 = { class: "text-right" };
    const _hoisted_6$6 = { key: 0 };
    const _hoisted_7$5 = {
      key: 1,
      class: "text-center"
    };
    function _sfc_render$s(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_text_editor = resolveComponent("text_editor");
      return openBlock(), createElementBlock("div", { id: $props.name }, [
        createBaseVNode("div", _hoisted_2$e, [
          renderSlot(_ctx.$slots, "default", { props: $props.data })
        ]),
        createBaseVNode("div", _hoisted_3$d, [
          $props.show_comments ? (openBlock(), createElementBlock("div", _hoisted_4$a, toDisplayString($setup.title) + " :", 1)) : createCommentVNode("", true),
          $props.show_comments ? (openBlock(), createBlock(_component_text_editor, {
            key: 1,
            save_data: $setup.get_data,
            event_id: $props.event_data
          }, null, 8, ["save_data", "event_id"])) : createCommentVNode("", true),
          createVNode($setup["html_to_image"], {
            element: $props.name,
            exclude_elements: $props.exclude_elements,
            event_id: $setup.uniqueEventId
          }, null, 8, ["element", "exclude_elements", "event_id"]),
          createBaseVNode("div", _hoisted_5$9, [
            createBaseVNode("button", {
              type: "button",
              class: "btn-nav my-3 exclude-element",
              onClick: $setup.save
            }, [
              $setup.loading ? (openBlock(), createElementBlock("span", _hoisted_6$6, _cache[0] || (_cache[0] = [
                createBaseVNode("i", { class: "fa fa-spinner fa-spin text-primary-800" }, null, -1),
                createBaseVNode("span", { class: "sr-only" }, "Loading...", -1)
              ]))) : createCommentVNode("", true),
              !$setup.loading ? (openBlock(), createElementBlock("span", _hoisted_7$5, toDisplayString($setup.stores.BaseStore.localization("imet-core::analysis_report.add_analysis")), 1)) : createCommentVNode("", true)
            ])
          ])
        ])
      ], 8, _hoisted_1$k);
    }
    const containerActions = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["render", _sfc_render$s], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/scaling_up_analysis/components/containers/container_actions.vue"]]);
    function useList(component_data) {
      const sortBy2 = ref(component_data.sortBy || null);
      const sortDir = ref(component_data.sortDir || "asc");
      const initial2 = ref(component_data.initial || null);
      function sortList(items) {
        return sortBy2.value !== null ? sorter(items) : items;
      }
      function sort(sortByParam, sortDirParam = null) {
        if (sortByParam === sortBy2.value && sortDirParam === null) {
          sortDir.value = sortDir.value === "asc" ? "desc" : "asc";
        } else if (sortDir.value !== sortDirParam) {
          sortDir.value = sortDirParam;
        }
        sortBy2.value = sortByParam;
      }
      function sorter(data) {
        return data.sort(function(a2, b2) {
          let dir = sortDir.value === "asc" ? 1 : -1;
          let text_a = getAttribute(a2, sortBy2.value);
          let text_b = getAttribute(b2, sortBy2.value);
          if (typeof text_a !== "undefined" && typeof text_b !== "undefined") {
            if (typeof text_a === "string") {
              if (text_a.toString().toLowerCase() > text_b.toString().toLowerCase()) {
                return dir;
              }
              if (text_a.toString().toLowerCase() < text_b.toString().toLowerCase()) {
                return -1 * dir;
              }
            } else {
              if (parseInt(text_a, 10) > parseInt(text_b, 10)) {
                return dir;
              }
              if (parseInt(text_a, 10) < parseInt(text_b, 10)) {
                return -1 * dir;
              }
            }
          }
          return 0;
        });
      }
      function sort_icon(selectedItem = "") {
        if (sortBy2.value === selectedItem && sortDir.value === "asc") {
          return "fa fa-arrow-up";
        }
        if (sortBy2.value === selectedItem && ["desc", null].includes(sortDir.value)) {
          return "fa fa-arrow-down";
        }
        return "";
      }
      function filterList(items) {
        items = filterByInitial(items);
        return items;
      }
      function filterByInitial(items) {
        if (initial2.value !== null) {
          items = items.filter((item) => {
            if (item.name.charAt(0).toLowerCase() === initial2.value.toLowerCase()) {
              return true;
            }
          });
        }
        return items;
      }
      function filterByAttribute2(items, filter_value, filter_on) {
        filter_value = filter_value === "" || filter_value === "null" ? null : filter_value;
        if (filter_value !== null) {
          items = items.filter((item) => {
            let value = getAttribute(item, filter_on);
            if (value.toString().toLowerCase() === filter_value.toString().toLowerCase()) {
              return true;
            }
          });
        }
        return items;
      }
      function getAttribute(item, attribute) {
        let value = null;
        if (attribute.includes(".")) {
          let path = attribute.split(".");
          value = item;
          for (let i2 = 0; i2 < path.length; ++i2) {
            value = value.hasOwnProperty(path[i2]) ? value[path[i2]] : "";
          }
        } else {
          value = item[attribute];
        }
        value = value === null ? "" : value;
        return value;
      }
      function calculateAverage(items) {
        const notAverageItems = items.filter((item) => item["name"] !== "Average");
        const averageItem = items.find((item) => item["name"] === "Average");
        const averageItems = [];
        if (averageItem && notAverageItems.length > 0) {
          const averageObj = Object.keys(averageItem).reduce((obj, key) => {
            obj[key] = 0;
            averageItems[key] = 0;
            return obj;
          }, {});
          notAverageItems.map((o2, x2) => {
            const keys3 = Object.keys(o2);
            keys3.forEach((v2, k2) => {
              if (v2 !== "name") {
                if (o2[v2] !== "-") {
                  averageObj[v2] += o2[v2];
                  averageItems[v2]++;
                }
              } else {
                averageObj[v2] = "Average";
              }
            });
            return o2;
          });
          const keys2 = Object.keys(averageObj);
          keys2.forEach((v2, k2) => {
            if (v2 !== "name") {
              if (averageItems[v2] > 0) {
                averageObj[v2] = parseFloat((averageObj[v2] / averageItems[v2]).toFixed(1));
              } else {
                averageObj[v2] = "-";
              }
            }
          });
          notAverageItems.push(averageObj);
        }
        if (items.length === 1 && notAverageItems.length === 0) {
          return items;
        }
        return notAverageItems;
      }
      function get_value(value) {
        if (value === "-") {
          return "";
        }
        return value;
      }
      function itemLabel(value) {
        if (value === "Average") {
          value = "* " + value;
        }
        if (value === "-") {
          return "";
        }
        return value;
      }
      function score_class(value, additional_classes = "") {
        let addClass = "";
        if ([null, "-"].includes(value)) {
          addClass = "score_no";
        } else if (value <= -51) {
          addClass = "score_danger_alert";
        } else if (value < -33 && value > -51) {
          addClass = "score_danger_warning";
        } else if (value <= 0) {
          addClass = "score_danger";
        } else if (value > 0 && value < 34) {
          addClass = "score_alert";
        } else if (value < 51) {
          addClass = "score_warning";
        } else {
          addClass = "score_success";
        }
        return `${addClass} ${additional_classes}`;
      }
      function customization(values2, columns) {
        let items = [];
        Object.entries(values2).forEach(([key, value]) => {
          const object2 = {};
          columns.forEach((value2) => {
            if (value[value2.field] !== "undefined") {
              if (value2["type"] && value2["type"] === "percentage") {
                object2[value2.field] = percentage(value[value2.field], value2.color);
              } else if (value2["type"] && value2["type"] === "color") {
                object2[value2.field] = colorArea(value[value2.field]);
              } else if (value2["type"] && value2["type"] === "bg-color") {
                object2[value2.field] = colorArea(value["color"], value[value2.field]);
              } else if (value2["type"] && value2["type"] === "value_in_area_with_color") {
                object2[value2.field] = colorArea(value2.color, value[value2.field]);
              } else {
                object2[value2.field] = value[value2.field];
              }
            }
          });
          items.push(object2);
        });
        return items;
      }
      function percentage(value, color) {
        return `${value} <br/><div class="progress"><div class="progress-bar" style="width: ${value}%; background-color: ${color}"></div></div>`;
      }
      function colorArea(color, value = "") {
        return `<div class="p-3 mb-2 " style="background-color: ${color}">${value}</div>`;
      }
      function parse_data(selected2 = null, items, columns, values_with_indicators_keys) {
        const values2 = Object.entries({ ...items });
        const data = [];
        values2.forEach((value, idx) => {
          var _a2;
          if (selected2 !== null && selected2[value[0]] || selected2 === null && ((_a2 = value[1]) == null ? void 0 : _a2.legend_selected)) {
            const item = {};
            columns.forEach((column, idx2) => {
              if (!["color", "name"].includes(column["field"])) {
                if (values_with_indicators_keys) {
                  item[column["field"]] = value[1][column["field"]];
                } else {
                  item[column["field"]] = value[1][idx2 - 1];
                }
              }
            });
            data.push({
              name: value[0],
              ...item,
              color: value[1]["color"]
            });
          }
        });
        return data;
      }
      return {
        parse_data,
        sortList,
        filterByAttribute: filterByAttribute2,
        sort_icon,
        score_class,
        itemLabel,
        get_value,
        calculateAverage,
        customization,
        percentage,
        colorArea,
        filterList,
        sort
      };
    }
    const _sfc_main$r = {
      __name: "datatable_custom",
      props: {
        columns: {
          type: Array,
          default: () => []
        },
        values: {
          type: Array,
          default: () => []
        }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const props = __props;
        const list = ref([]);
        const { Locale: Locale2 } = window;
        const {
          filterList,
          sortList,
          sort_icon,
          customization,
          percentage,
          colorArea
        } = useList({});
        const items = computed(() => {
          let items2 = list.value;
          items2 = filterList(items2);
          items2 = sortList(items2);
          return items2;
        });
        onMounted(() => {
          list.value = customization(props.values, props.columns);
        });
        const __returned__ = { props, list, Locale: Locale2, filterList, sortList, sort_icon, customization, percentage, colorArea, items, ref, onMounted, computed, get useList() {
          return useList;
        } };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$j = { id: "global_scores" };
    const _hoisted_2$d = ["onClick"];
    const _hoisted_3$c = ["innerHTML"];
    function _sfc_render$r(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("table", _hoisted_1$j, [
        createBaseVNode("thead", null, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($props.columns, (column) => {
            return openBlock(), createElementBlock("th", {
              onClick: ($event) => _ctx.sort(column.field),
              key: column.field
            }, [
              createTextVNode(toDisplayString(column.label) + " ", 1),
              createBaseVNode("i", {
                class: normalizeClass($setup.sort_icon(column.field))
              }, null, 2)
            ], 8, _hoisted_2$d);
          }), 128))
        ]),
        createBaseVNode("tbody", null, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($setup.items, (value, index) => {
            return openBlock(), createElementBlock("tr", { key: index }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList($props.columns, (column) => {
                return openBlock(), createElementBlock("td", {
                  innerHTML: value[column.field],
                  key: column.field
                }, null, 8, _hoisted_3$c);
              }), 128))
            ]);
          }), 128))
        ])
      ]);
    }
    const datatableCustom = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["render", _sfc_render$r], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/scaling_up_analysis/components/datatables/datatable_custom.vue"]]);
    const _sfc_main$q = {
      __name: "datatable_interact_with_radar",
      props: {
        values: {
          type: [Array, Object],
          default: () => {
          }
        },
        columns: {
          type: Array,
          default: () => {
          }
        },
        event_key: {
          type: String,
          default: ""
        },
        values_with_indicators_keys: {
          type: Boolean,
          default: false
        },
        refresh_average: {
          type: Boolean,
          default: true
        },
        default_order: {
          type: String,
          default: null
        },
        default_order_dir: {
          type: String,
          default: "asc"
        }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const emitter = inject("emitter");
        const data = ref([]);
        const props = __props;
        const { parse_data } = useList({ sortBy: props.default_order });
        onMounted(() => {
          emitter.on(`radar_data_${props.event_key}`, (params) => {
            params.selected["lower limit"] = false;
            params.selected["upper limit"] = false;
            data.value = parse_data(params.selected, props.values, props.columns, props.values_with_indicators_keys);
          });
          data.value = parse_data(null, props.values, props.columns, props.values_with_indicators_keys);
        });
        const __returned__ = { emitter, data, props, parse_data, ref, onMounted, inject, get useList() {
          return useList;
        } };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$i = { key: 0 };
    function _sfc_render$q(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_datatable_scaling = resolveComponent("datatable_scaling");
      return $setup.data.length ? (openBlock(), createElementBlock("div", _hoisted_1$i, [
        (openBlock(), createBlock(_component_datatable_scaling, {
          columns: $props.columns,
          default_order: $props.default_order,
          refresh_average: $props.refresh_average,
          values: $setup.data,
          key: $setup.data.length
        }, null, 8, ["columns", "default_order", "refresh_average", "values"]))
      ])) : createCommentVNode("", true);
    }
    const datatableInteractWithRadar = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["render", _sfc_render$q], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/scaling_up_analysis/components/datatables/datatable_interact_with_radar.vue"]]);
    const _sfc_main$p = {
      __name: "datatable_interact_with_scatter",
      props: {
        values: {
          type: [Array, Object],
          default: () => {
          }
        },
        columns: {
          type: Array,
          default: () => {
          }
        },
        event_key: {
          type: String,
          default: ""
        },
        values_with_indicators_keys: {
          type: Boolean,
          default: false
        },
        refresh_average: {
          type: Boolean,
          default: true
        },
        default_order: {
          type: String,
          default: null
        },
        default_order_dir: {
          type: String,
          default: "asc"
        }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const emitter = inject("emitter");
        const data = ref([]);
        const props = __props;
        onMounted(() => {
          emitter.on(`scatter_data_${props.event_key}`, (params) => {
            parse_data(params.selected);
          });
          parse_data();
        });
        function parse_data(selected2 = null) {
          const values2 = Object.entries({ ...props.values });
          const items = [];
          values2.forEach((value, idx) => {
            if (selected2 === null || selected2[value[1].name]) {
              items.push({
                name: value[1]["name"],
                context: value[1]["value"][0],
                planning: value[1]["value"][1],
                inputs: value[1]["value"][2]
              });
            }
          });
          data.value = items;
        }
        const __returned__ = { emitter, data, props, parse_data, ref, onMounted, inject, get useList() {
          return useList;
        } };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$h = { key: 0 };
    function _sfc_render$p(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_datatable_scaling = resolveComponent("datatable_scaling");
      return $setup.data.length ? (openBlock(), createElementBlock("div", _hoisted_1$h, [
        (openBlock(), createBlock(_component_datatable_scaling, {
          columns: $props.columns,
          default_order: $props.default_order,
          refresh_average: $props.refresh_average,
          values: $setup.data,
          key: $setup.data.length
        }, null, 8, ["columns", "default_order", "refresh_average", "values"]))
      ])) : createCommentVNode("", true);
    }
    const datatableInteractWithScatter = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["render", _sfc_render$p], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/scaling_up_analysis/components/datatables/datatable_interact_with_scatter.vue"]]);
    const _sfc_main$o = {
      __name: "datatable_scaling",
      props: {
        columns: {
          type: Array,
          default: () => []
        },
        values: {
          type: Array,
          default: () => []
        },
        default_order: {
          type: String,
          default: null
        },
        default_order_dir: {
          type: String,
          default: "asc"
        },
        refresh_average: {
          type: Boolean,
          default: true
        }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const props = __props;
        const stores = inject("stores");
        const list = ref([]);
        const { Locale: Locale2 } = window;
        const average = ref([]);
        const {
          filterList,
          sortList,
          sort_icon,
          score_class,
          calculateAverage,
          get_value,
          sort
        } = useList({ sortBy: props.default_order, sortDir: props.default_order_dir });
        onMounted(() => {
          list.value = props.values;
        });
        const items = computed(() => {
          let items2 = [];
          if (list.value.length) {
            items2 = list.value;
            items2 = filterList(items2);
            if (props.refresh_average) {
              items2 = calculateAverage(items2);
            }
            items2 = sortList(items2);
          }
          return items2;
        });
        const __returned__ = { props, stores, list, Locale: Locale2, average, filterList, sortList, sort_icon, score_class, calculateAverage, get_value, sort, items, inject, onMounted, ref, computed, reactive, get useList() {
          return useList;
        } };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$g = { class: "mb-4" };
    const _hoisted_2$c = {
      key: 0,
      class: "mb-3 mt-1",
      style: { "font-size": "12px" }
    };
    const _hoisted_3$b = { class: "align-center" };
    const _hoisted_4$9 = { id: "global_scores" };
    const _hoisted_5$8 = ["onClick"];
    const _hoisted_6$5 = ["innerHTML"];
    const _hoisted_7$4 = ["innerHTML"];
    const _hoisted_8$2 = { class: "flex flex-row items-center text-sm" };
    const _hoisted_9$2 = { class: "text-right mr-4" };
    function _sfc_render$o(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", _hoisted_1$g, [
        $setup.average.length ? (openBlock(), createElementBlock("div", _hoisted_2$c, [
          createBaseVNode("div", _hoisted_3$b, toDisplayString($setup.stores.BaseStore.localization("imet-core::analysis_report.average_explained")), 1)
        ])) : createCommentVNode("", true),
        createBaseVNode("table", _hoisted_4$9, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($props.columns, (column, idx) => {
            return openBlock(), createElementBlock("th", {
              onClick: ($event) => $setup.sort(column.field),
              style: normalizeStyle(idx === 0 ? "width:15%;" : "width:11%;"),
              key: column.field
            }, [
              createTextVNode(toDisplayString(column.label.charAt(0).toUpperCase() + column.label.slice(1)) + " " + toDisplayString(column.extra_label) + " ", 1),
              createBaseVNode("i", {
                class: normalizeClass($setup.sort_icon(column.field))
              }, null, 2)
            ], 12, _hoisted_5$8);
          }), 128)),
          (openBlock(true), createElementBlock(Fragment, null, renderList($setup.items, (value, index) => {
            return openBlock(), createElementBlock("tr", { key: index }, [
              $setup.items[index]["name"] !== "Average" ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList($props.columns, (column, idx) => {
                return openBlock(), createElementBlock("td", {
                  innerHTML: $setup.get_value(value[column.field]),
                  class: normalizeClass(idx === 0 ? "" : $setup.score_class(value[column.field])),
                  key: column.field
                }, null, 10, _hoisted_6$5);
              }), 128)) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList($props.columns, (column) => {
                return openBlock(), createElementBlock("td", {
                  innerHTML: $setup.get_value(value[column.field]),
                  key: column.field
                }, null, 8, _hoisted_7$4);
              }), 128))
            ]);
          }), 128))
        ]),
        createBaseVNode("div", _hoisted_8$2, [
          createBaseVNode("div", _hoisted_9$2, toDisplayString($setup.stores.BaseStore.localization("imet-core::analysis_report.scaling_legend")) + " : ", 1),
          createBaseVNode("div", {
            class: normalizeClass(["text-center px-3 py-2", $setup.score_class(null)])
          }, toDisplayString($setup.stores.BaseStore.localization("imet-core::analysis_report.no_value").toLowerCase()), 3),
          createBaseVNode("div", {
            class: normalizeClass(["text-center px-3 py-2", $setup.score_class(-52)])
          }, " -100 " + toDisplayString($setup.stores.BaseStore.localization("imet-core::analysis_report.to").toLowerCase()) + " -51 ", 3),
          createBaseVNode("div", {
            class: normalizeClass(["text-center px-3 py-2", $setup.score_class(-35)])
          }, " -50 " + toDisplayString($setup.stores.BaseStore.localization("imet-core::analysis_report.to").toLowerCase()) + " -34 ", 3),
          createBaseVNode("div", {
            class: normalizeClass(["text-center px-3 py-2", $setup.score_class(-1)])
          }, " -33 " + toDisplayString($setup.stores.BaseStore.localization("imet-core::analysis_report.to").toLowerCase()) + " 0 ", 3),
          createBaseVNode("div", {
            class: normalizeClass(["text-center px-3 py-2", $setup.score_class(10)])
          }, "1 " + toDisplayString($setup.stores.BaseStore.localization("imet-core::analysis_report.to").toLowerCase()) + " 33 ", 3),
          createBaseVNode("div", {
            class: normalizeClass(["text-center px-3 py-2", $setup.score_class(34)])
          }, "34 " + toDisplayString($setup.stores.BaseStore.localization("imet-core::analysis_report.to").toLowerCase()) + " 50 ", 3),
          createBaseVNode("div", {
            class: normalizeClass(["text-center px-3 py-2", $setup.score_class(51)])
          }, "51 " + toDisplayString($setup.stores.BaseStore.localization("imet-core::analysis_report.to").toLowerCase()) + " 100 ", 3)
        ])
      ]);
    }
    const datatableScaling = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["render", _sfc_render$o], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/scaling_up_analysis/components/datatables/datatable_scaling.vue"]]);
    const _sfc_main$n = {
      __name: "bar_reverse",
      props: {
        ...common,
        ...commonProps$2
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const props = __props;
        const { has_zoom, field_name, get_colors } = useBar({
          fields: props.fields,
          colors: props.colors,
          zoom: props.zoom
        });
        const bar_options = computed(
          () => {
            return {
              legend: {
                show: true,
                padding: [30, 0, 0, 0]
              },
              colors: ["#5470C6"],
              title: {
                text: props.title,
                left: "center"
              },
              tooltip: {
                trigger: "axis",
                axisPointer: {
                  type: "shadow"
                }
              },
              xAxis: {
                type: "value",
                realtimeSort: true,
                minInterval: 1,
                max: 0,
                min: -100
              },
              yAxis: {
                position: "right",
                type: "category",
                data: field_name(),
                axisLabel: {
                  rotate: props.rotate,
                  interval: 0
                }
              },
              grid: {
                left: "3%",
                right: "4%",
                bottom: "3%",
                containLabel: true
              },
              series: [{
                data: props.values,
                label: {
                  show: true,
                  position: "left"
                },
                name: props.title_data,
                type: "bar"
              }],
              ...has_zoom()
            };
          }
        );
        const __returned__ = { props, has_zoom, field_name, get_colors, bar_options, get useBar() {
          return useBar;
        }, imet_bar_chart: imetBarChart, get commonProps() {
          return commonProps$2;
        }, get common() {
          return common;
        }, computed };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    function _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createBlock($setup["imet_bar_chart"], {
        title_data: _ctx.title_data,
        title: _ctx.title,
        values: _ctx.values,
        colors: _ctx.colors,
        fields: _ctx.fields,
        rotate: $setup.props.rotate,
        "computed-object": $setup.bar_options
      }, null, 8, ["title_data", "title", "values", "colors", "fields", "rotate", "computed-object"]);
    }
    const barReverse = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["render", _sfc_render$n], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/scaling_up_analysis/components/bar_charts/bar_reverse.vue"]]);
    const _sfc_main$m = {
      __name: "bar_category_stack",
      props: {
        ...common,
        label_position: {
          type: String,
          default: "top"
        },
        show_option_label: {
          type: Boolean,
          default: false
        },
        height: {
          type: String,
          default: "800px"
        },
        raw_values: {
          type: [Array, Object],
          default: () => {
          }
        },
        percent_values: {
          type: [Array, Object],
          default: () => {
          }
        },
        legends: {
          type: [Array, Object],
          default: () => {
          }
        },
        x_axis_data: {
          type: [Array, Object],
          default: () => {
          }
        },
        show_y_axis: {
          type: Boolean,
          default: true
        },
        grid: {
          type: Object,
          default: () => {
            return {
              "grid": {
                "left": "3%",
                "right": "4%",
                "bottom": "3%",
                "containLabel": true
              }
            };
          }
        }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const chart = ref(null);
        const height_value = ref(700);
        const data = ref([]);
        const emitter = inject("emitter");
        const props = __props;
        const { save_data, initResize } = useResize({
          emitter
        });
        watch(data, (newValue, oldValue) => {
          draw_chart();
        }, { deep: true });
        onMounted(() => {
          const legends = Object.values(props.legends).length;
          height_value.value = parseInt(props.height.replace("px", ""));
          if (legends > 7) {
            height_value.value += (legends - 7) * 4;
          }
          data.value = props.values;
          draw_chart();
        });
        const bar_options = computed(() => {
          props.grid.grid.containLabel = function() {
            return props.show_option_label;
          };
          const { raw_values, percent_values } = props;
          return {
            title: {
              text: props.title,
              left: "center",
              textStyle: {
                fontWeight: "normal"
              }
            },
            legend: {
              data: Object.values(Array.isArray(props.legends) ? props.legends[0] : props.legends),
              selectedMode: false,
              padding: [30, 0, 0, 0]
            },
            ...props.grid,
            tooltip: {
              trigger: "axis",
              axisPointer: {
                type: "shadow"
              },
              formatter: function(params) {
                let tooltip_text = `${params[0].axisValueLabel} <br/>`;
                if (raw_values) {
                  params.forEach(function(item) {
                    const value = item.value;
                    if (value == -99999999) {
                      tooltip_text += `${item.marker} ${item.seriesName} : -</div> <br/>`;
                    } else {
                      let percent = percent_values[item.seriesName][item.dataIndex];
                      let raw_value = raw_values[item.dataIndex][item.componentIndex];
                      if (percent == -99999999) {
                        percent = "-";
                        raw_value = "-";
                      } else {
                        percent = percent + "%";
                      }
                      tooltip_text += `${item.marker} ${item.seriesName} : ${raw_value} (${percent})</div> <br/>`;
                    }
                  });
                } else {
                  params.forEach(function(item) {
                    const value = item.value;
                    if (value == -99999999) {
                      tooltip_text += `${item.marker} ${item.seriesName} : - </div> <br/>`;
                    } else {
                      tooltip_text += `${item.marker} ${item.seriesName} : ${value}</div> <br/>`;
                    }
                  });
                }
                return tooltip_text;
              }
            },
            xAxis: {
              type: "category",
              data: props.x_axis_data,
              ...props.axis_dimensions_x,
              axisLabel: {
                interval: 0,
                rotate: 0,
                formatter: function(value, index) {
                  return value.replace(/ /g, "\n");
                }
              }
            },
            yAxis: {
              type: "value",
              ...props.axis_dimensions_y,
              show: props.show_y_axis,
              realtimeSort: true,
              minInterval: 1
            },
            series: series()
          };
        });
        function series() {
          const bars = [];
          Object.entries(props.values).forEach((value, idx) => {
            bars.push({
              color: props.colors[idx],
              name: value[0],
              type: "bar",
              stack: "total",
              label: {
                show: false,
                position: props.label_position
              },
              emphasis: {
                focus: "series"
              },
              data: value[1].map((item, idx2) => {
                if (item == -99999999) {
                  return 0;
                }
                return item;
              })
            });
          });
          bars.map((bar, index) => {
            if (props.show_option_label) {
              bar.label = {
                show: true,
                color: "#000"
              };
            } else if (index === bars.length - 1) {
              bar.label = {
                show: true,
                position: props.label_position,
                color: "#000",
                formatter: (param) => {
                  let sum2 = 0;
                  bars.forEach((item) => {
                    if (item.data[param.dataIndex] !== "-") {
                      sum2 += parseFloat(item.data[param.dataIndex]);
                    }
                  });
                  if (sum2 === 0) {
                    return sum2;
                  }
                  return sum2.toFixed(1);
                }
              };
            }
            return bar;
          });
          return bars;
        }
        function get_colors() {
          if (props.colors === null) {
            return {};
          }
          return { colors: props.colors };
        }
        function field_name() {
          return props.fields.map((field) => {
            return field.length > 10 ? field.split(" ").join("\n") : field;
          });
        }
        function draw_chart() {
          let echartObject = null;
          if (Object.keys(props.values).length > 0) {
            if (chart.value.clientWidth > 0 && chart.value.clientHeight > 0) {
              echartObject = init(chart.value);
              echartObject.setOption(bar_options.value);
              initResize(echartObject);
            }
          }
        }
        const __returned__ = { chart, height_value, data, emitter, props, save_data, initResize, bar_options, series, get_colors, field_name, draw_chart, ref, onMounted, nextTick, watch, inject, computed, get echarts() {
          return echarts;
        }, get common() {
          return common;
        }, get useResize() {
          return useResize;
        } };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        ref: "chart",
        class: "bar",
        style: normalizeStyle("width:" + _ctx.width + "; min-height: " + $setup.height_value + "px;")
      }, null, 4);
    }
    const barCategoryStack = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["render", _sfc_render$m], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/scaling_up_analysis/components/bar_charts/bar_category_stack.vue"]]);
    const _sfc_main$l = {
      __name: "imet_bar_error",
      props: {
        ...common,
        title: {
          type: String,
          default: ""
        },
        height: {
          type: String,
          default: "600px"
        },
        indicators: {
          type: Array,
          default: () => {
          }
        },
        indicators_color: {
          type: String,
          default: ""
        },
        show_legends: {
          type: Boolean,
          default: false
        },
        font_size: {
          type: Number,
          default: 13
        },
        options: {
          type: [Object, Array],
          default: () => {
          }
        },
        legends: {
          type: Array,
          default: () => {
          }
        },
        error_color: {
          type: String,
          default: "#C23531"
        },
        inverse_y: {
          type: Boolean,
          default: false
        },
        inverse_x: {
          type: Boolean,
          default: false
        }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const stores = inject("stores");
        const emitter = inject("emitter");
        const Locale2 = window.Locale;
        const gather_colors = ref([]);
        const chart_container = ref(null);
        const props = __props;
        const { save_data, handleResize } = useResize({
          emitter
        });
        const bar_options = computed(() => {
          {
            const { values: values2, error_data, legends, indicators } = getValues();
            return {
              title: {
                text: props.title,
                left: "center",
                textStyle: {
                  fontWeight: "normal"
                }
              },
              legend: {
                show: props.show_legends,
                data: props.legends,
                padding: [30, 0, 0, 0]
              },
              ...grid(),
              xAxis: { ...props.axis_dimensions_x, inverse: props.inverse_x },
              yAxis: {
                data: indicators,
                inverse: props.inverse_y,
                axisLabel: {
                  fontSize: props.font_size,
                  interval: 0,
                  width: 0,
                  rotate: 0,
                  formatter: function(value) {
                    if (value.length < 35) {
                      return value.split(" ").join("\n");
                    }
                    const max_size = 16;
                    const reg = new RegExp(`.{${max_size}}`, "g");
                    const pieces = value.match(reg);
                    const accumulated = pieces.length * max_size;
                    const modulo = value.length % accumulated;
                    if (modulo) pieces.push(value.slice(accumulated));
                    return pieces.join("\n");
                  }
                }
              },
              series: bar_item(values2, error_data)
            };
          }
        });
        onMounted(() => {
          if (Object.keys(props.values).length > 0) {
            draw_chart();
          }
        });
        function grid() {
          return {
            grid: {
              left: "3%",
              right: "4%",
              bottom: "3%",
              containLabel: true
            }
          };
        }
        function render_item(params, api) {
          let xValue = api.value(0);
          let highPoint = api.coord([api.value(1), xValue]);
          let lowPoint = api.coord([api.value(2), xValue]);
          let halfWidth = api.size([0, 1])[1] * 0.2;
          let style = api.style({
            stroke: api.visual("color"),
            fill: null
          });
          return {
            type: "group",
            toolbox: {
              show: true,
              feature: {
                saveAsImage: {
                  type: "png",
                  show: true
                },
                dataView: { readOnly: false },
                magicType: { type: ["line", "bar"] }
              }
            },
            children: [{
              type: "line",
              transition: ["shape"],
              shape: {
                x1: highPoint[0],
                y1: highPoint[1] - halfWidth,
                x2: highPoint[0],
                y2: highPoint[1] + halfWidth
              },
              style
            }, {
              type: "line",
              transition: ["shape"],
              shape: {
                x1: highPoint[0],
                y1: highPoint[1],
                x2: lowPoint[0],
                y2: lowPoint[1]
              },
              style
            }, {
              type: "line",
              transition: ["shape"],
              shape: {
                x1: lowPoint[0],
                y1: lowPoint[1] - halfWidth,
                x2: lowPoint[0],
                y2: lowPoint[1] + halfWidth
              },
              style
            }]
          };
        }
        function setIndicators() {
          var _a2;
          if (!((_a2 = props.indicators) == null ? void 0 : _a2.length)) {
            return [];
          }
          if (props.values.Average) {
            return props.values.Average.map((value, key) => {
              return value["indicator"];
            });
          }
          return props.values.map((value, key) => {
            return value["indicator"];
          });
        }
        function colors(colors2) {
          return colors2;
        }
        function getValues(data = props.values) {
          let values2 = [];
          let indicators = [];
          let legends = [];
          let error_data = [];
          indicators = setIndicators();
          Object.entries(data).reverse().forEach(([key, value]) => {
            var _a2;
            const name = key.replace(" ", "\n");
            if (!((_a2 = props.indicators) == null ? void 0 : _a2.length)) {
              indicators.push(name);
            }
            if (key === "Average") {
              values2 = value.map((i2, k2) => {
                gather_colors.value[i2["itemStyle"]["color"]] = i2["itemStyle"]["color"];
                return { "value": i2["value"], "itemStyle": { "color": i2["itemStyle"]["color"] } };
              });
              error_data = value.map((i2, k2) => [k2, ...i2["upper limit"]]);
            }
          });
          return { values: values2, error_data, legends, indicators };
        }
        function line_style(value, color = null) {
          return {
            lineStyle: {
              type: value,
              color
            }
          };
        }
        function bar_item(bar_data, error_data) {
          const color = bar_data[0].itemStyle.color;
          return [
            {
              type: "bar",
              name: props.legends[0],
              data: bar_data.map((data) => {
                return { value: data.value, itemStyle: { color: data.itemStyle.color }, label: { color: "#000000" } };
              }),
              itemStyle: {
                color
              },
              label: {
                show: true,
                position: "inside",
                fontSize: 14
              }
            },
            {
              type: "custom",
              name: props.legends[1],
              itemStyle: {
                normal: {
                  borderWidth: 1.5,
                  color: props.error_color
                }
              },
              renderItem: render_item,
              encode: {
                x: [1, 2],
                y: 0
              },
              label: {
                show: false
              },
              data: error_data,
              z: 100
            }
          ];
        }
        function draw_chart() {
          let echartObject = null;
          if (Object.keys(props.values).length > 0) {
            if (chart_container.value.clientWidth > 0 && chart_container.value.clientHeight > 0) {
              echartObject = init(chart_container.value);
              echartObject.setOption(bar_options.value);
              save_data();
              window.addEventListener("resize", () => handleResize(echartObject));
            }
          }
        }
        const __returned__ = { stores, emitter, Locale: Locale2, gather_colors, chart_container, props, save_data, handleResize, bar_options, grid, render_item, setIndicators, colors, getValues, line_style, bar_item, draw_chart, ref, inject, onMounted, computed, get echarts() {
          return echarts;
        }, get useResize() {
          return useResize;
        }, get common() {
          return common;
        } };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        ref: "chart_container",
        class: "imet_bar_error",
        style: normalizeStyle("width:100%; height: " + $props.height + ";")
      }, null, 4);
    }
    const imetBarError = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["render", _sfc_render$l], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/scaling_up_analysis/components/bar_charts/imet_bar_error.vue"]]);
    function useRadar(component_data) {
      const always_first_in_legend = component_data.always_first_in_legend;
      const radar_indicators_for_negative = component_data.radar_indicators_for_negative;
      const radar_indicators_for_zero_negative = component_data.radar_indicators_for_zero_negative;
      const show_legends = component_data.show_legends;
      const showOnlyScaling = component_data.showOnlyScaling;
      const items = component_data.values;
      const indicators = component_data.indicators;
      const setIndicatorsFunction = component_data.setIndicatorsFunction ?? setIndicators;
      const legend_selected = component_data.legend_selected || [];
      const chart = component_data.chart || ref(null);
      function createItemsForScalingNumbers() {
        const render_items = [];
        if (showOnlyScaling) {
          const indi_length = indicators.length;
          indicators.forEach((i2, k2) => {
            const item = radar_item();
            item.value = new Array(indi_length).fill(0);
            item.value[0] = 20 * k2;
            item.lineStyle.color = "rgba(255, 255, 255, 0)";
            render_items.push(item);
          });
        }
        return render_items;
      }
      function radar_item() {
        return {
          value: [],
          name: "",
          itemStyle: {
            color: null
          },
          lineStyle: {
            type: "solid",
            color: null
          },
          label: {
            normal: {
              fontWeight: "bold",
              color: "#222",
              show: true
            }
          }
        };
      }
      function multipleData() {
        let indi = [];
        let legends2 = [];
        const render_items = [];
        const calculatedValues = items;
        if (show_legends) {
          legends2 = setLegends(calculatedValues);
        }
        const values2 = JSON.parse(JSON.stringify(calculatedValues));
        Object.entries(values2).forEach((data, key) => {
          const item = radar_item();
          const name = data.shift();
          item.name = name;
          Object.entries(data).forEach(([key2, value]) => {
            if (value === Object(value)) {
              if (showOnlyScaling) {
                item.label.normal.show = value.label_show ?? true;
              }
              item.symbolSize = 0;
              item.lineStyle.type = value == null ? void 0 : value.lineStyle;
              item.lineStyle.width = value == null ? void 0 : value.width;
              item.lineStyle.color = value == null ? void 0 : value.color;
              item.itemStyle.color = value == null ? void 0 : value.color;
              if (value.legend_selected) {
                legend_selected.push(name);
              }
              item.tooltip = {
                trigger: "item"
              };
              delete value["lineStyle"];
              delete value["color"];
              delete value["width"];
              delete value["wdpa_id"];
              delete value["legend_selected"];
              indi = Object.values(value);
            }
            find_if_array_has_negative_values(indi);
            item.value = indi;
          });
          render_items.push(item);
        });
        indi = setIndicatorsFunction();
        render_items.push(...createItemsForScalingNumbers());
        render_items.map((item) => {
          if (item.tooltip) {
            item.tooltip.formatter = (params, ticket) => {
              var _a2;
              let html2 = "";
              html2 = params.data.name + "<br/>";
              for (const val in params.data.value) {
                if (indi[val] !== void 0) {
                  html2 += ((_a2 = indi[val]) == null ? void 0 : _a2.text) + " : " + params.value[val] + "<br/>";
                }
              }
              return html2;
            };
          }
          return item;
        });
        return { render_items, legends: legends2, indicators: indi };
      }
      function setLegends(values2 = {}) {
        const legends_items = [];
        if (!values2) {
          values2 = items;
        }
        Object.entries(values2).reverse().forEach(([key, value]) => {
          legends_items.push({ name: key });
        });
        let on_top = [];
        if (always_first_in_legend.length) {
          on_top = legends_items.slice(0, 3);
        }
        return legends([...on_top, ...legends_items.sort((a2, b2) => a2.name.localeCompare(b2.name))]);
      }
      function singleData() {
        const render_items = [];
        const item = radar_item();
        const indi = [];
        let legends2 = [];
        Object.entries(items).reverse().forEach((data, key) => {
          indi.push({ text: data[0].replace(" ", "\n"), max: 100 });
          item.value.push(data[1]);
        });
        render_items.push(item);
        return { render_items, legends: legends2, indi };
      }
      function find_if_array_has_negative_values(array2) {
        return array2.findIndex((value) => value !== "-" ? value < 0 : false);
      }
      function legends(legends2 = null) {
        if (!legends2) {
          return null;
        }
        return {
          legend: {
            formatter: function(name) {
              if (name === "Average") {
                return `* ${name}`;
              }
              return name;
            },
            data: legends2,
            padding: [35, 5, 10, 5]
          }
        };
      }
      function setIndicators() {
        if (!(indicators == null ? void 0 : indicators.length)) {
          return [];
        }
        return indicators.map((value, key) => {
          const item = {
            text: value.replace(" ", "\n"),
            max: 100
          };
          if (radar_indicators_for_negative.includes(key)) {
            item.max = 100;
            item.min = -100;
            item.text += ` 
 ${window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.scale.negative_positive")} `;
          }
          if (radar_indicators_for_zero_negative.includes(key)) {
            item.max = 0;
            item.min = -100;
            item.text += ` 
 ${window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.scale.zero_negative")}`;
          }
          return item;
        });
      }
      function unselect_all_legends(legends2, chartScaling) {
        legends2.forEach((legend) => {
          if (!legend_selected.includes(legend.name)) {
            chartScaling.dispatchAction({
              type: "legendUnSelect",
              name: legend.name
            });
          }
        });
      }
      function calculateAverage(list_items, legends2, values2) {
        var _a2;
        let average = (_a2 = list_items.find((item) => item.name === "Average")) == null ? void 0 : _a2.value.map((v2) => 0);
        const averageItems = [...average ?? []];
        if (average) {
          list_items.forEach((item, index) => {
            if (!["Average", "upper limit", "lower limit"].includes(item["name"]) && legends2.selected[item["name"]] === true) {
              item["value"].forEach((val, i2) => {
                if (val !== "-") {
                  averageItems[i2]++;
                  average[i2] += val;
                }
              });
            }
          });
          average == null ? void 0 : average.forEach((value, index) => {
            if (averageItems[index] > 0) {
              average[index] = parseFloat((average[index] / averageItems[index]).toFixed(1));
            } else {
              average[index] = "-";
            }
          });
          if (average == null ? void 0 : average.every((i2) => i2 === "-")) {
            if (values2 && values2["Average"]) {
              average = values2["Average"];
              delete average["color"];
              delete average["legend_selected"];
            }
          }
          list_items.map((item) => {
            if (item["name"] === "Average") {
              item["value"] = Object.values(average);
            }
            return item;
          });
        }
        return list_items;
      }
      return { chart, singleData, multipleData, unselect_all_legends, calculateAverage };
    }
    const commonProps = {
      title: {
        type: String,
        default: ""
      },
      width: {
        type: Number,
        default: 180
      },
      height: {
        type: Number,
        default: 180
      },
      values: {
        type: Object,
        default: () => {
        }
      },
      indicators: {
        type: [Array, Object],
        default: () => {
        }
      },
      show_legends: {
        type: Boolean,
        default: false
      },
      single: {
        type: Boolean,
        default: true
      },
      showOnlyScaling: {
        type: Boolean,
        default: false
      },
      unselect_legends_on_load: {
        type: Boolean,
        default: false
      },
      radar_indicators_for_negative: {
        type: Array,
        default: () => {
          return [];
        }
      },
      radar_indicators_for_zero_negative: {
        type: Array,
        default: () => {
          return [];
        }
      },
      always_first_in_legend: {
        type: Array,
        default: () => {
          return [0, 1, 2];
        }
      },
      refresh_average: {
        type: Boolean,
        default: true
      },
      event_key: {
        type: String,
        default: ""
      }
    };
    const _sfc_main$k = {
      __name: "scaling_radar",
      props: {
        ...commonProps
      },
      emits: ["incoming-data"],
      setup(__props, { expose: __expose, emit: __emit }) {
        __expose();
        const chartCont = ref(null);
        const emitter = inject("emitter");
        const default_colors = ["#5470c6", "#91cc75", "#fac858", "#ee6666", "#73c0de", "#3ba272", "#fc8452", "#9a60b4", "#ea7ccc"];
        const legend_selected = ref([]);
        const props = __props;
        const obj = useRadar({ ...props, chart: chartCont });
        const { singleData, multipleData, unselect_all_legends, calculateAverage } = obj;
        const { initResize } = useResize({
          emitter
        });
        const emit = __emit;
        onMounted(() => {
          draw_chart();
        });
        const radar_options = computed(() => {
          let items = {};
          if (props.single) {
            items = singleData();
          } else {
            items = multipleData();
          }
          return {
            title: {
              text: props.title,
              left: "center",
              textStyle: {
                fontWeight: "normal"
              }
            },
            color: default_colors,
            tooltip: {
              trigger: "axis"
            },
            ...items.legends,
            grid: {
              left: "10%",
              right: "0%",
              bottom: "3%",
              width: "80%",
              height: "82%",
              top: 30,
              "containLabel": true
            },
            radar: {
              indicator: items.indicators,
              radius: "70%",
              startAngle: 90,
              axisLabel: {
                show: true,
                align: "right"
              },
              name: {
                lineHeight: 18,
                textStyle: {
                  color: "#111",
                  padding: [0, 0]
                }
              }
            },
            series: [{
              name: "",
              type: "radar",
              data: items.render_items
            }]
          };
        });
        function draw_chart() {
          var _a2, _b2;
          if (Object.entries(props.values).length > 0) {
            if (obj.chart.value.clientWidth > 0 && obj.chart.value.clientHeight > 0) {
              const chartScaling = init(obj.chart.value);
              chartScaling.setOption(radar_options.value);
              chartScaling.on("legendselectchanged", (params) => {
                if (props.refresh_average) {
                  radar_options.value.series[0].data = calculateAverage(radar_options.value.series[0].data, params);
                  chartScaling.setOption(radar_options.value);
                }
                emitter.emit(`radar_data_${props.event_key}`, params);
              });
              initResize(chartScaling);
              if (props.unselect_legends_on_load) {
                unselect_all_legends((_b2 = (_a2 = radar_options.value) == null ? void 0 : _a2.legend) == null ? void 0 : _b2.data, chartScaling);
              }
            }
          }
        }
        const __returned__ = { chartCont, emitter, default_colors, legend_selected, props, obj, singleData, multipleData, unselect_all_legends, calculateAverage, initResize, emit, radar_options, draw_chart, ref, onMounted, nextTick, inject, computed, get echarts() {
          return echarts;
        }, get useRadar() {
          return useRadar;
        }, get useResize() {
          return useResize;
        }, get commonProps() {
          return commonProps;
        } };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        ref: "chartCont",
        class: "imet_radar",
        style: normalizeStyle("width:100%; min-height: " + _ctx.height + "px;")
      }, null, 4);
    }
    const scalingRadar = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["render", _sfc_render$k], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/scaling_up_analysis/components/various_charts/scaling_radar.vue"]]);
    const _sfc_main$j = {
      __name: "treemap",
      props: {
        width: {
          type: String,
          default: "100%"
        },
        height: {
          type: String,
          default: "500px"
        },
        values: {
          type: [Array, Object],
          default: () => {
          }
        },
        title: {
          type: String,
          default: ""
        }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const emitter = inject("emitter");
        const chartContainer = ref(null);
        const props = __props;
        const bar_options = computed(() => {
          return {
            title: {
              text: props.title,
              left: "center"
            },
            series: [{
              type: "treemap",
              data: data_fix()
            }]
          };
        });
        const { initResize } = useResize({
          emitter
        });
        onMounted(() => {
          draw_chart();
        });
        function data_fix() {
          return props.values.map((item) => {
            return { name: item.label, value: item.area, itemStyle: { color: item.color } };
          });
        }
        function draw_chart() {
          if (Object.keys(props.values).length > 0) {
            if (chartContainer.value.clientWidth > 0 && chartContainer.value.clientHeight > 0) {
              let echartObject = init(chartContainer.value);
              echartObject.setOption(bar_options.value);
              initResize(echartObject);
            }
          }
        }
        const __returned__ = { emitter, chartContainer, props, bar_options, initResize, data_fix, draw_chart, ref, onMounted, computed, inject, get echarts() {
          return echarts;
        }, get useResize() {
          return useResize;
        } };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        ref: "chartContainer",
        class: "treemap",
        style: normalizeStyle("width:" + $props.width + "; height: " + $props.height + ";")
      }, null, 4);
    }
    const treemap = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["render", _sfc_render$j], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/scaling_up_analysis/components/various_charts/treemap.vue"]]);
    const _sfc_main$i = {
      __name: "chart_bar",
      props: {
        title: {
          type: String,
          default: null
        },
        indicators: {
          type: Array,
          default: () => []
        },
        api_data: {
          type: Object,
          default: () => null
        }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const props = __props;
        const barRef = ref(null);
        const defaultOptions = {
          tooltip: {
            trigger: "axis",
            axisPointer: {
              type: "line",
              lineStyle: {
                opacity: 0.5
              }
            }
          },
          grid: {
            left: "3%",
            right: "3%",
            bottom: "2%",
            top: "2%",
            containLabel: true
          },
          xAxis: [
            {
              type: "category",
              data: []
            }
          ],
          yAxis: [
            {
              type: "value"
            }
          ]
        };
        const setOptions = () => {
          let options = { ...defaultOptions };
          if (props.title != null) {
            options.title = {
              text: props.title,
              left: "center"
            };
            options.grid.top = "12%";
          }
          options.color = [];
          options.legend = {
            data: [],
            top: "bottom"
          };
          options.grid.bottom = "12%";
          props.indicators.forEach((item) => {
            options.color.push(item.color);
            options.legend.data.push(item.label);
          });
          options.xAxis[0].data = [];
          let data = readData();
          options.series = props.indicators.map((_2, index) => ({
            type: "bar",
            name: _2.label,
            data: data[index]
          }));
          return options;
        };
        const readData = () => {
          return props.indicators.map((item) => [props.api_data[item.field]]);
        };
        const drawChart = () => {
          if (props.api_data !== null) {
            let options = setOptions();
            let canvas_container = barRef.value;
            init(canvas_container).setOption(options);
          }
        };
        watch(() => props.api_data, drawChart);
        onMounted(() => {
          if (props.api_data !== null) {
            drawChart();
          }
        });
        const __returned__ = { props, barRef, defaultOptions, setOptions, readData, drawChart, ref, watch, onMounted, get echarts() {
          return echarts;
        } };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$f = {
      ref: "barRef",
      class: "bar"
    };
    function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", null, [
        createBaseVNode("div", _hoisted_1$f, null, 512)
      ]);
    }
    const dopa_chart_bar = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["render", _sfc_render$i], ["__scopeId", "data-v-ce31dc5d"], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/templates/dopa/chart_bar.vue"]]);
    const _sfc_main$h = {
      __name: "chart_doughnut",
      props: {
        title: {
          type: String,
          default: null
        },
        indicators: {
          type: Array,
          default: () => []
        },
        api_data: {
          type: Object,
          default: () => null
        }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const props = __props;
        const chartContainer = ref(null);
        const defaultOptions = {
          tooltip: {
            trigger: "item",
            formatter: "{b}<br />{c} ({d}%)"
          },
          series: [
            {
              type: "pie",
              radius: ["60%", "80%"],
              center: "50%",
              data: [],
              itemStyle: {
                emphasis: {
                  shadowBlur: 10,
                  shadowOffsetX: 0,
                  shadowColor: "rgba(0, 0, 0, 0.5)"
                }
              }
            }
          ]
        };
        const setOptions = () => {
          let options = { ...defaultOptions };
          if (props.title !== null) {
            options.title = {
              textStyle: { fontSize: 12 },
              text: props.title,
              left: "center"
            };
            options.series[0].center = ["50%", "55%"];
          }
          options.series[0].data = [];
          options.color = [];
          props.indicators.forEach((item) => {
            var _a2;
            options.color.push(item.color);
            options.series[0].data.push({
              value: ((_a2 = props.api_data[item.field]) == null ? void 0 : _a2.toFixed(1)) ?? 0,
              name: item.label
            });
          });
          return options;
        };
        const drawChart = () => {
          const options = setOptions();
          const canvas_container = chartContainer.value;
          init(canvas_container).setOption(options);
        };
        watch(() => props.api_data, (value) => {
          if (value !== null) {
            drawChart();
          }
        });
        onMounted(() => {
          if (props.api_data !== null) {
            drawChart();
          }
        });
        const __returned__ = { props, chartContainer, defaultOptions, setOptions, drawChart, ref, watch, onMounted, get echarts() {
          return echarts;
        } };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$e = {
      ref: "chartContainer",
      class: "doughnut"
    };
    function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", null, [
        createBaseVNode("div", _hoisted_1$e, null, 512)
      ]);
    }
    const scalingDopaChartDoughnut = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["render", _sfc_render$h], ["__scopeId", "data-v-7aa99828"], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/templates/dopa/chart_doughnut.vue"]]);
    const _sfc_main$g = {
      __name: "scatter",
      props: {
        title: {
          type: String,
          default: ""
        },
        width: {
          type: String,
          default: "100%"
        },
        label_axis_x: {
          type: String,
          default: ""
        },
        label_axis_y: {
          type: String,
          default: ""
        },
        label_axis_y2: {
          type: String,
          default: ""
        },
        label_axis_y2_show: {
          type: Boolean,
          default: false
        },
        height: {
          type: String,
          default: "800px"
        },
        values: {
          type: [Array, Object],
          default: () => {
          }
        },
        event_key: {
          type: String,
          default: ""
        },
        scatter_dimension_names: {
          type: Array,
          default: () => {
          }
        }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const emitter = inject("emitter");
        const chartContainer = ref(null);
        const props = __props;
        const { initResize } = useResize({
          emitter
        });
        onMounted(() => {
          draw_chart();
        });
        const bar_options = computed(() => {
          return {
            color: [
              ...get_colors()
            ],
            grid: {
              left: "10%",
              right: "0%",
              bottom: "3%",
              width: "80%",
              height: "85%"
            },
            title: {
              text: props.title,
              left: "center",
              textStyle: {
                fontWeight: "normal"
              }
            },
            legend: {
              ...get_legends(),
              padding: [35, 5, 10, 5]
            },
            tooltip: {
              trigger: "item",
              axisPointer: {
                type: "shadow"
              }
            },
            xAxis: {
              splitLine: { show: true },
              nameLocation: "middle",
              name: props.label_axis_x,
              min: 0,
              max: 100,
              nameGap: -30
            },
            yAxis: [{
              splitLine: { show: true },
              scale: true,
              nameLocation: "middle",
              name: props.label_axis_y,
              min: 0,
              max: 100,
              nameGap: -30
            }, {
              splitLine: { show: false },
              scale: true,
              min: 0,
              max: 100,
              show: true,
              name: props.label_axis_y2_show ? props.label_axis_y2 : "",
              nameLocation: "middle",
              nameGap: -30
            }],
            ...series()
          };
        });
        function draw_chart() {
          if (Object.keys(props.values).length > 0) {
            if (chartContainer.value.clientWidth > 0 && chartContainer.value.clientHeight > 0) {
              let echartObject = init(chartContainer.value);
              echartObject.setOption(bar_options.value);
              echartObject.on("legendselectchanged", (params) => {
                emitter.emit(`scatter_data_${props.event_key}`, params);
              });
              initResize(echartObject);
            }
          }
        }
        function get_colors() {
          return props.values.map((i2) => i2.itemStyle.borderColor);
        }
        function get_legends() {
          const legends = [];
          props.values.forEach((dato) => {
            legends.push({ "name": dato.name });
          });
          return {
            data: legends.sort((a2, b2) => {
              return a2.name > b2.name ? 1 : -1;
            })
          };
        }
        function series() {
          const items = [];
          props.values.forEach((record, idx) => {
            items.push({
              tooltip: {
                show: true,
                formatter(params) {
                  return `<b>${params.name}</b><br/><b>${props.label_axis_y}</b>: ${params.value[1]}<br/><b>${props.label_axis_x}</b>: ${params.value[0]}<br/><b>${props.label_axis_y2}</b>: ${params.value[2]}`;
                }
              },
              data: [record],
              type: "scatter",
              name: record["name"],
              symbol: "rect",
              symbolSize: function(data) {
                if (data[2] <= 33) {
                  return 25;
                } else if (data[2] <= 50) {
                  return 35;
                } else if (data[2] <= 65) {
                  return 45;
                } else if (data[2] <= 90) {
                  return 60;
                } else if (data[2] <= 100) {
                  return 70;
                }
              },
              emphasis: {
                focus: "self"
              },
              label: {
                show: true,
                formatter: function(param) {
                  return "";
                }
              }
            });
          });
          return { series: items };
        }
        const __returned__ = { emitter, chartContainer, props, initResize, bar_options, draw_chart, get_colors, get_legends, series, ref, onMounted, computed, inject, get echarts() {
          return echarts;
        }, get useResize() {
          return useResize;
        } };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        ref: "chartContainer",
        class: "scatter",
        style: normalizeStyle("width:" + $props.width + "; height: " + $props.height + ";")
      }, null, 4);
    }
    const scatter = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", _sfc_render$g], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/scaling_up_analysis/components/various_charts/scatter.vue"]]);
    const _sfc_main$f = {
      __name: "radar_threats",
      props: {
        ...commonProps
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const default_colors = ["#5470c6", "#91cc75", "#fac858", "#ee6666", "#73c0de", "#3ba272", "#fc8452", "#9a60b4", "#ea7ccc"];
        const chartCont = ref(null);
        function setIndicators() {
          var _a2;
          if (!((_a2 = props.indicators) == null ? void 0 : _a2.length)) {
            return [];
          }
          return props.indicators.map((value, key) => {
            return { text: value.replace(" ", "\n"), max: 0, min: -100 };
          });
        }
        const emitter = inject("emitter");
        const props = __props;
        const obj = useRadar({ ...props, chart: chartCont, setIndicatorsFunction: setIndicators });
        const { singleData, multipleData, unselect_all_legends, calculateAverage } = obj;
        const { initResize } = useResize({
          emitter
        });
        onMounted(() => {
          draw_chart();
        });
        const radar_options = computed(() => {
          let items = {};
          if (props.single) {
            items = singleData();
          } else {
            items = multipleData();
          }
          return {
            title: {
              text: props.title,
              left: "center",
              textStyle: {
                fontWeight: "normal"
              }
            },
            color: default_colors,
            tooltip: {
              trigger: "axis"
            },
            ...items.legends,
            grid: {
              left: "10%",
              right: "0%",
              bottom: "3%",
              width: "80%",
              height: "82%",
              top: 30,
              "containLabel": true
            },
            radar: {
              indicator: items.indicators,
              radius: "70%",
              startAngle: 60,
              axisLabel: {
                show: true,
                align: "right"
              },
              name: {
                lineHeight: 18,
                textStyle: {
                  color: "#111",
                  padding: [0, 0]
                }
              }
            },
            series: [{
              name: "",
              type: "radar",
              data: items.render_items
            }]
          };
        });
        function draw_chart() {
          var _a2, _b2;
          if (Object.keys(props.values).length > 0) {
            if (chartCont.value.clientWidth > 0 && chartCont.value.clientHeight > 0) {
              let echartObject = null;
              echartObject = init(chartCont.value);
              echartObject.setOption(radar_options.value);
              initResize(echartObject);
              if (props.unselect_legends_on_load) {
                unselect_all_legends((_b2 = (_a2 = radar_options.value) == null ? void 0 : _a2.legend) == null ? void 0 : _b2.data, echartObject);
              }
            }
          }
        }
        const __returned__ = { default_colors, chartCont, setIndicators, emitter, props, obj, singleData, multipleData, unselect_all_legends, calculateAverage, initResize, radar_options, draw_chart, ref, onMounted, inject, computed, get echarts() {
          return echarts;
        }, get useRadar() {
          return useRadar;
        }, get useResize() {
          return useResize;
        }, get commonProps() {
          return commonProps;
        } };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        ref: "chartCont",
        class: "imet_radar",
        style: normalizeStyle("width:100%; min-height: " + _ctx.height + "px;")
      }, null, 4);
    }
    const radarThreats = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render$f], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/scaling_up_analysis/components/various_charts/radar_threats.vue"]]);
    function tryOnScopeDispose(fn2) {
      if (getCurrentScope()) {
        onScopeDispose(fn2);
        return true;
      }
      return false;
    }
    function toValue(r2) {
      return typeof r2 === "function" ? r2() : unref(r2);
    }
    const isClient = typeof window !== "undefined" && typeof document !== "undefined";
    typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
    const toString = Object.prototype.toString;
    const isObject$1 = (val) => toString.call(val) === "[object Object]";
    const noop = () => {
    };
    const isIOS = /* @__PURE__ */ getIsIOS();
    function getIsIOS() {
      var _a2, _b2;
      return isClient && ((_a2 = window == null ? void 0 : window.navigator) == null ? void 0 : _a2.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((_b2 = window == null ? void 0 : window.navigator) == null ? void 0 : _b2.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
    }
    function createFilterWrapper(filter2, fn2) {
      function wrapper(...args) {
        return new Promise((resolve, reject2) => {
          Promise.resolve(filter2(() => fn2.apply(this, args), { fn: fn2, thisArg: this, args })).then(resolve).catch(reject2);
        });
      }
      return wrapper;
    }
    const bypassFilter = (invoke2) => {
      return invoke2();
    };
    function debounceFilter(ms, options = {}) {
      let timer;
      let maxTimer;
      let lastRejector = noop;
      const _clearTimeout = (timer2) => {
        clearTimeout(timer2);
        lastRejector();
        lastRejector = noop;
      };
      const filter2 = (invoke2) => {
        const duration = toValue(ms);
        const maxDuration = toValue(options.maxWait);
        if (timer)
          _clearTimeout(timer);
        if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
          if (maxTimer) {
            _clearTimeout(maxTimer);
            maxTimer = null;
          }
          return Promise.resolve(invoke2());
        }
        return new Promise((resolve, reject2) => {
          lastRejector = options.rejectOnCancel ? reject2 : resolve;
          if (maxDuration && !maxTimer) {
            maxTimer = setTimeout(() => {
              if (timer)
                _clearTimeout(timer);
              maxTimer = null;
              resolve(invoke2());
            }, maxDuration);
          }
          timer = setTimeout(() => {
            if (maxTimer)
              _clearTimeout(maxTimer);
            maxTimer = null;
            resolve(invoke2());
          }, duration);
        });
      };
      return filter2;
    }
    function pausableFilter(extendFilter = bypassFilter) {
      const isActive = ref(true);
      function pause() {
        isActive.value = false;
      }
      function resume() {
        isActive.value = true;
      }
      const eventFilter = (...args) => {
        if (isActive.value)
          extendFilter(...args);
      };
      return { isActive: readonly(isActive), pause, resume, eventFilter };
    }
    function createSingletonPromise(fn2) {
      let _promise;
      function wrapper() {
        if (!_promise)
          _promise = fn2();
        return _promise;
      }
      wrapper.reset = async () => {
        const _prev = _promise;
        _promise = void 0;
        if (_prev)
          await _prev;
      };
      return wrapper;
    }
    function getLifeCycleTarget(target) {
      return getCurrentInstance();
    }
    function useDebounceFn(fn2, ms = 200, options = {}) {
      return createFilterWrapper(
        debounceFilter(ms, options),
        fn2
      );
    }
    function watchWithFilter(source, cb, options = {}) {
      const {
        eventFilter = bypassFilter,
        ...watchOptions
      } = options;
      return watch(
        source,
        createFilterWrapper(
          eventFilter,
          cb
        ),
        watchOptions
      );
    }
    function watchPausable(source, cb, options = {}) {
      const {
        eventFilter: filter2,
        ...watchOptions
      } = options;
      const { eventFilter, pause, resume, isActive } = pausableFilter(filter2);
      const stop = watchWithFilter(
        source,
        cb,
        {
          ...watchOptions,
          eventFilter
        }
      );
      return { stop, pause, resume, isActive };
    }
    function tryOnMounted(fn2, sync = true, target) {
      const instance = getLifeCycleTarget();
      if (instance)
        onMounted(fn2, target);
      else if (sync)
        fn2();
      else
        nextTick(fn2);
    }
    function useTimeoutFn(cb, interval, options = {}) {
      const {
        immediate = true
      } = options;
      const isPending = ref(false);
      let timer = null;
      function clear() {
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
      }
      function stop() {
        isPending.value = false;
        clear();
      }
      function start2(...args) {
        clear();
        isPending.value = true;
        timer = setTimeout(() => {
          isPending.value = false;
          timer = null;
          cb(...args);
        }, toValue(interval));
      }
      if (immediate) {
        isPending.value = true;
        if (isClient)
          start2();
      }
      tryOnScopeDispose(stop);
      return {
        isPending: readonly(isPending),
        start: start2,
        stop
      };
    }
    function whenever(source, cb, options) {
      const stop = watch(
        source,
        (v2, ov, onInvalidate) => {
          if (v2) {
            if (options == null ? void 0 : options.once)
              nextTick(() => stop());
            cb(v2, ov, onInvalidate);
          }
        },
        {
          ...options,
          once: false
        }
      );
      return stop;
    }
    function unrefElement(elRef) {
      var _a2;
      const plain = toValue(elRef);
      return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
    }
    const defaultWindow = isClient ? window : void 0;
    const defaultNavigator = isClient ? window.navigator : void 0;
    function useEventListener(...args) {
      let target;
      let events2;
      let listeners;
      let options;
      if (typeof args[0] === "string" || Array.isArray(args[0])) {
        [events2, listeners, options] = args;
        target = defaultWindow;
      } else {
        [target, events2, listeners, options] = args;
      }
      if (!target)
        return noop;
      if (!Array.isArray(events2))
        events2 = [events2];
      if (!Array.isArray(listeners))
        listeners = [listeners];
      const cleanups = [];
      const cleanup = () => {
        cleanups.forEach((fn2) => fn2());
        cleanups.length = 0;
      };
      const register = (el, event, listener, options2) => {
        el.addEventListener(event, listener, options2);
        return () => el.removeEventListener(event, listener, options2);
      };
      const stopWatch = watch(
        () => [unrefElement(target), toValue(options)],
        ([el, options2]) => {
          cleanup();
          if (!el)
            return;
          const optionsClone = isObject$1(options2) ? { ...options2 } : options2;
          cleanups.push(
            ...events2.flatMap((event) => {
              return listeners.map((listener) => register(el, event, listener, optionsClone));
            })
          );
        },
        { immediate: true, flush: "post" }
      );
      const stop = () => {
        stopWatch();
        cleanup();
      };
      tryOnScopeDispose(stop);
      return stop;
    }
    let _iOSWorkaround = false;
    function onClickOutside(target, handler, options = {}) {
      const { window: window2 = defaultWindow, ignore = [], capture = true, detectIframe = false } = options;
      if (!window2)
        return noop;
      if (isIOS && !_iOSWorkaround) {
        _iOSWorkaround = true;
        Array.from(window2.document.body.children).forEach((el) => el.addEventListener("click", noop));
        window2.document.documentElement.addEventListener("click", noop);
      }
      let shouldListen = true;
      const shouldIgnore = (event) => {
        return ignore.some((target2) => {
          if (typeof target2 === "string") {
            return Array.from(window2.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));
          } else {
            const el = unrefElement(target2);
            return el && (event.target === el || event.composedPath().includes(el));
          }
        });
      };
      const listener = (event) => {
        const el = unrefElement(target);
        if (!el || el === event.target || event.composedPath().includes(el))
          return;
        if (event.detail === 0)
          shouldListen = !shouldIgnore(event);
        if (!shouldListen) {
          shouldListen = true;
          return;
        }
        handler(event);
      };
      const cleanup = [
        useEventListener(window2, "click", listener, { passive: true, capture }),
        useEventListener(window2, "pointerdown", (e2) => {
          const el = unrefElement(target);
          shouldListen = !shouldIgnore(e2) && !!(el && !e2.composedPath().includes(el));
        }, { passive: true }),
        detectIframe && useEventListener(window2, "blur", (event) => {
          setTimeout(() => {
            var _a2;
            const el = unrefElement(target);
            if (((_a2 = window2.document.activeElement) == null ? void 0 : _a2.tagName) === "IFRAME" && !(el == null ? void 0 : el.contains(window2.document.activeElement))) {
              handler(event);
            }
          }, 0);
        })
      ].filter(Boolean);
      const stop = () => cleanup.forEach((fn2) => fn2());
      return stop;
    }
    function useMounted() {
      const isMounted = ref(false);
      const instance = getCurrentInstance();
      if (instance) {
        onMounted(() => {
          isMounted.value = true;
        }, instance);
      }
      return isMounted;
    }
    function useSupported(callback) {
      const isMounted = useMounted();
      return computed(() => {
        isMounted.value;
        return Boolean(callback());
      });
    }
    function usePermission(permissionDesc, options = {}) {
      const {
        controls = false,
        navigator: navigator2 = defaultNavigator
      } = options;
      const isSupported = useSupported(() => navigator2 && "permissions" in navigator2);
      let permissionStatus;
      const desc = typeof permissionDesc === "string" ? { name: permissionDesc } : permissionDesc;
      const state = ref();
      const onChange = () => {
        if (permissionStatus)
          state.value = permissionStatus.state;
      };
      const query = createSingletonPromise(async () => {
        if (!isSupported.value)
          return;
        if (!permissionStatus) {
          try {
            permissionStatus = await navigator2.permissions.query(desc);
            useEventListener(permissionStatus, "change", onChange);
            onChange();
          } catch (e2) {
            state.value = "prompt";
          }
        }
        return permissionStatus;
      });
      query();
      if (controls) {
        return {
          state,
          isSupported,
          query
        };
      } else {
        return state;
      }
    }
    function useClipboard(options = {}) {
      const {
        navigator: navigator2 = defaultNavigator,
        read: read2 = false,
        source,
        copiedDuring = 1500,
        legacy = false
      } = options;
      const isClipboardApiSupported = useSupported(() => navigator2 && "clipboard" in navigator2);
      const permissionRead = usePermission("clipboard-read");
      const permissionWrite = usePermission("clipboard-write");
      const isSupported = computed(() => isClipboardApiSupported.value || legacy);
      const text2 = ref("");
      const copied = ref(false);
      const timeout = useTimeoutFn(() => copied.value = false, copiedDuring);
      function updateText() {
        if (isClipboardApiSupported.value && isAllowed(permissionRead.value)) {
          navigator2.clipboard.readText().then((value) => {
            text2.value = value;
          });
        } else {
          text2.value = legacyRead();
        }
      }
      if (isSupported.value && read2)
        useEventListener(["copy", "cut"], updateText);
      async function copy(value = toValue(source)) {
        if (isSupported.value && value != null) {
          if (isClipboardApiSupported.value && isAllowed(permissionWrite.value))
            await navigator2.clipboard.writeText(value);
          else
            legacyCopy(value);
          text2.value = value;
          copied.value = true;
          timeout.start();
        }
      }
      function legacyCopy(value) {
        const ta = document.createElement("textarea");
        ta.value = value != null ? value : "";
        ta.style.position = "absolute";
        ta.style.opacity = "0";
        document.body.appendChild(ta);
        ta.select();
        document.execCommand("copy");
        ta.remove();
      }
      function legacyRead() {
        var _a2, _b2, _c2;
        return (_c2 = (_b2 = (_a2 = document == null ? void 0 : document.getSelection) == null ? void 0 : _a2.call(document)) == null ? void 0 : _b2.toString()) != null ? _c2 : "";
      }
      function isAllowed(status) {
        return status === "granted" || status === "prompt";
      }
      return {
        isSupported,
        text: text2,
        copied,
        copy
      };
    }
    const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    const globalKey = "__vueuse_ssr_handlers__";
    const handlers = /* @__PURE__ */ getHandlers();
    function getHandlers() {
      if (!(globalKey in _global))
        _global[globalKey] = _global[globalKey] || {};
      return _global[globalKey];
    }
    function getSSRHandler(key, fallback) {
      return handlers[key] || fallback;
    }
    function guessSerializerType(rawInit) {
      return rawInit == null ? "any" : rawInit instanceof Set ? "set" : rawInit instanceof Map ? "map" : rawInit instanceof Date ? "date" : typeof rawInit === "boolean" ? "boolean" : typeof rawInit === "string" ? "string" : typeof rawInit === "object" ? "object" : !Number.isNaN(rawInit) ? "number" : "any";
    }
    const StorageSerializers = {
      boolean: {
        read: (v2) => v2 === "true",
        write: (v2) => String(v2)
      },
      object: {
        read: (v2) => JSON.parse(v2),
        write: (v2) => JSON.stringify(v2)
      },
      number: {
        read: (v2) => Number.parseFloat(v2),
        write: (v2) => String(v2)
      },
      any: {
        read: (v2) => v2,
        write: (v2) => String(v2)
      },
      string: {
        read: (v2) => v2,
        write: (v2) => String(v2)
      },
      map: {
        read: (v2) => new Map(JSON.parse(v2)),
        write: (v2) => JSON.stringify(Array.from(v2.entries()))
      },
      set: {
        read: (v2) => new Set(JSON.parse(v2)),
        write: (v2) => JSON.stringify(Array.from(v2))
      },
      date: {
        read: (v2) => new Date(v2),
        write: (v2) => v2.toISOString()
      }
    };
    const customStorageEventName = "vueuse-storage";
    function useStorage(key, defaults2, storage2, options = {}) {
      var _a2;
      const {
        flush = "pre",
        deep = true,
        listenToStorageChanges = true,
        writeDefaults = true,
        mergeDefaults = false,
        shallow,
        window: window2 = defaultWindow,
        eventFilter,
        onError = (e2) => {
          console.error(e2);
        },
        initOnMounted
      } = options;
      const data = (shallow ? shallowRef : ref)(typeof defaults2 === "function" ? defaults2() : defaults2);
      if (!storage2) {
        try {
          storage2 = getSSRHandler("getDefaultStorage", () => {
            var _a22;
            return (_a22 = defaultWindow) == null ? void 0 : _a22.localStorage;
          })();
        } catch (e2) {
          onError(e2);
        }
      }
      if (!storage2)
        return data;
      const rawInit = toValue(defaults2);
      const type = guessSerializerType(rawInit);
      const serializer = (_a2 = options.serializer) != null ? _a2 : StorageSerializers[type];
      const { pause: pauseWatch, resume: resumeWatch } = watchPausable(
        data,
        () => write2(data.value),
        { flush, deep, eventFilter }
      );
      if (window2 && listenToStorageChanges) {
        tryOnMounted(() => {
          useEventListener(window2, "storage", update2);
          useEventListener(window2, customStorageEventName, updateFromCustomEvent);
          if (initOnMounted)
            update2();
        });
      }
      if (!initOnMounted)
        update2();
      function dispatchWriteEvent(oldValue, newValue) {
        if (window2) {
          window2.dispatchEvent(new CustomEvent(customStorageEventName, {
            detail: {
              key,
              oldValue,
              newValue,
              storageArea: storage2
            }
          }));
        }
      }
      function write2(v2) {
        try {
          const oldValue = storage2.getItem(key);
          if (v2 == null) {
            dispatchWriteEvent(oldValue, null);
            storage2.removeItem(key);
          } else {
            const serialized = serializer.write(v2);
            if (oldValue !== serialized) {
              storage2.setItem(key, serialized);
              dispatchWriteEvent(oldValue, serialized);
            }
          }
        } catch (e2) {
          onError(e2);
        }
      }
      function read2(event) {
        const rawValue = event ? event.newValue : storage2.getItem(key);
        if (rawValue == null) {
          if (writeDefaults && rawInit != null)
            storage2.setItem(key, serializer.write(rawInit));
          return rawInit;
        } else if (!event && mergeDefaults) {
          const value = serializer.read(rawValue);
          if (typeof mergeDefaults === "function")
            return mergeDefaults(value, rawInit);
          else if (type === "object" && !Array.isArray(value))
            return { ...rawInit, ...value };
          return value;
        } else if (typeof rawValue !== "string") {
          return rawValue;
        } else {
          return serializer.read(rawValue);
        }
      }
      function update2(event) {
        if (event && event.storageArea !== storage2)
          return;
        if (event && event.key == null) {
          data.value = rawInit;
          return;
        }
        if (event && event.key !== key)
          return;
        pauseWatch();
        try {
          if ((event == null ? void 0 : event.newValue) !== serializer.write(data.value))
            data.value = read2(event);
        } catch (e2) {
          onError(e2);
        } finally {
          if (event)
            nextTick(resumeWatch);
          else
            resumeWatch();
        }
      }
      function updateFromCustomEvent(event) {
        update2(event.detail);
      }
      return data;
    }
    function useLocalStorage(key, initialValue, options = {}) {
      const { window: window2 = defaultWindow } = options;
      return useStorage(key, initialValue, window2 == null ? void 0 : window2.localStorage, options);
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    var trimLeft = /^\s+/;
    var trimRight = /\s+$/;
    function tinycolor(color, opts) {
      color = color ? color : "";
      opts = opts || {};
      if (color instanceof tinycolor) {
        return color;
      }
      if (!(this instanceof tinycolor)) {
        return new tinycolor(color, opts);
      }
      var rgb = inputToRGB(color);
      this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb.format;
      this._gradientType = opts.gradientType;
      if (this._r < 1) this._r = Math.round(this._r);
      if (this._g < 1) this._g = Math.round(this._g);
      if (this._b < 1) this._b = Math.round(this._b);
      this._ok = rgb.ok;
    }
    tinycolor.prototype = {
      isDark: function isDark() {
        return this.getBrightness() < 128;
      },
      isLight: function isLight() {
        return !this.isDark();
      },
      isValid: function isValid2() {
        return this._ok;
      },
      getOriginalInput: function getOriginalInput() {
        return this._originalInput;
      },
      getFormat: function getFormat() {
        return this._format;
      },
      getAlpha: function getAlpha() {
        return this._a;
      },
      getBrightness: function getBrightness() {
        var rgb = this.toRgb();
        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
      },
      getLuminance: function getLuminance() {
        var rgb = this.toRgb();
        var RsRGB, GsRGB, BsRGB, R2, G2, B2;
        RsRGB = rgb.r / 255;
        GsRGB = rgb.g / 255;
        BsRGB = rgb.b / 255;
        if (RsRGB <= 0.03928) R2 = RsRGB / 12.92;
        else R2 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
        if (GsRGB <= 0.03928) G2 = GsRGB / 12.92;
        else G2 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
        if (BsRGB <= 0.03928) B2 = BsRGB / 12.92;
        else B2 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
        return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B2;
      },
      setAlpha: function setAlpha(value) {
        this._a = boundAlpha(value);
        this._roundA = Math.round(100 * this._a) / 100;
        return this;
      },
      toHsv: function toHsv() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        return {
          h: hsv.h * 360,
          s: hsv.s,
          v: hsv.v,
          a: this._a
        };
      },
      toHsvString: function toHsvString() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        var h2 = Math.round(hsv.h * 360), s2 = Math.round(hsv.s * 100), v2 = Math.round(hsv.v * 100);
        return this._a == 1 ? "hsv(" + h2 + ", " + s2 + "%, " + v2 + "%)" : "hsva(" + h2 + ", " + s2 + "%, " + v2 + "%, " + this._roundA + ")";
      },
      toHsl: function toHsl() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        return {
          h: hsl.h * 360,
          s: hsl.s,
          l: hsl.l,
          a: this._a
        };
      },
      toHslString: function toHslString() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        var h2 = Math.round(hsl.h * 360), s2 = Math.round(hsl.s * 100), l2 = Math.round(hsl.l * 100);
        return this._a == 1 ? "hsl(" + h2 + ", " + s2 + "%, " + l2 + "%)" : "hsla(" + h2 + ", " + s2 + "%, " + l2 + "%, " + this._roundA + ")";
      },
      toHex: function toHex(allow3Char) {
        return rgbToHex(this._r, this._g, this._b, allow3Char);
      },
      toHexString: function toHexString(allow3Char) {
        return "#" + this.toHex(allow3Char);
      },
      toHex8: function toHex8(allow4Char) {
        return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
      },
      toHex8String: function toHex8String(allow4Char) {
        return "#" + this.toHex8(allow4Char);
      },
      toRgb: function toRgb() {
        return {
          r: Math.round(this._r),
          g: Math.round(this._g),
          b: Math.round(this._b),
          a: this._a
        };
      },
      toRgbString: function toRgbString() {
        return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
      },
      toPercentageRgb: function toPercentageRgb() {
        return {
          r: Math.round(bound01(this._r, 255) * 100) + "%",
          g: Math.round(bound01(this._g, 255) * 100) + "%",
          b: Math.round(bound01(this._b, 255) * 100) + "%",
          a: this._a
        };
      },
      toPercentageRgbString: function toPercentageRgbString() {
        return this._a == 1 ? "rgb(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
      },
      toName: function toName() {
        if (this._a === 0) {
          return "transparent";
        }
        if (this._a < 1) {
          return false;
        }
        return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
      },
      toFilter: function toFilter(secondColor) {
        var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
        var secondHex8String = hex8String;
        var gradientType = this._gradientType ? "GradientType = 1, " : "";
        if (secondColor) {
          var s2 = tinycolor(secondColor);
          secondHex8String = "#" + rgbaToArgbHex(s2._r, s2._g, s2._b, s2._a);
        }
        return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
      },
      toString: function toString2(format) {
        var formatSet = !!format;
        format = format || this._format;
        var formattedString = false;
        var hasAlpha = this._a < 1 && this._a >= 0;
        var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");
        if (needsAlphaFormat) {
          if (format === "name" && this._a === 0) {
            return this.toName();
          }
          return this.toRgbString();
        }
        if (format === "rgb") {
          formattedString = this.toRgbString();
        }
        if (format === "prgb") {
          formattedString = this.toPercentageRgbString();
        }
        if (format === "hex" || format === "hex6") {
          formattedString = this.toHexString();
        }
        if (format === "hex3") {
          formattedString = this.toHexString(true);
        }
        if (format === "hex4") {
          formattedString = this.toHex8String(true);
        }
        if (format === "hex8") {
          formattedString = this.toHex8String();
        }
        if (format === "name") {
          formattedString = this.toName();
        }
        if (format === "hsl") {
          formattedString = this.toHslString();
        }
        if (format === "hsv") {
          formattedString = this.toHsvString();
        }
        return formattedString || this.toHexString();
      },
      clone: function clone2() {
        return tinycolor(this.toString());
      },
      _applyModification: function _applyModification(fn2, args) {
        var color = fn2.apply(null, [this].concat([].slice.call(args)));
        this._r = color._r;
        this._g = color._g;
        this._b = color._b;
        this.setAlpha(color._a);
        return this;
      },
      lighten: function lighten() {
        return this._applyModification(_lighten, arguments);
      },
      brighten: function brighten() {
        return this._applyModification(_brighten, arguments);
      },
      darken: function darken() {
        return this._applyModification(_darken, arguments);
      },
      desaturate: function desaturate() {
        return this._applyModification(_desaturate, arguments);
      },
      saturate: function saturate() {
        return this._applyModification(_saturate, arguments);
      },
      greyscale: function greyscale() {
        return this._applyModification(_greyscale, arguments);
      },
      spin: function spin() {
        return this._applyModification(_spin, arguments);
      },
      _applyCombination: function _applyCombination(fn2, args) {
        return fn2.apply(null, [this].concat([].slice.call(args)));
      },
      analogous: function analogous() {
        return this._applyCombination(_analogous, arguments);
      },
      complement: function complement() {
        return this._applyCombination(_complement, arguments);
      },
      monochromatic: function monochromatic() {
        return this._applyCombination(_monochromatic, arguments);
      },
      splitcomplement: function splitcomplement() {
        return this._applyCombination(_splitcomplement, arguments);
      },
      // Disabled until https://github.com/bgrins/TinyColor/issues/254
      // polyad: function (number) {
      //   return this._applyCombination(polyad, [number]);
      // },
      triad: function triad() {
        return this._applyCombination(polyad, [3]);
      },
      tetrad: function tetrad() {
        return this._applyCombination(polyad, [4]);
      }
    };
    tinycolor.fromRatio = function(color, opts) {
      if (_typeof(color) == "object") {
        var newColor = {};
        for (var i2 in color) {
          if (color.hasOwnProperty(i2)) {
            if (i2 === "a") {
              newColor[i2] = color[i2];
            } else {
              newColor[i2] = convertToPercentage(color[i2]);
            }
          }
        }
        color = newColor;
      }
      return tinycolor(color, opts);
    };
    function inputToRGB(color) {
      var rgb = {
        r: 0,
        g: 0,
        b: 0
      };
      var a2 = 1;
      var s2 = null;
      var v2 = null;
      var l2 = null;
      var ok = false;
      var format = false;
      if (typeof color == "string") {
        color = stringInputToObject(color);
      }
      if (_typeof(color) == "object") {
        if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
          rgb = rgbToRgb(color.r, color.g, color.b);
          ok = true;
          format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
        } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
          s2 = convertToPercentage(color.s);
          v2 = convertToPercentage(color.v);
          rgb = hsvToRgb(color.h, s2, v2);
          ok = true;
          format = "hsv";
        } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
          s2 = convertToPercentage(color.s);
          l2 = convertToPercentage(color.l);
          rgb = hslToRgb(color.h, s2, l2);
          ok = true;
          format = "hsl";
        }
        if (color.hasOwnProperty("a")) {
          a2 = color.a;
        }
      }
      a2 = boundAlpha(a2);
      return {
        ok,
        format: color.format || format,
        r: Math.min(255, Math.max(rgb.r, 0)),
        g: Math.min(255, Math.max(rgb.g, 0)),
        b: Math.min(255, Math.max(rgb.b, 0)),
        a: a2
      };
    }
    function rgbToRgb(r2, g2, b2) {
      return {
        r: bound01(r2, 255) * 255,
        g: bound01(g2, 255) * 255,
        b: bound01(b2, 255) * 255
      };
    }
    function rgbToHsl(r2, g2, b2) {
      r2 = bound01(r2, 255);
      g2 = bound01(g2, 255);
      b2 = bound01(b2, 255);
      var max2 = Math.max(r2, g2, b2), min2 = Math.min(r2, g2, b2);
      var h2, s2, l2 = (max2 + min2) / 2;
      if (max2 == min2) {
        h2 = s2 = 0;
      } else {
        var d2 = max2 - min2;
        s2 = l2 > 0.5 ? d2 / (2 - max2 - min2) : d2 / (max2 + min2);
        switch (max2) {
          case r2:
            h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
            break;
          case g2:
            h2 = (b2 - r2) / d2 + 2;
            break;
          case b2:
            h2 = (r2 - g2) / d2 + 4;
            break;
        }
        h2 /= 6;
      }
      return {
        h: h2,
        s: s2,
        l: l2
      };
    }
    function hslToRgb(h2, s2, l2) {
      var r2, g2, b2;
      h2 = bound01(h2, 360);
      s2 = bound01(s2, 100);
      l2 = bound01(l2, 100);
      function hue2rgb(p3, q3, t2) {
        if (t2 < 0) t2 += 1;
        if (t2 > 1) t2 -= 1;
        if (t2 < 1 / 6) return p3 + (q3 - p3) * 6 * t2;
        if (t2 < 1 / 2) return q3;
        if (t2 < 2 / 3) return p3 + (q3 - p3) * (2 / 3 - t2) * 6;
        return p3;
      }
      if (s2 === 0) {
        r2 = g2 = b2 = l2;
      } else {
        var q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
        var p2 = 2 * l2 - q2;
        r2 = hue2rgb(p2, q2, h2 + 1 / 3);
        g2 = hue2rgb(p2, q2, h2);
        b2 = hue2rgb(p2, q2, h2 - 1 / 3);
      }
      return {
        r: r2 * 255,
        g: g2 * 255,
        b: b2 * 255
      };
    }
    function rgbToHsv(r2, g2, b2) {
      r2 = bound01(r2, 255);
      g2 = bound01(g2, 255);
      b2 = bound01(b2, 255);
      var max2 = Math.max(r2, g2, b2), min2 = Math.min(r2, g2, b2);
      var h2, s2, v2 = max2;
      var d2 = max2 - min2;
      s2 = max2 === 0 ? 0 : d2 / max2;
      if (max2 == min2) {
        h2 = 0;
      } else {
        switch (max2) {
          case r2:
            h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
            break;
          case g2:
            h2 = (b2 - r2) / d2 + 2;
            break;
          case b2:
            h2 = (r2 - g2) / d2 + 4;
            break;
        }
        h2 /= 6;
      }
      return {
        h: h2,
        s: s2,
        v: v2
      };
    }
    function hsvToRgb(h2, s2, v2) {
      h2 = bound01(h2, 360) * 6;
      s2 = bound01(s2, 100);
      v2 = bound01(v2, 100);
      var i2 = Math.floor(h2), f2 = h2 - i2, p2 = v2 * (1 - s2), q2 = v2 * (1 - f2 * s2), t2 = v2 * (1 - (1 - f2) * s2), mod = i2 % 6, r2 = [v2, q2, p2, p2, t2, v2][mod], g2 = [t2, v2, v2, q2, p2, p2][mod], b2 = [p2, p2, t2, v2, v2, q2][mod];
      return {
        r: r2 * 255,
        g: g2 * 255,
        b: b2 * 255
      };
    }
    function rgbToHex(r2, g2, b2, allow3Char) {
      var hex = [pad2(Math.round(r2).toString(16)), pad2(Math.round(g2).toString(16)), pad2(Math.round(b2).toString(16))];
      if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
      }
      return hex.join("");
    }
    function rgbaToHex(r2, g2, b2, a2, allow4Char) {
      var hex = [pad2(Math.round(r2).toString(16)), pad2(Math.round(g2).toString(16)), pad2(Math.round(b2).toString(16)), pad2(convertDecimalToHex(a2))];
      if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
      }
      return hex.join("");
    }
    function rgbaToArgbHex(r2, g2, b2, a2) {
      var hex = [pad2(convertDecimalToHex(a2)), pad2(Math.round(r2).toString(16)), pad2(Math.round(g2).toString(16)), pad2(Math.round(b2).toString(16))];
      return hex.join("");
    }
    tinycolor.equals = function(color1, color2) {
      if (!color1 || !color2) return false;
      return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
    };
    tinycolor.random = function() {
      return tinycolor.fromRatio({
        r: Math.random(),
        g: Math.random(),
        b: Math.random()
      });
    };
    function _desaturate(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl = tinycolor(color).toHsl();
      hsl.s -= amount / 100;
      hsl.s = clamp01(hsl.s);
      return tinycolor(hsl);
    }
    function _saturate(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl = tinycolor(color).toHsl();
      hsl.s += amount / 100;
      hsl.s = clamp01(hsl.s);
      return tinycolor(hsl);
    }
    function _greyscale(color) {
      return tinycolor(color).desaturate(100);
    }
    function _lighten(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl = tinycolor(color).toHsl();
      hsl.l += amount / 100;
      hsl.l = clamp01(hsl.l);
      return tinycolor(hsl);
    }
    function _brighten(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var rgb = tinycolor(color).toRgb();
      rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
      rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
      rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
      return tinycolor(rgb);
    }
    function _darken(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl = tinycolor(color).toHsl();
      hsl.l -= amount / 100;
      hsl.l = clamp01(hsl.l);
      return tinycolor(hsl);
    }
    function _spin(color, amount) {
      var hsl = tinycolor(color).toHsl();
      var hue = (hsl.h + amount) % 360;
      hsl.h = hue < 0 ? 360 + hue : hue;
      return tinycolor(hsl);
    }
    function _complement(color) {
      var hsl = tinycolor(color).toHsl();
      hsl.h = (hsl.h + 180) % 360;
      return tinycolor(hsl);
    }
    function polyad(color, number2) {
      if (isNaN(number2) || number2 <= 0) {
        throw new Error("Argument to polyad must be a positive number");
      }
      var hsl = tinycolor(color).toHsl();
      var result2 = [tinycolor(color)];
      var step = 360 / number2;
      for (var i2 = 1; i2 < number2; i2++) {
        result2.push(tinycolor({
          h: (hsl.h + i2 * step) % 360,
          s: hsl.s,
          l: hsl.l
        }));
      }
      return result2;
    }
    function _splitcomplement(color) {
      var hsl = tinycolor(color).toHsl();
      var h2 = hsl.h;
      return [tinycolor(color), tinycolor({
        h: (h2 + 72) % 360,
        s: hsl.s,
        l: hsl.l
      }), tinycolor({
        h: (h2 + 216) % 360,
        s: hsl.s,
        l: hsl.l
      })];
    }
    function _analogous(color, results, slices) {
      results = results || 6;
      slices = slices || 30;
      var hsl = tinycolor(color).toHsl();
      var part = 360 / slices;
      var ret = [tinycolor(color)];
      for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
        hsl.h = (hsl.h + part) % 360;
        ret.push(tinycolor(hsl));
      }
      return ret;
    }
    function _monochromatic(color, results) {
      results = results || 6;
      var hsv = tinycolor(color).toHsv();
      var h2 = hsv.h, s2 = hsv.s, v2 = hsv.v;
      var ret = [];
      var modification = 1 / results;
      while (results--) {
        ret.push(tinycolor({
          h: h2,
          s: s2,
          v: v2
        }));
        v2 = (v2 + modification) % 1;
      }
      return ret;
    }
    tinycolor.mix = function(color1, color2, amount) {
      amount = amount === 0 ? 0 : amount || 50;
      var rgb1 = tinycolor(color1).toRgb();
      var rgb2 = tinycolor(color2).toRgb();
      var p2 = amount / 100;
      var rgba = {
        r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
        g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
        b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
        a: (rgb2.a - rgb1.a) * p2 + rgb1.a
      };
      return tinycolor(rgba);
    };
    tinycolor.readability = function(color1, color2) {
      var c1 = tinycolor(color1);
      var c2 = tinycolor(color2);
      return (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
    };
    tinycolor.isReadable = function(color1, color2, wcag2) {
      var readability = tinycolor.readability(color1, color2);
      var wcag2Parms, out;
      out = false;
      wcag2Parms = validateWCAG2Parms(wcag2);
      switch (wcag2Parms.level + wcag2Parms.size) {
        case "AAsmall":
        case "AAAlarge":
          out = readability >= 4.5;
          break;
        case "AAlarge":
          out = readability >= 3;
          break;
        case "AAAsmall":
          out = readability >= 7;
          break;
      }
      return out;
    };
    tinycolor.mostReadable = function(baseColor, colorList, args) {
      var bestColor = null;
      var bestScore = 0;
      var readability;
      var includeFallbackColors, level, size2;
      args = args || {};
      includeFallbackColors = args.includeFallbackColors;
      level = args.level;
      size2 = args.size;
      for (var i2 = 0; i2 < colorList.length; i2++) {
        readability = tinycolor.readability(baseColor, colorList[i2]);
        if (readability > bestScore) {
          bestScore = readability;
          bestColor = tinycolor(colorList[i2]);
        }
      }
      if (tinycolor.isReadable(baseColor, bestColor, {
        level,
        size: size2
      }) || !includeFallbackColors) {
        return bestColor;
      } else {
        args.includeFallbackColors = false;
        return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
      }
    };
    var names = tinycolor.names = {
      aliceblue: "f0f8ff",
      antiquewhite: "faebd7",
      aqua: "0ff",
      aquamarine: "7fffd4",
      azure: "f0ffff",
      beige: "f5f5dc",
      bisque: "ffe4c4",
      black: "000",
      blanchedalmond: "ffebcd",
      blue: "00f",
      blueviolet: "8a2be2",
      brown: "a52a2a",
      burlywood: "deb887",
      burntsienna: "ea7e5d",
      cadetblue: "5f9ea0",
      chartreuse: "7fff00",
      chocolate: "d2691e",
      coral: "ff7f50",
      cornflowerblue: "6495ed",
      cornsilk: "fff8dc",
      crimson: "dc143c",
      cyan: "0ff",
      darkblue: "00008b",
      darkcyan: "008b8b",
      darkgoldenrod: "b8860b",
      darkgray: "a9a9a9",
      darkgreen: "006400",
      darkgrey: "a9a9a9",
      darkkhaki: "bdb76b",
      darkmagenta: "8b008b",
      darkolivegreen: "556b2f",
      darkorange: "ff8c00",
      darkorchid: "9932cc",
      darkred: "8b0000",
      darksalmon: "e9967a",
      darkseagreen: "8fbc8f",
      darkslateblue: "483d8b",
      darkslategray: "2f4f4f",
      darkslategrey: "2f4f4f",
      darkturquoise: "00ced1",
      darkviolet: "9400d3",
      deeppink: "ff1493",
      deepskyblue: "00bfff",
      dimgray: "696969",
      dimgrey: "696969",
      dodgerblue: "1e90ff",
      firebrick: "b22222",
      floralwhite: "fffaf0",
      forestgreen: "228b22",
      fuchsia: "f0f",
      gainsboro: "dcdcdc",
      ghostwhite: "f8f8ff",
      gold: "ffd700",
      goldenrod: "daa520",
      gray: "808080",
      green: "008000",
      greenyellow: "adff2f",
      grey: "808080",
      honeydew: "f0fff0",
      hotpink: "ff69b4",
      indianred: "cd5c5c",
      indigo: "4b0082",
      ivory: "fffff0",
      khaki: "f0e68c",
      lavender: "e6e6fa",
      lavenderblush: "fff0f5",
      lawngreen: "7cfc00",
      lemonchiffon: "fffacd",
      lightblue: "add8e6",
      lightcoral: "f08080",
      lightcyan: "e0ffff",
      lightgoldenrodyellow: "fafad2",
      lightgray: "d3d3d3",
      lightgreen: "90ee90",
      lightgrey: "d3d3d3",
      lightpink: "ffb6c1",
      lightsalmon: "ffa07a",
      lightseagreen: "20b2aa",
      lightskyblue: "87cefa",
      lightslategray: "789",
      lightslategrey: "789",
      lightsteelblue: "b0c4de",
      lightyellow: "ffffe0",
      lime: "0f0",
      limegreen: "32cd32",
      linen: "faf0e6",
      magenta: "f0f",
      maroon: "800000",
      mediumaquamarine: "66cdaa",
      mediumblue: "0000cd",
      mediumorchid: "ba55d3",
      mediumpurple: "9370db",
      mediumseagreen: "3cb371",
      mediumslateblue: "7b68ee",
      mediumspringgreen: "00fa9a",
      mediumturquoise: "48d1cc",
      mediumvioletred: "c71585",
      midnightblue: "191970",
      mintcream: "f5fffa",
      mistyrose: "ffe4e1",
      moccasin: "ffe4b5",
      navajowhite: "ffdead",
      navy: "000080",
      oldlace: "fdf5e6",
      olive: "808000",
      olivedrab: "6b8e23",
      orange: "ffa500",
      orangered: "ff4500",
      orchid: "da70d6",
      palegoldenrod: "eee8aa",
      palegreen: "98fb98",
      paleturquoise: "afeeee",
      palevioletred: "db7093",
      papayawhip: "ffefd5",
      peachpuff: "ffdab9",
      peru: "cd853f",
      pink: "ffc0cb",
      plum: "dda0dd",
      powderblue: "b0e0e6",
      purple: "800080",
      rebeccapurple: "663399",
      red: "f00",
      rosybrown: "bc8f8f",
      royalblue: "4169e1",
      saddlebrown: "8b4513",
      salmon: "fa8072",
      sandybrown: "f4a460",
      seagreen: "2e8b57",
      seashell: "fff5ee",
      sienna: "a0522d",
      silver: "c0c0c0",
      skyblue: "87ceeb",
      slateblue: "6a5acd",
      slategray: "708090",
      slategrey: "708090",
      snow: "fffafa",
      springgreen: "00ff7f",
      steelblue: "4682b4",
      tan: "d2b48c",
      teal: "008080",
      thistle: "d8bfd8",
      tomato: "ff6347",
      turquoise: "40e0d0",
      violet: "ee82ee",
      wheat: "f5deb3",
      white: "fff",
      whitesmoke: "f5f5f5",
      yellow: "ff0",
      yellowgreen: "9acd32"
    };
    var hexNames = tinycolor.hexNames = flip$2(names);
    function flip$2(o2) {
      var flipped = {};
      for (var i2 in o2) {
        if (o2.hasOwnProperty(i2)) {
          flipped[o2[i2]] = i2;
        }
      }
      return flipped;
    }
    function boundAlpha(a2) {
      a2 = parseFloat(a2);
      if (isNaN(a2) || a2 < 0 || a2 > 1) {
        a2 = 1;
      }
      return a2;
    }
    function bound01(n2, max2) {
      if (isOnePointZero(n2)) n2 = "100%";
      var processPercent = isPercentage(n2);
      n2 = Math.min(max2, Math.max(0, parseFloat(n2)));
      if (processPercent) {
        n2 = parseInt(n2 * max2, 10) / 100;
      }
      if (Math.abs(n2 - max2) < 1e-6) {
        return 1;
      }
      return n2 % max2 / parseFloat(max2);
    }
    function clamp01(val) {
      return Math.min(1, Math.max(0, val));
    }
    function parseIntFromHex(val) {
      return parseInt(val, 16);
    }
    function isOnePointZero(n2) {
      return typeof n2 == "string" && n2.indexOf(".") != -1 && parseFloat(n2) === 1;
    }
    function isPercentage(n2) {
      return typeof n2 === "string" && n2.indexOf("%") != -1;
    }
    function pad2(c2) {
      return c2.length == 1 ? "0" + c2 : "" + c2;
    }
    function convertToPercentage(n2) {
      if (n2 <= 1) {
        n2 = n2 * 100 + "%";
      }
      return n2;
    }
    function convertDecimalToHex(d2) {
      return Math.round(parseFloat(d2) * 255).toString(16);
    }
    function convertHexToDecimal(h2) {
      return parseIntFromHex(h2) / 255;
    }
    var matchers = function() {
      var CSS_INTEGER = "[-\\+]?\\d+%?";
      var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
      var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
      var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
      var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
      return {
        CSS_UNIT: new RegExp(CSS_UNIT),
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
      };
    }();
    function isValidCSSUnit(color) {
      return !!matchers.CSS_UNIT.exec(color);
    }
    function stringInputToObject(color) {
      color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
      var named = false;
      if (names[color]) {
        color = names[color];
        named = true;
      } else if (color == "transparent") {
        return {
          r: 0,
          g: 0,
          b: 0,
          a: 0,
          format: "name"
        };
      }
      var match;
      if (match = matchers.rgb.exec(color)) {
        return {
          r: match[1],
          g: match[2],
          b: match[3]
        };
      }
      if (match = matchers.rgba.exec(color)) {
        return {
          r: match[1],
          g: match[2],
          b: match[3],
          a: match[4]
        };
      }
      if (match = matchers.hsl.exec(color)) {
        return {
          h: match[1],
          s: match[2],
          l: match[3]
        };
      }
      if (match = matchers.hsla.exec(color)) {
        return {
          h: match[1],
          s: match[2],
          l: match[3],
          a: match[4]
        };
      }
      if (match = matchers.hsv.exec(color)) {
        return {
          h: match[1],
          s: match[2],
          v: match[3]
        };
      }
      if (match = matchers.hsva.exec(color)) {
        return {
          h: match[1],
          s: match[2],
          v: match[3],
          a: match[4]
        };
      }
      if (match = matchers.hex8.exec(color)) {
        return {
          r: parseIntFromHex(match[1]),
          g: parseIntFromHex(match[2]),
          b: parseIntFromHex(match[3]),
          a: convertHexToDecimal(match[4]),
          format: named ? "name" : "hex8"
        };
      }
      if (match = matchers.hex6.exec(color)) {
        return {
          r: parseIntFromHex(match[1]),
          g: parseIntFromHex(match[2]),
          b: parseIntFromHex(match[3]),
          format: named ? "name" : "hex"
        };
      }
      if (match = matchers.hex4.exec(color)) {
        return {
          r: parseIntFromHex(match[1] + "" + match[1]),
          g: parseIntFromHex(match[2] + "" + match[2]),
          b: parseIntFromHex(match[3] + "" + match[3]),
          a: convertHexToDecimal(match[4] + "" + match[4]),
          format: named ? "name" : "hex8"
        };
      }
      if (match = matchers.hex3.exec(color)) {
        return {
          r: parseIntFromHex(match[1] + "" + match[1]),
          g: parseIntFromHex(match[2] + "" + match[2]),
          b: parseIntFromHex(match[3] + "" + match[3]),
          format: named ? "name" : "hex"
        };
      }
      return false;
    }
    function validateWCAG2Parms(parms) {
      var level, size2;
      parms = parms || {
        level: "AA",
        size: "small"
      };
      level = (parms.level || "AA").toUpperCase();
      size2 = (parms.size || "small").toLowerCase();
      if (level !== "AA" && level !== "AAA") {
        level = "AA";
      }
      if (size2 !== "small" && size2 !== "large") {
        size2 = "small";
      }
      return {
        level,
        size: size2
      };
    }
    var GradientParser = GradientParser || {};
    GradientParser.stringify = /* @__PURE__ */ function() {
      var visitor = {
        "visit_linear-gradient": function(node) {
          return visitor.visit_gradient(node);
        },
        "visit_repeating-linear-gradient": function(node) {
          return visitor.visit_gradient(node);
        },
        "visit_radial-gradient": function(node) {
          return visitor.visit_gradient(node);
        },
        "visit_repeating-radial-gradient": function(node) {
          return visitor.visit_gradient(node);
        },
        "visit_gradient": function(node) {
          var orientation = visitor.visit(node.orientation);
          if (orientation) {
            orientation += ", ";
          }
          return node.type + "(" + orientation + visitor.visit(node.colorStops) + ")";
        },
        "visit_shape": function(node) {
          var result2 = node.value, at2 = visitor.visit(node.at), style = visitor.visit(node.style);
          if (style) {
            result2 += " " + style;
          }
          if (at2) {
            result2 += " at " + at2;
          }
          return result2;
        },
        "visit_default-radial": function(node) {
          var result2 = "", at2 = visitor.visit(node.at);
          if (at2) {
            result2 += at2;
          }
          return result2;
        },
        "visit_extent-keyword": function(node) {
          var result2 = node.value, at2 = visitor.visit(node.at);
          if (at2) {
            result2 += " at " + at2;
          }
          return result2;
        },
        "visit_position-keyword": function(node) {
          return node.value;
        },
        "visit_position": function(node) {
          return visitor.visit(node.value.x) + " " + visitor.visit(node.value.y);
        },
        "visit_%": function(node) {
          return node.value + "%";
        },
        "visit_em": function(node) {
          return node.value + "em";
        },
        "visit_px": function(node) {
          return node.value + "px";
        },
        "visit_literal": function(node) {
          return visitor.visit_color(node.value, node);
        },
        "visit_hex": function(node) {
          return visitor.visit_color("#" + node.value, node);
        },
        "visit_rgb": function(node) {
          return visitor.visit_color("rgb(" + node.value.join(", ") + ")", node);
        },
        "visit_rgba": function(node) {
          return visitor.visit_color("rgba(" + node.value.join(", ") + ")", node);
        },
        "visit_color": function(resultColor, node) {
          var result2 = resultColor, length = visitor.visit(node.length);
          if (length) {
            result2 += " " + length;
          }
          return result2;
        },
        "visit_angular": function(node) {
          return node.value + "deg";
        },
        "visit_directional": function(node) {
          return "to " + node.value;
        },
        "visit_array": function(elements2) {
          var result2 = "", size2 = elements2.length;
          elements2.forEach(function(element, i2) {
            result2 += visitor.visit(element);
            if (i2 < size2 - 1) {
              result2 += ", ";
            }
          });
          return result2;
        },
        "visit": function(element) {
          if (!element) {
            return "";
          }
          var result2 = "";
          if (element instanceof Array) {
            return visitor.visit_array(element, result2);
          } else if (element.type) {
            var nodeVisitor = visitor["visit_" + element.type];
            if (nodeVisitor) {
              return nodeVisitor(element);
            } else {
              throw Error("Missing visitor visit_" + element.type);
            }
          } else {
            throw Error("Invalid node.");
          }
        }
      };
      return function(root2) {
        return visitor.visit(root2);
      };
    }();
    var GradientParser = GradientParser || {};
    GradientParser.parse = /* @__PURE__ */ function() {
      var tokens = {
        linearGradient: /^(\-(webkit|o|ms|moz)\-)?(linear\-gradient)/i,
        repeatingLinearGradient: /^(\-(webkit|o|ms|moz)\-)?(repeating\-linear\-gradient)/i,
        radialGradient: /^(\-(webkit|o|ms|moz)\-)?(radial\-gradient)/i,
        repeatingRadialGradient: /^(\-(webkit|o|ms|moz)\-)?(repeating\-radial\-gradient)/i,
        sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|left|right|top|bottom)/i,
        extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
        positionKeywords: /^(left|center|right|top|bottom)/i,
        pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
        percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
        emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
        angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
        startCall: /^\(/,
        endCall: /^\)/,
        comma: /^,/,
        hexColor: /^\#([0-9a-fA-F]+)/,
        literalColor: /^([a-zA-Z]+)/,
        rgbColor: /^rgb/i,
        rgbaColor: /^rgba/i,
        number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
      };
      var input = "";
      function error(msg) {
        var err = new Error(input + ": " + msg);
        err.source = input;
        throw err;
      }
      function getAST() {
        var ast = matchListDefinitions();
        if (input.length > 0) {
          error("Invalid input not EOF");
        }
        return ast;
      }
      function matchListDefinitions() {
        return matchListing(matchDefinition);
      }
      function matchDefinition() {
        return matchGradient(
          "linear-gradient",
          tokens.linearGradient,
          matchLinearOrientation
        ) || matchGradient(
          "repeating-linear-gradient",
          tokens.repeatingLinearGradient,
          matchLinearOrientation
        ) || matchGradient(
          "radial-gradient",
          tokens.radialGradient,
          matchListRadialOrientations
        ) || matchGradient(
          "repeating-radial-gradient",
          tokens.repeatingRadialGradient,
          matchListRadialOrientations
        );
      }
      function matchGradient(gradientType, pattern, orientationMatcher) {
        return matchCall(pattern, function(captures) {
          var orientation = orientationMatcher();
          if (orientation) {
            if (!scan(tokens.comma)) {
              error("Missing comma before color stops");
            }
          }
          return {
            type: gradientType,
            orientation,
            colorStops: matchListing(matchColorStop)
          };
        });
      }
      function matchCall(pattern, callback) {
        var captures = scan(pattern);
        if (captures) {
          if (!scan(tokens.startCall)) {
            error("Missing (");
          }
          var result2 = callback(captures);
          if (!scan(tokens.endCall)) {
            error("Missing )");
          }
          return result2;
        }
      }
      function matchLinearOrientation() {
        return matchSideOrCorner() || matchAngle();
      }
      function matchSideOrCorner() {
        return match("directional", tokens.sideOrCorner, 1);
      }
      function matchAngle() {
        return match("angular", tokens.angleValue, 1);
      }
      function matchListRadialOrientations() {
        var radialOrientations, radialOrientation = matchRadialOrientation(), lookaheadCache;
        if (radialOrientation) {
          radialOrientations = [];
          radialOrientations.push(radialOrientation);
          lookaheadCache = input;
          if (scan(tokens.comma)) {
            radialOrientation = matchRadialOrientation();
            if (radialOrientation) {
              radialOrientations.push(radialOrientation);
            } else {
              input = lookaheadCache;
            }
          }
        }
        return radialOrientations;
      }
      function matchRadialOrientation() {
        var radialType = matchCircle() || matchEllipse();
        if (radialType) {
          radialType.at = matchAtPosition();
        } else {
          var extent = matchExtentKeyword();
          if (extent) {
            radialType = extent;
            var positionAt = matchAtPosition();
            if (positionAt) {
              radialType.at = positionAt;
            }
          } else {
            var defaultPosition = matchPositioning();
            if (defaultPosition) {
              radialType = {
                type: "default-radial",
                at: defaultPosition
              };
            }
          }
        }
        return radialType;
      }
      function matchCircle() {
        var circle = match("shape", /^(circle)/i, 0);
        if (circle) {
          circle.style = matchLength() || matchExtentKeyword();
        }
        return circle;
      }
      function matchEllipse() {
        var ellipse = match("shape", /^(ellipse)/i, 0);
        if (ellipse) {
          ellipse.style = matchDistance() || matchExtentKeyword();
        }
        return ellipse;
      }
      function matchExtentKeyword() {
        return match("extent-keyword", tokens.extentKeywords, 1);
      }
      function matchAtPosition() {
        if (match("position", /^at/, 0)) {
          var positioning = matchPositioning();
          if (!positioning) {
            error("Missing positioning value");
          }
          return positioning;
        }
      }
      function matchPositioning() {
        var location2 = matchCoordinates();
        if (location2.x || location2.y) {
          return {
            type: "position",
            value: location2
          };
        }
      }
      function matchCoordinates() {
        return {
          x: matchDistance(),
          y: matchDistance()
        };
      }
      function matchListing(matcher) {
        var captures = matcher(), result2 = [];
        if (captures) {
          result2.push(captures);
          while (scan(tokens.comma)) {
            captures = matcher();
            if (captures) {
              result2.push(captures);
            } else {
              error("One extra comma");
            }
          }
        }
        return result2;
      }
      function matchColorStop() {
        var color = matchColor();
        if (!color) {
          error("Expected color definition");
        }
        color.length = matchDistance();
        return color;
      }
      function matchColor() {
        return matchHexColor() || matchRGBAColor() || matchRGBColor() || matchLiteralColor();
      }
      function matchLiteralColor() {
        return match("literal", tokens.literalColor, 0);
      }
      function matchHexColor() {
        return match("hex", tokens.hexColor, 1);
      }
      function matchRGBColor() {
        return matchCall(tokens.rgbColor, function() {
          return {
            type: "rgb",
            value: matchListing(matchNumber)
          };
        });
      }
      function matchRGBAColor() {
        return matchCall(tokens.rgbaColor, function() {
          return {
            type: "rgba",
            value: matchListing(matchNumber)
          };
        });
      }
      function matchNumber() {
        return scan(tokens.number)[1];
      }
      function matchDistance() {
        return match("%", tokens.percentageValue, 1) || matchPositionKeyword() || matchLength();
      }
      function matchPositionKeyword() {
        return match("position-keyword", tokens.positionKeywords, 1);
      }
      function matchLength() {
        return match("px", tokens.pixelValue, 1) || match("em", tokens.emValue, 1);
      }
      function match(type, pattern, captureIndex) {
        var captures = scan(pattern);
        if (captures) {
          return {
            type,
            value: captures[captureIndex]
          };
        }
      }
      function scan(regexp) {
        var captures, blankCaptures;
        blankCaptures = /^[\n\r\t\s]+/.exec(input);
        if (blankCaptures) {
          consume(blankCaptures[0].length);
        }
        captures = regexp.exec(input);
        if (captures) {
          consume(captures[0].length);
        }
        return captures;
      }
      function consume(size2) {
        input = input.substr(size2);
      }
      return function(code) {
        input = code.toString();
        return getAST();
      };
    }();
    var parse = GradientParser.parse;
    var stringify = GradientParser.stringify;
    var top = "top";
    var bottom = "bottom";
    var right = "right";
    var left = "left";
    var auto = "auto";
    var basePlacements = [top, bottom, right, left];
    var start = "start";
    var end = "end";
    var clippingParents = "clippingParents";
    var viewport = "viewport";
    var popper = "popper";
    var reference = "reference";
    var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
      return acc.concat([placement + "-" + start, placement + "-" + end]);
    }, []);
    var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
      return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
    }, []);
    var beforeRead = "beforeRead";
    var read = "read";
    var afterRead = "afterRead";
    var beforeMain = "beforeMain";
    var main = "main";
    var afterMain = "afterMain";
    var beforeWrite = "beforeWrite";
    var write = "write";
    var afterWrite = "afterWrite";
    var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
    function getNodeName(element) {
      return element ? (element.nodeName || "").toLowerCase() : null;
    }
    function getWindow(node) {
      if (node == null) {
        return window;
      }
      if (node.toString() !== "[object Window]") {
        var ownerDocument = node.ownerDocument;
        return ownerDocument ? ownerDocument.defaultView || window : window;
      }
      return node;
    }
    function isElement(node) {
      var OwnElement = getWindow(node).Element;
      return node instanceof OwnElement || node instanceof Element;
    }
    function isHTMLElement(node) {
      var OwnElement = getWindow(node).HTMLElement;
      return node instanceof OwnElement || node instanceof HTMLElement;
    }
    function isShadowRoot(node) {
      if (typeof ShadowRoot === "undefined") {
        return false;
      }
      var OwnElement = getWindow(node).ShadowRoot;
      return node instanceof OwnElement || node instanceof ShadowRoot;
    }
    function applyStyles(_ref) {
      var state = _ref.state;
      Object.keys(state.elements).forEach(function(name) {
        var style = state.styles[name] || {};
        var attributes = state.attributes[name] || {};
        var element = state.elements[name];
        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        }
        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function(name2) {
          var value = attributes[name2];
          if (value === false) {
            element.removeAttribute(name2);
          } else {
            element.setAttribute(name2, value === true ? "" : value);
          }
        });
      });
    }
    function effect$2(_ref2) {
      var state = _ref2.state;
      var initialStyles = {
        popper: {
          position: state.options.strategy,
          left: "0",
          top: "0",
          margin: "0"
        },
        arrow: {
          position: "absolute"
        },
        reference: {}
      };
      Object.assign(state.elements.popper.style, initialStyles.popper);
      state.styles = initialStyles;
      if (state.elements.arrow) {
        Object.assign(state.elements.arrow.style, initialStyles.arrow);
      }
      return function() {
        Object.keys(state.elements).forEach(function(name) {
          var element = state.elements[name];
          var attributes = state.attributes[name] || {};
          var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
          var style = styleProperties.reduce(function(style2, property2) {
            style2[property2] = "";
            return style2;
          }, {});
          if (!isHTMLElement(element) || !getNodeName(element)) {
            return;
          }
          Object.assign(element.style, style);
          Object.keys(attributes).forEach(function(attribute) {
            element.removeAttribute(attribute);
          });
        });
      };
    }
    const applyStyles$1 = {
      name: "applyStyles",
      enabled: true,
      phase: "write",
      fn: applyStyles,
      effect: effect$2,
      requires: ["computeStyles"]
    };
    function getBasePlacement(placement) {
      return placement.split("-")[0];
    }
    var max = Math.max;
    var min = Math.min;
    var round = Math.round;
    function getUAString() {
      var uaData = navigator.userAgentData;
      if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
        return uaData.brands.map(function(item) {
          return item.brand + "/" + item.version;
        }).join(" ");
      }
      return navigator.userAgent;
    }
    function isLayoutViewport() {
      return !/^((?!chrome|android).)*safari/i.test(getUAString());
    }
    function getBoundingClientRect(element, includeScale, isFixedStrategy) {
      if (includeScale === void 0) {
        includeScale = false;
      }
      if (isFixedStrategy === void 0) {
        isFixedStrategy = false;
      }
      var clientRect = element.getBoundingClientRect();
      var scaleX = 1;
      var scaleY = 1;
      if (includeScale && isHTMLElement(element)) {
        scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
        scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
      }
      var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
      var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
      var x2 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
      var y2 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
      var width = clientRect.width / scaleX;
      var height = clientRect.height / scaleY;
      return {
        width,
        height,
        top: y2,
        right: x2 + width,
        bottom: y2 + height,
        left: x2,
        x: x2,
        y: y2
      };
    }
    function getLayoutRect(element) {
      var clientRect = getBoundingClientRect(element);
      var width = element.offsetWidth;
      var height = element.offsetHeight;
      if (Math.abs(clientRect.width - width) <= 1) {
        width = clientRect.width;
      }
      if (Math.abs(clientRect.height - height) <= 1) {
        height = clientRect.height;
      }
      return {
        x: element.offsetLeft,
        y: element.offsetTop,
        width,
        height
      };
    }
    function contains(parent2, child) {
      var rootNode = child.getRootNode && child.getRootNode();
      if (parent2.contains(child)) {
        return true;
      } else if (rootNode && isShadowRoot(rootNode)) {
        var next = child;
        do {
          if (next && parent2.isSameNode(next)) {
            return true;
          }
          next = next.parentNode || next.host;
        } while (next);
      }
      return false;
    }
    function getComputedStyle$1(element) {
      return getWindow(element).getComputedStyle(element);
    }
    function isTableElement(element) {
      return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
    }
    function getDocumentElement(element) {
      return ((isElement(element) ? element.ownerDocument : (
        // $FlowFixMe[prop-missing]
        element.document
      )) || window.document).documentElement;
    }
    function getParentNode(element) {
      if (getNodeName(element) === "html") {
        return element;
      }
      return (
        // this is a quicker (but less type safe) way to save quite some bytes from the bundle
        // $FlowFixMe[incompatible-return]
        // $FlowFixMe[prop-missing]
        element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
        element.parentNode || // DOM Element detected
        (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
        // $FlowFixMe[incompatible-call]: HTMLElement is a Node
        getDocumentElement(element)
      );
    }
    function getTrueOffsetParent(element) {
      if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
      getComputedStyle$1(element).position === "fixed") {
        return null;
      }
      return element.offsetParent;
    }
    function getContainingBlock(element) {
      var isFirefox = /firefox/i.test(getUAString());
      var isIE = /Trident/i.test(getUAString());
      if (isIE && isHTMLElement(element)) {
        var elementCss = getComputedStyle$1(element);
        if (elementCss.position === "fixed") {
          return null;
        }
      }
      var currentNode = getParentNode(element);
      if (isShadowRoot(currentNode)) {
        currentNode = currentNode.host;
      }
      while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
        var css = getComputedStyle$1(currentNode);
        if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
          return currentNode;
        } else {
          currentNode = currentNode.parentNode;
        }
      }
      return null;
    }
    function getOffsetParent(element) {
      var window2 = getWindow(element);
      var offsetParent = getTrueOffsetParent(element);
      while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
        offsetParent = getTrueOffsetParent(offsetParent);
      }
      if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static")) {
        return window2;
      }
      return offsetParent || getContainingBlock(element) || window2;
    }
    function getMainAxisFromPlacement(placement) {
      return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
    }
    function within(min$12, value, max$12) {
      return max(min$12, min(value, max$12));
    }
    function withinMaxClamp(min2, value, max2) {
      var v2 = within(min2, value, max2);
      return v2 > max2 ? max2 : v2;
    }
    function getFreshSideObject() {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
    }
    function mergePaddingObject(paddingObject) {
      return Object.assign({}, getFreshSideObject(), paddingObject);
    }
    function expandToHashMap(value, keys2) {
      return keys2.reduce(function(hashMap, key) {
        hashMap[key] = value;
        return hashMap;
      }, {});
    }
    var toPaddingObject = function toPaddingObject2(padding, state) {
      padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
        placement: state.placement
      })) : padding;
      return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
    };
    function arrow(_ref) {
      var _state$modifiersData$;
      var state = _ref.state, name = _ref.name, options = _ref.options;
      var arrowElement = state.elements.arrow;
      var popperOffsets2 = state.modifiersData.popperOffsets;
      var basePlacement = getBasePlacement(state.placement);
      var axis = getMainAxisFromPlacement(basePlacement);
      var isVertical = [left, right].indexOf(basePlacement) >= 0;
      var len = isVertical ? "height" : "width";
      if (!arrowElement || !popperOffsets2) {
        return;
      }
      var paddingObject = toPaddingObject(options.padding, state);
      var arrowRect = getLayoutRect(arrowElement);
      var minProp = axis === "y" ? top : left;
      var maxProp = axis === "y" ? bottom : right;
      var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
      var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
      var arrowOffsetParent = getOffsetParent(arrowElement);
      var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
      var centerToReference = endDiff / 2 - startDiff / 2;
      var min2 = paddingObject[minProp];
      var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
      var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
      var offset2 = within(min2, center, max2);
      var axisProp = axis;
      state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
    }
    function effect$1(_ref2) {
      var state = _ref2.state, options = _ref2.options;
      var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
      if (arrowElement == null) {
        return;
      }
      if (typeof arrowElement === "string") {
        arrowElement = state.elements.popper.querySelector(arrowElement);
        if (!arrowElement) {
          return;
        }
      }
      if (!contains(state.elements.popper, arrowElement)) {
        return;
      }
      state.elements.arrow = arrowElement;
    }
    const arrow$1 = {
      name: "arrow",
      enabled: true,
      phase: "main",
      fn: arrow,
      effect: effect$1,
      requires: ["popperOffsets"],
      requiresIfExists: ["preventOverflow"]
    };
    function getVariation(placement) {
      return placement.split("-")[1];
    }
    var unsetSides = {
      top: "auto",
      right: "auto",
      bottom: "auto",
      left: "auto"
    };
    function roundOffsetsByDPR(_ref, win) {
      var x2 = _ref.x, y2 = _ref.y;
      var dpr = win.devicePixelRatio || 1;
      return {
        x: round(x2 * dpr) / dpr || 0,
        y: round(y2 * dpr) / dpr || 0
      };
    }
    function mapToStyles(_ref2) {
      var _Object$assign2;
      var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
      var _offsets$x = offsets.x, x2 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y2 = _offsets$y === void 0 ? 0 : _offsets$y;
      var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
        x: x2,
        y: y2
      }) : {
        x: x2,
        y: y2
      };
      x2 = _ref3.x;
      y2 = _ref3.y;
      var hasX = offsets.hasOwnProperty("x");
      var hasY = offsets.hasOwnProperty("y");
      var sideX = left;
      var sideY = top;
      var win = window;
      if (adaptive) {
        var offsetParent = getOffsetParent(popper2);
        var heightProp = "clientHeight";
        var widthProp = "clientWidth";
        if (offsetParent === getWindow(popper2)) {
          offsetParent = getDocumentElement(popper2);
          if (getComputedStyle$1(offsetParent).position !== "static" && position === "absolute") {
            heightProp = "scrollHeight";
            widthProp = "scrollWidth";
          }
        }
        offsetParent = offsetParent;
        if (placement === top || (placement === left || placement === right) && variation === end) {
          sideY = bottom;
          var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
            // $FlowFixMe[prop-missing]
            offsetParent[heightProp]
          );
          y2 -= offsetY - popperRect.height;
          y2 *= gpuAcceleration ? 1 : -1;
        }
        if (placement === left || (placement === top || placement === bottom) && variation === end) {
          sideX = right;
          var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
            // $FlowFixMe[prop-missing]
            offsetParent[widthProp]
          );
          x2 -= offsetX - popperRect.width;
          x2 *= gpuAcceleration ? 1 : -1;
        }
      }
      var commonStyles = Object.assign({
        position
      }, adaptive && unsetSides);
      var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
        x: x2,
        y: y2
      }, getWindow(popper2)) : {
        x: x2,
        y: y2
      };
      x2 = _ref4.x;
      y2 = _ref4.y;
      if (gpuAcceleration) {
        var _Object$assign;
        return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y2 + "px)" : "translate3d(" + x2 + "px, " + y2 + "px, 0)", _Object$assign));
      }
      return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
    }
    function computeStyles(_ref5) {
      var state = _ref5.state, options = _ref5.options;
      var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
      var commonStyles = {
        placement: getBasePlacement(state.placement),
        variation: getVariation(state.placement),
        popper: state.elements.popper,
        popperRect: state.rects.popper,
        gpuAcceleration,
        isFixed: state.options.strategy === "fixed"
      };
      if (state.modifiersData.popperOffsets != null) {
        state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.popperOffsets,
          position: state.options.strategy,
          adaptive,
          roundOffsets
        })));
      }
      if (state.modifiersData.arrow != null) {
        state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.arrow,
          position: "absolute",
          adaptive: false,
          roundOffsets
        })));
      }
      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        "data-popper-placement": state.placement
      });
    }
    const computeStyles$1 = {
      name: "computeStyles",
      enabled: true,
      phase: "beforeWrite",
      fn: computeStyles,
      data: {}
    };
    var passive = {
      passive: true
    };
    function effect(_ref) {
      var state = _ref.state, instance = _ref.instance, options = _ref.options;
      var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
      var window2 = getWindow(state.elements.popper);
      var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
      if (scroll) {
        scrollParents.forEach(function(scrollParent) {
          scrollParent.addEventListener("scroll", instance.update, passive);
        });
      }
      if (resize) {
        window2.addEventListener("resize", instance.update, passive);
      }
      return function() {
        if (scroll) {
          scrollParents.forEach(function(scrollParent) {
            scrollParent.removeEventListener("scroll", instance.update, passive);
          });
        }
        if (resize) {
          window2.removeEventListener("resize", instance.update, passive);
        }
      };
    }
    const eventListeners = {
      name: "eventListeners",
      enabled: true,
      phase: "write",
      fn: function fn2() {
      },
      effect,
      data: {}
    };
    var hash$1 = {
      left: "right",
      right: "left",
      bottom: "top",
      top: "bottom"
    };
    function getOppositePlacement(placement) {
      return placement.replace(/left|right|bottom|top/g, function(matched) {
        return hash$1[matched];
      });
    }
    var hash = {
      start: "end",
      end: "start"
    };
    function getOppositeVariationPlacement(placement) {
      return placement.replace(/start|end/g, function(matched) {
        return hash[matched];
      });
    }
    function getWindowScroll(node) {
      var win = getWindow(node);
      var scrollLeft = win.pageXOffset;
      var scrollTop = win.pageYOffset;
      return {
        scrollLeft,
        scrollTop
      };
    }
    function getWindowScrollBarX(element) {
      return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
    }
    function getViewportRect(element, strategy) {
      var win = getWindow(element);
      var html2 = getDocumentElement(element);
      var visualViewport = win.visualViewport;
      var width = html2.clientWidth;
      var height = html2.clientHeight;
      var x2 = 0;
      var y2 = 0;
      if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height;
        var layoutViewport = isLayoutViewport();
        if (layoutViewport || !layoutViewport && strategy === "fixed") {
          x2 = visualViewport.offsetLeft;
          y2 = visualViewport.offsetTop;
        }
      }
      return {
        width,
        height,
        x: x2 + getWindowScrollBarX(element),
        y: y2
      };
    }
    function getDocumentRect(element) {
      var _element$ownerDocumen;
      var html2 = getDocumentElement(element);
      var winScroll = getWindowScroll(element);
      var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
      var width = max(html2.scrollWidth, html2.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
      var height = max(html2.scrollHeight, html2.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
      var x2 = -winScroll.scrollLeft + getWindowScrollBarX(element);
      var y2 = -winScroll.scrollTop;
      if (getComputedStyle$1(body || html2).direction === "rtl") {
        x2 += max(html2.clientWidth, body ? body.clientWidth : 0) - width;
      }
      return {
        width,
        height,
        x: x2,
        y: y2
      };
    }
    function isScrollParent(element) {
      var _getComputedStyle = getComputedStyle$1(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
      return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
    }
    function getScrollParent(node) {
      if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
        return node.ownerDocument.body;
      }
      if (isHTMLElement(node) && isScrollParent(node)) {
        return node;
      }
      return getScrollParent(getParentNode(node));
    }
    function listScrollParents(element, list) {
      var _element$ownerDocumen;
      if (list === void 0) {
        list = [];
      }
      var scrollParent = getScrollParent(element);
      var isBody2 = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
      var win = getWindow(scrollParent);
      var target = isBody2 ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
      var updatedList = list.concat(target);
      return isBody2 ? updatedList : (
        // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
        updatedList.concat(listScrollParents(getParentNode(target)))
      );
    }
    function rectToClientRect(rect) {
      return Object.assign({}, rect, {
        left: rect.x,
        top: rect.y,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height
      });
    }
    function getInnerBoundingClientRect(element, strategy) {
      var rect = getBoundingClientRect(element, false, strategy === "fixed");
      rect.top = rect.top + element.clientTop;
      rect.left = rect.left + element.clientLeft;
      rect.bottom = rect.top + element.clientHeight;
      rect.right = rect.left + element.clientWidth;
      rect.width = element.clientWidth;
      rect.height = element.clientHeight;
      rect.x = rect.left;
      rect.y = rect.top;
      return rect;
    }
    function getClientRectFromMixedType(element, clippingParent, strategy) {
      return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
    }
    function getClippingParents(element) {
      var clippingParents2 = listScrollParents(getParentNode(element));
      var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$1(element).position) >= 0;
      var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
      if (!isElement(clipperElement)) {
        return [];
      }
      return clippingParents2.filter(function(clippingParent) {
        return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
      });
    }
    function getClippingRect(element, boundary, rootBoundary, strategy) {
      var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
      var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
      var firstClippingParent = clippingParents2[0];
      var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
        var rect = getClientRectFromMixedType(element, clippingParent, strategy);
        accRect.top = max(rect.top, accRect.top);
        accRect.right = min(rect.right, accRect.right);
        accRect.bottom = min(rect.bottom, accRect.bottom);
        accRect.left = max(rect.left, accRect.left);
        return accRect;
      }, getClientRectFromMixedType(element, firstClippingParent, strategy));
      clippingRect.width = clippingRect.right - clippingRect.left;
      clippingRect.height = clippingRect.bottom - clippingRect.top;
      clippingRect.x = clippingRect.left;
      clippingRect.y = clippingRect.top;
      return clippingRect;
    }
    function computeOffsets(_ref) {
      var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
      var basePlacement = placement ? getBasePlacement(placement) : null;
      var variation = placement ? getVariation(placement) : null;
      var commonX = reference2.x + reference2.width / 2 - element.width / 2;
      var commonY = reference2.y + reference2.height / 2 - element.height / 2;
      var offsets;
      switch (basePlacement) {
        case top:
          offsets = {
            x: commonX,
            y: reference2.y - element.height
          };
          break;
        case bottom:
          offsets = {
            x: commonX,
            y: reference2.y + reference2.height
          };
          break;
        case right:
          offsets = {
            x: reference2.x + reference2.width,
            y: commonY
          };
          break;
        case left:
          offsets = {
            x: reference2.x - element.width,
            y: commonY
          };
          break;
        default:
          offsets = {
            x: reference2.x,
            y: reference2.y
          };
      }
      var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
      if (mainAxis != null) {
        var len = mainAxis === "y" ? "height" : "width";
        switch (variation) {
          case start:
            offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
            break;
          case end:
            offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
            break;
        }
      }
      return offsets;
    }
    function detectOverflow(state, options) {
      if (options === void 0) {
        options = {};
      }
      var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
      var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
      var altContext = elementContext === popper ? reference : popper;
      var popperRect = state.rects.popper;
      var element = state.elements[altBoundary ? altContext : elementContext];
      var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
      var referenceClientRect = getBoundingClientRect(state.elements.reference);
      var popperOffsets2 = computeOffsets({
        reference: referenceClientRect,
        element: popperRect,
        strategy: "absolute",
        placement
      });
      var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
      var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
      var overflowOffsets = {
        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
        right: elementClientRect.right - clippingClientRect.right + paddingObject.right
      };
      var offsetData = state.modifiersData.offset;
      if (elementContext === popper && offsetData) {
        var offset2 = offsetData[placement];
        Object.keys(overflowOffsets).forEach(function(key) {
          var multiply2 = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
          var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
          overflowOffsets[key] += offset2[axis] * multiply2;
        });
      }
      return overflowOffsets;
    }
    function computeAutoPlacement(state, options) {
      if (options === void 0) {
        options = {};
      }
      var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
      var variation = getVariation(placement);
      var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
        return getVariation(placement2) === variation;
      }) : basePlacements;
      var allowedPlacements = placements$1.filter(function(placement2) {
        return allowedAutoPlacements.indexOf(placement2) >= 0;
      });
      if (allowedPlacements.length === 0) {
        allowedPlacements = placements$1;
      }
      var overflows = allowedPlacements.reduce(function(acc, placement2) {
        acc[placement2] = detectOverflow(state, {
          placement: placement2,
          boundary,
          rootBoundary,
          padding
        })[getBasePlacement(placement2)];
        return acc;
      }, {});
      return Object.keys(overflows).sort(function(a2, b2) {
        return overflows[a2] - overflows[b2];
      });
    }
    function getExpandedFallbackPlacements(placement) {
      if (getBasePlacement(placement) === auto) {
        return [];
      }
      var oppositePlacement = getOppositePlacement(placement);
      return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
    }
    function flip(_ref) {
      var state = _ref.state, options = _ref.options, name = _ref.name;
      if (state.modifiersData[name]._skip) {
        return;
      }
      var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
      var preferredPlacement = state.options.placement;
      var basePlacement = getBasePlacement(preferredPlacement);
      var isBasePlacement = basePlacement === preferredPlacement;
      var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
      var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
        return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
          placement: placement2,
          boundary,
          rootBoundary,
          padding,
          flipVariations,
          allowedAutoPlacements
        }) : placement2);
      }, []);
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var checksMap = /* @__PURE__ */ new Map();
      var makeFallbackChecks = true;
      var firstFittingPlacement = placements2[0];
      for (var i2 = 0; i2 < placements2.length; i2++) {
        var placement = placements2[i2];
        var _basePlacement = getBasePlacement(placement);
        var isStartVariation = getVariation(placement) === start;
        var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
        var len = isVertical ? "width" : "height";
        var overflow = detectOverflow(state, {
          placement,
          boundary,
          rootBoundary,
          altBoundary,
          padding
        });
        var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
        if (referenceRect[len] > popperRect[len]) {
          mainVariationSide = getOppositePlacement(mainVariationSide);
        }
        var altVariationSide = getOppositePlacement(mainVariationSide);
        var checks = [];
        if (checkMainAxis) {
          checks.push(overflow[_basePlacement] <= 0);
        }
        if (checkAltAxis) {
          checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
        }
        if (checks.every(function(check2) {
          return check2;
        })) {
          firstFittingPlacement = placement;
          makeFallbackChecks = false;
          break;
        }
        checksMap.set(placement, checks);
      }
      if (makeFallbackChecks) {
        var numberOfChecks = flipVariations ? 3 : 1;
        var _loop = function _loop2(_i3) {
          var fittingPlacement = placements2.find(function(placement2) {
            var checks2 = checksMap.get(placement2);
            if (checks2) {
              return checks2.slice(0, _i3).every(function(check2) {
                return check2;
              });
            }
          });
          if (fittingPlacement) {
            firstFittingPlacement = fittingPlacement;
            return "break";
          }
        };
        for (var _i2 = numberOfChecks; _i2 > 0; _i2--) {
          var _ret = _loop(_i2);
          if (_ret === "break") break;
        }
      }
      if (state.placement !== firstFittingPlacement) {
        state.modifiersData[name]._skip = true;
        state.placement = firstFittingPlacement;
        state.reset = true;
      }
    }
    const flip$1 = {
      name: "flip",
      enabled: true,
      phase: "main",
      fn: flip,
      requiresIfExists: ["offset"],
      data: {
        _skip: false
      }
    };
    function getSideOffsets(overflow, rect, preventedOffsets) {
      if (preventedOffsets === void 0) {
        preventedOffsets = {
          x: 0,
          y: 0
        };
      }
      return {
        top: overflow.top - rect.height - preventedOffsets.y,
        right: overflow.right - rect.width + preventedOffsets.x,
        bottom: overflow.bottom - rect.height + preventedOffsets.y,
        left: overflow.left - rect.width - preventedOffsets.x
      };
    }
    function isAnySideFullyClipped(overflow) {
      return [top, right, bottom, left].some(function(side) {
        return overflow[side] >= 0;
      });
    }
    function hide(_ref) {
      var state = _ref.state, name = _ref.name;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var preventedOffsets = state.modifiersData.preventOverflow;
      var referenceOverflow = detectOverflow(state, {
        elementContext: "reference"
      });
      var popperAltOverflow = detectOverflow(state, {
        altBoundary: true
      });
      var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
      var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
      var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
      var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
      state.modifiersData[name] = {
        referenceClippingOffsets,
        popperEscapeOffsets,
        isReferenceHidden,
        hasPopperEscaped
      };
      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        "data-popper-reference-hidden": isReferenceHidden,
        "data-popper-escaped": hasPopperEscaped
      });
    }
    const hide$1 = {
      name: "hide",
      enabled: true,
      phase: "main",
      requiresIfExists: ["preventOverflow"],
      fn: hide
    };
    function distanceAndSkiddingToXY(placement, rects, offset2) {
      var basePlacement = getBasePlacement(placement);
      var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
      var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
        placement
      })) : offset2, skidding = _ref[0], distance = _ref[1];
      skidding = skidding || 0;
      distance = (distance || 0) * invertDistance;
      return [left, right].indexOf(basePlacement) >= 0 ? {
        x: distance,
        y: skidding
      } : {
        x: skidding,
        y: distance
      };
    }
    function offset(_ref2) {
      var state = _ref2.state, options = _ref2.options, name = _ref2.name;
      var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
      var data = placements.reduce(function(acc, placement) {
        acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
        return acc;
      }, {});
      var _data$state$placement = data[state.placement], x2 = _data$state$placement.x, y2 = _data$state$placement.y;
      if (state.modifiersData.popperOffsets != null) {
        state.modifiersData.popperOffsets.x += x2;
        state.modifiersData.popperOffsets.y += y2;
      }
      state.modifiersData[name] = data;
    }
    const offset$1 = {
      name: "offset",
      enabled: true,
      phase: "main",
      requires: ["popperOffsets"],
      fn: offset
    };
    function popperOffsets(_ref) {
      var state = _ref.state, name = _ref.name;
      state.modifiersData[name] = computeOffsets({
        reference: state.rects.reference,
        element: state.rects.popper,
        strategy: "absolute",
        placement: state.placement
      });
    }
    const popperOffsets$1 = {
      name: "popperOffsets",
      enabled: true,
      phase: "read",
      fn: popperOffsets,
      data: {}
    };
    function getAltAxis(axis) {
      return axis === "x" ? "y" : "x";
    }
    function preventOverflow(_ref) {
      var state = _ref.state, options = _ref.options, name = _ref.name;
      var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
      var overflow = detectOverflow(state, {
        boundary,
        rootBoundary,
        padding,
        altBoundary
      });
      var basePlacement = getBasePlacement(state.placement);
      var variation = getVariation(state.placement);
      var isBasePlacement = !variation;
      var mainAxis = getMainAxisFromPlacement(basePlacement);
      var altAxis = getAltAxis(mainAxis);
      var popperOffsets2 = state.modifiersData.popperOffsets;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
        placement: state.placement
      })) : tetherOffset;
      var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
        mainAxis: tetherOffsetValue,
        altAxis: tetherOffsetValue
      } : Object.assign({
        mainAxis: 0,
        altAxis: 0
      }, tetherOffsetValue);
      var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
      var data = {
        x: 0,
        y: 0
      };
      if (!popperOffsets2) {
        return;
      }
      if (checkMainAxis) {
        var _offsetModifierState$;
        var mainSide = mainAxis === "y" ? top : left;
        var altSide = mainAxis === "y" ? bottom : right;
        var len = mainAxis === "y" ? "height" : "width";
        var offset2 = popperOffsets2[mainAxis];
        var min$12 = offset2 + overflow[mainSide];
        var max$12 = offset2 - overflow[altSide];
        var additive = tether ? -popperRect[len] / 2 : 0;
        var minLen = variation === start ? referenceRect[len] : popperRect[len];
        var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
        var arrowElement = state.elements.arrow;
        var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
          width: 0,
          height: 0
        };
        var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
        var arrowPaddingMin = arrowPaddingObject[mainSide];
        var arrowPaddingMax = arrowPaddingObject[altSide];
        var arrowLen = within(0, referenceRect[len], arrowRect[len]);
        var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
        var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
        var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
        var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
        var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
        var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
        var tetherMax = offset2 + maxOffset - offsetModifierValue;
        var preventedOffset = within(tether ? min(min$12, tetherMin) : min$12, offset2, tether ? max(max$12, tetherMax) : max$12);
        popperOffsets2[mainAxis] = preventedOffset;
        data[mainAxis] = preventedOffset - offset2;
      }
      if (checkAltAxis) {
        var _offsetModifierState$2;
        var _mainSide = mainAxis === "x" ? top : left;
        var _altSide = mainAxis === "x" ? bottom : right;
        var _offset = popperOffsets2[altAxis];
        var _len = altAxis === "y" ? "height" : "width";
        var _min = _offset + overflow[_mainSide];
        var _max = _offset - overflow[_altSide];
        var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
        var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
        var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
        var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
        var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
        popperOffsets2[altAxis] = _preventedOffset;
        data[altAxis] = _preventedOffset - _offset;
      }
      state.modifiersData[name] = data;
    }
    const preventOverflow$1 = {
      name: "preventOverflow",
      enabled: true,
      phase: "main",
      fn: preventOverflow,
      requiresIfExists: ["offset"]
    };
    function getHTMLElementScroll(element) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }
    function getNodeScroll(node) {
      if (node === getWindow(node) || !isHTMLElement(node)) {
        return getWindowScroll(node);
      } else {
        return getHTMLElementScroll(node);
      }
    }
    function isElementScaled(element) {
      var rect = element.getBoundingClientRect();
      var scaleX = round(rect.width) / element.offsetWidth || 1;
      var scaleY = round(rect.height) / element.offsetHeight || 1;
      return scaleX !== 1 || scaleY !== 1;
    }
    function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
      if (isFixed === void 0) {
        isFixed = false;
      }
      var isOffsetParentAnElement = isHTMLElement(offsetParent);
      var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
      var documentElement = getDocumentElement(offsetParent);
      var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
      var scroll = {
        scrollLeft: 0,
        scrollTop: 0
      };
      var offsets = {
        x: 0,
        y: 0
      };
      if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
        isScrollParent(documentElement)) {
          scroll = getNodeScroll(offsetParent);
        }
        if (isHTMLElement(offsetParent)) {
          offsets = getBoundingClientRect(offsetParent, true);
          offsets.x += offsetParent.clientLeft;
          offsets.y += offsetParent.clientTop;
        } else if (documentElement) {
          offsets.x = getWindowScrollBarX(documentElement);
        }
      }
      return {
        x: rect.left + scroll.scrollLeft - offsets.x,
        y: rect.top + scroll.scrollTop - offsets.y,
        width: rect.width,
        height: rect.height
      };
    }
    function order(modifiers) {
      var map2 = /* @__PURE__ */ new Map();
      var visited = /* @__PURE__ */ new Set();
      var result2 = [];
      modifiers.forEach(function(modifier) {
        map2.set(modifier.name, modifier);
      });
      function sort(modifier) {
        visited.add(modifier.name);
        var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
        requires.forEach(function(dep) {
          if (!visited.has(dep)) {
            var depModifier = map2.get(dep);
            if (depModifier) {
              sort(depModifier);
            }
          }
        });
        result2.push(modifier);
      }
      modifiers.forEach(function(modifier) {
        if (!visited.has(modifier.name)) {
          sort(modifier);
        }
      });
      return result2;
    }
    function orderModifiers(modifiers) {
      var orderedModifiers = order(modifiers);
      return modifierPhases.reduce(function(acc, phase) {
        return acc.concat(orderedModifiers.filter(function(modifier) {
          return modifier.phase === phase;
        }));
      }, []);
    }
    function debounce(fn2) {
      var pending;
      return function() {
        if (!pending) {
          pending = new Promise(function(resolve) {
            Promise.resolve().then(function() {
              pending = void 0;
              resolve(fn2());
            });
          });
        }
        return pending;
      };
    }
    function mergeByName(modifiers) {
      var merged = modifiers.reduce(function(merged2, current) {
        var existing = merged2[current.name];
        merged2[current.name] = existing ? Object.assign({}, existing, current, {
          options: Object.assign({}, existing.options, current.options),
          data: Object.assign({}, existing.data, current.data)
        }) : current;
        return merged2;
      }, {});
      return Object.keys(merged).map(function(key) {
        return merged[key];
      });
    }
    var DEFAULT_OPTIONS = {
      placement: "bottom",
      modifiers: [],
      strategy: "absolute"
    };
    function areValidElements() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return !args.some(function(element) {
        return !(element && typeof element.getBoundingClientRect === "function");
      });
    }
    function popperGenerator(generatorOptions) {
      if (generatorOptions === void 0) {
        generatorOptions = {};
      }
      var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
      return function createPopper2(reference2, popper2, options) {
        if (options === void 0) {
          options = defaultOptions;
        }
        var state = {
          placement: "bottom",
          orderedModifiers: [],
          options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
          modifiersData: {},
          elements: {
            reference: reference2,
            popper: popper2
          },
          attributes: {},
          styles: {}
        };
        var effectCleanupFns = [];
        var isDestroyed = false;
        var instance = {
          state,
          setOptions: function setOptions(setOptionsAction) {
            var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
            cleanupModifierEffects();
            state.options = Object.assign({}, defaultOptions, state.options, options2);
            state.scrollParents = {
              reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
              popper: listScrollParents(popper2)
            };
            var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
            state.orderedModifiers = orderedModifiers.filter(function(m2) {
              return m2.enabled;
            });
            runModifierEffects();
            return instance.update();
          },
          // Sync update  it will always be executed, even if not necessary. This
          // is useful for low frequency updates where sync behavior simplifies the
          // logic.
          // For high frequency updates (e.g. `resize` and `scroll` events), always
          // prefer the async Popper#update method
          forceUpdate: function forceUpdate() {
            if (isDestroyed) {
              return;
            }
            var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
            if (!areValidElements(reference3, popper3)) {
              return;
            }
            state.rects = {
              reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
              popper: getLayoutRect(popper3)
            };
            state.reset = false;
            state.placement = state.options.placement;
            state.orderedModifiers.forEach(function(modifier) {
              return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
            });
            for (var index = 0; index < state.orderedModifiers.length; index++) {
              if (state.reset === true) {
                state.reset = false;
                index = -1;
                continue;
              }
              var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
              if (typeof fn2 === "function") {
                state = fn2({
                  state,
                  options: _options,
                  name,
                  instance
                }) || state;
              }
            }
          },
          // Async and optimistically optimized update  it will not be executed if
          // not necessary (debounced to run at most once-per-tick)
          update: debounce(function() {
            return new Promise(function(resolve) {
              instance.forceUpdate();
              resolve(state);
            });
          }),
          destroy: function destroy() {
            cleanupModifierEffects();
            isDestroyed = true;
          }
        };
        if (!areValidElements(reference2, popper2)) {
          return instance;
        }
        instance.setOptions(options).then(function(state2) {
          if (!isDestroyed && options.onFirstUpdate) {
            options.onFirstUpdate(state2);
          }
        });
        function runModifierEffects() {
          state.orderedModifiers.forEach(function(_ref) {
            var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect2 = _ref.effect;
            if (typeof effect2 === "function") {
              var cleanupFn = effect2({
                state,
                name,
                instance,
                options: options2
              });
              var noopFn = function noopFn2() {
              };
              effectCleanupFns.push(cleanupFn || noopFn);
            }
          });
        }
        function cleanupModifierEffects() {
          effectCleanupFns.forEach(function(fn2) {
            return fn2();
          });
          effectCleanupFns = [];
        }
        return instance;
      };
    }
    var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
    var createPopper = /* @__PURE__ */ popperGenerator({
      defaultModifiers
    });
    /*!
     * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
     *
     * Copyright (c) 2014-2017, Jon Schlinkert.
     * Released under the MIT License.
     */
    function isObject(o2) {
      return Object.prototype.toString.call(o2) === "[object Object]";
    }
    function isPlainObject(o2) {
      var ctor, prot;
      if (isObject(o2) === false) return false;
      ctor = o2.constructor;
      if (ctor === void 0) return true;
      prot = ctor.prototype;
      if (isObject(prot) === false) return false;
      if (prot.hasOwnProperty("isPrototypeOf") === false) {
        return false;
      }
      return true;
    }
    function t$1() {
      return t$1 = Object.assign ? Object.assign.bind() : function(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var r2 = arguments[t2];
          for (var n2 in r2) Object.prototype.hasOwnProperty.call(r2, n2) && (e2[n2] = r2[n2]);
        }
        return e2;
      }, t$1.apply(this, arguments);
    }
    function r$1(e2, t2) {
      if (null == e2) return {};
      var r2, n2, i2 = {}, o2 = Object.keys(e2);
      for (n2 = 0; n2 < o2.length; n2++) t2.indexOf(r2 = o2[n2]) >= 0 || (i2[r2] = e2[r2]);
      return i2;
    }
    const n$1 = { silent: false, logLevel: "warn" }, i$1 = ["validator"], o$1 = Object.prototype, a$1 = o$1.toString, s$1 = o$1.hasOwnProperty, u$1 = /^\s*function (\w+)/;
    function l$1(e2) {
      var t2;
      const r2 = null !== (t2 = null == e2 ? void 0 : e2.type) && void 0 !== t2 ? t2 : e2;
      if (r2) {
        const e3 = r2.toString().match(u$1);
        return e3 ? e3[1] : "";
      }
      return "";
    }
    const c$1 = isPlainObject, f$1 = (e2) => e2;
    let d$1 = f$1;
    {
      const e2 = "undefined" != typeof console;
      d$1 = e2 ? function(e3, t2 = n$1.logLevel) {
        false === n$1.silent && console[t2](`[VueTypes warn]: ${e3}`);
      } : f$1;
    }
    const p$1 = (e2, t2) => s$1.call(e2, t2), y$1 = Number.isInteger || function(e2) {
      return "number" == typeof e2 && isFinite(e2) && Math.floor(e2) === e2;
    }, v$1 = Array.isArray || function(e2) {
      return "[object Array]" === a$1.call(e2);
    }, h$1 = (e2) => "[object Function]" === a$1.call(e2), b$1 = (e2) => c$1(e2) && p$1(e2, "_vueTypes_name"), g$1 = (e2) => c$1(e2) && (p$1(e2, "type") || ["_vueTypes_name", "validator", "default", "required"].some((t2) => p$1(e2, t2)));
    function O$1(e2, t2) {
      return Object.defineProperty(e2.bind(t2), "__original", { value: e2 });
    }
    function m$1(e2, t2, r2 = false) {
      let n2, i2 = true, o2 = "";
      n2 = c$1(e2) ? e2 : { type: e2 };
      const a2 = b$1(n2) ? n2._vueTypes_name + " - " : "";
      if (g$1(n2) && null !== n2.type) {
        if (void 0 === n2.type || true === n2.type) return i2;
        if (!n2.required && void 0 === t2) return i2;
        v$1(n2.type) ? (i2 = n2.type.some((e3) => true === m$1(e3, t2, true)), o2 = n2.type.map((e3) => l$1(e3)).join(" or ")) : (o2 = l$1(n2), i2 = "Array" === o2 ? v$1(t2) : "Object" === o2 ? c$1(t2) : "String" === o2 || "Number" === o2 || "Boolean" === o2 || "Function" === o2 ? function(e3) {
          if (null == e3) return "";
          const t3 = e3.constructor.toString().match(u$1);
          return t3 ? t3[1] : "";
        }(t2) === o2 : t2 instanceof n2.type);
      }
      if (!i2) {
        const e3 = `${a2}value "${t2}" should be of type "${o2}"`;
        return false === r2 ? (d$1(e3), false) : e3;
      }
      if (p$1(n2, "validator") && h$1(n2.validator)) {
        const e3 = d$1, o3 = [];
        if (d$1 = (e4) => {
          o3.push(e4);
        }, i2 = n2.validator(t2), d$1 = e3, !i2) {
          const e4 = (o3.length > 1 ? "* " : "") + o3.join("\n* ");
          return o3.length = 0, false === r2 ? (d$1(e4), i2) : e4;
        }
      }
      return i2;
    }
    function j$1(e2, t2) {
      const r2 = Object.defineProperties(t2, { _vueTypes_name: { value: e2, writable: true }, isRequired: { get() {
        return this.required = true, this;
      } }, def: { value(e3) {
        return void 0 === e3 ? (p$1(this, "default") && delete this.default, this) : h$1(e3) || true === m$1(this, e3, true) ? (this.default = v$1(e3) ? () => [...e3] : c$1(e3) ? () => Object.assign({}, e3) : e3, this) : (d$1(`${this._vueTypes_name} - invalid default value: "${e3}"`), this);
      } } }), { validator: n2 } = r2;
      return h$1(n2) && (r2.validator = O$1(n2, r2)), r2;
    }
    function _$1(e2, t2) {
      const r2 = j$1(e2, t2);
      return Object.defineProperty(r2, "validate", { value(e3) {
        return h$1(this.validator) && d$1(`${this._vueTypes_name} - calling .validate() will overwrite the current custom validator function. Validator info:
${JSON.stringify(this)}`), this.validator = O$1(e3, this), this;
      } });
    }
    function T$1(e2, t2, n2) {
      const o2 = function(e3) {
        const t3 = {};
        return Object.getOwnPropertyNames(e3).forEach((r2) => {
          t3[r2] = Object.getOwnPropertyDescriptor(e3, r2);
        }), Object.defineProperties({}, t3);
      }(t2);
      if (o2._vueTypes_name = e2, !c$1(n2)) return o2;
      const { validator: a2 } = n2, s2 = r$1(n2, i$1);
      if (h$1(a2)) {
        let { validator: e3 } = o2;
        e3 && (e3 = null !== (l2 = (u2 = e3).__original) && void 0 !== l2 ? l2 : u2), o2.validator = O$1(e3 ? function(t3) {
          return e3.call(this, t3) && a2.call(this, t3);
        } : a2, o2);
      }
      var u2, l2;
      return Object.assign(o2, s2);
    }
    function $$2(e2) {
      return e2.replace(/^(?!\s*$)/gm, "  ");
    }
    const w$1 = () => _$1("any", {}), P$2 = () => _$1("function", { type: Function }), x$1 = () => _$1("boolean", { type: Boolean }), E$1 = () => _$1("string", { type: String }), N$1 = () => _$1("number", { type: Number }), q$2 = () => _$1("array", { type: Array }), A$2 = () => _$1("object", { type: Object }), V$1 = () => j$1("integer", { type: Number, validator: (e2) => y$1(e2) }), S$1 = () => j$1("symbol", { validator: (e2) => "symbol" == typeof e2 });
    function D$1(e2, t2 = "custom validation failed") {
      if ("function" != typeof e2) throw new TypeError("[VueTypes error]: You must provide a function as argument");
      return j$1(e2.name || "<<anonymous function>>", { type: null, validator(r2) {
        const n2 = e2(r2);
        return n2 || d$1(`${this._vueTypes_name} - ${t2}`), n2;
      } });
    }
    function L$1(e2) {
      if (!v$1(e2)) throw new TypeError("[VueTypes error]: You must provide an array as argument.");
      const t2 = `oneOf - value should be one of "${e2.join('", "')}".`, r2 = e2.reduce((e3, t3) => {
        if (null != t3) {
          const r3 = t3.constructor;
          -1 === e3.indexOf(r3) && e3.push(r3);
        }
        return e3;
      }, []);
      return j$1("oneOf", { type: r2.length > 0 ? r2 : void 0, validator(r3) {
        const n2 = -1 !== e2.indexOf(r3);
        return n2 || d$1(t2), n2;
      } });
    }
    function F$1(e2) {
      if (!v$1(e2)) throw new TypeError("[VueTypes error]: You must provide an array as argument");
      let t2 = false, r2 = [];
      for (let n3 = 0; n3 < e2.length; n3 += 1) {
        const i2 = e2[n3];
        if (g$1(i2)) {
          if (b$1(i2) && "oneOf" === i2._vueTypes_name && i2.type) {
            r2 = r2.concat(i2.type);
            continue;
          }
          if (h$1(i2.validator) && (t2 = true), true === i2.type || !i2.type) {
            d$1('oneOfType - invalid usage of "true" or "null" as types.');
            continue;
          }
          r2 = r2.concat(i2.type);
        } else r2.push(i2);
      }
      r2 = r2.filter((e3, t3) => r2.indexOf(e3) === t3);
      const n2 = r2.length > 0 ? r2 : null;
      return j$1("oneOfType", t2 ? { type: n2, validator(t3) {
        const r3 = [], n3 = e2.some((e3) => {
          const n4 = m$1(b$1(e3) && "oneOf" === e3._vueTypes_name ? e3.type || null : e3, t3, true);
          return "string" == typeof n4 && r3.push(n4), true === n4;
        });
        return n3 || d$1(`oneOfType - provided value does not match any of the ${r3.length} passed-in validators:
${$$2(r3.join("\n"))}`), n3;
      } } : { type: n2 });
    }
    function Y$1(e2) {
      return j$1("arrayOf", { type: Array, validator(t2) {
        let r2 = "";
        const n2 = t2.every((t3) => (r2 = m$1(e2, t3, true), true === r2));
        return n2 || d$1(`arrayOf - value validation error:
${$$2(r2)}`), n2;
      } });
    }
    function B$1(e2) {
      return j$1("instanceOf", { type: e2 });
    }
    function I$1(e2) {
      return j$1("objectOf", { type: Object, validator(t2) {
        let r2 = "";
        const n2 = Object.keys(t2).every((n3) => (r2 = m$1(e2, t2[n3], true), true === r2));
        return n2 || d$1(`objectOf - value validation error:
${$$2(r2)}`), n2;
      } });
    }
    function J$1(e2) {
      const t2 = Object.keys(e2), r2 = t2.filter((t3) => {
        var r3;
        return !(null === (r3 = e2[t3]) || void 0 === r3 || !r3.required);
      }), n2 = j$1("shape", { type: Object, validator(n3) {
        if (!c$1(n3)) return false;
        const i2 = Object.keys(n3);
        if (r2.length > 0 && r2.some((e3) => -1 === i2.indexOf(e3))) {
          const e3 = r2.filter((e4) => -1 === i2.indexOf(e4));
          return d$1(1 === e3.length ? `shape - required property "${e3[0]}" is not defined.` : `shape - required properties "${e3.join('", "')}" are not defined.`), false;
        }
        return i2.every((r3) => {
          if (-1 === t2.indexOf(r3)) return true === this._vueTypes_isLoose || (d$1(`shape - shape definition does not include a "${r3}" property. Allowed keys: "${t2.join('", "')}".`), false);
          const i3 = m$1(e2[r3], n3[r3], true);
          return "string" == typeof i3 && d$1(`shape - "${r3}" property validation error:
 ${$$2(i3)}`), true === i3;
        });
      } });
      return Object.defineProperty(n2, "_vueTypes_isLoose", { writable: true, value: false }), Object.defineProperty(n2, "loose", { get() {
        return this._vueTypes_isLoose = true, this;
      } }), n2;
    }
    const M$1 = ["name", "validate", "getter"], R$1 = /* @__PURE__ */ (() => {
      var e2;
      return (e2 = class {
        static get any() {
          return w$1();
        }
        static get func() {
          return P$2().def(this.defaults.func);
        }
        static get bool() {
          return x$1().def(this.defaults.bool);
        }
        static get string() {
          return E$1().def(this.defaults.string);
        }
        static get number() {
          return N$1().def(this.defaults.number);
        }
        static get array() {
          return q$2().def(this.defaults.array);
        }
        static get object() {
          return A$2().def(this.defaults.object);
        }
        static get integer() {
          return V$1().def(this.defaults.integer);
        }
        static get symbol() {
          return S$1();
        }
        static get nullable() {
          return { type: null };
        }
        static extend(e3) {
          if (v$1(e3)) return e3.forEach((e4) => this.extend(e4)), this;
          const { name: t2, validate: n2 = false, getter: i2 = false } = e3, o2 = r$1(e3, M$1);
          if (p$1(this, t2)) throw new TypeError(`[VueTypes error]: Type "${t2}" already defined`);
          const { type: a2 } = o2;
          if (b$1(a2)) return delete o2.type, Object.defineProperty(this, t2, i2 ? { get: () => T$1(t2, a2, o2) } : { value(...e4) {
            const r2 = T$1(t2, a2, o2);
            return r2.validator && (r2.validator = r2.validator.bind(r2, ...e4)), r2;
          } });
          let s2;
          return s2 = i2 ? { get() {
            const e4 = Object.assign({}, o2);
            return n2 ? _$1(t2, e4) : j$1(t2, e4);
          }, enumerable: true } : { value(...e4) {
            const r2 = Object.assign({}, o2);
            let i3;
            return i3 = n2 ? _$1(t2, r2) : j$1(t2, r2), r2.validator && (i3.validator = r2.validator.bind(i3, ...e4)), i3;
          }, enumerable: true }, Object.defineProperty(this, t2, s2);
        }
      }).defaults = {}, e2.sensibleDefaults = void 0, e2.config = n$1, e2.custom = D$1, e2.oneOf = L$1, e2.instanceOf = B$1, e2.oneOfType = F$1, e2.arrayOf = Y$1, e2.objectOf = I$1, e2.shape = J$1, e2.utils = { validate: (e3, t2) => true === m$1(t2, e3, true), toType: (e3, t2, r2 = false) => r2 ? _$1(e3, t2) : j$1(e3, t2) }, e2;
    })();
    function z$1(e2 = { func: () => {
    }, bool: true, string: "", number: 0, array: () => [], object: () => ({}), integer: 0 }) {
      var r2;
      return (r2 = class extends R$1 {
        static get sensibleDefaults() {
          return t$1({}, this.defaults);
        }
        static set sensibleDefaults(r3) {
          this.defaults = false !== r3 ? t$1({}, true !== r3 ? r3 : e2) : {};
        }
      }).defaults = t$1({}, e2), r2;
    }
    let C$1 = class C extends z$1() {
    };
    var t = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
    function e(t2) {
      var e2 = { exports: {} };
      return t2(e2, e2.exports), e2.exports;
    }
    var n = function(t2) {
      return t2 && t2.Math == Math && t2;
    }, r = n("object" == typeof globalThis && globalThis) || n("object" == typeof window && window) || n("object" == typeof self && self) || n("object" == typeof t && t) || /* @__PURE__ */ function() {
      return this;
    }() || Function("return this")(), o = function(t2) {
      try {
        return !!t2();
      } catch (t3) {
        return true;
      }
    }, i = !o(function() {
      return 7 != Object.defineProperty({}, 1, { get: function() {
        return 7;
      } })[1];
    }), u = {}.propertyIsEnumerable, a = Object.getOwnPropertyDescriptor, c = { f: a && !u.call({ 1: 2 }, 1) ? function(t2) {
      var e2 = a(this, t2);
      return !!e2 && e2.enumerable;
    } : u }, l = function(t2, e2) {
      return { enumerable: !(1 & t2), configurable: !(2 & t2), writable: !(4 & t2), value: e2 };
    }, f = {}.toString, s = function(t2) {
      return f.call(t2).slice(8, -1);
    }, d = "".split, v = o(function() {
      return !Object("z").propertyIsEnumerable(0);
    }) ? function(t2) {
      return "String" == s(t2) ? d.call(t2, "") : Object(t2);
    } : Object, p = function(t2) {
      if (null == t2) throw TypeError("Can't call method on " + t2);
      return t2;
    }, g = function(t2) {
      return v(p(t2));
    }, h = function(t2) {
      return "object" == typeof t2 ? null !== t2 : "function" == typeof t2;
    }, y = function(t2, e2) {
      if (!h(t2)) return t2;
      var n2, r2;
      if (e2 && "function" == typeof (n2 = t2.toString) && !h(r2 = n2.call(t2))) return r2;
      if ("function" == typeof (n2 = t2.valueOf) && !h(r2 = n2.call(t2))) return r2;
      if (!e2 && "function" == typeof (n2 = t2.toString) && !h(r2 = n2.call(t2))) return r2;
      throw TypeError("Can't convert object to primitive value");
    }, m = {}.hasOwnProperty, S = function(t2, e2) {
      return m.call(t2, e2);
    }, x = r.document, b = h(x) && h(x.createElement), E = function(t2) {
      return b ? x.createElement(t2) : {};
    }, w = !i && !o(function() {
      return 7 != Object.defineProperty(E("div"), "a", { get: function() {
        return 7;
      } }).a;
    }), O = Object.getOwnPropertyDescriptor, T = { f: i ? O : function(t2, e2) {
      if (t2 = g(t2), e2 = y(e2, true), w) try {
        return O(t2, e2);
      } catch (t3) {
      }
      if (S(t2, e2)) return l(!c.f.call(t2, e2), t2[e2]);
    } }, A$1 = function(t2) {
      if (!h(t2)) throw TypeError(String(t2) + " is not an object");
      return t2;
    }, k = Object.defineProperty, R = { f: i ? k : function(t2, e2, n2) {
      if (A$1(t2), e2 = y(e2, true), A$1(n2), w) try {
        return k(t2, e2, n2);
      } catch (t3) {
      }
      if ("get" in n2 || "set" in n2) throw TypeError("Accessors not supported");
      return "value" in n2 && (t2[e2] = n2.value), t2;
    } }, I = i ? function(t2, e2, n2) {
      return R.f(t2, e2, l(1, n2));
    } : function(t2, e2, n2) {
      return t2[e2] = n2, t2;
    }, j = function(t2, e2) {
      try {
        I(r, t2, e2);
      } catch (n2) {
        r[t2] = e2;
      }
      return e2;
    }, C = r["__core-js_shared__"] || j("__core-js_shared__", {}), L = Function.toString;
    "function" != typeof C.inspectSource && (C.inspectSource = function(t2) {
      return L.call(t2);
    });
    var P$1, M, _, D = C.inspectSource, U = r.WeakMap, N = "function" == typeof U && /native code/.test(D(U)), F = e(function(t2) {
      (t2.exports = function(t3, e2) {
        return C[t3] || (C[t3] = void 0 !== e2 ? e2 : {});
      })("versions", []).push({ version: "3.8.3", mode: "global", copyright: " 2021 Denis Pushkarev (zloirock.ru)" });
    }), W$1 = 0, z = Math.random(), $$1 = function(t2) {
      return "Symbol(" + String(void 0 === t2 ? "" : t2) + ")_" + (++W$1 + z).toString(36);
    }, B = F("keys"), Y = function(t2) {
      return B[t2] || (B[t2] = $$1(t2));
    }, G = {}, H = r.WeakMap;
    if (N) {
      var X = C.state || (C.state = new H()), V = X.get, K = X.has, q$1 = X.set;
      P$1 = function(t2, e2) {
        return e2.facade = t2, q$1.call(X, t2, e2), e2;
      }, M = function(t2) {
        return V.call(X, t2) || {};
      }, _ = function(t2) {
        return K.call(X, t2);
      };
    } else {
      var Q = Y("state");
      G[Q] = true, P$1 = function(t2, e2) {
        return e2.facade = t2, I(t2, Q, e2), e2;
      }, M = function(t2) {
        return S(t2, Q) ? t2[Q] : {};
      }, _ = function(t2) {
        return S(t2, Q);
      };
    }
    var J = { set: P$1, get: M, has: _, enforce: function(t2) {
      return _(t2) ? M(t2) : P$1(t2, {});
    }, getterFor: function(t2) {
      return function(e2) {
        var n2;
        if (!h(e2) || (n2 = M(e2)).type !== t2) throw TypeError("Incompatible receiver, " + t2 + " required");
        return n2;
      };
    } }, Z = e(function(t2) {
      var e2 = J.get, n2 = J.enforce, o2 = String(String).split("String");
      (t2.exports = function(t3, e3, i2, u2) {
        var a2, c2 = !!u2 && !!u2.unsafe, l2 = !!u2 && !!u2.enumerable, f2 = !!u2 && !!u2.noTargetGet;
        "function" == typeof i2 && ("string" != typeof e3 || S(i2, "name") || I(i2, "name", e3), (a2 = n2(i2)).source || (a2.source = o2.join("string" == typeof e3 ? e3 : ""))), t3 !== r ? (c2 ? !f2 && t3[e3] && (l2 = true) : delete t3[e3], l2 ? t3[e3] = i2 : I(t3, e3, i2)) : l2 ? t3[e3] = i2 : j(e3, i2);
      })(Function.prototype, "toString", function() {
        return "function" == typeof this && e2(this).source || D(this);
      });
    }), tt = r, et = function(t2) {
      return "function" == typeof t2 ? t2 : void 0;
    }, nt = function(t2, e2) {
      return arguments.length < 2 ? et(tt[t2]) || et(r[t2]) : tt[t2] && tt[t2][e2] || r[t2] && r[t2][e2];
    }, rt = Math.ceil, ot = Math.floor, it$1 = function(t2) {
      return isNaN(t2 = +t2) ? 0 : (t2 > 0 ? ot : rt)(t2);
    }, ut$1 = Math.min, at = function(t2) {
      return t2 > 0 ? ut$1(it$1(t2), 9007199254740991) : 0;
    }, ct$1 = Math.max, lt$1 = Math.min, ft$1 = function(t2, e2) {
      var n2 = it$1(t2);
      return n2 < 0 ? ct$1(n2 + e2, 0) : lt$1(n2, e2);
    }, st$1 = function(t2) {
      return function(e2, n2, r2) {
        var o2, i2 = g(e2), u2 = at(i2.length), a2 = ft$1(r2, u2);
        if (t2 && n2 != n2) {
          for (; u2 > a2; ) if ((o2 = i2[a2++]) != o2) return true;
        } else for (; u2 > a2; a2++) if ((t2 || a2 in i2) && i2[a2] === n2) return t2 || a2 || 0;
        return !t2 && -1;
      };
    }, dt$1 = { includes: st$1(true), indexOf: st$1(false) }, vt$1 = dt$1.indexOf, pt$1 = function(t2, e2) {
      var n2, r2 = g(t2), o2 = 0, i2 = [];
      for (n2 in r2) !S(G, n2) && S(r2, n2) && i2.push(n2);
      for (; e2.length > o2; ) S(r2, n2 = e2[o2++]) && (~vt$1(i2, n2) || i2.push(n2));
      return i2;
    }, gt$1 = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], ht$1 = gt$1.concat("length", "prototype"), yt$1 = { f: Object.getOwnPropertyNames || function(t2) {
      return pt$1(t2, ht$1);
    } }, mt$1 = { f: Object.getOwnPropertySymbols }, St$1 = nt("Reflect", "ownKeys") || function(t2) {
      var e2 = yt$1.f(A$1(t2)), n2 = mt$1.f;
      return n2 ? e2.concat(n2(t2)) : e2;
    }, xt$1 = function(t2, e2) {
      for (var n2 = St$1(e2), r2 = R.f, o2 = T.f, i2 = 0; i2 < n2.length; i2++) {
        var u2 = n2[i2];
        S(t2, u2) || r2(t2, u2, o2(e2, u2));
      }
    }, bt$1 = /#|\.prototype\./, Et$1 = function(t2, e2) {
      var n2 = Ot$1[wt$1(t2)];
      return n2 == At$1 || n2 != Tt$1 && ("function" == typeof e2 ? o(e2) : !!e2);
    }, wt$1 = Et$1.normalize = function(t2) {
      return String(t2).replace(bt$1, ".").toLowerCase();
    }, Ot$1 = Et$1.data = {}, Tt$1 = Et$1.NATIVE = "N", At$1 = Et$1.POLYFILL = "P", kt$1 = Et$1, Rt$1 = T.f, It$1 = function(t2, e2) {
      var n2, o2, i2, u2, a2, c2 = t2.target, l2 = t2.global, f2 = t2.stat;
      if (n2 = l2 ? r : f2 ? r[c2] || j(c2, {}) : (r[c2] || {}).prototype) for (o2 in e2) {
        if (u2 = e2[o2], i2 = t2.noTargetGet ? (a2 = Rt$1(n2, o2)) && a2.value : n2[o2], !kt$1(l2 ? o2 : c2 + (f2 ? "." : "#") + o2, t2.forced) && void 0 !== i2) {
          if (typeof u2 == typeof i2) continue;
          xt$1(u2, i2);
        }
        (t2.sham || i2 && i2.sham) && I(u2, "sham", true), Z(n2, o2, u2, t2);
      }
    }, jt$1 = function(t2, e2) {
      var n2 = [][t2];
      return !!n2 && o(function() {
        n2.call(null, e2 || function() {
          throw 1;
        }, 1);
      });
    }, Ct$1 = Object.defineProperty, Lt$1 = {}, Pt$1 = function(t2) {
      throw t2;
    }, Mt$1 = function(t2, e2) {
      if (S(Lt$1, t2)) return Lt$1[t2];
      e2 || (e2 = {});
      var n2 = [][t2], r2 = !!S(e2, "ACCESSORS") && e2.ACCESSORS, u2 = S(e2, 0) ? e2[0] : Pt$1, a2 = S(e2, 1) ? e2[1] : void 0;
      return Lt$1[t2] = !!n2 && !o(function() {
        if (r2 && !i) return true;
        var t3 = { length: -1 };
        r2 ? Ct$1(t3, 1, { enumerable: true, get: Pt$1 }) : t3[1] = 1, n2.call(t3, u2, a2);
      });
    }, _t$1 = dt$1.indexOf, Dt$1 = [].indexOf, Ut$1 = !!Dt$1 && 1 / [1].indexOf(1, -0) < 0, Nt$1 = jt$1("indexOf"), Ft$1 = Mt$1("indexOf", { ACCESSORS: true, 1: 0 });
    function Wt$1(t2, e2) {
      if (!(t2 instanceof e2)) throw new TypeError("Cannot call a class as a function");
    }
    function zt$1(t2, e2) {
      for (var n2 = 0; n2 < e2.length; n2++) {
        var r2 = e2[n2];
        r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t2, r2.key, r2);
      }
    }
    function $t$1(t2, e2, n2) {
      return n2 && zt$1(t2, n2), t2;
    }
    It$1({ target: "Array", proto: true, forced: Ut$1 || !Nt$1 || !Ft$1 }, { indexOf: function(t2) {
      return Ut$1 ? Dt$1.apply(this, arguments) || 0 : _t$1(this, t2, arguments.length > 1 ? arguments[1] : void 0);
    } });
    (function() {
      function t2() {
        Wt$1(this, t2);
      }
      return $t$1(t2, null, [{ key: "isInBrowser", value: function() {
        return "undefined" != typeof window;
      } }, { key: "isServer", value: function() {
        return "undefined" == typeof window;
      } }, { key: "getUA", value: function() {
        return t2.isInBrowser() ? window.navigator.userAgent.toLowerCase() : "";
      } }, { key: "isMobile", value: function() {
        return /Mobile|mini|Fennec|Android|iP(ad|od|hone)/.test(navigator.appVersion);
      } }, { key: "isOpera", value: function() {
        return -1 !== navigator.userAgent.indexOf("Opera");
      } }, { key: "isIE", value: function() {
        var e2 = t2.getUA();
        return "" !== e2 && e2.indexOf("msie") > 0;
      } }, { key: "isIE9", value: function() {
        var e2 = t2.getUA();
        return "" !== e2 && e2.indexOf("msie 9.0") > 0;
      } }, { key: "isEdge", value: function() {
        var e2 = t2.getUA();
        return "" !== e2 && e2.indexOf("edge/") > 0;
      } }, { key: "isChrome", value: function() {
        var e2 = t2.getUA();
        return "" !== e2 && /chrome\/\d+/.test(e2) && !t2.isEdge();
      } }, { key: "isPhantomJS", value: function() {
        var e2 = t2.getUA();
        return "" !== e2 && /phantomjs/.test(e2);
      } }, { key: "isFirefox", value: function() {
        var e2 = t2.getUA();
        return "" !== e2 && /firefox/.test(e2);
      } }]), t2;
    })();
    var Yt$1 = [].join, Gt$1 = v != Object, Ht$1 = jt$1("join", ",");
    It$1({ target: "Array", proto: true, forced: Gt$1 || !Ht$1 }, { join: function(t2) {
      return Yt$1.call(g(this), void 0 === t2 ? "," : t2);
    } });
    var Xt$1, Vt$1, Kt$1 = function(t2) {
      return Object(p(t2));
    }, qt$1 = Array.isArray || function(t2) {
      return "Array" == s(t2);
    }, Qt$1 = !!Object.getOwnPropertySymbols && !o(function() {
      return !String(Symbol());
    }), Jt$1 = Qt$1 && !Symbol.sham && "symbol" == typeof Symbol.iterator, Zt$1 = F("wks"), te = r.Symbol, ee = Jt$1 ? te : te && te.withoutSetter || $$1, ne = function(t2) {
      return S(Zt$1, t2) || (Qt$1 && S(te, t2) ? Zt$1[t2] = te[t2] : Zt$1[t2] = ee("Symbol." + t2)), Zt$1[t2];
    }, re$1 = ne("species"), oe = function(t2, e2) {
      var n2;
      return qt$1(t2) && ("function" != typeof (n2 = t2.constructor) || n2 !== Array && !qt$1(n2.prototype) ? h(n2) && null === (n2 = n2[re$1]) && (n2 = void 0) : n2 = void 0), new (void 0 === n2 ? Array : n2)(0 === e2 ? 0 : e2);
    }, ie = function(t2, e2, n2) {
      var r2 = y(e2);
      r2 in t2 ? R.f(t2, r2, l(0, n2)) : t2[r2] = n2;
    }, ue$1 = nt("navigator", "userAgent") || "", ae = r.process, ce = ae && ae.versions, le = ce && ce.v8;
    le ? Vt$1 = (Xt$1 = le.split("."))[0] + Xt$1[1] : ue$1 && (!(Xt$1 = ue$1.match(/Edge\/(\d+)/)) || Xt$1[1] >= 74) && (Xt$1 = ue$1.match(/Chrome\/(\d+)/)) && (Vt$1 = Xt$1[1]);
    var fe$1 = Vt$1 && +Vt$1, se = ne("species"), de$1 = function(t2) {
      return fe$1 >= 51 || !o(function() {
        var e2 = [];
        return (e2.constructor = {})[se] = function() {
          return { foo: 1 };
        }, 1 !== e2[t2](Boolean).foo;
      });
    }, ve$1 = de$1("splice"), pe = Mt$1("splice", { ACCESSORS: true, 0: 0, 1: 2 }), ge = Math.max, he = Math.min;
    It$1({ target: "Array", proto: true, forced: !ve$1 || !pe }, { splice: function(t2, e2) {
      var n2, r2, o2, i2, u2, a2, c2 = Kt$1(this), l2 = at(c2.length), f2 = ft$1(t2, l2), s2 = arguments.length;
      if (0 === s2 ? n2 = r2 = 0 : 1 === s2 ? (n2 = 0, r2 = l2 - f2) : (n2 = s2 - 2, r2 = he(ge(it$1(e2), 0), l2 - f2)), l2 + n2 - r2 > 9007199254740991) throw TypeError("Maximum allowed length exceeded");
      for (o2 = oe(c2, r2), i2 = 0; i2 < r2; i2++) (u2 = f2 + i2) in c2 && ie(o2, i2, c2[u2]);
      if (o2.length = r2, n2 < r2) {
        for (i2 = f2; i2 < l2 - r2; i2++) a2 = i2 + n2, (u2 = i2 + r2) in c2 ? c2[a2] = c2[u2] : delete c2[a2];
        for (i2 = l2; i2 > l2 - r2 + n2; i2--) delete c2[i2 - 1];
      } else if (n2 > r2) for (i2 = l2 - r2; i2 > f2; i2--) a2 = i2 + n2 - 1, (u2 = i2 + r2 - 1) in c2 ? c2[a2] = c2[u2] : delete c2[a2];
      for (i2 = 0; i2 < n2; i2++) c2[i2 + f2] = arguments[i2 + 2];
      return c2.length = l2 - r2 + n2, o2;
    } });
    var ye$1 = {};
    ye$1[ne("toStringTag")] = "z";
    var me$1 = "[object z]" === String(ye$1), Se$1 = ne("toStringTag"), xe = "Arguments" == s(/* @__PURE__ */ function() {
      return arguments;
    }()), be$1 = me$1 ? s : function(t2) {
      var e2, n2, r2;
      return void 0 === t2 ? "Undefined" : null === t2 ? "Null" : "string" == typeof (n2 = function(t3, e3) {
        try {
          return t3[e3];
        } catch (t4) {
        }
      }(e2 = Object(t2), Se$1)) ? n2 : xe ? s(e2) : "Object" == (r2 = s(e2)) && "function" == typeof e2.callee ? "Arguments" : r2;
    }, Ee = me$1 ? {}.toString : function() {
      return "[object " + be$1(this) + "]";
    };
    me$1 || Z(Object.prototype, "toString", Ee, { unsafe: true });
    var we = function() {
      var t2 = A$1(this), e2 = "";
      return t2.global && (e2 += "g"), t2.ignoreCase && (e2 += "i"), t2.multiline && (e2 += "m"), t2.dotAll && (e2 += "s"), t2.unicode && (e2 += "u"), t2.sticky && (e2 += "y"), e2;
    };
    function Oe(t2, e2) {
      return RegExp(t2, e2);
    }
    var Te, Ae$1, ke$1 = { UNSUPPORTED_Y: o(function() {
      var t2 = Oe("a", "y");
      return t2.lastIndex = 2, null != t2.exec("abcd");
    }), BROKEN_CARET: o(function() {
      var t2 = Oe("^r", "gy");
      return t2.lastIndex = 2, null != t2.exec("str");
    }) }, Re = RegExp.prototype.exec, Ie = String.prototype.replace, je = Re, Ce$1 = (Te = /a/, Ae$1 = /b*/g, Re.call(Te, "a"), Re.call(Ae$1, "a"), 0 !== Te.lastIndex || 0 !== Ae$1.lastIndex), Le$1 = ke$1.UNSUPPORTED_Y || ke$1.BROKEN_CARET, Pe$1 = void 0 !== /()??/.exec("")[1];
    (Ce$1 || Pe$1 || Le$1) && (je = function(t2) {
      var e2, n2, r2, o2, i2 = this, u2 = Le$1 && i2.sticky, a2 = we.call(i2), c2 = i2.source, l2 = 0, f2 = t2;
      return u2 && (-1 === (a2 = a2.replace("y", "")).indexOf("g") && (a2 += "g"), f2 = String(t2).slice(i2.lastIndex), i2.lastIndex > 0 && (!i2.multiline || i2.multiline && "\n" !== t2[i2.lastIndex - 1]) && (c2 = "(?: " + c2 + ")", f2 = " " + f2, l2++), n2 = new RegExp("^(?:" + c2 + ")", a2)), Pe$1 && (n2 = new RegExp("^" + c2 + "$(?!\\s)", a2)), Ce$1 && (e2 = i2.lastIndex), r2 = Re.call(u2 ? n2 : i2, f2), u2 ? r2 ? (r2.input = r2.input.slice(l2), r2[0] = r2[0].slice(l2), r2.index = i2.lastIndex, i2.lastIndex += r2[0].length) : i2.lastIndex = 0 : Ce$1 && r2 && (i2.lastIndex = i2.global ? r2.index + r2[0].length : e2), Pe$1 && r2 && r2.length > 1 && Ie.call(r2[0], n2, function() {
        for (o2 = 1; o2 < arguments.length - 2; o2++) void 0 === arguments[o2] && (r2[o2] = void 0);
      }), r2;
    });
    var Me$1 = je;
    It$1({ target: "RegExp", proto: true, forced: /./.exec !== Me$1 }, { exec: Me$1 });
    var _e$1 = RegExp.prototype, De = _e$1.toString, Ue = o(function() {
      return "/a/b" != De.call({ source: "a", flags: "b" });
    }), Ne$1 = "toString" != De.name;
    (Ue || Ne$1) && Z(RegExp.prototype, "toString", function() {
      var t2 = A$1(this), e2 = String(t2.source), n2 = t2.flags;
      return "/" + e2 + "/" + String(void 0 === n2 && t2 instanceof RegExp && !("flags" in _e$1) ? we.call(t2) : n2);
    }, { unsafe: true });
    var Fe = ne("species"), We = !o(function() {
      var t2 = /./;
      return t2.exec = function() {
        var t3 = [];
        return t3.groups = { a: "7" }, t3;
      }, "7" !== "".replace(t2, "$<a>");
    }), ze = "$0" === "a".replace(/./, "$0"), $e = ne("replace"), Be = !!/./[$e] && "" === /./[$e]("a", "$0"), Ye$1 = !o(function() {
      var t2 = /(?:)/, e2 = t2.exec;
      t2.exec = function() {
        return e2.apply(this, arguments);
      };
      var n2 = "ab".split(t2);
      return 2 !== n2.length || "a" !== n2[0] || "b" !== n2[1];
    }), Ge = function(t2, e2, n2, r2) {
      var i2 = ne(t2), u2 = !o(function() {
        var e3 = {};
        return e3[i2] = function() {
          return 7;
        }, 7 != ""[t2](e3);
      }), a2 = u2 && !o(function() {
        var e3 = false, n3 = /a/;
        return "split" === t2 && ((n3 = {}).constructor = {}, n3.constructor[Fe] = function() {
          return n3;
        }, n3.flags = "", n3[i2] = /./[i2]), n3.exec = function() {
          return e3 = true, null;
        }, n3[i2](""), !e3;
      });
      if (!u2 || !a2 || "replace" === t2 && (!We || !ze || Be) || "split" === t2 && !Ye$1) {
        var c2 = /./[i2], l2 = n2(i2, ""[t2], function(t3, e3, n3, r3, o2) {
          return e3.exec === Me$1 ? u2 && !o2 ? { done: true, value: c2.call(e3, n3, r3) } : { done: true, value: t3.call(n3, e3, r3) } : { done: false };
        }, { REPLACE_KEEPS_$0: ze, REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: Be }), f2 = l2[0], s2 = l2[1];
        Z(String.prototype, t2, f2), Z(RegExp.prototype, i2, function(t3, e3) {
          return s2.call(t3, this, e3);
        });
      }
      r2 && I(RegExp.prototype[i2], "sham", true);
    }, He = ne("match"), Xe = function(t2) {
      var e2;
      return h(t2) && (void 0 !== (e2 = t2[He]) ? !!e2 : "RegExp" == s(t2));
    }, Ve$1 = function(t2) {
      if ("function" != typeof t2) throw TypeError(String(t2) + " is not a function");
      return t2;
    }, Ke$1 = ne("species"), qe$1 = function(t2) {
      return function(e2, n2) {
        var r2, o2, i2 = String(p(e2)), u2 = it$1(n2), a2 = i2.length;
        return u2 < 0 || u2 >= a2 ? t2 ? "" : void 0 : (r2 = i2.charCodeAt(u2)) < 55296 || r2 > 56319 || u2 + 1 === a2 || (o2 = i2.charCodeAt(u2 + 1)) < 56320 || o2 > 57343 ? t2 ? i2.charAt(u2) : r2 : t2 ? i2.slice(u2, u2 + 2) : o2 - 56320 + (r2 - 55296 << 10) + 65536;
      };
    }, Qe = { codeAt: qe$1(false), charAt: qe$1(true) }, Je = Qe.charAt, Ze = function(t2, e2, n2) {
      return e2 + (n2 ? Je(t2, e2).length : 1);
    }, tn = function(t2, e2) {
      var n2 = t2.exec;
      if ("function" == typeof n2) {
        var r2 = n2.call(t2, e2);
        if ("object" != typeof r2) throw TypeError("RegExp exec method returned something other than an Object or null");
        return r2;
      }
      if ("RegExp" !== s(t2)) throw TypeError("RegExp#exec called on incompatible receiver");
      return Me$1.call(t2, e2);
    }, en = [].push, nn = Math.min, rn = !o(function() {
      return !RegExp(4294967295, "y");
    });
    Ge("split", 2, function(t2, e2, n2) {
      var r2;
      return r2 = "c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1).length || 2 != "ab".split(/(?:ab)*/).length || 4 != ".".split(/(.?)(.?)/).length || ".".split(/()()/).length > 1 || "".split(/.?/).length ? function(t3, n3) {
        var r3 = String(p(this)), o2 = void 0 === n3 ? 4294967295 : n3 >>> 0;
        if (0 === o2) return [];
        if (void 0 === t3) return [r3];
        if (!Xe(t3)) return e2.call(r3, t3, o2);
        for (var i2, u2, a2, c2 = [], l2 = (t3.ignoreCase ? "i" : "") + (t3.multiline ? "m" : "") + (t3.unicode ? "u" : "") + (t3.sticky ? "y" : ""), f2 = 0, s2 = new RegExp(t3.source, l2 + "g"); (i2 = Me$1.call(s2, r3)) && !((u2 = s2.lastIndex) > f2 && (c2.push(r3.slice(f2, i2.index)), i2.length > 1 && i2.index < r3.length && en.apply(c2, i2.slice(1)), a2 = i2[0].length, f2 = u2, c2.length >= o2)); ) s2.lastIndex === i2.index && s2.lastIndex++;
        return f2 === r3.length ? !a2 && s2.test("") || c2.push("") : c2.push(r3.slice(f2)), c2.length > o2 ? c2.slice(0, o2) : c2;
      } : "0".split(void 0, 0).length ? function(t3, n3) {
        return void 0 === t3 && 0 === n3 ? [] : e2.call(this, t3, n3);
      } : e2, [function(e3, n3) {
        var o2 = p(this), i2 = null == e3 ? void 0 : e3[t2];
        return void 0 !== i2 ? i2.call(e3, o2, n3) : r2.call(String(o2), e3, n3);
      }, function(t3, o2) {
        var i2 = n2(r2, t3, this, o2, r2 !== e2);
        if (i2.done) return i2.value;
        var u2 = A$1(t3), a2 = String(this), c2 = function(t4, e3) {
          var n3, r3 = A$1(t4).constructor;
          return void 0 === r3 || null == (n3 = A$1(r3)[Ke$1]) ? e3 : Ve$1(n3);
        }(u2, RegExp), l2 = u2.unicode, f2 = (u2.ignoreCase ? "i" : "") + (u2.multiline ? "m" : "") + (u2.unicode ? "u" : "") + (rn ? "y" : "g"), s2 = new c2(rn ? u2 : "^(?:" + u2.source + ")", f2), d2 = void 0 === o2 ? 4294967295 : o2 >>> 0;
        if (0 === d2) return [];
        if (0 === a2.length) return null === tn(s2, a2) ? [a2] : [];
        for (var v2 = 0, p2 = 0, g2 = []; p2 < a2.length; ) {
          s2.lastIndex = rn ? p2 : 0;
          var h2, y2 = tn(s2, rn ? a2 : a2.slice(p2));
          if (null === y2 || (h2 = nn(at(s2.lastIndex + (rn ? 0 : p2)), a2.length)) === v2) p2 = Ze(a2, p2, l2);
          else {
            if (g2.push(a2.slice(v2, p2)), g2.length === d2) return g2;
            for (var m2 = 1; m2 <= y2.length - 1; m2++) if (g2.push(y2[m2]), g2.length === d2) return g2;
            p2 = v2 = h2;
          }
        }
        return g2.push(a2.slice(v2)), g2;
      }];
    }, !rn);
    var on = "	\n\v\f\r \u2028\u2029\uFEFF", un = "[" + on + "]", an = RegExp("^" + un + un + "*"), cn = RegExp(un + un + "*$"), ln = function(t2) {
      return function(e2) {
        var n2 = String(p(e2));
        return 1 & t2 && (n2 = n2.replace(an, "")), 2 & t2 && (n2 = n2.replace(cn, "")), n2;
      };
    }, fn = { start: ln(1), end: ln(2), trim: ln(3) }, sn = fn.trim;
    It$1({ target: "String", proto: true, forced: function(t2) {
      return o(function() {
        return !!on[t2]() || "" != ""[t2]() || on[t2].name !== t2;
      });
    }("trim") }, { trim: function() {
      return sn(this);
    } });
    var dn = de$1("slice"), vn = Mt$1("slice", { ACCESSORS: true, 0: 0, 1: 2 }), pn = ne("species"), gn = [].slice, hn = Math.max;
    It$1({ target: "Array", proto: true, forced: !dn || !vn }, { slice: function(t2, e2) {
      var n2, r2, o2, i2 = g(this), u2 = at(i2.length), a2 = ft$1(t2, u2), c2 = ft$1(void 0 === e2 ? u2 : e2, u2);
      if (qt$1(i2) && ("function" != typeof (n2 = i2.constructor) || n2 !== Array && !qt$1(n2.prototype) ? h(n2) && null === (n2 = n2[pn]) && (n2 = void 0) : n2 = void 0, n2 === Array || void 0 === n2)) return gn.call(i2, a2, c2);
      for (r2 = new (void 0 === n2 ? Array : n2)(hn(c2 - a2, 0)), o2 = 0; a2 < c2; a2++, o2++) a2 in i2 && ie(r2, o2, i2[a2]);
      return r2.length = o2, r2;
    } });
    var yn = Object.keys || function(t2) {
      return pt$1(t2, gt$1);
    }, mn = o(function() {
      yn(1);
    });
    It$1({ target: "Object", stat: true, forced: mn }, { keys: function(t2) {
      return yn(Kt$1(t2));
    } });
    var Sn, xn = function(t2) {
      if (Xe(t2)) throw TypeError("The method doesn't accept regular expressions");
      return t2;
    }, bn = ne("match"), En = T.f, wn = "".startsWith, On = Math.min, Tn = function(t2) {
      var e2 = /./;
      try {
        "/./"[t2](e2);
      } catch (n2) {
        try {
          return e2[bn] = false, "/./"[t2](e2);
        } catch (t3) {
        }
      }
      return false;
    }("startsWith"), An = !(Tn || (Sn = En(String.prototype, "startsWith"), !Sn || Sn.writable));
    function kn(t2) {
      return (kn = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
        return typeof t3;
      } : function(t3) {
        return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
      })(t2);
    }
    It$1({ target: "String", proto: true, forced: !An && !Tn }, { startsWith: function(t2) {
      var e2 = String(p(this));
      xn(t2);
      var n2 = at(On(arguments.length > 1 ? arguments[1] : void 0, e2.length)), r2 = String(t2);
      return wn ? wn.call(e2, r2, n2) : e2.slice(n2, n2 + r2.length) === r2;
    } });
    var jn = function(t2) {
      return "string" == typeof t2;
    }, Mn = function(t2) {
      return null !== t2 && "object" === kn(t2);
    }, Vn = function() {
      function t2() {
        Wt$1(this, t2);
      }
      return $t$1(t2, null, [{ key: "isWindow", value: function(t3) {
        return t3 === window;
      } }, { key: "addEventListener", value: function(t3, e2, n2) {
        var r2 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
        t3 && e2 && n2 && t3.addEventListener(e2, n2, r2);
      } }, { key: "removeEventListener", value: function(t3, e2, n2) {
        var r2 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
        t3 && e2 && n2 && t3.removeEventListener(e2, n2, r2);
      } }, { key: "triggerDragEvent", value: function(e2, n2) {
        var r2 = false, o2 = function(t3) {
          var e3;
          null === (e3 = n2.drag) || void 0 === e3 || e3.call(n2, t3);
        }, i2 = function e3(i3) {
          var u2;
          t2.removeEventListener(document, "mousemove", o2), t2.removeEventListener(document, "mouseup", e3), document.onselectstart = null, document.ondragstart = null, r2 = false, null === (u2 = n2.end) || void 0 === u2 || u2.call(n2, i3);
        };
        t2.addEventListener(e2, "mousedown", function(e3) {
          var u2;
          r2 || (document.onselectstart = function() {
            return false;
          }, document.ondragstart = function() {
            return false;
          }, t2.addEventListener(document, "mousemove", o2), t2.addEventListener(document, "mouseup", i2), r2 = true, null === (u2 = n2.start) || void 0 === u2 || u2.call(n2, e3));
        });
      } }, { key: "getBoundingClientRect", value: function(t3) {
        return t3 && Mn(t3) && 1 === t3.nodeType ? t3.getBoundingClientRect() : null;
      } }, { key: "hasClass", value: function(t3, e2) {
        return !!(t3 && Mn(t3) && jn(e2) && 1 === t3.nodeType) && t3.classList.contains(e2.trim());
      } }, { key: "addClass", value: function(e2, n2) {
        if (e2 && Mn(e2) && jn(n2) && 1 === e2.nodeType && (n2 = n2.trim(), !t2.hasClass(e2, n2))) {
          var r2 = e2.className;
          e2.className = r2 ? r2 + " " + n2 : n2;
        }
      } }, { key: "removeClass", value: function(t3, e2) {
        if (t3 && Mn(t3) && jn(e2) && 1 === t3.nodeType && "string" == typeof t3.className) {
          e2 = e2.trim();
          for (var n2 = t3.className.trim().split(" "), r2 = n2.length - 1; r2 >= 0; r2--) n2[r2] = n2[r2].trim(), n2[r2] && n2[r2] !== e2 || n2.splice(r2, 1);
          t3.className = n2.join(" ");
        }
      } }, { key: "toggleClass", value: function(t3, e2, n2) {
        t3 && Mn(t3) && jn(e2) && 1 === t3.nodeType && t3.classList.toggle(e2, n2);
      } }, { key: "replaceClass", value: function(e2, n2, r2) {
        e2 && Mn(e2) && jn(n2) && jn(r2) && 1 === e2.nodeType && (n2 = n2.trim(), r2 = r2.trim(), t2.removeClass(e2, n2), t2.addClass(e2, r2));
      } }, { key: "getScrollTop", value: function(t3) {
        var e2 = "scrollTop" in t3 ? t3.scrollTop : t3.pageYOffset;
        return Math.max(e2, 0);
      } }, { key: "setScrollTop", value: function(t3, e2) {
        "scrollTop" in t3 ? t3.scrollTop = e2 : t3.scrollTo(t3.scrollX, e2);
      } }, { key: "getRootScrollTop", value: function() {
        return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
      } }, { key: "setRootScrollTop", value: function(e2) {
        t2.setScrollTop(window, e2), t2.setScrollTop(document.body, e2);
      } }, { key: "getElementTop", value: function(e2, n2) {
        if (t2.isWindow(e2)) return 0;
        var r2 = n2 ? t2.getScrollTop(n2) : t2.getRootScrollTop();
        return e2.getBoundingClientRect().top + r2;
      } }, { key: "getVisibleHeight", value: function(e2) {
        return t2.isWindow(e2) ? e2.innerHeight : e2.getBoundingClientRect().height;
      } }, { key: "isHidden", value: function(t3) {
        if (!t3) return false;
        var e2 = window.getComputedStyle(t3), n2 = "none" === e2.display, r2 = null === t3.offsetParent && "fixed" !== e2.position;
        return n2 || r2;
      } }, { key: "triggerEvent", value: function(t3, e2) {
        if ("createEvent" in document) {
          var n2 = document.createEvent("HTMLEvents");
          n2.initEvent(e2, false, true), t3.dispatchEvent(n2);
        }
      } }, { key: "calcAngle", value: function(t3, e2) {
        var n2 = t3.getBoundingClientRect(), r2 = n2.left + n2.width / 2, o2 = n2.top + n2.height / 2, i2 = Math.abs(r2 - e2.clientX), u2 = Math.abs(o2 - e2.clientY), a2 = u2 / Math.sqrt(Math.pow(i2, 2) + Math.pow(u2, 2)), c2 = Math.acos(a2), l2 = Math.floor(180 / (Math.PI / c2));
        return e2.clientX > r2 && e2.clientY > o2 && (l2 = 180 - l2), e2.clientX == r2 && e2.clientY > o2 && (l2 = 180), e2.clientX > r2 && e2.clientY == o2 && (l2 = 90), e2.clientX < r2 && e2.clientY > o2 && (l2 = 180 + l2), e2.clientX < r2 && e2.clientY == o2 && (l2 = 270), e2.clientX < r2 && e2.clientY < o2 && (l2 = 360 - l2), l2;
      } }, { key: "querySelector", value: function(t3, e2) {
        return e2 ? e2.querySelector(t3) : document.querySelector(t3);
      } }, { key: "createElement", value: function(t3) {
        for (var e2 = document.createElement(t3), n2 = arguments.length, r2 = new Array(n2 > 1 ? n2 - 1 : 0), o2 = 1; o2 < n2; o2++) r2[o2 - 1] = arguments[o2];
        for (var i2 = 0; i2 < r2.length; i2++) r2[i2] && e2.classList.add(r2[i2]);
        return e2;
      } }, { key: "appendChild", value: function(t3) {
        for (var e2 = 0; e2 < (arguments.length <= 1 ? 0 : arguments.length - 1); e2++) t3.appendChild(e2 + 1 < 1 || arguments.length <= e2 + 1 ? void 0 : arguments[e2 + 1]);
      } }, { key: "getWindow", value: function(t3) {
        if ("[object Window]" !== t3.toString()) {
          var e2 = t3.ownerDocument;
          return e2 && e2.defaultView || window;
        }
        return t3;
      } }, { key: "isElement", value: function(t3) {
        return t3 instanceof this.getWindow(t3).Element || t3 instanceof Element;
      } }, { key: "isHTMLElement", value: function(t3) {
        return t3 instanceof this.getWindow(t3).HTMLElement || t3 instanceof HTMLElement;
      } }, { key: "isShadowRoot", value: function(t3) {
        return "undefined" != typeof ShadowRoot && (t3 instanceof this.getWindow(t3).ShadowRoot || t3 instanceof ShadowRoot);
      } }, { key: "getWindowScroll", value: function(t3) {
        var e2 = this.getWindow(t3);
        return { scrollLeft: e2.pageXOffset || 0, scrollTop: e2.pageYOffset || 0 };
      } }]), t2;
    }(), Kn = Math.floor, qn = "".replace, Qn = /\$([$&'`]|\d\d?|<[^>]*>)/g, Jn = /\$([$&'`]|\d\d?)/g, Zn = function(t2, e2, n2, r2, o2, i2) {
      var u2 = n2 + t2.length, a2 = r2.length, c2 = Jn;
      return void 0 !== o2 && (o2 = Kt$1(o2), c2 = Qn), qn.call(i2, c2, function(i3, c3) {
        var l2;
        switch (c3.charAt(0)) {
          case "$":
            return "$";
          case "&":
            return t2;
          case "`":
            return e2.slice(0, n2);
          case "'":
            return e2.slice(u2);
          case "<":
            l2 = o2[c3.slice(1, -1)];
            break;
          default:
            var f2 = +c3;
            if (0 === f2) return i3;
            if (f2 > a2) {
              var s2 = Kn(f2 / 10);
              return 0 === s2 ? i3 : s2 <= a2 ? void 0 === r2[s2 - 1] ? c3.charAt(1) : r2[s2 - 1] + c3.charAt(1) : i3;
            }
            l2 = r2[f2 - 1];
        }
        return void 0 === l2 ? "" : l2;
      });
    }, tr = Math.max, er = Math.min;
    Ge("replace", 2, function(t2, e2, n2, r2) {
      var o2 = r2.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE, i2 = r2.REPLACE_KEEPS_$0, u2 = o2 ? "$" : "$0";
      return [function(n3, r3) {
        var o3 = p(this), i3 = null == n3 ? void 0 : n3[t2];
        return void 0 !== i3 ? i3.call(n3, o3, r3) : e2.call(String(o3), n3, r3);
      }, function(t3, r3) {
        if (!o2 && i2 || "string" == typeof r3 && -1 === r3.indexOf(u2)) {
          var a2 = n2(e2, t3, this, r3);
          if (a2.done) return a2.value;
        }
        var c2 = A$1(t3), l2 = String(this), f2 = "function" == typeof r3;
        f2 || (r3 = String(r3));
        var s2 = c2.global;
        if (s2) {
          var d2 = c2.unicode;
          c2.lastIndex = 0;
        }
        for (var v2 = []; ; ) {
          var p2 = tn(c2, l2);
          if (null === p2) break;
          if (v2.push(p2), !s2) break;
          "" === String(p2[0]) && (c2.lastIndex = Ze(l2, at(c2.lastIndex), d2));
        }
        for (var g2, h2 = "", y2 = 0, m2 = 0; m2 < v2.length; m2++) {
          p2 = v2[m2];
          for (var S2 = String(p2[0]), x2 = tr(er(it$1(p2.index), l2.length), 0), b2 = [], E2 = 1; E2 < p2.length; E2++) b2.push(void 0 === (g2 = p2[E2]) ? g2 : String(g2));
          var w2 = p2.groups;
          if (f2) {
            var O2 = [S2].concat(b2, x2, l2);
            void 0 !== w2 && O2.push(w2);
            var T2 = String(r3.apply(void 0, O2));
          } else T2 = Zn(S2, l2, x2, b2, w2, r3);
          x2 >= y2 && (h2 += l2.slice(y2, x2) + T2, y2 = x2 + S2.length);
        }
        return h2 + l2.slice(y2);
      }];
    });
    (function() {
      function t2() {
        Wt$1(this, t2);
      }
      return $t$1(t2, null, [{ key: "camelize", value: function(t3) {
        return t3.replace(/-(\w)/g, function(t4, e2) {
          return e2 ? e2.toUpperCase() : "";
        });
      } }, { key: "capitalize", value: function(t3) {
        return t3.charAt(0).toUpperCase() + t3.slice(1);
      } }]), t2;
    })();
    (function() {
      function t2() {
        Wt$1(this, t2);
      }
      return $t$1(t2, null, [{ key: "_clone", value: function() {
      } }]), t2;
    })();
    var or = ne("isConcatSpreadable"), ir = fe$1 >= 51 || !o(function() {
      var t2 = [];
      return t2[or] = false, t2.concat()[0] !== t2;
    }), ur = de$1("concat"), ar = function(t2) {
      if (!h(t2)) return false;
      var e2 = t2[or];
      return void 0 !== e2 ? !!e2 : qt$1(t2);
    };
    It$1({ target: "Array", proto: true, forced: !ir || !ur }, { concat: function(t2) {
      var e2, n2, r2, o2, i2, u2 = Kt$1(this), a2 = oe(u2, 0), c2 = 0;
      for (e2 = -1, r2 = arguments.length; e2 < r2; e2++) if (ar(i2 = -1 === e2 ? u2 : arguments[e2])) {
        if (c2 + (o2 = at(i2.length)) > 9007199254740991) throw TypeError("Maximum allowed index exceeded");
        for (n2 = 0; n2 < o2; n2++, c2++) n2 in i2 && ie(a2, c2, i2[n2]);
      } else {
        if (c2 >= 9007199254740991) throw TypeError("Maximum allowed index exceeded");
        ie(a2, c2++, i2);
      }
      return a2.length = c2, a2;
    } });
    var cr, lr = function(t2, e2, n2) {
      if (Ve$1(t2), void 0 === e2) return t2;
      switch (n2) {
        case 0:
          return function() {
            return t2.call(e2);
          };
        case 1:
          return function(n3) {
            return t2.call(e2, n3);
          };
        case 2:
          return function(n3, r2) {
            return t2.call(e2, n3, r2);
          };
        case 3:
          return function(n3, r2, o2) {
            return t2.call(e2, n3, r2, o2);
          };
      }
      return function() {
        return t2.apply(e2, arguments);
      };
    }, fr = [].push, sr = function(t2) {
      var e2 = 1 == t2, n2 = 2 == t2, r2 = 3 == t2, o2 = 4 == t2, i2 = 6 == t2, u2 = 7 == t2, a2 = 5 == t2 || i2;
      return function(c2, l2, f2, s2) {
        for (var d2, p2, g2 = Kt$1(c2), h2 = v(g2), y2 = lr(l2, f2, 3), m2 = at(h2.length), S2 = 0, x2 = s2 || oe, b2 = e2 ? x2(c2, m2) : n2 || u2 ? x2(c2, 0) : void 0; m2 > S2; S2++) if ((a2 || S2 in h2) && (p2 = y2(d2 = h2[S2], S2, g2), t2)) if (e2) b2[S2] = p2;
        else if (p2) switch (t2) {
          case 3:
            return true;
          case 5:
            return d2;
          case 6:
            return S2;
          case 2:
            fr.call(b2, d2);
        }
        else switch (t2) {
          case 4:
            return false;
          case 7:
            fr.call(b2, d2);
        }
        return i2 ? -1 : r2 || o2 ? o2 : b2;
      };
    }, dr = { forEach: sr(0), map: sr(1), filter: sr(2), some: sr(3), every: sr(4), find: sr(5), findIndex: sr(6), filterOut: sr(7) }, vr = i ? Object.defineProperties : function(t2, e2) {
      A$1(t2);
      for (var n2, r2 = yn(e2), o2 = r2.length, i2 = 0; o2 > i2; ) R.f(t2, n2 = r2[i2++], e2[n2]);
      return t2;
    }, pr = nt("document", "documentElement"), gr = Y("IE_PROTO"), hr = function() {
    }, yr = function(t2) {
      return "<script>" + t2 + "<\/script>";
    }, mr = function() {
      try {
        cr = document.domain && new ActiveXObject("htmlfile");
      } catch (t3) {
      }
      var t2, e2;
      mr = cr ? function(t3) {
        t3.write(yr("")), t3.close();
        var e3 = t3.parentWindow.Object;
        return t3 = null, e3;
      }(cr) : ((e2 = E("iframe")).style.display = "none", pr.appendChild(e2), e2.src = String("javascript:"), (t2 = e2.contentWindow.document).open(), t2.write(yr("document.F=Object")), t2.close(), t2.F);
      for (var n2 = gt$1.length; n2--; ) delete mr.prototype[gt$1[n2]];
      return mr();
    };
    G[gr] = true;
    var Sr = Object.create || function(t2, e2) {
      var n2;
      return null !== t2 ? (hr.prototype = A$1(t2), n2 = new hr(), hr.prototype = null, n2[gr] = t2) : n2 = mr(), void 0 === e2 ? n2 : vr(n2, e2);
    }, xr = ne("unscopables"), br = Array.prototype;
    null == br[xr] && R.f(br, xr, { configurable: true, value: Sr(null) });
    var Er = function(t2) {
      br[xr][t2] = true;
    }, wr = dr.find, Or = true, Tr = Mt$1("find");
    "find" in [] && Array(1).find(function() {
      Or = false;
    }), It$1({ target: "Array", proto: true, forced: Or || !Tr }, { find: function(t2) {
      return wr(this, t2, arguments.length > 1 ? arguments[1] : void 0);
    } }), Er("find");
    var Ar = dr.findIndex, kr = true, Rr = Mt$1("findIndex");
    "findIndex" in [] && Array(1).findIndex(function() {
      kr = false;
    }), It$1({ target: "Array", proto: true, forced: kr || !Rr }, { findIndex: function(t2) {
      return Ar(this, t2, arguments.length > 1 ? arguments[1] : void 0);
    } }), Er("findIndex");
    var Ir = function(t2, e2, n2, r2, o2, i2, u2, a2) {
      for (var c2, l2 = o2, f2 = 0, s2 = !!u2 && lr(u2, a2, 3); f2 < r2; ) {
        if (f2 in n2) {
          if (c2 = s2 ? s2(n2[f2], f2, e2) : n2[f2], i2 > 0 && qt$1(c2)) l2 = Ir(t2, e2, c2, at(c2.length), l2, i2 - 1) - 1;
          else {
            if (l2 >= 9007199254740991) throw TypeError("Exceed the acceptable array length");
            t2[l2] = c2;
          }
          l2++;
        }
        f2++;
      }
      return l2;
    }, jr = Ir;
    It$1({ target: "Array", proto: true }, { flat: function() {
      var t2 = arguments.length ? arguments[0] : void 0, e2 = Kt$1(this), n2 = at(e2.length), r2 = oe(e2, 0);
      return r2.length = jr(r2, e2, e2, n2, 0, void 0 === t2 ? 1 : it$1(t2)), r2;
    } });
    var Cr = function(t2) {
      var e2 = t2.return;
      if (void 0 !== e2) return A$1(e2.call(t2)).value;
    }, Lr = function(t2, e2, n2, r2) {
      try {
        return r2 ? e2(A$1(n2)[0], n2[1]) : e2(n2);
      } catch (e3) {
        throw Cr(t2), e3;
      }
    }, Pr = {}, Mr = ne("iterator"), _r = Array.prototype, Dr = function(t2) {
      return void 0 !== t2 && (Pr.Array === t2 || _r[Mr] === t2);
    }, Ur = ne("iterator"), Nr = function(t2) {
      if (null != t2) return t2[Ur] || t2["@@iterator"] || Pr[be$1(t2)];
    }, Fr = ne("iterator"), Wr = false;
    try {
      var zr = 0, $r = { next: function() {
        return { done: !!zr++ };
      }, return: function() {
        Wr = true;
      } };
      $r[Fr] = function() {
        return this;
      }, Array.from($r, function() {
        throw 2;
      });
    } catch (t2) {
    }
    var Br = function(t2, e2) {
      if (!Wr) return false;
      var n2 = false;
      try {
        var r2 = {};
        r2[Fr] = function() {
          return { next: function() {
            return { done: n2 = true };
          } };
        }, t2(r2);
      } catch (t3) {
      }
      return n2;
    }, Yr = !Br(function(t2) {
      Array.from(t2);
    });
    It$1({ target: "Array", stat: true, forced: Yr }, { from: function(t2) {
      var e2, n2, r2, o2, i2, u2, a2 = Kt$1(t2), c2 = "function" == typeof this ? this : Array, l2 = arguments.length, f2 = l2 > 1 ? arguments[1] : void 0, s2 = void 0 !== f2, d2 = Nr(a2), v2 = 0;
      if (s2 && (f2 = lr(f2, l2 > 2 ? arguments[2] : void 0, 2)), null == d2 || c2 == Array && Dr(d2)) for (n2 = new c2(e2 = at(a2.length)); e2 > v2; v2++) u2 = s2 ? f2(a2[v2], v2) : a2[v2], ie(n2, v2, u2);
      else for (i2 = (o2 = d2.call(a2)).next, n2 = new c2(); !(r2 = i2.call(o2)).done; v2++) u2 = s2 ? Lr(o2, f2, [r2.value, v2], true) : r2.value, ie(n2, v2, u2);
      return n2.length = v2, n2;
    } });
    var Gr = function(t2) {
      return function(e2, n2, r2, o2) {
        Ve$1(n2);
        var i2 = Kt$1(e2), u2 = v(i2), a2 = at(i2.length), c2 = t2 ? a2 - 1 : 0, l2 = t2 ? -1 : 1;
        if (r2 < 2) for (; ; ) {
          if (c2 in u2) {
            o2 = u2[c2], c2 += l2;
            break;
          }
          if (c2 += l2, t2 ? c2 < 0 : a2 <= c2) throw TypeError("Reduce of empty array with no initial value");
        }
        for (; t2 ? c2 >= 0 : a2 > c2; c2 += l2) c2 in u2 && (o2 = n2(o2, u2[c2], c2, i2));
        return o2;
      };
    }, Hr = { left: Gr(false), right: Gr(true) }, Xr = "process" == s(r.process), Vr = Hr.left, Kr = jt$1("reduce"), qr = Mt$1("reduce", { 1: 0 });
    It$1({ target: "Array", proto: true, forced: !Kr || !qr || !Xr && fe$1 > 79 && fe$1 < 83 }, { reduce: function(t2) {
      return Vr(this, t2, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
    } }), Er("flat");
    var Qr, Jr, Zr, to$1 = !o(function() {
      return Object.isExtensible(Object.preventExtensions({}));
    }), eo$1 = e(function(t2) {
      var e2 = R.f, n2 = $$1("meta"), r2 = 0, o2 = Object.isExtensible || function() {
        return true;
      }, i2 = function(t3) {
        e2(t3, n2, { value: { objectID: "O" + ++r2, weakData: {} } });
      }, u2 = t2.exports = { REQUIRED: false, fastKey: function(t3, e3) {
        if (!h(t3)) return "symbol" == typeof t3 ? t3 : ("string" == typeof t3 ? "S" : "P") + t3;
        if (!S(t3, n2)) {
          if (!o2(t3)) return "F";
          if (!e3) return "E";
          i2(t3);
        }
        return t3[n2].objectID;
      }, getWeakData: function(t3, e3) {
        if (!S(t3, n2)) {
          if (!o2(t3)) return true;
          if (!e3) return false;
          i2(t3);
        }
        return t3[n2].weakData;
      }, onFreeze: function(t3) {
        return to$1 && u2.REQUIRED && o2(t3) && !S(t3, n2) && i2(t3), t3;
      } };
      G[n2] = true;
    }), no$1 = function(t2, e2) {
      this.stopped = t2, this.result = e2;
    }, ro$1 = function(t2, e2, n2) {
      var r2, o2, i2, u2, a2, c2, l2, f2 = n2 && n2.that, s2 = !(!n2 || !n2.AS_ENTRIES), d2 = !(!n2 || !n2.IS_ITERATOR), v2 = !(!n2 || !n2.INTERRUPTED), p2 = lr(e2, f2, 1 + s2 + v2), g2 = function(t3) {
        return r2 && Cr(r2), new no$1(true, t3);
      }, h2 = function(t3) {
        return s2 ? (A$1(t3), v2 ? p2(t3[0], t3[1], g2) : p2(t3[0], t3[1])) : v2 ? p2(t3, g2) : p2(t3);
      };
      if (d2) r2 = t2;
      else {
        if ("function" != typeof (o2 = Nr(t2))) throw TypeError("Target is not iterable");
        if (Dr(o2)) {
          for (i2 = 0, u2 = at(t2.length); u2 > i2; i2++) if ((a2 = h2(t2[i2])) && a2 instanceof no$1) return a2;
          return new no$1(false);
        }
        r2 = o2.call(t2);
      }
      for (c2 = r2.next; !(l2 = c2.call(r2)).done; ) {
        try {
          a2 = h2(l2.value);
        } catch (t3) {
          throw Cr(r2), t3;
        }
        if ("object" == typeof a2 && a2 && a2 instanceof no$1) return a2;
      }
      return new no$1(false);
    }, oo$1 = function(t2, e2, n2) {
      if (!(t2 instanceof e2)) throw TypeError("Incorrect " + (n2 ? n2 + " " : "") + "invocation");
      return t2;
    }, io$1 = R.f, uo$1 = ne("toStringTag"), ao$1 = function(t2, e2, n2) {
      t2 && !S(t2 = n2 ? t2 : t2.prototype, uo$1) && io$1(t2, uo$1, { configurable: true, value: e2 });
    }, co$1 = Object.setPrototypeOf || ("__proto__" in {} ? function() {
      var t2, e2 = false, n2 = {};
      try {
        (t2 = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set).call(n2, []), e2 = n2 instanceof Array;
      } catch (t3) {
      }
      return function(n3, r2) {
        return A$1(n3), function(t3) {
          if (!h(t3) && null !== t3) throw TypeError("Can't set " + String(t3) + " as a prototype");
        }(r2), e2 ? t2.call(n3, r2) : n3.__proto__ = r2, n3;
      };
    }() : void 0), lo$1 = function(t2, e2, n2) {
      for (var r2 in e2) Z(t2, r2, e2[r2], n2);
      return t2;
    }, fo$1 = !o(function() {
      function t2() {
      }
      return t2.prototype.constructor = null, Object.getPrototypeOf(new t2()) !== t2.prototype;
    }), so$1 = Y("IE_PROTO"), vo$1 = Object.prototype, po$1 = fo$1 ? Object.getPrototypeOf : function(t2) {
      return t2 = Kt$1(t2), S(t2, so$1) ? t2[so$1] : "function" == typeof t2.constructor && t2 instanceof t2.constructor ? t2.constructor.prototype : t2 instanceof Object ? vo$1 : null;
    }, go$1 = ne("iterator"), ho$1 = false;
    [].keys && ("next" in (Zr = [].keys()) ? (Jr = po$1(po$1(Zr))) !== Object.prototype && (Qr = Jr) : ho$1 = true), (null == Qr || o(function() {
      var t2 = {};
      return Qr[go$1].call(t2) !== t2;
    })) && (Qr = {}), S(Qr, go$1) || I(Qr, go$1, function() {
      return this;
    });
    var yo$1 = { IteratorPrototype: Qr, BUGGY_SAFARI_ITERATORS: ho$1 }, mo$1 = yo$1.IteratorPrototype, So$1 = function() {
      return this;
    }, xo = yo$1.IteratorPrototype, bo$1 = yo$1.BUGGY_SAFARI_ITERATORS, Eo$1 = ne("iterator"), wo$1 = function() {
      return this;
    }, Oo$1 = function(t2, e2, n2, r2, o2, i2, u2) {
      !function(t3, e3, n3) {
        var r3 = e3 + " Iterator";
        t3.prototype = Sr(mo$1, { next: l(1, n3) }), ao$1(t3, r3, false), Pr[r3] = So$1;
      }(n2, e2, r2);
      var a2, c2, f2, s2 = function(t3) {
        if (t3 === o2 && h2) return h2;
        if (!bo$1 && t3 in p2) return p2[t3];
        switch (t3) {
          case "keys":
          case "values":
          case "entries":
            return function() {
              return new n2(this, t3);
            };
        }
        return function() {
          return new n2(this);
        };
      }, d2 = e2 + " Iterator", v2 = false, p2 = t2.prototype, g2 = p2[Eo$1] || p2["@@iterator"] || o2 && p2[o2], h2 = !bo$1 && g2 || s2(o2), y2 = "Array" == e2 && p2.entries || g2;
      if (y2 && (a2 = po$1(y2.call(new t2())), xo !== Object.prototype && a2.next && (po$1(a2) !== xo && (co$1 ? co$1(a2, xo) : "function" != typeof a2[Eo$1] && I(a2, Eo$1, wo$1)), ao$1(a2, d2, true))), "values" == o2 && g2 && "values" !== g2.name && (v2 = true, h2 = function() {
        return g2.call(this);
      }), p2[Eo$1] !== h2 && I(p2, Eo$1, h2), Pr[e2] = h2, o2) if (c2 = { values: s2("values"), keys: i2 ? h2 : s2("keys"), entries: s2("entries") }, u2) for (f2 in c2) (bo$1 || v2 || !(f2 in p2)) && Z(p2, f2, c2[f2]);
      else It$1({ target: e2, proto: true, forced: bo$1 || v2 }, c2);
      return c2;
    }, To$1 = ne("species"), Ao$1 = R.f, ko$1 = eo$1.fastKey, Ro$1 = J.set, Io$1 = J.getterFor;
    !function(t2, e2, n2) {
      var i2 = -1 !== t2.indexOf("Map"), u2 = -1 !== t2.indexOf("Weak"), a2 = i2 ? "set" : "add", c2 = r[t2], l2 = c2 && c2.prototype, f2 = c2, s2 = {}, d2 = function(t3) {
        var e3 = l2[t3];
        Z(l2, t3, "add" == t3 ? function(t4) {
          return e3.call(this, 0 === t4 ? 0 : t4), this;
        } : "delete" == t3 ? function(t4) {
          return !(u2 && !h(t4)) && e3.call(this, 0 === t4 ? 0 : t4);
        } : "get" == t3 ? function(t4) {
          return u2 && !h(t4) ? void 0 : e3.call(this, 0 === t4 ? 0 : t4);
        } : "has" == t3 ? function(t4) {
          return !(u2 && !h(t4)) && e3.call(this, 0 === t4 ? 0 : t4);
        } : function(t4, n3) {
          return e3.call(this, 0 === t4 ? 0 : t4, n3), this;
        });
      };
      if (kt$1(t2, "function" != typeof c2 || !(u2 || l2.forEach && !o(function() {
        new c2().entries().next();
      })))) f2 = n2.getConstructor(e2, t2, i2, a2), eo$1.REQUIRED = true;
      else if (kt$1(t2, true)) {
        var v2 = new f2(), p2 = v2[a2](u2 ? {} : -0, 1) != v2, g2 = o(function() {
          v2.has(1);
        }), y2 = Br(function(t3) {
          new c2(t3);
        }), m2 = !u2 && o(function() {
          for (var t3 = new c2(), e3 = 5; e3--; ) t3[a2](e3, e3);
          return !t3.has(-0);
        });
        y2 || ((f2 = e2(function(e3, n3) {
          oo$1(e3, f2, t2);
          var r2 = function(t3, e4, n4) {
            var r3, o2;
            return co$1 && "function" == typeof (r3 = e4.constructor) && r3 !== n4 && h(o2 = r3.prototype) && o2 !== n4.prototype && co$1(t3, o2), t3;
          }(new c2(), e3, f2);
          return null != n3 && ro$1(n3, r2[a2], { that: r2, AS_ENTRIES: i2 }), r2;
        })).prototype = l2, l2.constructor = f2), (g2 || m2) && (d2("delete"), d2("has"), i2 && d2("get")), (m2 || p2) && d2(a2), u2 && l2.clear && delete l2.clear;
      }
      s2[t2] = f2, It$1({ global: true, forced: f2 != c2 }, s2), ao$1(f2, t2), u2 || n2.setStrong(f2, t2, i2);
    }("Set", function(t2) {
      return function() {
        return t2(this, arguments.length ? arguments[0] : void 0);
      };
    }, { getConstructor: function(t2, e2, n2, r2) {
      var o2 = t2(function(t3, u3) {
        oo$1(t3, o2, e2), Ro$1(t3, { type: e2, index: Sr(null), first: void 0, last: void 0, size: 0 }), i || (t3.size = 0), null != u3 && ro$1(u3, t3[r2], { that: t3, AS_ENTRIES: n2 });
      }), u2 = Io$1(e2), a2 = function(t3, e3, n3) {
        var r3, o3, a3 = u2(t3), l2 = c2(t3, e3);
        return l2 ? l2.value = n3 : (a3.last = l2 = { index: o3 = ko$1(e3, true), key: e3, value: n3, previous: r3 = a3.last, next: void 0, removed: false }, a3.first || (a3.first = l2), r3 && (r3.next = l2), i ? a3.size++ : t3.size++, "F" !== o3 && (a3.index[o3] = l2)), t3;
      }, c2 = function(t3, e3) {
        var n3, r3 = u2(t3), o3 = ko$1(e3);
        if ("F" !== o3) return r3.index[o3];
        for (n3 = r3.first; n3; n3 = n3.next) if (n3.key == e3) return n3;
      };
      return lo$1(o2.prototype, { clear: function() {
        for (var t3 = u2(this), e3 = t3.index, n3 = t3.first; n3; ) n3.removed = true, n3.previous && (n3.previous = n3.previous.next = void 0), delete e3[n3.index], n3 = n3.next;
        t3.first = t3.last = void 0, i ? t3.size = 0 : this.size = 0;
      }, delete: function(t3) {
        var e3 = this, n3 = u2(e3), r3 = c2(e3, t3);
        if (r3) {
          var o3 = r3.next, a3 = r3.previous;
          delete n3.index[r3.index], r3.removed = true, a3 && (a3.next = o3), o3 && (o3.previous = a3), n3.first == r3 && (n3.first = o3), n3.last == r3 && (n3.last = a3), i ? n3.size-- : e3.size--;
        }
        return !!r3;
      }, forEach: function(t3) {
        for (var e3, n3 = u2(this), r3 = lr(t3, arguments.length > 1 ? arguments[1] : void 0, 3); e3 = e3 ? e3.next : n3.first; ) for (r3(e3.value, e3.key, this); e3 && e3.removed; ) e3 = e3.previous;
      }, has: function(t3) {
        return !!c2(this, t3);
      } }), lo$1(o2.prototype, n2 ? { get: function(t3) {
        var e3 = c2(this, t3);
        return e3 && e3.value;
      }, set: function(t3, e3) {
        return a2(this, 0 === t3 ? 0 : t3, e3);
      } } : { add: function(t3) {
        return a2(this, t3 = 0 === t3 ? 0 : t3, t3);
      } }), i && Ao$1(o2.prototype, "size", { get: function() {
        return u2(this).size;
      } }), o2;
    }, setStrong: function(t2, e2, n2) {
      var r2 = e2 + " Iterator", o2 = Io$1(e2), u2 = Io$1(r2);
      Oo$1(t2, e2, function(t3, e3) {
        Ro$1(this, { type: r2, target: t3, state: o2(t3), kind: e3, last: void 0 });
      }, function() {
        for (var t3 = u2(this), e3 = t3.kind, n3 = t3.last; n3 && n3.removed; ) n3 = n3.previous;
        return t3.target && (t3.last = n3 = n3 ? n3.next : t3.state.first) ? "keys" == e3 ? { value: n3.key, done: false } : "values" == e3 ? { value: n3.value, done: false } : { value: [n3.key, n3.value], done: false } : (t3.target = void 0, { value: void 0, done: true });
      }, n2 ? "entries" : "values", !n2, true), function(t3) {
        var e3 = nt(t3), n3 = R.f;
        i && e3 && !e3[To$1] && n3(e3, To$1, { configurable: true, get: function() {
          return this;
        } });
      }(e2);
    } });
    var jo$1 = Qe.charAt, Co$1 = J.set, Lo$1 = J.getterFor("String Iterator");
    Oo$1(String, "String", function(t2) {
      Co$1(this, { type: "String Iterator", string: String(t2), index: 0 });
    }, function() {
      var t2, e2 = Lo$1(this), n2 = e2.string, r2 = e2.index;
      return r2 >= n2.length ? { value: void 0, done: true } : (t2 = jo$1(n2, r2), e2.index += t2.length, { value: t2, done: false });
    });
    var Po$1 = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 }, Mo$1 = J.set, _o$1 = J.getterFor("Array Iterator"), Do$1 = Oo$1(Array, "Array", function(t2, e2) {
      Mo$1(this, { type: "Array Iterator", target: g(t2), index: 0, kind: e2 });
    }, function() {
      var t2 = _o$1(this), e2 = t2.target, n2 = t2.kind, r2 = t2.index++;
      return !e2 || r2 >= e2.length ? (t2.target = void 0, { value: void 0, done: true }) : "keys" == n2 ? { value: r2, done: false } : "values" == n2 ? { value: e2[r2], done: false } : { value: [r2, e2[r2]], done: false };
    }, "values");
    Pr.Arguments = Pr.Array, Er("keys"), Er("values"), Er("entries");
    var Uo$1 = ne("iterator"), No$1 = ne("toStringTag"), Fo$1 = Do$1.values;
    for (var Wo$1 in Po$1) {
      var zo$1 = r[Wo$1], $o$1 = zo$1 && zo$1.prototype;
      if ($o$1) {
        if ($o$1[Uo$1] !== Fo$1) try {
          I($o$1, Uo$1, Fo$1);
        } catch (t2) {
          $o$1[Uo$1] = Fo$1;
        }
        if ($o$1[No$1] || I($o$1, No$1, Wo$1), Po$1[Wo$1]) {
          for (var Bo$1 in Do$1) if ($o$1[Bo$1] !== Do$1[Bo$1]) try {
            I($o$1, Bo$1, Do$1[Bo$1]);
          } catch (t2) {
            $o$1[Bo$1] = Do$1[Bo$1];
          }
        }
      }
    }
    (function() {
      function t2() {
        Wt$1(this, t2);
      }
      return $t$1(t2, null, [{ key: "deduplicate", value: function(t3) {
        return Array.from(new Set(t3));
      } }, { key: "flat", value: function(e2) {
        return e2.reduce(function(e3, n2) {
          var r2 = Array.isArray(n2) ? t2.flat(n2) : n2;
          return e3.concat(r2);
        }, []);
      } }, { key: "find", value: function(t3, e2) {
        return t3.find(e2);
      } }, { key: "findIndex", value: function(t3, e2) {
        return t3.findIndex(e2);
      } }]), t2;
    })();
    (function() {
      function t2() {
        Wt$1(this, t2);
      }
      return $t$1(t2, null, [{ key: "today", value: function() {
        return /* @__PURE__ */ new Date();
      } }]), t2;
    })();
    (function() {
      function t2() {
        Wt$1(this, t2);
      }
      return $t$1(t2, null, [{ key: "range", value: function(t3, e2, n2) {
        return Math.min(Math.max(t3, e2), n2);
      } }, { key: "clamp", value: function(t3, e2, n2) {
        return e2 < n2 ? t3 < e2 ? e2 : t3 > n2 ? n2 : t3 : t3 < n2 ? n2 : t3 > e2 ? e2 : t3;
      } }]), t2;
    })();
    var qe = Object.defineProperty;
    var Ye = (e2, t2, o2) => t2 in e2 ? qe(e2, t2, { enumerable: true, configurable: true, writable: true, value: o2 }) : e2[t2] = o2;
    var W = (e2, t2, o2) => (Ye(e2, typeof t2 != "symbol" ? t2 + "" : t2, o2), o2);
    const P = (e2) => Math.round(e2 * 100) / 100;
    class A {
      constructor(t2) {
        W(this, "instance");
        W(this, "alphaValue", 0);
        W(this, "redValue", 0);
        W(this, "greenValue", 0);
        W(this, "blueValue", 0);
        W(this, "hueValue", 0);
        W(this, "saturationValue", 0);
        W(this, "brightnessValue", 0);
        W(this, "hslSaturationValue", 0);
        W(this, "lightnessValue", 0);
        W(this, "initAlpha", () => {
          const t3 = this.instance.getAlpha();
          this.alphaValue = Math.min(1, t3) * 100;
        });
        W(this, "initLightness", () => {
          const { s: t3, l: o2 } = this.instance.toHsl();
          this.hslSaturationValue = P(t3), this.lightnessValue = P(o2);
        });
        W(this, "initRgb", () => {
          const { r: t3, g: o2, b: n2 } = this.instance.toRgb();
          this.redValue = P(t3), this.greenValue = P(o2), this.blueValue = P(n2);
        });
        W(this, "initHsb", () => {
          const { h: t3, s: o2, v: n2 } = this.instance.toHsv();
          this.hueValue = Math.min(360, Math.ceil(t3)), this.saturationValue = P(o2), this.brightnessValue = P(n2);
        });
        W(this, "toHexString", () => this.instance.toHexString());
        W(this, "toRgbString", () => this.instance.toRgbString());
        this.instance = tinycolor(t2), this.initRgb(), this.initHsb(), this.initLightness(), this.initAlpha();
      }
      toString(t2) {
        return this.instance.toString(t2);
      }
      get hex() {
        return this.instance.toHex();
      }
      set hex(t2) {
        this.instance = tinycolor(t2), this.initHsb(), this.initRgb(), this.initAlpha(), this.initLightness();
      }
      // 
      set hue(t2) {
        this.saturation === 0 && this.brightness === 0 && (this.saturationValue = 1, this.brightnessValue = 1), this.instance = tinycolor({
          h: P(t2),
          s: this.saturation,
          v: this.brightness,
          a: this.alphaValue / 100
        }), this.initRgb(), this.initLightness(), this.hueValue = P(t2);
      }
      get hue() {
        return this.hueValue;
      }
      // 
      set saturation(t2) {
        this.instance = tinycolor({
          h: this.hue,
          s: P(t2),
          v: this.brightness,
          a: this.alphaValue / 100
        }), this.initRgb(), this.initLightness(), this.saturationValue = P(t2);
      }
      get saturation() {
        return this.saturationValue;
      }
      // 
      set brightness(t2) {
        this.instance = tinycolor({
          h: this.hue,
          s: this.saturation,
          v: P(t2),
          a: this.alphaValue / 100
        }), this.initRgb(), this.initLightness(), this.brightnessValue = P(t2);
      }
      get brightness() {
        return this.brightnessValue;
      }
      // 
      set lightness(t2) {
        this.instance = tinycolor({
          h: this.hue,
          s: this.hslSaturationValue,
          l: P(t2),
          a: this.alphaValue / 100
        }), this.initRgb(), this.initHsb(), this.lightnessValue = P(t2);
      }
      get lightness() {
        return this.lightnessValue;
      }
      // red
      set red(t2) {
        const o2 = this.instance.toRgb();
        this.instance = tinycolor({
          ...o2,
          r: P(t2),
          a: this.alphaValue / 100
        }), this.initHsb(), this.initLightness(), this.redValue = P(t2);
      }
      get red() {
        return this.redValue;
      }
      // green
      set green(t2) {
        const o2 = this.instance.toRgb();
        this.instance = tinycolor({
          ...o2,
          g: P(t2),
          a: this.alphaValue / 100
        }), this.initHsb(), this.initLightness(), this.greenValue = P(t2);
      }
      get green() {
        return this.greenValue;
      }
      // blue
      set blue(t2) {
        const o2 = this.instance.toRgb();
        this.instance = tinycolor({
          ...o2,
          b: P(t2),
          a: this.alphaValue / 100
        }), this.initHsb(), this.initLightness(), this.blueValue = P(t2);
      }
      get blue() {
        return this.blueValue;
      }
      // alpha
      set alpha(t2) {
        this.instance.setAlpha(t2 / 100), this.alphaValue = t2;
      }
      get alpha() {
        return this.alphaValue;
      }
      get RGB() {
        return [this.red, this.green, this.blue, parseFloat((this.alpha / 100).toFixed(2))];
      }
      get HSB() {
        return [this.hue, this.saturation, this.brightness, parseFloat((this.alpha / 100).toFixed(2))];
      }
      get HSL() {
        return [
          this.hue,
          this.hslSaturationValue,
          this.lightness,
          parseFloat((this.alpha / 100).toFixed(2))
        ];
      }
    }
    function Ae(e2, t2, o2, n2) {
      return `rgba(${[e2, t2, o2, n2 / 100].join(",")})`;
    }
    const ue = (e2, t2, o2) => t2 < o2 ? e2 < t2 ? t2 : e2 > o2 ? o2 : e2 : e2 < o2 ? o2 : e2 > t2 ? t2 : e2, fe = "color-history", Ce = 8;
    const q = (e2, t2) => {
      const o2 = e2.__vccOpts || e2;
      for (const [n2, i2] of t2)
        o2[n2] = i2;
      return o2;
    }, lt = defineComponent({
      name: "Alpha",
      props: {
        color: C$1.instanceOf(A),
        size: C$1.oneOf(["small", "default"]).def("default")
      },
      emits: ["change"],
      setup(e2, { emit: t2 }) {
        const o2 = ref(null), n2 = ref(null);
        let i2 = e2.color || new A();
        const l2 = reactive({
          red: i2.red,
          green: i2.green,
          blue: i2.blue,
          alpha: i2.alpha
        });
        watch(
          () => e2.color,
          (g2) => {
            g2 && (i2 = g2, merge$1(l2, {
              red: g2.red,
              green: g2.green,
              blue: g2.blue,
              alpha: g2.alpha
            }));
          },
          { deep: true }
        );
        const a2 = computed(() => {
          const g2 = Ae(l2.red, l2.green, l2.blue, 0), d2 = Ae(l2.red, l2.green, l2.blue, 100);
          return {
            background: `linear-gradient(to right, ${g2} , ${d2})`
          };
        }), r2 = () => {
          if (o2.value && n2.value) {
            const g2 = l2.alpha / 100, d2 = o2.value.getBoundingClientRect(), m2 = n2.value.offsetWidth;
            return Math.round(g2 * (d2.width - m2) + m2 / 2);
          }
          return 0;
        }, c2 = computed(() => ({
          left: r2() + "px",
          top: 0
        })), k2 = (g2) => {
          g2.target !== o2.value && p2(g2);
        }, p2 = (g2) => {
          if (g2.stopPropagation(), o2.value && n2.value) {
            const d2 = o2.value.getBoundingClientRect(), m2 = n2.value.offsetWidth;
            let b2 = g2.clientX - d2.left;
            b2 = Math.max(m2 / 2, b2), b2 = Math.min(b2, d2.width - m2 / 2);
            const h2 = Math.round((b2 - m2 / 2) / (d2.width - m2) * 100);
            i2.alpha = h2, l2.alpha = h2, t2("change", h2);
          }
        };
        return tryOnMounted(() => {
          const g2 = {
            drag: (d2) => {
              p2(d2);
            },
            end: (d2) => {
              p2(d2);
            }
          };
          o2.value && n2.value && Vn.triggerDragEvent(o2.value, g2);
        }), { barElement: o2, cursorElement: n2, getCursorStyle: c2, getBackgroundStyle: a2, onClickSider: k2 };
      }
    }), st = (e2) => (pushScopeId("data-v-18925ba6"), e2 = e2(), popScopeId(), e2), it = /* @__PURE__ */ st(() => /* @__PURE__ */ createBaseVNode("div", { class: "vc-alpha-slider__bar-handle" }, null, -1)), ct = [
      it
    ];
    function ut(e2, t2, o2, n2, i2, l2) {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["vc-alpha-slider", "transparent", { "small-slider": e2.size === "small" }])
      }, [
        createBaseVNode("div", {
          ref: "barElement",
          class: "vc-alpha-slider__bar",
          style: normalizeStyle(e2.getBackgroundStyle),
          onClick: t2[0] || (t2[0] = (...a2) => e2.onClickSider && e2.onClickSider(...a2))
        }, [
          createBaseVNode("div", {
            class: normalizeClass(["vc-alpha-slider__bar-pointer", { "small-bar": e2.size === "small" }]),
            ref: "cursorElement",
            style: normalizeStyle(e2.getCursorStyle)
          }, ct, 6)
        ], 4)
      ], 2);
    }
    const ve = /* @__PURE__ */ q(lt, [["render", ut], ["__scopeId", "data-v-18925ba6"]]);
    const dt = [
      // 
      [
        "#fcc02e",
        "#f67c01",
        "#e64a19",
        "#d81b43",
        "#8e24aa",
        "#512da7",
        "#1f87e8",
        "#008781",
        "#05a045"
      ],
      // 
      [
        "#fed835",
        "#fb8c00",
        "#f5511e",
        "#eb1d4e",
        "#9c28b1",
        "#5d35b0",
        "#2097f3",
        "#029688",
        "#4cb050"
      ],
      // 
      [
        "#ffeb3c",
        "#ffa727",
        "#fe5722",
        "#eb4165",
        "#aa47bc",
        "#673bb7",
        "#42a5f6",
        "#26a59a",
        "#83c683"
      ],
      // 
      [
        "#fff176",
        "#ffb74e",
        "#ff8a66",
        "#f1627e",
        "#b968c7",
        "#7986cc",
        "#64b5f6",
        "#80cbc4",
        "#a5d6a7"
      ],
      // 
      [
        "#fff59c",
        "#ffcc80",
        "#ffab91",
        "#fb879e",
        "#cf93d9",
        "#9ea8db",
        "#90caf8",
        "#b2dfdc",
        "#c8e6ca"
      ],
      // 
      [
        "transparent",
        "#ffffff",
        "#dedede",
        "#a9a9a9",
        "#4b4b4b",
        "#353535",
        "#212121",
        "#000000",
        "advance"
      ]
    ], gt = defineComponent({
      name: "Palette",
      emits: ["change"],
      setup(e2, { emit: t2 }) {
        return { palettes: dt, computedBgStyle: (i2) => i2 === "transparent" ? i2 : i2 === "advance" ? {} : { background: tinycolor(i2).toRgbString() }, onColorChange: (i2) => {
          t2("change", i2);
        } };
      }
    }), ht = { class: "vc-compact" }, pt = ["onClick"];
    function ft(e2, t2, o2, n2, i2, l2) {
      return openBlock(), createElementBlock("div", ht, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(e2.palettes, (a2, r2) => (openBlock(), createElementBlock("div", {
          key: r2,
          class: "vc-compact__row"
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(a2, (c2, k2) => (openBlock(), createElementBlock("div", {
            key: k2,
            class: "vc-compact__color-cube--wrap",
            onClick: (p2) => e2.onColorChange(c2)
          }, [
            createBaseVNode("div", {
              class: normalizeClass([
                "vc-compact__color_cube",
                {
                  advance: c2 === "advance",
                  transparent: c2 === "transparent"
                }
              ]),
              style: normalizeStyle(e2.computedBgStyle(c2))
            }, null, 6)
          ], 8, pt))), 128))
        ]))), 128))
      ]);
    }
    const Ke = /* @__PURE__ */ q(gt, [["render", ft], ["__scopeId", "data-v-b969fd48"]]);
    const Ct = defineComponent({
      name: "Board",
      props: {
        color: C$1.instanceOf(A),
        round: C$1.bool.def(false),
        hide: C$1.bool.def(true)
      },
      emits: ["change"],
      setup(e2, { emit: t2 }) {
        var y2, f2, w2;
        const o2 = getCurrentInstance(), n2 = {
          h: ((y2 = e2.color) == null ? void 0 : y2.hue) || 0,
          s: 1,
          v: 1
        }, i2 = new A(n2).toHexString(), l2 = reactive({
          hueColor: i2,
          saturation: ((f2 = e2.color) == null ? void 0 : f2.saturation) || 0,
          brightness: ((w2 = e2.color) == null ? void 0 : w2.brightness) || 0
        }), a2 = ref(0), r2 = ref(0), c2 = ref(), k2 = computed(() => ({
          top: a2.value + "px",
          left: r2.value + "px"
        })), p2 = () => {
          if (o2) {
            const S2 = o2.vnode.el;
            r2.value = l2.saturation * (S2 == null ? void 0 : S2.clientWidth), a2.value = (1 - l2.brightness) * (S2 == null ? void 0 : S2.clientHeight);
          }
        };
        let g2 = false;
        const d2 = (S2) => {
          g2 = true, h2(S2);
        }, m2 = (S2) => {
          g2 && h2(S2);
        }, b2 = () => {
          g2 = false;
        }, h2 = (S2) => {
          if (o2) {
            const F2 = o2.vnode.el, E2 = F2 == null ? void 0 : F2.getBoundingClientRect();
            let L2 = S2.clientX - E2.left, U2 = S2.clientY - E2.top;
            L2 = ue(L2, 0, E2.width), U2 = ue(U2, 0, E2.height);
            const J2 = L2 / E2.width, X2 = ue(-(U2 / E2.height) + 1, 0, 1);
            r2.value = L2, a2.value = U2, l2.saturation = J2, l2.brightness = X2, t2("change", J2, X2);
          }
        };
        return tryOnMounted(() => {
          o2 && o2.vnode.el && c2.value && nextTick(() => {
            p2();
          });
        }), whenever(
          () => e2.color,
          (S2) => {
            merge$1(l2, {
              hueColor: new A({ h: S2.hue, s: 1, v: 1 }).toHexString(),
              saturation: S2.saturation,
              brightness: S2.brightness
            }), p2();
          },
          { deep: true }
        ), { state: l2, cursorElement: c2, getCursorStyle: k2, onClickBoard: d2, onDrag: m2, onDragEnd: b2 };
      }
    }), be = (e2) => (pushScopeId("data-v-7f0cdcdf"), e2 = e2(), popScopeId(), e2), vt = /* @__PURE__ */ be(() => /* @__PURE__ */ createBaseVNode("div", { class: "vc-saturation__white" }, null, -1)), bt = /* @__PURE__ */ be(() => /* @__PURE__ */ createBaseVNode("div", { class: "vc-saturation__black" }, null, -1)), yt = /* @__PURE__ */ be(() => /* @__PURE__ */ createBaseVNode("div", null, null, -1)), _t = [
      yt
    ];
    function mt(e2, t2, o2, n2, i2, l2) {
      return openBlock(), createElementBlock("div", {
        ref: "boardElement",
        class: normalizeClass(["vc-saturation", { "vc-saturation__chrome": e2.round, "vc-saturation__hidden": e2.hide }]),
        style: normalizeStyle({ backgroundColor: e2.state.hueColor }),
        onMousedown: t2[0] || (t2[0] = (...a2) => e2.onClickBoard && e2.onClickBoard(...a2)),
        onMousemove: t2[1] || (t2[1] = (...a2) => e2.onDrag && e2.onDrag(...a2)),
        onMouseup: t2[2] || (t2[2] = (...a2) => e2.onDragEnd && e2.onDragEnd(...a2))
      }, [
        vt,
        bt,
        createBaseVNode("div", {
          class: "vc-saturation__cursor",
          ref: "cursorElement",
          style: normalizeStyle(e2.getCursorStyle)
        }, _t, 4)
      ], 38);
    }
    const ye = /* @__PURE__ */ q(Ct, [["render", mt], ["__scopeId", "data-v-7f0cdcdf"]]);
    const St = defineComponent({
      name: "Hue",
      props: {
        color: C$1.instanceOf(A),
        size: C$1.oneOf(["small", "default"]).def("default")
      },
      emits: ["change"],
      setup(e2, { emit: t2 }) {
        const o2 = ref(null), n2 = ref(null);
        let i2 = e2.color || new A();
        const l2 = reactive({
          hue: i2.hue || 0
        });
        watch(
          () => e2.color,
          (p2) => {
            p2 && (i2 = p2, merge$1(l2, { hue: i2.hue }));
          },
          { deep: true }
        );
        const a2 = () => {
          if (o2.value && n2.value) {
            const p2 = o2.value.getBoundingClientRect(), g2 = n2.value.offsetWidth;
            return l2.hue === 360 ? p2.width - g2 / 2 : l2.hue % 360 * (p2.width - g2) / 360 + g2 / 2;
          }
          return 0;
        }, r2 = computed(() => ({
          left: a2() + "px",
          top: 0
        })), c2 = (p2) => {
          p2.target !== o2.value && k2(p2);
        }, k2 = (p2) => {
          if (p2.stopPropagation(), o2.value && n2.value) {
            const g2 = o2.value.getBoundingClientRect(), d2 = n2.value.offsetWidth;
            let m2 = p2.clientX - g2.left;
            m2 = Math.min(m2, g2.width - d2 / 2), m2 = Math.max(d2 / 2, m2);
            const b2 = Math.round((m2 - d2 / 2) / (g2.width - d2) * 360);
            i2.hue = b2, l2.hue = b2, t2("change", b2);
          }
        };
        return tryOnMounted(() => {
          const p2 = {
            drag: (g2) => {
              k2(g2);
            },
            end: (g2) => {
              k2(g2);
            }
          };
          o2.value && n2.value && Vn.triggerDragEvent(o2.value, p2);
        }), { barElement: o2, cursorElement: n2, getCursorStyle: r2, onClickSider: c2 };
      }
    }), kt = (e2) => (pushScopeId("data-v-e1a08576"), e2 = e2(), popScopeId(), e2), $t = /* @__PURE__ */ kt(() => /* @__PURE__ */ createBaseVNode("div", { class: "vc-hue-slider__bar-handle" }, null, -1)), wt = [
      $t
    ];
    function Bt(e2, t2, o2, n2, i2, l2) {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["vc-hue-slider", { "small-slider": e2.size === "small" }])
      }, [
        createBaseVNode("div", {
          ref: "barElement",
          class: "vc-hue-slider__bar",
          onClick: t2[0] || (t2[0] = (...a2) => e2.onClickSider && e2.onClickSider(...a2))
        }, [
          createBaseVNode("div", {
            class: normalizeClass(["vc-hue-slider__bar-pointer", { "small-bar": e2.size === "small" }]),
            ref: "cursorElement",
            style: normalizeStyle(e2.getCursorStyle)
          }, wt, 6)
        ], 512)
      ], 2);
    }
    const _e = /* @__PURE__ */ q(St, [["render", Bt], ["__scopeId", "data-v-e1a08576"]]);
    const Ht = defineComponent({
      name: "Lightness",
      props: {
        color: C$1.instanceOf(A),
        size: C$1.oneOf(["small", "default"]).def("default")
      },
      emits: ["change"],
      setup(e2, { emit: t2 }) {
        const o2 = ref(null), n2 = ref(null);
        let i2 = e2.color || new A();
        const [l2, a2, r2] = i2.HSL, c2 = reactive({
          hue: l2,
          saturation: a2,
          lightness: r2
        });
        watch(
          () => e2.color,
          (b2) => {
            if (b2) {
              i2 = b2;
              const [h2, y2, f2] = i2.HSL;
              merge$1(c2, {
                hue: h2,
                saturation: y2,
                lightness: f2
              });
            }
          },
          { deep: true }
        );
        const k2 = computed(() => {
          const b2 = tinycolor({
            h: c2.hue,
            s: c2.saturation,
            l: 0.8
          }).toPercentageRgbString(), h2 = tinycolor({
            h: c2.hue,
            s: c2.saturation,
            l: 0.6
          }).toPercentageRgbString(), y2 = tinycolor({
            h: c2.hue,
            s: c2.saturation,
            l: 0.4
          }).toPercentageRgbString(), f2 = tinycolor({
            h: c2.hue,
            s: c2.saturation,
            l: 0.2
          }).toPercentageRgbString();
          return {
            background: [
              `linear-gradient(to right, rgb(255, 255, 255), ${b2}, ${h2}, ${y2}, ${f2}, rgb(0, 0, 0))`,
              `-webkit-linear-gradient(left, rgb(255, 255, 255), ${b2}, ${h2}, ${y2}, ${f2}, rgb(0, 0, 0))`,
              `-moz-linear-gradient(left, rgb(255, 255, 255), ${b2}, ${h2}, ${y2}, ${f2}, rgb(0, 0, 0))`,
              `-ms-linear-gradient(left, rgb(255, 255, 255), ${b2}, ${h2}, ${y2}, ${f2}, rgb(0, 0, 0))`
            ]
          };
        }), p2 = () => {
          if (o2.value && n2.value) {
            const b2 = c2.lightness, h2 = o2.value.getBoundingClientRect(), y2 = n2.value.offsetWidth;
            return (1 - b2) * (h2.width - y2) + y2 / 2;
          }
          return 0;
        }, g2 = computed(() => ({
          left: p2() + "px",
          top: 0
        })), d2 = (b2) => {
          b2.target !== o2.value && m2(b2);
        }, m2 = (b2) => {
          if (b2.stopPropagation(), o2.value && n2.value) {
            const h2 = o2.value.getBoundingClientRect(), y2 = n2.value.offsetWidth;
            let f2 = b2.clientX - h2.left;
            f2 = Math.max(y2 / 2, f2), f2 = Math.min(f2, h2.width - y2 / 2);
            const w2 = 1 - (f2 - y2 / 2) / (h2.width - y2);
            i2.lightness = w2, t2("change", w2);
          }
        };
        return tryOnMounted(() => {
          const b2 = {
            drag: (h2) => {
              m2(h2);
            },
            end: (h2) => {
              m2(h2);
            }
          };
          o2.value && n2.value && Vn.triggerDragEvent(o2.value, b2);
        }), { barElement: o2, cursorElement: n2, getCursorStyle: g2, getBackgroundStyle: k2, onClickSider: d2 };
      }
    }), Rt = (e2) => (pushScopeId("data-v-94a50a9e"), e2 = e2(), popScopeId(), e2), At = /* @__PURE__ */ Rt(() => /* @__PURE__ */ createBaseVNode("div", { class: "vc-lightness-slider__bar-handle" }, null, -1)), Pt = [
      At
    ];
    function Vt(e2, t2, o2, n2, i2, l2) {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["vc-lightness-slider", { "small-slider": e2.size === "small" }])
      }, [
        createBaseVNode("div", {
          ref: "barElement",
          class: "vc-lightness-slider__bar",
          style: normalizeStyle(e2.getBackgroundStyle),
          onClick: t2[0] || (t2[0] = (...a2) => e2.onClickSider && e2.onClickSider(...a2))
        }, [
          createBaseVNode("div", {
            class: normalizeClass(["vc-lightness-slider__bar-pointer", { "small-bar": e2.size === "small" }]),
            ref: "cursorElement",
            style: normalizeStyle(e2.getCursorStyle)
          }, Pt, 6)
        ], 4)
      ], 2);
    }
    const Le = /* @__PURE__ */ q(Ht, [["render", Vt], ["__scopeId", "data-v-94a50a9e"]]);
    const Mt = defineComponent({
      name: "History",
      props: {
        colors: C$1.arrayOf(String).def(() => []),
        round: C$1.bool.def(false)
      },
      emits: ["change"],
      setup(e2, { emit: t2 }) {
        return { onColorSelect: (n2) => {
          t2("change", n2);
        } };
      }
    }), Et = {
      key: 0,
      class: "vc-colorPicker__record"
    }, It = { class: "color-list" }, Kt = ["onClick"];
    function Lt(e2, t2, o2, n2, i2, l2) {
      return e2.colors && e2.colors.length > 0 ? (openBlock(), createElementBlock("div", Et, [
        createBaseVNode("div", It, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(e2.colors, (a2, r2) => (openBlock(), createElementBlock("div", {
            key: r2,
            class: normalizeClass(["color-item", "transparent", { "color-item__round": e2.round }]),
            onClick: (c2) => e2.onColorSelect(a2)
          }, [
            createBaseVNode("div", {
              class: "color-item__display",
              style: normalizeStyle({ backgroundColor: a2 })
            }, null, 4)
          ], 10, Kt))), 128))
        ])
      ])) : createCommentVNode("", true);
    }
    const me = /* @__PURE__ */ q(Mt, [["render", Lt], ["__scopeId", "data-v-0f657238"]]);
    const Nt = defineComponent({
      name: "Display",
      props: {
        color: C$1.instanceOf(A),
        disableAlpha: C$1.bool.def(false)
      },
      emits: ["update:color", "change"],
      setup(e2, { emit: t2 }) {
        var m2, b2, h2, y2;
        const { copy: o2, copied: n2, isSupported: i2 } = useClipboard(), l2 = ref("hex"), a2 = reactive({
          color: e2.color,
          hex: (m2 = e2.color) == null ? void 0 : m2.hex,
          alpha: Math.round(((b2 = e2.color) == null ? void 0 : b2.alpha) || 100),
          rgba: (h2 = e2.color) == null ? void 0 : h2.RGB,
          previewBgColor: (y2 = e2.color) == null ? void 0 : y2.toRgbString()
        }), r2 = computed(() => ({
          background: a2.previewBgColor
        })), c2 = () => {
          l2.value = l2.value === "rgba" ? "hex" : "rgba";
        }, k2 = useDebounceFn((f2) => {
          if (!f2.target.value)
            return;
          let w2 = parseInt(f2.target.value.replace("%", ""));
          w2 > 100 && (f2.target.value = "100", w2 = 100), w2 < 0 && (f2.target.value = "0", w2 = 0), isNaN(w2) && (f2.target.value = "100", w2 = 100), !isNaN(w2) && a2.color && (a2.color.alpha = w2), t2("change", a2.color);
        }, 300), p2 = useDebounceFn((f2, w2) => {
          if (a2.color) {
            if (l2.value === "hex") {
              const S2 = f2.target.value.replace("#", "");
              tinycolor(S2).isValid() ? [3, 4].includes(S2.length) && (a2.color.hex = S2) : a2.color.hex = "000000", t2("change", a2.color);
            } else if (l2.value === "rgba" && w2 === 3 && f2.target.value.toString() === "0." && a2.rgba) {
              a2.rgba[w2] = f2.target.value;
              const [S2, F2, E2, L2] = a2.rgba;
              a2.color.hex = tinycolor({ r: S2, g: F2, b: E2 }).toHex(), a2.color.alpha = Math.round(L2 * 100), t2("change", a2.color);
            }
          }
        }, 100), g2 = useDebounceFn((f2, w2) => {
          if (f2.target.value) {
            if (l2.value === "hex") {
              const S2 = f2.target.value.replace("#", "");
              tinycolor(S2).isValid() && a2.color && [6, 8].includes(S2.length) && (a2.color.hex = S2);
            } else if (w2 !== void 0 && a2.rgba && a2.color) {
              if (f2.target.value < 0 && (f2.target.value = 0), w2 === 3 && ((f2.target.value > 1 || isNaN(f2.target.value)) && (f2.target.value = 1), f2.target.value.toString() === "0."))
                return;
              w2 < 3 && f2.target.value > 255 && (f2.target.value = 255), a2.rgba[w2] = f2.target.value;
              const [S2, F2, E2, L2] = a2.rgba;
              a2.color.hex = tinycolor({ r: S2, g: F2, b: E2 }).toHex(), a2.color.alpha = Math.round(L2 * 100);
            }
            t2("change", a2.color);
          }
        }, 300), d2 = () => {
          if (i2 && a2.color) {
            const f2 = l2.value === "hex" ? a2.color.toString(a2.color.alpha === 100 ? "hex6" : "hex8") : a2.color.toRgbString();
            o2(f2 || "");
          }
        };
        return whenever(
          () => e2.color,
          (f2) => {
            f2 && (a2.color = f2, a2.alpha = Math.round(a2.color.alpha), a2.hex = a2.color.hex, a2.rgba = a2.color.RGB);
          },
          { deep: true }
        ), whenever(
          () => a2.color,
          () => {
            a2.color && (a2.previewBgColor = a2.color.toRgbString());
          },
          { deep: true }
        ), {
          state: a2,
          getBgColorStyle: r2,
          inputType: l2,
          copied: n2,
          onInputTypeChange: c2,
          onAlphaBlur: k2,
          onInputChange: g2,
          onBlurChange: p2,
          onCopyColorStr: d2
        };
      }
    }), Wt = { class: "vc-display" }, Dt = { class: "vc-current-color vc-transparent" }, Tt = {
      key: 0,
      class: "copy-text"
    }, Ot = {
      key: 0,
      style: { display: "flex", flex: "1", gap: "4px", height: "100%" }
    }, zt = { class: "vc-color-input" }, Gt = {
      key: 0,
      class: "vc-alpha-input"
    }, Ft = ["value"], Xt = {
      key: 1,
      style: { display: "flex", flex: "1", gap: "4px", height: "100%" }
    }, qt = ["value", "onInput", "onBlur"];
    function Yt(e2, t2, o2, n2, i2, l2) {
      return openBlock(), createElementBlock("div", Wt, [
        createBaseVNode("div", Dt, [
          createBaseVNode("div", {
            class: "color-cube",
            style: normalizeStyle(e2.getBgColorStyle),
            onClick: t2[0] || (t2[0] = (...a2) => e2.onCopyColorStr && e2.onCopyColorStr(...a2))
          }, [
            e2.copied ? (openBlock(), createElementBlock("span", Tt, "Copied!")) : createCommentVNode("", true)
          ], 4)
        ]),
        e2.inputType === "hex" ? (openBlock(), createElementBlock("div", Ot, [
          createBaseVNode("div", zt, [
            withDirectives(createBaseVNode("input", {
              "onUpdate:modelValue": t2[1] || (t2[1] = (a2) => e2.state.hex = a2),
              maxlength: "8",
              onInput: t2[2] || (t2[2] = (...a2) => e2.onInputChange && e2.onInputChange(...a2)),
              onBlur: t2[3] || (t2[3] = (...a2) => e2.onBlurChange && e2.onBlurChange(...a2))
            }, null, 544), [
              [vModelText, e2.state.hex]
            ])
          ]),
          e2.disableAlpha ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", Gt, [
            createBaseVNode("input", {
              class: "vc-alpha-input__inner",
              value: e2.state.alpha,
              onInput: t2[4] || (t2[4] = (...a2) => e2.onAlphaBlur && e2.onAlphaBlur(...a2))
            }, null, 40, Ft),
            createTextVNode("% ")
          ]))
        ])) : e2.state.rgba ? (openBlock(), createElementBlock("div", Xt, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(e2.state.rgba, (a2, r2) => (openBlock(), createElementBlock("div", {
            class: "vc-color-input",
            key: r2
          }, [
            createBaseVNode("input", {
              value: a2,
              onInput: (c2) => e2.onInputChange(c2, r2),
              onBlur: (c2) => e2.onBlurChange(c2, r2)
            }, null, 40, qt)
          ]))), 128))
        ])) : createCommentVNode("", true),
        createBaseVNode("div", {
          class: "vc-input-toggle",
          onClick: t2[5] || (t2[5] = (...a2) => e2.onInputTypeChange && e2.onInputTypeChange(...a2))
        }, toDisplayString(e2.inputType), 1)
      ]);
    }
    const Se = /* @__PURE__ */ q(Nt, [["render", Yt], ["__scopeId", "data-v-7334ac20"]]);
    const Ut = defineComponent({
      name: "FkColorPicker",
      components: { Display: Se, Alpha: ve, Palette: Ke, Board: ye, Hue: _e, Lightness: Le, History: me },
      props: {
        color: C$1.instanceOf(A),
        disableHistory: C$1.bool.def(false),
        roundHistory: C$1.bool.def(false),
        disableAlpha: C$1.bool.def(false)
      },
      emits: ["update:color", "change", "advanceChange"],
      setup(e2, { emit: t2 }) {
        const o2 = e2.color || new A(), n2 = reactive({
          color: o2,
          hex: o2.toHexString(),
          rgb: o2.toRgbString()
        }), i2 = ref(false), l2 = computed(() => ({ background: n2.rgb })), a2 = () => {
          i2.value = false, t2("advanceChange", false);
        }, r2 = useLocalStorage(fe, [], {}), c2 = useDebounceFn(() => {
          if (e2.disableHistory)
            return;
          const h2 = n2.color.toRgbString();
          if (r2.value = r2.value.filter((y2) => !tinycolor.equals(y2, h2)), !r2.value.includes(h2)) {
            for (; r2.value.length > Ce; )
              r2.value.pop();
            r2.value.unshift(h2);
          }
        }, 500), k2 = (h2) => {
          h2 === "advance" ? (i2.value = true, t2("advanceChange", true)) : (n2.color.hex = h2, t2("advanceChange", false));
        }, p2 = (h2) => {
          n2.color.alpha = h2;
        }, g2 = (h2) => {
          n2.color.hue = h2;
        }, d2 = (h2, y2) => {
          n2.color.saturation = h2, n2.color.brightness = y2;
        }, m2 = (h2) => {
          n2.color.lightness = h2;
        }, b2 = (h2) => {
          const f2 = h2.target.value.replace("#", "");
          tinycolor(f2).isValid() && (n2.color.hex = f2);
        };
        return whenever(
          () => e2.color,
          (h2) => {
            h2 && (n2.color = h2);
          },
          { deep: true }
        ), whenever(
          () => n2.color,
          () => {
            n2.hex = n2.color.hex, n2.rgb = n2.color.toRgbString(), c2(), t2("update:color", n2.color), t2("change", n2.color);
          },
          { deep: true }
        ), {
          state: n2,
          advancePanelShow: i2,
          onBack: a2,
          onCompactChange: k2,
          onAlphaChange: p2,
          onHueChange: g2,
          onBoardChange: d2,
          onLightChange: m2,
          onInputChange: b2,
          previewStyle: l2,
          historyColors: r2
        };
      }
    }), jt = (e2) => (pushScopeId("data-v-48e3c224"), e2 = e2(), popScopeId(), e2), Zt = { class: "vc-fk-colorPicker" }, Jt = { class: "vc-fk-colorPicker__inner" }, Qt = { class: "vc-fk-colorPicker__header" }, xt = /* @__PURE__ */ jt(() => /* @__PURE__ */ createBaseVNode("div", { class: "back" }, null, -1)), eo = [
      xt
    ];
    function to(e2, t2, o2, n2, i2, l2) {
      const a2 = resolveComponent("Palette"), r2 = resolveComponent("Board"), c2 = resolveComponent("Hue"), k2 = resolveComponent("Lightness"), p2 = resolveComponent("Alpha"), g2 = resolveComponent("Display"), d2 = resolveComponent("History");
      return openBlock(), createElementBlock("div", Zt, [
        createBaseVNode("div", Jt, [
          createBaseVNode("div", Qt, [
            e2.advancePanelShow ? (openBlock(), createElementBlock("span", {
              key: 0,
              style: { cursor: "pointer" },
              onClick: t2[0] || (t2[0] = (...m2) => e2.onBack && e2.onBack(...m2))
            }, eo)) : createCommentVNode("", true)
          ]),
          e2.advancePanelShow ? createCommentVNode("", true) : (openBlock(), createBlock(a2, {
            key: 0,
            onChange: e2.onCompactChange
          }, null, 8, ["onChange"])),
          e2.advancePanelShow ? (openBlock(), createBlock(r2, {
            key: 1,
            color: e2.state.color,
            onChange: e2.onBoardChange
          }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
          e2.advancePanelShow ? (openBlock(), createBlock(c2, {
            key: 2,
            color: e2.state.color,
            onChange: e2.onHueChange
          }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
          e2.advancePanelShow ? createCommentVNode("", true) : (openBlock(), createBlock(k2, {
            key: 3,
            color: e2.state.color,
            onChange: e2.onLightChange
          }, null, 8, ["color", "onChange"])),
          e2.disableAlpha ? createCommentVNode("", true) : (openBlock(), createBlock(p2, {
            key: 4,
            color: e2.state.color,
            onChange: e2.onAlphaChange
          }, null, 8, ["color", "onChange"])),
          createVNode(g2, {
            color: e2.state.color,
            "disable-alpha": e2.disableAlpha
          }, null, 8, ["color", "disable-alpha"]),
          e2.disableHistory ? createCommentVNode("", true) : (openBlock(), createBlock(d2, {
            key: 5,
            round: e2.roundHistory,
            colors: e2.historyColors,
            onChange: e2.onCompactChange
          }, null, 8, ["round", "colors", "onChange"]))
        ])
      ]);
    }
    const Pe = /* @__PURE__ */ q(Ut, [["render", to], ["__scopeId", "data-v-48e3c224"]]);
    const oo = defineComponent({
      name: "ChromeColorPicker",
      components: { Display: Se, Alpha: ve, Board: ye, Hue: _e, History: me },
      props: {
        color: C$1.instanceOf(A),
        disableHistory: C$1.bool.def(false),
        roundHistory: C$1.bool.def(false),
        disableAlpha: C$1.bool.def(false)
      },
      emits: ["update:color", "change"],
      setup(e2, { emit: t2 }) {
        const o2 = e2.color || new A(), n2 = reactive({
          color: o2,
          hex: o2.toHexString(),
          rgb: o2.toRgbString()
        }), i2 = computed(() => ({ background: n2.rgb })), l2 = useLocalStorage(fe, [], {}), a2 = useDebounceFn(() => {
          if (e2.disableHistory)
            return;
          const d2 = n2.color.toRgbString();
          if (l2.value = l2.value.filter((m2) => !tinycolor.equals(m2, d2)), !l2.value.includes(d2)) {
            for (; l2.value.length > Ce; )
              l2.value.pop();
            l2.value.unshift(d2);
          }
        }, 500), r2 = (d2) => {
          n2.color.alpha = d2;
        }, c2 = (d2) => {
          n2.color.hue = d2;
        }, k2 = (d2) => {
          d2.hex !== void 0 && (n2.color.hex = d2.hex), d2.alpha !== void 0 && (n2.color.alpha = d2.alpha);
        }, p2 = (d2, m2) => {
          n2.color.saturation = d2, n2.color.brightness = m2;
        }, g2 = (d2) => {
          d2 !== "advance" && (n2.color.hex = d2);
        };
        return whenever(
          () => e2.color,
          (d2) => {
            d2 && (n2.color = d2);
          },
          { deep: true }
        ), whenever(
          () => n2.color,
          () => {
            n2.hex = n2.color.hex, n2.rgb = n2.color.toRgbString(), a2(), t2("update:color", n2.color), t2("change", n2.color);
          },
          { deep: true }
        ), {
          state: n2,
          previewStyle: i2,
          historyColors: l2,
          onAlphaChange: r2,
          onHueChange: c2,
          onBoardChange: p2,
          onInputChange: k2,
          onCompactChange: g2
        };
      }
    }), no = { class: "vc-chrome-colorPicker" }, ao = { class: "vc-chrome-colorPicker-body" }, ro = { class: "chrome-controls" }, lo = { class: "chrome-sliders" };
    function so(e2, t2, o2, n2, i2, l2) {
      const a2 = resolveComponent("Board"), r2 = resolveComponent("Hue"), c2 = resolveComponent("Alpha"), k2 = resolveComponent("Display"), p2 = resolveComponent("History");
      return openBlock(), createElementBlock("div", no, [
        createVNode(a2, {
          round: true,
          hide: false,
          color: e2.state.color,
          onChange: e2.onBoardChange
        }, null, 8, ["color", "onChange"]),
        createBaseVNode("div", ao, [
          createBaseVNode("div", ro, [
            createBaseVNode("div", lo, [
              createVNode(r2, {
                size: "small",
                color: e2.state.color,
                onChange: e2.onHueChange
              }, null, 8, ["color", "onChange"]),
              e2.disableAlpha ? createCommentVNode("", true) : (openBlock(), createBlock(c2, {
                key: 0,
                size: "small",
                color: e2.state.color,
                onChange: e2.onAlphaChange
              }, null, 8, ["color", "onChange"]))
            ])
          ]),
          createVNode(k2, {
            color: e2.state.color,
            "disable-alpha": e2.disableAlpha
          }, null, 8, ["color", "disable-alpha"]),
          e2.disableHistory ? createCommentVNode("", true) : (openBlock(), createBlock(p2, {
            key: 0,
            round: e2.roundHistory,
            colors: e2.historyColors,
            onChange: e2.onCompactChange
          }, null, 8, ["round", "colors", "onChange"]))
        ])
      ]);
    }
    const Ve = /* @__PURE__ */ q(oo, [["render", so], ["__scopeId", "data-v-2611d66c"]]), ke = "Vue3ColorPickerProvider", io = (e2, t2) => {
      const o2 = e2.getBoundingClientRect(), n2 = o2.left + o2.width / 2, i2 = o2.top + o2.height / 2, l2 = Math.abs(n2 - t2.clientX), a2 = Math.abs(i2 - t2.clientY), r2 = Math.sqrt(Math.pow(l2, 2) + Math.pow(a2, 2)), c2 = a2 / r2, k2 = Math.acos(c2);
      let p2 = Math.floor(180 / (Math.PI / k2));
      return t2.clientX > n2 && t2.clientY > i2 && (p2 = 180 - p2), t2.clientX == n2 && t2.clientY > i2 && (p2 = 180), t2.clientX > n2 && t2.clientY == i2 && (p2 = 90), t2.clientX < n2 && t2.clientY > i2 && (p2 = 180 + p2), t2.clientX < n2 && t2.clientY == i2 && (p2 = 270), t2.clientX < n2 && t2.clientY < i2 && (p2 = 360 - p2), p2;
    };
    let de = false;
    const co = (e2, t2) => {
      const o2 = function(i2) {
        var l2;
        (l2 = t2.drag) == null || l2.call(t2, i2);
      }, n2 = function(i2) {
        var l2;
        document.removeEventListener("mousemove", o2, false), document.removeEventListener("mouseup", n2, false), document.onselectstart = null, document.ondragstart = null, de = false, (l2 = t2.end) == null || l2.call(t2, i2);
      };
      e2 && e2.addEventListener("mousedown", (i2) => {
        var l2;
        de || (document.onselectstart = () => false, document.ondragstart = () => false, document.addEventListener("mousemove", o2, false), document.addEventListener("mouseup", n2, false), de = true, (l2 = t2.start) == null || l2.call(t2, i2));
      });
    };
    const uo = {
      angle: {
        type: Number,
        default: 0
      },
      size: {
        type: Number,
        default: 16,
        validator: (e2) => e2 >= 16
      },
      borderWidth: {
        type: Number,
        default: 1,
        validator: (e2) => e2 >= 1
      },
      borderColor: {
        type: String,
        default: "#666"
      }
    }, go = defineComponent({
      name: "Angle",
      props: uo,
      emits: ["update:angle", "change"],
      setup(e2, {
        emit: t2
      }) {
        const o2 = ref(null), n2 = ref(0);
        watch(() => e2.angle, (r2) => {
          n2.value = r2;
        });
        const i2 = () => {
          let r2 = Number(n2.value);
          isNaN(r2) || (r2 = r2 > 360 || r2 < 0 ? e2.angle : r2, n2.value = r2 === 360 ? 0 : r2, t2("update:angle", n2.value), t2("change", n2.value));
        }, l2 = computed(() => ({
          width: e2.size + "px",
          height: e2.size + "px",
          borderWidth: e2.borderWidth + "px",
          borderColor: e2.borderColor,
          transform: `rotate(${n2.value}deg)`
        })), a2 = (r2) => {
          o2.value && (n2.value = io(o2.value, r2) % 360, i2());
        };
        return onMounted(() => {
          const r2 = {
            drag: (c2) => {
              a2(c2);
            },
            end: (c2) => {
              a2(c2);
            }
          };
          o2.value && co(o2.value, r2);
        }), () => createVNode("div", {
          class: "bee-angle"
        }, [createVNode("div", {
          class: "bee-angle__round",
          ref: o2,
          style: l2.value
        }, null)]);
      }
    });
    const ho = defineComponent({
      name: "GradientColorPicker",
      components: { Angle: go, Display: Se, Alpha: ve, Palette: Ke, Board: ye, Hue: _e, Lightness: Le, History: me },
      props: {
        startColor: C$1.instanceOf(A).isRequired,
        endColor: C$1.instanceOf(A).isRequired,
        startColorStop: C$1.number.def(0),
        endColorStop: C$1.number.def(100),
        angle: C$1.number.def(0),
        type: C$1.oneOf(["linear", "radial"]).def("linear"),
        disableHistory: C$1.bool.def(false),
        roundHistory: C$1.bool.def(false),
        disableAlpha: C$1.bool.def(false),
        pickerType: C$1.oneOf(["fk", "chrome"]).def("fk")
      },
      emits: [
        "update:startColor",
        "update:endColor",
        "update:angle",
        "update:startColorStop",
        "update:endColorStop",
        "startColorChange",
        "endColorChange",
        "advanceChange",
        "angleChange",
        "startColorStopChange",
        "endColorStopChange",
        "typeChange"
      ],
      setup(e2, { emit: t2 }) {
        const o2 = reactive({
          startActive: true,
          startColor: e2.startColor,
          endColor: e2.endColor,
          startColorStop: e2.startColorStop,
          endColorStop: e2.endColorStop,
          angle: e2.angle,
          type: e2.type,
          // rgba
          startColorRgba: e2.startColor.toRgbString(),
          endColorRgba: e2.endColor.toRgbString()
        }), n2 = inject(ke), i2 = ref(e2.pickerType === "chrome"), l2 = ref(), a2 = ref(), r2 = ref();
        watch(
          () => [e2.startColor, e2.endColor, e2.angle],
          (s2) => {
            o2.startColor = s2[0], o2.endColor = s2[1], o2.angle = s2[2];
          }
        ), watch(
          () => e2.type,
          (s2) => {
            o2.type = s2;
          }
        );
        const c2 = computed({
          get: () => o2.startActive ? o2.startColor : o2.endColor,
          set: (s2) => {
            if (o2.startActive) {
              o2.startColor = s2;
              return;
            }
            o2.endColor = s2;
          }
        }), k2 = computed(() => {
          if (r2.value && l2.value) {
            const s2 = o2.startColorStop / 100, _2 = r2.value.getBoundingClientRect(), H2 = l2.value.offsetWidth;
            return Math.round(s2 * (_2.width - H2) + H2 / 2);
          }
          return 0;
        }), p2 = computed(() => {
          if (r2.value && a2.value) {
            const s2 = o2.endColorStop / 100, _2 = r2.value.getBoundingClientRect(), H2 = a2.value.offsetWidth;
            return Math.round(s2 * (_2.width - H2) + H2 / 2);
          }
          return 0;
        }), g2 = computed(() => {
          let s2 = `background: linear-gradient(${o2.angle}deg, ${o2.startColorRgba} ${o2.startColorStop}%, ${o2.endColorRgba} ${o2.endColorStop}%)`;
          return o2.type === "radial" && (s2 = `background: radial-gradient(circle, ${o2.startColorRgba} ${o2.startColorStop}%, ${o2.endColorRgba} ${o2.endColorStop}%)`), s2;
        }), d2 = (s2) => {
          var _2;
          if (o2.startActive = true, r2.value && l2.value) {
            const H2 = (_2 = r2.value) == null ? void 0 : _2.getBoundingClientRect();
            let N2 = s2.clientX - H2.left;
            N2 = Math.max(l2.value.offsetWidth / 2, N2), N2 = Math.min(N2, H2.width - l2.value.offsetWidth / 2), o2.startColorStop = Math.round(
              (N2 - l2.value.offsetWidth / 2) / (H2.width - l2.value.offsetWidth) * 100
            ), t2("update:startColorStop", o2.startColorStop), t2("startColorStopChange", o2.startColorStop);
          }
        }, m2 = (s2) => {
          var _2;
          if (o2.startActive = false, r2.value && a2.value) {
            const H2 = (_2 = r2.value) == null ? void 0 : _2.getBoundingClientRect();
            let N2 = s2.clientX - H2.left;
            N2 = Math.max(a2.value.offsetWidth / 2, N2), N2 = Math.min(N2, H2.width - a2.value.offsetWidth / 2), o2.endColorStop = Math.round(
              (N2 - a2.value.offsetWidth / 2) / (H2.width - a2.value.offsetWidth) * 100
            ), t2("update:endColorStop", o2.endColorStop), t2("endColorStopChange", o2.endColorStop);
          }
        }, b2 = (s2) => {
          const _2 = s2.target, H2 = parseInt(_2.value.replace("", ""));
          isNaN(H2) || (o2.angle = H2 % 360), t2("update:angle", o2.angle), t2("angleChange", o2.angle);
        }, h2 = (s2) => {
          o2.angle = s2, t2("update:angle", o2.angle), t2("angleChange", o2.angle);
        }, y2 = (s2) => {
          s2 === "advance" ? (i2.value = true, t2("advanceChange", true)) : (c2.value.hex = s2, t2("advanceChange", false)), L2();
        }, f2 = (s2) => {
          c2.value.alpha = s2, L2();
        }, w2 = (s2) => {
          c2.value.hue = s2, L2();
        }, S2 = (s2, _2) => {
          c2.value.saturation = s2, c2.value.brightness = _2, L2();
        }, F2 = (s2) => {
          c2.value.lightness = s2, L2();
        }, E2 = () => {
          L2();
        }, L2 = () => {
          o2.startActive ? (t2("update:startColor", o2.startColor), t2("startColorChange", o2.startColor)) : (t2("update:endColor", o2.endColor), t2("endColorChange", o2.endColor));
        }, U2 = () => {
          i2.value = false, t2("advanceChange", false);
        }, J2 = () => {
          o2.type = o2.type === "linear" ? "radial" : "linear", t2("typeChange", o2.type);
        }, X2 = useLocalStorage(fe, [], {}), ce2 = useDebounceFn(() => {
          if (e2.disableHistory)
            return;
          const s2 = c2.value.toRgbString();
          if (X2.value = X2.value.filter((_2) => !tinycolor.equals(_2, s2)), !X2.value.includes(s2)) {
            for (; X2.value.length > Ce; )
              X2.value.pop();
            X2.value.unshift(s2);
          }
        }, 500);
        return tryOnMounted(() => {
          a2.value && l2.value && (Vn.triggerDragEvent(a2.value, {
            drag: (s2) => {
              m2(s2);
            },
            end: (s2) => {
              m2(s2);
            }
          }), Vn.triggerDragEvent(l2.value, {
            drag: (s2) => {
              d2(s2);
            },
            end: (s2) => {
              d2(s2);
            }
          }));
        }), whenever(
          () => o2.startColor,
          (s2) => {
            o2.startColorRgba = s2.toRgbString();
          },
          { deep: true }
        ), whenever(
          () => o2.endColor,
          (s2) => {
            o2.endColorRgba = s2.toRgbString();
          },
          { deep: true }
        ), whenever(
          () => c2.value,
          () => {
            ce2();
          },
          { deep: true }
        ), {
          startGradientRef: l2,
          stopGradientRef: a2,
          colorRangeRef: r2,
          state: o2,
          currentColor: c2,
          getStartColorLeft: k2,
          getEndColorLeft: p2,
          gradientBg: g2,
          advancePanelShow: i2,
          onDegreeBlur: b2,
          onCompactChange: y2,
          onAlphaChange: f2,
          onHueChange: w2,
          onBoardChange: S2,
          onLightChange: F2,
          historyColors: X2,
          onBack: U2,
          onDegreeChange: h2,
          onDisplayChange: E2,
          onTypeChange: J2,
          lang: n2 == null ? void 0 : n2.lang
        };
      }
    }), Ne = (e2) => (pushScopeId("data-v-c4d6d6ea"), e2 = e2(), popScopeId(), e2), po = { class: "vc-gradient-picker" }, fo = { class: "vc-gradient-picker__header" }, Co = { class: "vc-gradient__types" }, vo = { class: "vc-gradient-wrap__types" }, bo = { class: "vc-picker-degree-input vc-degree-input" }, yo = { class: "vc-degree-input__control" }, _o = ["value"], mo = { class: "vc-degree-input__panel" }, So = { class: "vc-degree-input__disk" }, ko = { class: "vc-gradient-picker__body" }, $o = {
      class: "vc-color-range",
      ref: "colorRangeRef"
    }, wo = { class: "vc-color-range__container" }, Bo = { class: "vc-gradient__stop__container" }, Ho = ["title"], Ro = /* @__PURE__ */ Ne(() => /* @__PURE__ */ createBaseVNode("span", { class: "vc-gradient__stop--inner" }, null, -1)), Ao = [
      Ro
    ], Po = ["title"], Vo = /* @__PURE__ */ Ne(() => /* @__PURE__ */ createBaseVNode("span", { class: "vc-gradient__stop--inner" }, null, -1)), Mo = [
      Vo
    ];
    function Eo(e2, t2, o2, n2, i2, l2) {
      var b2, h2;
      const a2 = resolveComponent("Angle"), r2 = resolveComponent("Board"), c2 = resolveComponent("Hue"), k2 = resolveComponent("Palette"), p2 = resolveComponent("Lightness"), g2 = resolveComponent("Alpha"), d2 = resolveComponent("Display"), m2 = resolveComponent("History");
      return openBlock(), createElementBlock("div", po, [
        createBaseVNode("div", fo, [
          createBaseVNode("div", null, [
            withDirectives(createBaseVNode("div", {
              class: "back",
              style: { cursor: "pointer" },
              onClick: t2[0] || (t2[0] = (...y2) => e2.onBack && e2.onBack(...y2))
            }, null, 512), [
              [vShow, e2.pickerType === "fk" && e2.advancePanelShow]
            ])
          ]),
          createBaseVNode("div", Co, [
            createBaseVNode("div", vo, [
              (openBlock(), createElementBlock(Fragment, null, renderList(["linear", "radial"], (y2) => createBaseVNode("div", {
                class: normalizeClass(["vc-gradient__type", { active: e2.state.type === y2 }]),
                key: y2,
                onClick: t2[1] || (t2[1] = (...f2) => e2.onTypeChange && e2.onTypeChange(...f2))
              }, toDisplayString(e2.lang ? e2.lang[y2] : y2), 3)), 64))
            ]),
            withDirectives(createBaseVNode("div", bo, [
              createBaseVNode("div", yo, [
                createBaseVNode("input", {
                  value: e2.state.angle,
                  onBlur: t2[2] || (t2[2] = (...y2) => e2.onDegreeBlur && e2.onDegreeBlur(...y2))
                }, null, 40, _o),
                createTextVNode("deg ")
              ]),
              createBaseVNode("div", mo, [
                createBaseVNode("div", So, [
                  createVNode(a2, {
                    angle: e2.state.angle,
                    "onUpdate:angle": t2[3] || (t2[3] = (y2) => e2.state.angle = y2),
                    size: 40,
                    onChange: e2.onDegreeChange
                  }, null, 8, ["angle", "onChange"])
                ])
              ])
            ], 512), [
              [vShow, e2.state.type === "linear"]
            ])
          ])
        ]),
        createBaseVNode("div", ko, [
          createBaseVNode("div", $o, [
            createBaseVNode("div", wo, [
              createBaseVNode("div", {
                class: "vc-background",
                style: normalizeStyle(e2.gradientBg)
              }, null, 4),
              createBaseVNode("div", Bo, [
                createBaseVNode("div", {
                  class: normalizeClass(["vc-gradient__stop", {
                    "vc-gradient__stop--current": e2.state.startActive
                  }]),
                  ref: "startGradientRef",
                  title: (b2 = e2.lang) == null ? void 0 : b2.start,
                  style: normalizeStyle({ left: e2.getStartColorLeft + "px", backgroundColor: e2.state.startColorRgba })
                }, Ao, 14, Ho),
                createBaseVNode("div", {
                  class: normalizeClass(["vc-gradient__stop", {
                    "vc-gradient__stop--current": !e2.state.startActive
                  }]),
                  ref: "stopGradientRef",
                  title: (h2 = e2.lang) == null ? void 0 : h2.end,
                  style: normalizeStyle({ left: e2.getEndColorLeft + "px", backgroundColor: e2.state.endColorRgba })
                }, Mo, 14, Po)
              ])
            ])
          ], 512)
        ]),
        e2.advancePanelShow ? (openBlock(), createBlock(r2, {
          key: 0,
          color: e2.currentColor,
          onChange: e2.onBoardChange
        }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
        e2.advancePanelShow ? (openBlock(), createBlock(c2, {
          key: 1,
          color: e2.currentColor,
          onChange: e2.onHueChange
        }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
        e2.advancePanelShow ? createCommentVNode("", true) : (openBlock(), createBlock(k2, {
          key: 2,
          onChange: e2.onCompactChange
        }, null, 8, ["onChange"])),
        e2.advancePanelShow ? createCommentVNode("", true) : (openBlock(), createBlock(p2, {
          key: 3,
          color: e2.currentColor,
          onChange: e2.onLightChange
        }, null, 8, ["color", "onChange"])),
        e2.disableAlpha ? createCommentVNode("", true) : (openBlock(), createBlock(g2, {
          key: 4,
          color: e2.currentColor,
          onChange: e2.onAlphaChange
        }, null, 8, ["color", "onChange"])),
        createVNode(d2, {
          color: e2.currentColor,
          "disable-alpha": e2.disableAlpha,
          onChange: e2.onDisplayChange
        }, null, 8, ["color", "disable-alpha", "onChange"]),
        e2.disableHistory ? createCommentVNode("", true) : (openBlock(), createBlock(m2, {
          key: 5,
          round: e2.roundHistory,
          colors: e2.historyColors,
          onChange: e2.onCompactChange
        }, null, 8, ["round", "colors", "onChange"]))
      ]);
    }
    const Me = /* @__PURE__ */ q(ho, [["render", Eo], ["__scopeId", "data-v-c4d6d6ea"]]);
    const Io = defineComponent({
      name: "WrapContainer",
      props: {
        theme: C$1.oneOf(["white", "black"]).def("white"),
        showTab: C$1.bool.def(false),
        activeKey: C$1.oneOf(["pure", "gradient"]).def("pure")
      },
      emits: ["update:activeKey", "change"],
      setup(e2, { emit: t2 }) {
        const o2 = reactive({
          activeKey: e2.activeKey
        }), n2 = inject(ke), i2 = (l2) => {
          o2.activeKey = l2, t2("update:activeKey", l2), t2("change", l2);
        };
        return whenever(
          () => e2.activeKey,
          (l2) => {
            o2.activeKey = l2;
          }
        ), { state: o2, onActiveKeyChange: i2, lang: n2 == null ? void 0 : n2.lang };
      }
    }), Ko = { class: "vc-colorpicker--container" }, Lo = {
      key: 0,
      class: "vc-colorpicker--tabs"
    }, No = { class: "vc-colorpicker--tabs__inner" }, Wo = { class: "vc-btn__content" }, Do = { class: "vc-btn__content" };
    function To(e2, t2, o2, n2, i2, l2) {
      var a2, r2;
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["vc-colorpicker", e2.theme])
      }, [
        createBaseVNode("div", Ko, [
          e2.showTab ? (openBlock(), createElementBlock("div", Lo, [
            createBaseVNode("div", No, [
              createBaseVNode("div", {
                class: normalizeClass([
                  "vc-colorpicker--tabs__btn",
                  {
                    "vc-btn-active": e2.state.activeKey === "pure"
                  }
                ]),
                onClick: t2[0] || (t2[0] = (c2) => e2.onActiveKeyChange("pure"))
              }, [
                createBaseVNode("button", null, [
                  createBaseVNode("div", Wo, toDisplayString((a2 = e2.lang) == null ? void 0 : a2.pure), 1)
                ])
              ], 2),
              createBaseVNode("div", {
                class: normalizeClass([
                  "vc-colorpicker--tabs__btn",
                  {
                    "vc-btn-active": e2.state.activeKey === "gradient"
                  }
                ]),
                onClick: t2[1] || (t2[1] = (c2) => e2.onActiveKeyChange("gradient"))
              }, [
                createBaseVNode("button", null, [
                  createBaseVNode("div", Do, toDisplayString((r2 = e2.lang) == null ? void 0 : r2.gradient), 1)
                ])
              ], 2),
              createBaseVNode("div", {
                class: "vc-colorpicker--tabs__bg",
                style: normalizeStyle({
                  width: "50%",
                  left: `calc(${e2.state.activeKey === "gradient" ? 50 : 0}%)`
                })
              }, null, 4)
            ])
          ])) : createCommentVNode("", true),
          renderSlot(e2.$slots, "default", {}, void 0, true)
        ])
      ], 2);
    }
    const Oo = /* @__PURE__ */ q(Io, [["render", To], ["__scopeId", "data-v-0492277d"]]), zo = {
      start: "Start",
      end: "End",
      pure: "Pure",
      gradient: "Gradient",
      linear: "linear",
      radial: "radial"
    }, Go = {
      start: "",
      end: "",
      pure: "",
      gradient: "",
      linear: "",
      radial: ""
    }, Fo = {
      En: zo,
      "ZH-cn": Go
    };
    const Xo = {
      isWidget: C$1.bool.def(false),
      pickerType: C$1.oneOf(["fk", "chrome"]).def("fk"),
      shape: C$1.oneOf(["circle", "square"]).def("square"),
      pureColor: {
        type: [String, Object],
        default: "#000000"
      },
      gradientColor: C$1.string.def(
        "linear-gradient(90deg, rgba(255, 255, 255, 1) 0%, rgba(0, 0, 0, 1) 100%)"
      ),
      format: {
        type: String,
        default: "rgb"
      },
      disableAlpha: C$1.bool.def(false),
      disableHistory: C$1.bool.def(false),
      roundHistory: C$1.bool.def(false),
      useType: C$1.oneOf(["pure", "gradient", "both"]).def("pure"),
      activeKey: C$1.oneOf(["pure", "gradient"]).def("pure"),
      lang: {
        type: String,
        default: "ZH-cn"
      },
      zIndex: C$1.number.def(9999),
      pickerContainer: {
        type: [String, HTMLElement],
        default: "body"
      },
      debounce: C$1.number.def(100),
      theme: C$1.oneOf(["white", "black"]).def("white"),
      blurClose: C$1.bool.def(false),
      defaultPopup: C$1.bool.def(false)
    }, qo = defineComponent({
      name: "ColorPicker",
      components: { FkColorPicker: Pe, ChromeColorPicker: Ve, GradientColorPicker: Me, WrapContainer: Oo },
      inheritAttrs: false,
      props: Xo,
      emits: [
        "update:pureColor",
        "pureColorChange",
        "update:gradientColor",
        "gradientColorChange",
        "update:activeKey",
        "activeKeyChange"
      ],
      setup(e2, { emit: t2 }) {
        provide(ke, {
          lang: computed(() => Fo[e2.lang || "ZH-cn"])
        });
        const o2 = !!useSlots().extra, n2 = reactive({
          pureColor: e2.pureColor || "",
          activeKey: e2.useType === "gradient" ? "gradient" : e2.activeKey,
          //  "pure" | "gradient"
          isAdvanceMode: false
        }), i2 = new A("#000"), l2 = new A("#000"), a2 = new A(n2.pureColor), r2 = reactive({
          startColor: i2,
          endColor: l2,
          startColorStop: 0,
          endColorStop: 100,
          angle: 0,
          type: "linear",
          gradientColor: e2.gradientColor
        }), c2 = ref(a2), k2 = ref(e2.defaultPopup), p2 = ref(null), g2 = ref(null);
        let d2 = null;
        const m2 = computed(() => ({
          background: n2.activeKey !== "gradient" ? tinycolor(n2.pureColor).toRgbString() : r2.gradientColor
        })), b2 = computed(() => n2.activeKey === "gradient" ? Me.name : e2.pickerType === "fk" ? Pe.name : Ve.name), h2 = (s2) => {
          n2.isAdvanceMode = s2;
        }, y2 = computed(() => {
          const s2 = {
            disableAlpha: e2.disableAlpha,
            disableHistory: e2.disableHistory,
            roundHistory: e2.roundHistory,
            pickerType: e2.pickerType
          };
          return n2.activeKey === "gradient" ? {
            ...s2,
            startColor: r2.startColor,
            endColor: r2.endColor,
            angle: r2.angle,
            type: r2.type,
            startColorStop: r2.startColorStop,
            endColorStop: r2.endColorStop,
            onStartColorChange: (_2) => {
              r2.startColor = _2, E2();
            },
            onEndColorChange: (_2) => {
              r2.endColor = _2, E2();
            },
            onStartColorStopChange: (_2) => {
              r2.startColorStop = _2, E2();
            },
            onEndColorStopChange: (_2) => {
              r2.endColorStop = _2, E2();
            },
            onAngleChange: (_2) => {
              r2.angle = _2, E2();
            },
            onTypeChange: (_2) => {
              r2.type = _2, E2();
            },
            onAdvanceChange: h2
          } : {
            ...s2,
            disableAlpha: e2.disableAlpha,
            disableHistory: e2.disableHistory,
            roundHistory: e2.roundHistory,
            color: c2.value,
            onChange: J2,
            onAdvanceChange: h2
          };
        }), f2 = () => {
          k2.value = true, d2 ? d2.update() : U2();
        }, w2 = () => {
          k2.value = false;
        }, S2 = useDebounceFn(() => {
          !e2.isWidget && e2.blurClose && w2();
        }, 100);
        onClickOutside(g2, () => {
          w2();
        });
        const F2 = () => {
          var s2, _2, H2, N2;
          try {
            const [z2] = parse(r2.gradientColor);
            if (z2 && z2.type.includes("gradient") && z2.colorStops.length >= 2) {
              const $e2 = z2.colorStops[0], we2 = z2.colorStops[1];
              r2.startColorStop = Number((s2 = $e2.length) == null ? void 0 : s2.value) || 0, r2.endColorStop = Number((_2 = we2.length) == null ? void 0 : _2.value) || 0, z2.type === "linear-gradient" && ((H2 = z2.orientation) == null ? void 0 : H2.type) === "angular" && (r2.angle = Number((N2 = z2.orientation) == null ? void 0 : N2.value) || 0), r2.type = z2.type.split("-")[0];
              const [We2, De2, Te2, Oe2] = $e2.value, [ze2, Ge2, Fe2, Xe2] = we2.value;
              r2.startColor = new A({
                r: Number(We2),
                g: Number(De2),
                b: Number(Te2),
                a: Number(Oe2)
              }), r2.endColor = new A({
                r: Number(ze2),
                g: Number(Ge2),
                b: Number(Fe2),
                a: Number(Xe2)
              });
            }
          } catch (z2) {
            console.log(`[Parse Color]: ${z2}`);
          }
        }, E2 = useDebounceFn(() => {
          const s2 = L2();
          try {
            r2.gradientColor = stringify(s2), t2("update:gradientColor", r2.gradientColor), t2("gradientColorChange", r2.gradientColor);
          } catch (_2) {
            console.log(_2);
          }
        }, e2.debounce), L2 = () => {
          const s2 = [], _2 = r2.startColor.RGB.map((z2) => z2.toString()), H2 = r2.endColor.RGB.map((z2) => z2.toString()), N2 = [
            {
              type: "rgba",
              value: [_2[0], _2[1], _2[2], _2[3]],
              length: { value: r2.startColorStop + "", type: "%" }
            },
            {
              type: "rgba",
              value: [H2[0], H2[1], H2[2], H2[3]],
              length: { value: r2.endColorStop + "", type: "%" }
            }
          ];
          return r2.type === "linear" ? s2.push({
            type: "linear-gradient",
            orientation: { type: "angular", value: r2.angle + "" },
            colorStops: N2
          }) : r2.type === "radial" && s2.push({
            type: "radial-gradient",
            orientation: [{ type: "shape", value: "circle" }],
            colorStops: N2
          }), s2;
        }, U2 = () => {
          p2.value && g2.value && (d2 = createPopper(p2.value, g2.value, {
            placement: "auto",
            modifiers: [
              {
                name: "offset",
                options: {
                  offset: [0, 8]
                }
              },
              {
                name: "flip",
                options: {
                  allowedAutoPlacements: ["top", "bottom", "left", "right"],
                  rootBoundary: "viewport"
                }
              }
            ]
          }));
        }, J2 = (s2) => {
          c2.value = s2, n2.pureColor = s2.toString(e2.format), X2();
        }, X2 = useDebounceFn(() => {
          t2("update:pureColor", n2.pureColor), t2("pureColorChange", n2.pureColor);
        }, e2.debounce), ce2 = (s2) => {
          n2.activeKey = s2, t2("update:activeKey", s2), t2("activeKeyChange", s2);
        };
        return tryOnMounted(() => {
          F2(), d2 || U2();
        }), whenever(
          () => e2.gradientColor,
          (s2) => {
            s2 != r2.gradientColor && (r2.gradientColor = s2);
          }
        ), whenever(
          () => r2.gradientColor,
          () => {
            F2();
          }
        ), whenever(
          () => e2.activeKey,
          (s2) => {
            n2.activeKey = s2;
          }
        ), whenever(
          () => e2.useType,
          (s2) => {
            n2.activeKey !== "gradient" && s2 === "gradient" ? n2.activeKey = "gradient" : n2.activeKey = "pure";
          }
        ), whenever(
          () => e2.pureColor,
          (s2) => {
            tinycolor.equals(s2, n2.pureColor) || (n2.pureColor = s2, c2.value = new A(s2));
          },
          { deep: true }
        ), {
          colorCubeRef: p2,
          pickerRef: g2,
          showPicker: k2,
          colorInstance: c2,
          getBgColorStyle: m2,
          getComponentName: b2,
          getBindArgs: y2,
          state: n2,
          hasExtra: o2,
          onColorChange: J2,
          onShowPicker: f2,
          onActiveKeyChange: ce2,
          onAutoClose: S2
        };
      }
    }), Yo = {
      key: 0,
      class: "vc-color-extra"
    }, Uo = {
      key: 0,
      class: "vc-color-extra"
    };
    function jo(e2, t2, o2, n2, i2, l2) {
      const a2 = resolveComponent("WrapContainer");
      return openBlock(), createElementBlock(Fragment, null, [
        e2.isWidget ? (openBlock(), createBlock(a2, {
          key: 0,
          "active-key": e2.state.activeKey,
          "onUpdate:activeKey": t2[0] || (t2[0] = (r2) => e2.state.activeKey = r2),
          "show-tab": e2.useType === "both",
          style: normalizeStyle({ zIndex: e2.zIndex }),
          theme: e2.theme,
          onChange: e2.onActiveKeyChange
        }, {
          default: withCtx(() => [
            (openBlock(), createBlock(resolveDynamicComponent(e2.getComponentName), mergeProps({ key: e2.getComponentName }, e2.getBindArgs), null, 16)),
            e2.hasExtra ? (openBlock(), createElementBlock("div", Yo, [
              renderSlot(e2.$slots, "extra", {}, void 0, true)
            ])) : createCommentVNode("", true)
          ]),
          _: 3
        }, 8, ["active-key", "show-tab", "style", "theme", "onChange"])) : createCommentVNode("", true),
        e2.isWidget ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          createBaseVNode("div", {
            class: normalizeClass(["vc-color-wrap transparent", { round: e2.shape === "circle" }]),
            ref: "colorCubeRef"
          }, [
            createBaseVNode("div", {
              class: "current-color",
              style: normalizeStyle(e2.getBgColorStyle),
              onClick: t2[1] || (t2[1] = (...r2) => e2.onShowPicker && e2.onShowPicker(...r2))
            }, null, 4)
          ], 2),
          (openBlock(), createBlock(Teleport, { to: e2.pickerContainer }, [
            withDirectives(createBaseVNode("div", {
              ref: "pickerRef",
              style: normalizeStyle({ zIndex: e2.zIndex }),
              onMouseleave: t2[3] || (t2[3] = (...r2) => e2.onAutoClose && e2.onAutoClose(...r2))
            }, [
              e2.showPicker ? (openBlock(), createBlock(a2, {
                key: 0,
                "show-tab": e2.useType === "both" && !e2.state.isAdvanceMode,
                theme: e2.theme,
                "active-key": e2.state.activeKey,
                "onUpdate:activeKey": t2[2] || (t2[2] = (r2) => e2.state.activeKey = r2),
                onChange: e2.onActiveKeyChange
              }, {
                default: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent(e2.getComponentName), mergeProps({ key: e2.getComponentName }, e2.getBindArgs), null, 16)),
                  e2.hasExtra ? (openBlock(), createElementBlock("div", Uo, [
                    renderSlot(e2.$slots, "extra", {}, void 0, true)
                  ])) : createCommentVNode("", true)
                ]),
                _: 3
              }, 8, ["show-tab", "theme", "active-key", "onChange"])) : createCommentVNode("", true)
            ], 36), [
              [vShow, e2.showPicker]
            ])
          ], 8, ["to"]))
        ], 64))
      ], 64);
    }
    const re = /* @__PURE__ */ q(qo, [["render", jo], ["__scopeId", "data-v-354ca836"]]);
    const _sfc_main$e = {
      __name: "color_picker",
      props: {
        text_box_name: {
          type: String,
          default: () => ""
        },
        default_color: {
          type: String,
          default: () => "#59c7f9"
        }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const props = __props;
        const color = ref("#F64272");
        const colorValue = ref("");
        const predefinedColors = ["#F64272", "#F6648B", "#F493A7", "#F891A6", "#FFCCD5"];
        onMounted(() => {
          color.value = props.default_color;
          colorValue.value = getColor();
        });
        function getColor() {
          return color.value;
        }
        function onChange(newColor) {
          colorValue.value = getColor();
        }
        const __returned__ = { props, color, colorValue, predefinedColors, getColor, onChange, ref, onMounted, get ColorPicker() {
          return re;
        } };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$d = ["value", "name", "id"];
    function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", null, [
        createVNode($setup["ColorPicker"], {
          pureColor: $setup.color,
          "onUpdate:pureColor": _cache[0] || (_cache[0] = ($event) => $setup.color = $event),
          onPureColorChange: $setup.onChange,
          shape: "circle",
          format: "hex",
          disableFields: true,
          defaultColors: $setup.predefinedColors
        }, null, 8, ["pureColor"]),
        createBaseVNode("input", {
          type: "hidden",
          value: $setup.colorValue,
          name: `color-${$props.text_box_name}`,
          id: `color-${$props.text_box_name}`,
          class: "field-edit",
          readonly: ""
        }, null, 8, _hoisted_1$d)
      ]);
    }
    const colorPicker = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$e], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/scaling_up_analysis/tools/color_picker.vue"]]);
    const _sfc_main$d = {
      props: {
        url: {
          type: String,
          default: ""
        },
        width: {
          type: String,
          default: "100px"
        }
      },
      name: "preview_item"
    };
    const _hoisted_1$c = { class: "img-container" };
    const _hoisted_2$b = ["src", "width"];
    const _hoisted_3$a = { class: "img-text" };
    function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", _hoisted_1$c, [
        createBaseVNode("img", {
          src: "/" + $props.url,
          width: $props.width
        }, null, 8, _hoisted_2$b),
        createBaseVNode("div", _hoisted_3$a, [
          renderSlot(_ctx.$slots, "default", {}, void 0, true)
        ])
      ]);
    }
    const preview_item = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$d], ["__scopeId", "data-v-ed216a7c"], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/scaling_up_analysis/components/basket/preview_item.vue"]]);
    const _sfc_main$c = {
      __name: "basket",
      setup(__props, { expose: __expose }) {
        __expose();
        const stores = inject("stores");
        const emitter = inject("emitter");
        const preview_images = ref([]);
        const just_added = ref(false);
        const basket_events = () => {
          emitter.on("add-section-template", (item) => {
            preview_images.value.push({ id: item.id, url: item.item });
            just_added.value = true;
          });
        };
        const not_empty = () => preview_images.value.length > 0;
        const load_all = async () => {
          const items = await stores.BasketStore.retrieve_all();
          items == null ? void 0 : items.forEach((item) => {
            preview_images.value.push({ id: item.id, url: item.item });
          });
        };
        const remove_item = async (idx) => {
          preview_images.value = [];
          const success = await stores.BasketStore.delete(idx);
          if (success) {
            await load_all();
          }
        };
        const remove_all = async () => {
          preview_images.value = [];
          const success = await stores.BasketStore.clear();
          if (success) {
            await load_all();
          }
        };
        const printElement = async () => {
          window.open(
            window.Routes.scaling_up_preview.replace("__id__", stores.BasketStore.get_scaling_up_id()),
            "",
            "directories=no,titlebar=no,toolbar=no,location=no,status=no,menubar=no,scrollbars=no,resizable=no"
          );
        };
        onMounted(async () => {
          basket_events();
          await load_all();
        });
        const __returned__ = { stores, emitter, preview_images, just_added, basket_events, not_empty, load_all, remove_item, remove_all, printElement, ref, onMounted, inject, preview_item };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$b = { class: "basket" };
    const _hoisted_2$a = { class: "basket-menu" };
    const _hoisted_3$9 = { class: "badge badge-pill badge-primary" };
    const _hoisted_4$8 = { class: "basket-content" };
    const _hoisted_5$7 = { class: "flex justify-start gap-2" };
    const _hoisted_6$4 = ["onClick"];
    const _hoisted_7$3 = { key: 1 };
    function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", null, [
        createBaseVNode("div", _hoisted_1$b, [
          createBaseVNode("div", _hoisted_2$a, [
            createBaseVNode("span", _hoisted_3$9, toDisplayString($setup.preview_images.length), 1),
            createBaseVNode("i", {
              onClick: _cache[0] || (_cache[0] = ($event) => $setup.remove_all()),
              class: "fa fa-trash text-red-800"
            }),
            createBaseVNode("i", {
              class: "fas fa-print",
              onClick: $setup.printElement
            })
          ]),
          createBaseVNode("div", _hoisted_4$8, [
            $setup.preview_images.length > 0 ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList($setup.preview_images, (image2, idx) => {
              return openBlock(), createElementBlock("div", {
                key: image2.id
              }, [
                createBaseVNode("div", _hoisted_5$7, [
                  createBaseVNode("i", {
                    onClick: ($event) => $setup.remove_item(image2.id),
                    class: "fa fa-times fa-2x text-red-800"
                  }, null, 8, _hoisted_6$4),
                  createVNode($setup["preview_item"], {
                    url: image2.url,
                    width: "100%"
                  }, null, 8, ["url"])
                ])
              ]);
            }), 128)) : (openBlock(), createElementBlock("div", _hoisted_7$3, " Basket is empty "))
          ])
        ]),
        _cache[1] || (_cache[1] = createBaseVNode("div", { style: { "display": "none" } }, [
          createBaseVNode("div", { id: "template" })
        ], -1))
      ]);
    }
    const basket = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$c], ["__scopeId", "data-v-8fca49ba"], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/scaling_up_analysis/components/basket.vue"]]);
    const _sfc_main$b = {
      __name: "guidance",
      props: {
        label: {
          type: String,
          default: ""
        }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const stores = inject("stores");
        const show_more = ref(false);
        const hasGuidance = ref(false);
        const props = __props;
        onMounted(() => {
          hasGuidance.value = has_guidance();
        });
        function has_guidance() {
          return props.label.length > 0 && key_exist(".intro");
        }
        function key_exist(element = ".info") {
          return stores.BaseStore.localization(props.label + element).toUpperCase() !== (props.label + element).toUpperCase();
        }
        function toggle_more() {
          show_more.value = !show_more.value;
        }
        const __returned__ = { stores, show_more, hasGuidance, props, has_guidance, key_exist, toggle_more, ref, inject, onMounted };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$a = {
      key: 0,
      class: "module-bar info-bar mt-2 mb-2 guidance",
      style: { "grid-column": "span 2" },
      id: "guidance"
    };
    const _hoisted_2$9 = { class: "message" };
    const _hoisted_3$8 = ["innerHTML"];
    const _hoisted_4$7 = ["innerHTML"];
    const _hoisted_5$6 = ["innerHTML"];
    const _hoisted_6$3 = ["innerHTML"];
    function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
      return $setup.hasGuidance ? (openBlock(), createElementBlock("div", _hoisted_1$a, [
        _cache[2] || (_cache[2] = createBaseVNode("div", { class: "icon blue" }, [
          createBaseVNode("span", {
            class: "fas fa-fw fa-info-circle",
            style: { "font-size": "1.4em" }
          })
        ], -1)),
        createBaseVNode("div", _hoisted_2$9, [
          createBaseVNode("div", null, [
            createBaseVNode("span", {
              innerHTML: $setup.stores.BaseStore.localization($props.label + ".intro")
            }, null, 8, _hoisted_3$8),
            !$setup.show_more && $setup.key_exist() ? (openBlock(), createElementBlock("a", {
              key: 0,
              href: "#",
              onClick: _cache[0] || (_cache[0] = withModifiers(($event) => $setup.toggle_more(), ["prevent"]))
            }, "show more...")) : $setup.key_exist() ? (openBlock(), createElementBlock("a", {
              key: 1,
              href: "#",
              onClick: _cache[1] || (_cache[1] = withModifiers(($event) => $setup.toggle_more(), ["prevent"]))
            }, "show less")) : createCommentVNode("", true)
          ]),
          $setup.show_more && $setup.key_exist() ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "mt-2",
            innerHTML: $setup.stores.BaseStore.localization($props.label + ".info")
          }, null, 8, _hoisted_4$7)) : createCommentVNode("", true),
          $setup.show_more && $setup.key_exist(".table") ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: "mt-5 p-2 border border-dark",
            innerHTML: $setup.stores.BaseStore.localization($props.label + ".table")
          }, null, 8, _hoisted_5$6)) : createCommentVNode("", true),
          $setup.show_more && $setup.key_exist(".extra_info") ? (openBlock(), createElementBlock("div", {
            key: 2,
            class: "mt-2",
            innerHTML: $setup.stores.BaseStore.localization($props.label + ".extra_info")
          }, null, 8, _hoisted_6$3)) : createCommentVNode("", true)
        ])
      ])) : createCommentVNode("", true);
    }
    const guidance = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$b], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/scaling_up_analysis/components/guidance.vue"]]);
    const _sfc_main$a = {
      __name: "small_menu",
      props: {
        items: {
          type: [Object, Array],
          default: () => ({})
        },
        exclude: {
          type: String,
          default: ""
        },
        ids: {
          type: String,
          default: ""
        },
        root_dir: {
          type: String,
          default: ""
        }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const props = __props;
        const listNames = ref([]);
        const selection = ref(null);
        const excludedItems = props.exclude.split(",");
        const listItems = () => {
          const objectEntries = Object.entries(props.items);
          if (objectEntries.length > 0) {
            objectEntries.forEach((item) => {
              if (!excludedItems.includes(item[0])) {
                listNames.value.unshift(item[0]);
              }
            });
          }
        };
        const scrollToSection = (idx) => {
          const element = document.getElementById(props.ids + idx);
          element == null ? void 0 : element.scrollIntoView({ behavior: "smooth" });
          selection.value = idx;
        };
        const isSelected = (index) => selection.value === index;
        onMounted(() => {
          listItems();
        });
        const __returned__ = { props, listNames, selection, excludedItems, listItems, scrollToSection, isSelected, ref, onMounted, computed };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$9 = {
      class: "smallMenu",
      style: { "min-height": "80px" }
    };
    const _hoisted_2$8 = {
      key: 0,
      class: "standalone js-smallMenu",
      id: "smallMenu"
    };
    const _hoisted_3$7 = ["innerHTML", "onClick"];
    function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", _hoisted_1$9, [
        $setup.listNames.length > 1 ? (openBlock(), createElementBlock("div", _hoisted_2$8, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($setup.listNames, (item, idx) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass({ active: $setup.isSelected(idx) }),
              innerHTML: item,
              onClick: ($event) => $setup.scrollToSection(idx),
              key: idx
            }, null, 10, _hoisted_3$7);
          }), 128))
        ])) : createCommentVNode("", true)
      ]);
    }
    const smallMenu = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$a], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/scaling_up_analysis/components/menus/small_menu.vue"]]);
    const _sfc_main$9 = {
      props: {
        title: {
          type: String,
          default: null
        },
        indicators: {
          type: [Array],
          default: () => null
        },
        api_data: {
          type: [Object],
          default: () => null
        }
      },
      methods: {
        pretty_number(value, precision = 0) {
          return window.ModularForms.Helpers.Common.pretty_number(value, precision);
        },
        getValue(item) {
          let value = null;
          if (item.hasOwnProperty("fields")) {
            value = this.api_data[item.fields[item.fields.length - 1]];
          } else if (item.hasOwnProperty("field")) {
            value = this.api_data[item.field];
          }
          return parseFloat(value).toFixed(1);
        }
      }
    };
    const _hoisted_1$8 = {
      key: 0,
      class: "list-key-numbers"
    };
    const _hoisted_2$7 = {
      key: 0,
      class: "list-head"
    };
    const _hoisted_3$6 = { class: "grid grid-cols-3 gap-4" };
    const _hoisted_4$6 = { class: "text-sm mb-1" };
    function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
      return $props.api_data !== null ? (openBlock(), createElementBlock("div", _hoisted_1$8, [
        $props.title != null ? (openBlock(), createElementBlock("div", _hoisted_2$7, toDisplayString($props.title), 1)) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_3$6, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($props.indicators, (item) => {
            return openBlock(), createElementBlock("div", {
              key: item.label,
              class: "flex flex-col items-center"
            }, [
              createBaseVNode("span", _hoisted_4$6, toDisplayString(item.label), 1),
              createBaseVNode("span", {
                class: "text-lg font-bold highlight",
                style: normalizeStyle({ color: item.color })
              }, toDisplayString($options.pretty_number($options.getValue(item))), 5)
            ]);
          }), 128))
        ])
      ])) : createCommentVNode("", true);
    }
    const dopa_indicators_table = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$9], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/templates/dopa/indicators_table.vue"]]);
    const _sfc_main$8 = {
      __name: "checkboxes_list",
      props: {
        items: {
          type: Object,
          default: () => {
          }
        },
        event: {
          type: String,
          default: ""
        },
        minimum_valid_items: {
          type: Number,
          default: 1
        }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const are_checked_all = ref(false);
        const checkboxes = ref([]);
        const pas = ref([]);
        const show_overall = ref(false);
        const emitter = inject("emitter");
        const stores = inject("stores");
        const props = __props;
        onMounted(() => {
          const areas = [];
          Object.entries(props.items).forEach((val) => {
            areas.push({ "FormID": val[0], "name": val[1] });
          });
          areas.sort((a2, b2) => a2.name.localeCompare(b2.name));
          pas.value = areas;
        });
        function is_checked(id) {
          return checkboxes.value.some((checkbox2) => {
            return parseInt(checkbox2) === parseInt(id);
          });
        }
        function selectValue(value) {
          if (checkboxes.value.includes(value)) {
            checkboxes.value = checkboxes.value.filter((item) => item !== value);
          } else {
            checkboxes.value.push(value);
            selected2();
          }
          show_overall.value = false;
        }
        function checkboxes_ids() {
          return checkboxes.value.join(",");
        }
        function enable_overall() {
          if (props.event) {
            emitter.emit(props.event, checkboxes_ids());
          } else {
            if (show_overall.value) {
              setTimeout(() => {
                show_overall.value = !show_overall.value;
              }, 500);
            }
            show_overall.value = !show_overall.value;
          }
        }
        function button_status() {
          return checkboxes.value.length <= props.minimum_valid_items;
        }
        function check_all() {
          if (!are_checked_all.value) {
            const checkboxes_list = [...document.querySelectorAll(".vue-checkboxes")];
            for (const key in checkboxes_list) {
              const check_box = checkboxes_list[key];
              const exist = is_checked(check_box.defaultValue);
              if (!exist) {
                checkboxes.value.push(check_box.defaultValue);
              }
            }
            are_checked_all.value = true;
          } else {
            clearSelections();
          }
          selected2();
        }
        function selected2() {
          emitter.emit("actionData", JSON.stringify(checkboxes.value));
        }
        function clearSelections() {
          checkboxes.value = [];
          are_checked_all.value = false;
        }
        const __returned__ = { are_checked_all, checkboxes, pas, show_overall, emitter, stores, props, is_checked, selectValue, checkboxes_ids, enable_overall, button_status, check_all, selected: selected2, clearSelections, ref, onMounted, inject };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$7 = { class: "grid grid-cols-2 gap-4 pb-4 pt-4" };
    const _hoisted_2$6 = ["checked", "data-name", "onClick", "value"];
    const _hoisted_3$5 = { class: "flex flex-row justify-center gap-4" };
    const _hoisted_4$5 = ["disabled"];
    const _hoisted_5$5 = { key: 0 };
    function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock(Fragment, null, [
        createBaseVNode("div", _hoisted_1$7, [
          $setup.pas.length > 0 ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList($setup.pas, (selection, i2) => {
            return openBlock(), createElementBlock("div", {
              key: i2,
              class: "p-2 bg-yellow-100 rounded border border-yellow-200"
            }, [
              createBaseVNode("input", {
                type: "checkbox",
                checked: $setup.is_checked(selection.FormID),
                class: "vue-checkboxes",
                "data-name": selection.name,
                onClick: ($event) => $setup.selectValue(selection.FormID),
                value: selection.FormID
              }, null, 8, _hoisted_2$6),
              createBaseVNode("strong", null, "" + toDisplayString(selection.name), 1)
            ]);
          }), 128)) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_3$5, [
          createBaseVNode("button", {
            disabled: $setup.button_status(),
            onClick: _cache[0] || (_cache[0] = ($event) => $setup.enable_overall()),
            class: "btn-nav"
          }, toDisplayString($setup.stores.BaseStore.localization("imet-core::analysis_report.apply")), 9, _hoisted_4$5),
          createBaseVNode("button", {
            onClick: _cache[1] || (_cache[1] = ($event) => $setup.check_all()),
            class: "btn-nav"
          }, toDisplayString($setup.stores.BaseStore.localization("imet-core::analysis_report.select_all")), 1),
          createBaseVNode("button", {
            onClick: _cache[2] || (_cache[2] = ($event) => $setup.clearSelections()),
            class: "btn-nav red"
          }, toDisplayString($setup.stores.BaseStore.localization("imet-core::analysis_report.reset")), 1)
        ]),
        $setup.show_overall ? (openBlock(), createElementBlock("div", _hoisted_5$5, [
          renderSlot(_ctx.$slots, "default", {
            props: { "ids": $setup.checkboxes_ids(), "show_view": $setup.show_overall }
          })
        ])) : createCommentVNode("", true)
      ], 64);
    }
    const checkboxesList = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$8], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/scaling_up_analysis/components/checkboxes_list.vue"]]);
    class LocaleStorage {
      constructor() {
      }
      save(key, value) {
        const values2 = window.localStorage.getItem(key);
        if (values2) {
          const json_recorded = JSON.parse(values2);
          json_recorded.push(value);
          window.localStorage.setItem(key, JSON.stringify(json_recorded));
        } else {
          window.localStorage.setItem(key, JSON.stringify([value]));
        }
      }
      retrieve(key) {
        return JSON.parse(window.localStorage.getItem(key));
      }
      delete_item_child(key, id) {
        const children = JSON.parse(window.localStorage.getItem(key));
        const not_deleted_items = children.filter((child, key2) => key2 !== id);
        window.localStorage.setItem(key, JSON.stringify(not_deleted_items));
        return this.retrieve(key);
      }
      delete(key) {
        window.localStorage.removeItem(key);
      }
      clear() {
        window.localStorage.clear();
      }
    }
    const LocalStore = new LocaleStorage();
    class BaseStore {
      constructor(args) {
        this.protected_areas = null;
        this.is_country = null;
        this.scaling_up_id = args.scaling_up_id;
        this.init();
      }
      init() {
      }
      get_scaling_up() {
        return this.scaling_up_id;
      }
      is_country_enabled() {
        return this.is_country;
      }
      toggle_country_enabled() {
        return this.is_country != this.is_country;
      }
      find_config_by_name(config2, name) {
        const items = config2.find((item) => item.name === name);
        return items;
      }
      add_color_to_value(values2, id, colors) {
        const color_items = [];
        const items = Object.values(values2);
        items.forEach((item) => {
          const color = colors.filter((c2) => c2[id]);
          color_items.push({ value: item, itemStyle: { color: color[0][id] } });
        });
        return color_items;
      }
      add_color_to_value_by_cat(values2, id, indicators, colors) {
        const items = Object.values(values2.Average);
        return items;
      }
      add_color_to_value_rel(values2, colors) {
        if (!values2.Average) {
          return {};
        }
        const items = Object.values(values2.Average);
        items.forEach((item, idx) => {
          values2.Average[idx] = {
            value: item["value"],
            "upper limit": item["upper limit"],
            itemStyle: { color: colors[idx] }
          };
        });
        const result2 = { "Average": Object.keys(values2.Average).map((k2) => values2.Average[k2]) };
        return result2;
      }
      parse_indicators(indicators) {
        return Object.values(indicators);
      }
      is_visible(values2) {
        if (typeof values2 === "undefined") {
          return false;
        }
        return Object.keys(values2).length;
      }
      localization(value) {
        return window.ModularForms.Helpers.Locale.getLabel(value);
      }
    }
    const config = {
      indicators: [
        window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.context"),
        window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.outcomes"),
        window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.outputs"),
        window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.process"),
        window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.inputs"),
        window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.planning")
      ],
      color: [
        "#00B050",
        "#92D050",
        "#0099CC",
        "#ffc000",
        "#bfbfbf",
        "#ffff00"
      ],
      color_correct_order: [
        "#ffff00",
        "#bfbfbf",
        "#ffc000",
        "#0099CC",
        "#92D050",
        "#00B050"
      ],
      element_diagrams: {
        color: [
          { "context": "#ffff00" },
          { "planning": "#bfbfbf" },
          { "inputs": "#ffc000" },
          { "process": "#0099CC" },
          { "outputs": "#92D050" },
          { "outcomes": "#00B050" }
        ],
        context: [
          {
            key: "overall_scores",
            name: "main",
            menu: {
              header: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.context.main.header"),
              title: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.context.main.title"),
              radar: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.context.main.radar"),
              ranking: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.context.main.ranking"),
              average_contribution: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.context.main.average_contribution"),
              datatable: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.context.main.datatable")
            },
            ranking_labels: false,
            columns: [
              {
                "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.Create.fields.wdpa_id"),
                "field": "name"
              },
              {
                "label": `C1: ${((_b = window.ScalingUp) == null ? void 0 : _b.labels("C1")) ?? ""}`,
                "field": "C1"
              },
              {
                "label": `C2: ${((_c = window == null ? void 0 : window.ScalingUp) == null ? void 0 : _c.labels("C2")) ?? ""}`,
                "field": "C2",
                "extra_label": ` ${window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.scale.negative_positive")}`
              },
              {
                "label": `C3: ${(_d = window == null ? void 0 : window.ScalingUp) == null ? void 0 : _d.labels("C3")}`,
                "field": "C3",
                "extra_label": ` ${window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.scale.zero_negative")}`
              },
              {
                "label": `${window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.context")}`,
                "field": "context",
                "extra_label": ``
              }
            ]
          },
          {
            key: "context_value_and_importance",
            name: "context_value_and_importance",
            menu: {
              title: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.context.context_value_and_importance.title"),
              radar: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.context.context_value_and_importance.radar"),
              ranking: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.context.context_value_and_importance.ranking"),
              average_contribution: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.context.context_value_and_importance.average_contribution"),
              datatable: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.context.context_value_and_importance.datatable")
            },
            ranking_labels: false,
            columns: [
              {
                "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.Create.fields.wdpa_id"),
                "field": "name"
              },
              {
                "label": `C1.1: ${((_e2 = window.ScalingUp) == null ? void 0 : _e2.labels("C11")) ?? ""}`,
                "field": "C11"
              },
              {
                "label": `C1.2: ${(_f = window.ScalingUp) == null ? void 0 : _f.labels("C12")}`,
                "field": "C12"
              },
              {
                "label": `C1.3: ${(_g = window.ScalingUp) == null ? void 0 : _g.labels("C13")}`,
                "field": "C13"
              },
              {
                "label": `C1.4: ${(_h = window.ScalingUp) == null ? void 0 : _h.labels("C14")}`,
                "field": "C14"
              },
              {
                "label": `C1.5: ${(_i = window.ScalingUp) == null ? void 0 : _i.labels("C15")}`,
                "field": "C15"
              },
              {
                "label": `${window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.context.context_value_and_importance.datatable_average")}`,
                "field": "avg"
              }
            ]
          }
        ],
        threats: {
          name: "threats",
          ranking_labels: false,
          menu: {
            title: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.threats.threats.title"),
            radar: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.threats.threats.radar"),
            ranking: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.threats.threats.ranking"),
            average_contribution: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.threats.threats.average_contribution"),
            datatable: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.threats.threats.datatable")
          }
        },
        planning: [
          {
            name: "main",
            menu: {
              header: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.planning.main.header"),
              radar: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.planning.main.radar"),
              ranking: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.planning.main.ranking"),
              average_contribution: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.planning.main.average_contribution"),
              datatable: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.planning.main.datatable")
            },
            ranking_labels: false,
            columns: [
              {
                "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.Create.fields.wdpa_id"),
                "field": "name"
              },
              {
                "label": `P1: ${(_j = window.ScalingUp) == null ? void 0 : _j.labels("P1")}`,
                "field": "P1"
              },
              {
                "label": `P2: ${(_k = window.ScalingUp) == null ? void 0 : _k.labels("P2")}`,
                "field": "P2"
              },
              {
                "label": `P3: ${(_l = window.ScalingUp) == null ? void 0 : _l.labels("P3")}`,
                "field": "P3"
              },
              {
                "label": `P4: ${(_m = window.ScalingUp) == null ? void 0 : _m.labels("P4")}`,
                "field": "P4"
              },
              {
                "label": `P.5: ${(_n = window.ScalingUp) == null ? void 0 : _n.labels("P5")}`,
                "field": "P5"
              },
              {
                "label": `P6: ${(_o2 = window.ScalingUp) == null ? void 0 : _o2.labels("P6")}`,
                "field": "P6"
              },
              {
                "label": `${window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.planning")}`,
                "field": "planning",
                "extra_label": ``
              }
            ]
          }
        ],
        inputs: [
          {
            name: "main",
            menu: {
              header: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.inputs.main.header"),
              radar: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.inputs.main.radar"),
              ranking: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.inputs.main.ranking"),
              average_contribution: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.inputs.main.average_contribution"),
              datatable: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.inputs.main.datatable")
            },
            ranking_labels: false,
            columns: [
              {
                "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.Create.fields.wdpa_id"),
                "field": "name"
              },
              {
                "label": `I1: ${(_p = window.ScalingUp) == null ? void 0 : _p.labels("I1")}`,
                "field": "I1"
              },
              {
                "label": `I2: ${(_q = window.ScalingUp) == null ? void 0 : _q.labels("I2")}`,
                "field": "I2"
              },
              {
                "label": `I3: ${(_r2 = window.ScalingUp) == null ? void 0 : _r2.labels("I3")}`,
                "field": "I3"
              },
              {
                "label": `I4: ${(_s = window.ScalingUp) == null ? void 0 : _s.labels("I4")}`,
                "field": "I4"
              },
              {
                "label": `I5: ${(_t2 = window.ScalingUp) == null ? void 0 : _t2.labels("I5")}`,
                "field": "I5"
              },
              {
                "label": `${window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.inputs")}`,
                "field": "inputs",
                "extra_label": ``
              }
            ]
          }
        ],
        process: [
          {
            name: "process_sub_indicators",
            menu: {
              header: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.process.process_sub_indicators.header"),
              title: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.process.process_sub_indicators.title"),
              radar: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.process.process_sub_indicators.radar"),
              ranking: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.process.process_sub_indicators.ranking"),
              average_contribution: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.process.process_sub_indicators.average_contribution"),
              datatable: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.process.process_sub_indicators.datatable")
            },
            ranking_labels: false,
            columns: [
              {
                "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.Create.fields.wdpa_id"),
                "field": "name"
              },
              {
                "label": `PR A: ${(_u = window.ScalingUp) == null ? void 0 : _u.labels("PRA")}`,
                "field": "PRA"
              },
              {
                "label": `PR B: ${(_v = window.ScalingUp) == null ? void 0 : _v.labels("PRB")}`,
                "field": "PRB"
              },
              {
                "label": `PR C: ${(_w = window.ScalingUp) == null ? void 0 : _w.labels("RC")}`,
                "field": "PRC"
              },
              {
                "label": `PR D: ${(_x = window.ScalingUp) == null ? void 0 : _x.labels("PRD")}`,
                "field": "PRD"
              },
              {
                "label": `PR E: ${(_y = window.ScalingUp) == null ? void 0 : _y.labels("PRE")}`,
                "field": "PRE"
              },
              {
                "label": `PR F: ${(_z = window.ScalingUp) == null ? void 0 : _z.labels("PRF")}`,
                "field": "PRF"
              },
              {
                "label": `${window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.process")}`,
                "field": "process"
              }
            ]
          }
        ],
        process_PRA: [{
          name: "process_internal_management",
          menu: {
            title: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.process.process_internal_management_systems_processes.title"),
            radar: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.process.process_internal_management_systems_processes.radar"),
            ranking: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.process.process_internal_management_systems_processes.ranking"),
            average_contribution: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.process.process_internal_management_systems_processes.average_contribution"),
            datatable: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.process.process_internal_management_systems_processes.datatable")
          },
          columns: [
            {
              "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.Create.fields.wdpa_id"),
              "field": "name"
            },
            {
              "label": `PR1: ${(_A = window.ScalingUp) == null ? void 0 : _A.labels("PR1")}`,
              "field": "PR1"
            },
            {
              "label": `PR2: ${(_B = window.ScalingUp) == null ? void 0 : _B.labels("PR2")}`,
              "field": "PR2"
            },
            {
              "label": `PR3: ${(_C = window.ScalingUp) == null ? void 0 : _C.labels("PR3")}`,
              "field": "PR3"
            },
            {
              "label": `PR4: ${(_D = window.ScalingUp) == null ? void 0 : _D.labels("PR4")}`,
              "field": "PR4"
            },
            {
              "label": `PR5: ${(_E = window.ScalingUp) == null ? void 0 : _E.labels("PR5")}`,
              "field": "PR5"
            },
            {
              "label": `PR6: ${(_F = window.ScalingUp) == null ? void 0 : _F.labels("PR6")}`,
              "field": "PR6"
            },
            {
              "label": `${window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.process.process_internal_management_systems_processes.datatable_average")}`,
              "field": "avg"
            }
          ]
        }],
        process_PRB: [{
          name: "process_management_protection_values",
          menu: {
            title: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.process.process_management_protection_values.title"),
            radar: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.process.process_management_protection_values.radar"),
            ranking: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.process.process_management_protection_values.ranking"),
            average_contribution: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.process.process_management_protection_values.average_contribution"),
            datatable: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.process.process_management_protection_values.datatable")
          },
          columns: [
            {
              "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.Create.fields.wdpa_id"),
              "field": "name"
            },
            {
              "label": `PR7: ${(_G = window.ScalingUp) == null ? void 0 : _G.labels("PR7")}`,
              "field": "PR7"
            },
            {
              "label": `PR8: ${(_H = window.ScalingUp) == null ? void 0 : _H.labels("PR8")}`,
              "field": "PR8"
            },
            {
              "label": `PR9: ${(_I = window.ScalingUp) == null ? void 0 : _I.labels("PR9")}`,
              "field": "PR9"
            },
            {
              "label": `${window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.process.process_management_protection_values.datatable_average")}`,
              "field": "avg"
            }
          ]
        }],
        process_PRC: [{
          name: "process_stakeholders_relationships",
          menu: {
            title: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.process.process_stakeholders_relationships.title"),
            radar: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.process.process_stakeholders_relationships.radar"),
            ranking: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.process.process_stakeholders_relationships.ranking"),
            average_contribution: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.process.process_stakeholders_relationships.average_contribution"),
            datatable: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.process.process_stakeholders_relationships.datatable")
          },
          columns: [
            {
              "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.Create.fields.wdpa_id"),
              "field": "name"
            },
            {
              "label": `PR10: ${(_J = window.ScalingUp) == null ? void 0 : _J.labels("PR10")}`,
              "field": "PR10"
            },
            {
              "label": `PR11: ${(_K = window.ScalingUp) == null ? void 0 : _K.labels("PR11")}`,
              "field": "PR11"
            },
            {
              "label": `PR12: ${(_L = window.ScalingUp) == null ? void 0 : _L.labels("PR12")}`,
              "field": "PR12"
            },
            {
              "label": `${window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.process.process_stakeholders_relationships.datatable_average")}`,
              "field": "avg"
            }
          ]
        }],
        process_PRD: [{
          name: "process_tourism_management",
          menu: {
            title: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.process.process_tourism_management.title"),
            radar: ``,
            ranking: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.process.process_tourism_management.ranking"),
            average_contribution: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.process.process_tourism_management.average_contribution"),
            datatable: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.process.process_tourism_management.datatable")
          },
          columns: [
            {
              "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.Create.fields.wdpa_id"),
              "field": "name"
            },
            {
              "label": `PR13: ${(_M = window.ScalingUp) == null ? void 0 : _M.labels("PR13")}`,
              "field": "PR13"
            },
            {
              "label": `PR14: ${(_N = window.ScalingUp) == null ? void 0 : _N.labels("PR14")}`,
              "field": "PR14"
            },
            {
              "label": `${window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.process.process_tourism_management.datatable_average")}`,
              "field": "avg"
            }
          ]
        }],
        process_PRE: [{
          name: "process_monitoring_and_research",
          menu: {
            title: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.process.process_monitoring_and_research.title"),
            radar: "",
            ranking: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.process.process_monitoring_and_research.ranking"),
            average_contribution: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.process.process_monitoring_and_research.average_contribution"),
            datatable: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.process.process_monitoring_and_research.datatable")
          },
          columns: [
            {
              "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.Create.fields.wdpa_id"),
              "field": "name"
            },
            {
              "label": `PR15: ${(_O = window.ScalingUp) == null ? void 0 : _O.labels("PR15")}`,
              "field": "PR15"
            },
            {
              "label": `PR16: ${(_P = window.ScalingUp) == null ? void 0 : _P.labels("PR16")}`,
              "field": "PR16"
            },
            {
              "label": `${window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.process.process_monitoring_and_research.datatable_average")}`,
              "field": "avg"
            }
          ]
        }],
        process_PRF: [
          {
            name: "process_effects_of_climate_change",
            menu: {
              title: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.process.process_effects_of_climate_change.title"),
              radar: "",
              ranking: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.process.process_effects_of_climate_change.ranking"),
              average_contribution: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.process.process_effects_of_climate_change.average_contribution"),
              datatable: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.process.process_effects_of_climate_change.datatable")
            },
            columns: [
              {
                "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.Create.fields.wdpa_id"),
                "field": "name"
              },
              {
                "label": `PR17: ${(_Q = window.ScalingUp) == null ? void 0 : _Q.labels("PR17")}`,
                "field": "PR17"
              },
              {
                "label": `PR18: ${(_R = window.ScalingUp) == null ? void 0 : _R.labels("PR18")}`,
                "field": "PR18"
              },
              {
                "label": `${window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.process.process_effects_of_climate_change.datatable_average")}`,
                "field": "avg"
              }
            ]
          }
        ],
        outputs: [
          {
            name: "main",
            menu: {
              header: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.outputs.main.header"),
              radar: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.outputs.main.radar"),
              ranking: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.outputs.main.ranking"),
              average_contribution: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.outputs.main.average_contribution"),
              datatable: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.outputs.main.datatable")
            },
            ranking_labels: false,
            columns: [
              {
                "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.Create.fields.wdpa_id"),
                "field": "name"
              },
              {
                "label": `O/P1: ${(_S = window.ScalingUp) == null ? void 0 : _S.labels("OP1")}`,
                "field": "OP1"
              },
              {
                "label": `O/P2: ${(_T = window.ScalingUp) == null ? void 0 : _T.labels("OP2")}`,
                "field": "OP2"
              },
              {
                "label": `O/P3: ${(_U = window.ScalingUp) == null ? void 0 : _U.labels("OP3")}`,
                "field": "OP3"
              },
              {
                "label": `O/P4: ${(_V = window.ScalingUp) == null ? void 0 : _V.labels("OP4")}`,
                "field": "OP4"
              },
              {
                "label": `${window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.outputs")}`,
                "field": "outputs",
                "extra_label": ``
              }
            ]
          }
        ],
        outcomes: [
          {
            name: "main",
            menu: {
              header: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.outcomes.main.header"),
              radar: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.outcomes.main.radar"),
              ranking: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.outcomes.main.ranking"),
              average_contribution: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.outcomes.main.average_contribution"),
              datatable: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.element_diagrams.outcomes.main.datatable")
            },
            ranking_labels: false,
            columns: [
              {
                "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.Create.fields.wdpa_id"),
                "field": "name"
              },
              {
                "label": `O/C1: ${(_W = window.ScalingUp) == null ? void 0 : _W.labels("OC1")}`,
                "field": "OC1"
              },
              {
                "label": `O/C2: ${(_X = window.ScalingUp) == null ? void 0 : _X.labels("OC2")}`,
                "field": "OC2",
                "extra_label": ` ${window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.scale.negative_positive")}`
              },
              {
                "label": `O/C3: ${(_Y = window.ScalingUp) == null ? void 0 : _Y.labels("OC3")}`,
                "field": "OC3",
                "extra_label": ` ${window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.scale.negative_positive")}`
              },
              {
                "label": `${window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.outcomes")}`,
                "field": "outcomes",
                "extra_label": ``
              }
            ]
          }
        ]
      },
      dopa_indicators: {
        protected_area_coverage_and_connectivity: {
          title_table: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.protected_area_coverage_and_connectivity.title"),
          title_chart: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.protected_area_coverage_and_connectivity.chart"),
          bar_indicators: [
            {
              field: "area_prot_terr_perc",
              label: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.protected_area_coverage_and_connectivity.protected_land_area"),
              color: "#cae5a1"
            },
            {
              field: "area_prot_mar_perc",
              label: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.protected_area_coverage_and_connectivity.protected_marine_area"),
              color: "#8ecfe0"
            },
            {
              field: "protconn",
              label: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.protected_area_coverage_and_connectivity.protected_connected_land"),
              color: "#91ad41"
            }
          ],
          table_bar_indicators: [
            {
              field: "area_terr_km2",
              label: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.protected_area_coverage_and_connectivity.total_land_area")
            },
            {
              field: "area_prot_terr_km2",
              label: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.protected_area_coverage_and_connectivity.protected_land_area")
            },
            {
              field: "area_prot_terr_perc",
              label: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.protected_area_coverage_and_connectivity.terrestrial_coverage"),
              color: "#cae5a1"
            },
            {
              field: "area_mar_km2",
              label: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.protected_area_coverage_and_connectivity.total_marine_area")
            },
            {
              field: "area_prot_mar_km2",
              label: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.protected_area_coverage_and_connectivity.protected_marine_area")
            },
            {
              field: "area_prot_mar_perc",
              label: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.protected_area_coverage_and_connectivity.marine_coverage"),
              color: "#8ecfe0"
            },
            {
              field: "protconn",
              label: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.protected_area_coverage_and_connectivity.protected_connected_land"),
              color: "#91ad41"
            }
          ]
        },
        land_degradation: {
          title_table: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.land_degradation.title"),
          title_chart: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.land_degradation.chart"),
          indicators: [
            {
              field: "lpd_null_km2",
              label: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.land_degradation.indicators.no_biomas"),
              color: "#46a246"
            },
            {
              field: "lpd_severe_km2",
              label: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.land_degradation.indicators.persistent_severe"),
              color: "#c2c5cc"
            },
            {
              field: "lpd_moderate_km2",
              label: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.land_degradation.indicators.persistent_moderate"),
              color: "#b8d879"
            },
            {
              field: "lpd_stressed_km2",
              label: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.land_degradation.indicators.stable_stressed"),
              color: "#ec4900"
            },
            {
              field: "lpd_stable_km2",
              label: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.land_degradation.indicators.stable_productivity"),
              color: "#ed732e"
            },
            {
              field: "lpd_increased_km2",
              label: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.land_degradation.indicators.persistent_increase"),
              color: "#ab2849"
            }
          ],
          bar_indicators: [
            {
              field: "lpd_null_km2",
              label: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.land_degradation.bar_indicators.no_biomas"),
              color: "#46a246"
            },
            {
              field: "lpd_severe_km2",
              label: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.land_degradation.bar_indicators.persistent_severe"),
              color: "#c2c5cc"
            },
            {
              field: "lpd_moderate_km2",
              label: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.land_degradation.bar_indicators.persistent_moderate"),
              color: "#b8d879"
            },
            {
              field: "lpd_stressed_km2",
              label: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.land_degradation.bar_indicators.persistent_strong"),
              color: "#ec4900"
            },
            {
              field: "lpd_stable_km2",
              label: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.land_degradation.bar_indicators.stable_productivity"),
              color: "#ed732e"
            },
            {
              field: "lpd_increased_km2",
              label: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.land_degradation.bar_indicators.persistent_increase"),
              color: "#ab2849"
            }
          ]
        },
        total_carbon: {
          title_table: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.total_carbon.title"),
          indicators: [
            {
              field: "carbon_min_c_mg",
              label: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.total_carbon.min")
            },
            {
              field: "carbon_mean_c_mg",
              label: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.total_carbon.mean")
            },
            {
              field: "carbon_max_c_mg",
              label: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.total_carbon.max")
            },
            {
              field: "carbon_stdev_c_mg",
              label: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.total_carbon.std_dev")
            },
            {
              field: "carbon_tot_c_mg",
              label: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.total_carbon.sum")
            }
          ]
        },
        forest_cover: {
          title_table: "Forest Cover",
          title_chart: "Forest loss and gain (%)",
          indicators: [
            {
              field: "gfc_treecover_km2",
              label: "Forest cover [km2]",
              color: "#5b5b5b"
            },
            {
              field: "gfc_treecover_perc",
              label: "Forest cover [%]",
              color: "#5b5b5b"
            },
            {
              field: "gfc_loss_km2",
              label: "Forest loss [km2]",
              color: "#D9534F"
            },
            {
              field: "gfc_loss_perc",
              label: "Forest loss [%]",
              color: "#D9534F"
            },
            {
              field: "gfc_gain_km2",
              label: "Forest gain [km2]",
              color: "#337AB7"
            },
            {
              field: "gfc_gain_perc",
              label: "Forest gain [%]",
              color: "#337AB7"
            }
          ],
          bar_indicators: [
            {
              field: "gfc_loss_perc",
              label: "Forest loss [%]",
              color: "#D9534F"
            },
            {
              field: "gfc_gain_perc",
              label: "Forest gain [%]",
              color: "#337AB7"
            }
          ]
        }
      },
      performance_diagram: {
        indicators: [
          window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.context"),
          window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.outcomes"),
          window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.outputs"),
          window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.process"),
          window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.inputs"),
          window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.planning")
        ],
        color: [
          "#ffff00",
          "#bfbfbf",
          "#ffc000",
          "#0099CC",
          "#92D050",
          "#00B050"
        ],
        columns: [
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.Create.fields.wdpa_id"),
            "field": "name"
          },
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.context"),
            "field": "context"
          },
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.planning"),
            "field": "planning"
          },
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.inputs"),
            "field": "inputs"
          },
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.process"),
            "field": "process"
          },
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.outputs"),
            "field": "outputs"
          },
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.outcomes"),
            "field": "outcomes"
          },
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.indexes.imet"),
            "field": "imet_index"
          }
        ]
      },
      evaluation_of_protected_area_management_cycle: {
        columns: [
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.Create.fields.wdpa_id"),
            "field": "name"
          },
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.context"),
            "field": "context"
          },
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.planning"),
            "field": "planning"
          },
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.inputs"),
            "field": "inputs"
          },
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.process"),
            "field": "process"
          },
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.outputs"),
            "field": "outputs"
          },
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.outcomes"),
            "field": "outcomes"
          },
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.indexes.imet"),
            "field": "imet_index"
          }
        ]
      },
      relative_performance_effectiveness_bar_average: {
        indicators: [
          window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.outcomes"),
          window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.outputs"),
          window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.process"),
          window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.inputs"),
          window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.planning"),
          window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.context")
        ],
        color: [
          "#00B050",
          "#92D050",
          "#0099CC",
          "#ffc000",
          "#bfbfbf",
          "#ffff00",
          "#ffff00"
        ]
      },
      group_analysis_on_demand: {
        scatter_columns: [
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.Create.fields.wdpa_id"),
            "field": "name"
          },
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.process"),
            "field": "context"
          },
          {
            "label": `${window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.context")}, ${window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.planning")}, ${window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.inputs")}`,
            "field": "planning"
          },
          {
            "label": `${window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.outputs")}, ${window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.outcomes")}`,
            "field": "inputs"
          }
        ],
        columns: [
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.Create.fields.wdpa_id"),
            "field": "name"
          },
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.context"),
            "field": "context"
          },
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.planning"),
            "field": "planning"
          },
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.inputs"),
            "field": "inputs"
          },
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.process"),
            "field": "process"
          },
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.outputs"),
            "field": "outputs"
          },
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::common.steps_eval.outcomes"),
            "field": "outcomes"
          }
        ]
      },
      terrestial_ecoregions: {
        columns: [
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.terrestial_ecoregions.name"),
            "field": "eco_name"
          },
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.terrestial_ecoregions.area"),
            "field": "ecoregion_tot_sqkm"
          },
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.terrestial_ecoregions.ecoregion_pa_sqkm"),
            "field": "ecoregion_prot_sqkm",
            color: "#cae5a1"
          },
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.terrestial_ecoregions.ecoregion_protected_tot_sqkm"),
            "field": "pa_tot_sqkm",
            color: "#8ecfe0"
          },
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.terrestial_ecoregions.protected_in_ecoregion"),
            "field": "pa_in_eco_sqkm",
            color: "#91ad41"
          }
        ]
      },
      marine_ecoregions: {
        columns: [
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.terrestial_ecoregions.name"),
            "field": "eco_name"
          },
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.terrestial_ecoregions.area"),
            "field": "ecoregion_tot_sqkm"
          },
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.terrestial_ecoregions.ecoregion_pa_sqkm"),
            "field": "ecoregion_prot_sqkm",
            color: "#cae5a1"
          },
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.terrestial_ecoregions.ecoregion_protected_tot_sqkm"),
            "field": "pa_tot_sqkm",
            color: "#8ecfe0"
          },
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.terrestial_ecoregions.protected_in_ecoregion"),
            "field": "pa_in_eco_sqkm",
            color: "#91ad41"
          }
        ]
      },
      copernicus: {
        columns: [
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.copernicus.label"),
            "field": "label"
          },
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.copernicus.percent"),
            "field": "percent"
          },
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.copernicus.area"),
            "field": "area"
          },
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.copernicus.color"),
            "field": "color",
            type: "color"
          }
        ]
      },
      protected_area: {
        columns: [
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.protected_area.name"),
            "field": "name"
          },
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.protected_area.gis_area"),
            "field": "gis_area"
          },
          {
            "label": window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.protected_area.nature"),
            "field": "nature",
            type: "bg-color"
          }
        ]
      },
      map: {
        fields: [
          {
            label: "%",
            children: [
              {
                label: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.map.fields.area_prot_terr_perc"),
                field: "area_prot_terr_perc",
                color: "#91cc75"
              },
              {
                label: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.map.fields.protconn"),
                field: "protconn",
                color: "#3ba272"
              }
            ]
          }
        ],
        dopa_indicators: {
          terrestial_area: {
            title_table: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.map.dopa_indicators.terrestial_area.title_table"),
            indicators: [
              {
                field: "area_terr_perc",
                label: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.map.dopa_indicators.terrestial_area.area_terr_perc")
              },
              {
                field: "area_prot_terr_km2",
                label: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.map.dopa_indicators.terrestial_area.area_prot_terr_km2")
              },
              {
                field: "area_terr_km2",
                label: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.map.dopa_indicators.terrestial_area.area_terr_km2")
              }
            ]
          },
          marine_area: {
            title_table: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.map.dopa_indicators.marine_indicators.title_table"),
            indicators: [
              {
                field: "area_mar_perc",
                label: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.map.dopa_indicators.marine_indicators.area_mar_perc")
              },
              {
                field: "area_prot_mar_km2",
                label: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.map.dopa_indicators.marine_indicators.area_prot_mar_km2")
              },
              {
                field: "area_mar_km2",
                label: window.ModularForms.Helpers.Locale.getLabel("imet-core::analysis_report.map.dopa_indicators.marine_indicators.area_mar_km2")
              }
            ]
          }
        }
      }
    };
    const _sfc_main$7 = {
      __name: "app",
      props: {
        scaling_up_id: {
          type: Number,
          default: 0
        },
        labels: {
          type: String,
          default: ""
        }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const props = __props;
        const initializeScalingUpLabels = () => {
          window.ScalingUp = {};
          window.ScalingUp.labels = function(label) {
            return props.labels[label] ?? label;
          };
        };
        initializeScalingUpLabels();
        const stores = {
          BasketStore: new BasketStore({ scaling_up_id: props.scaling_up_id }),
          BaseStore: new BaseStore({ scaling_up_id: props.scaling_up_id }),
          LocalStore
        };
        provide("stores", stores);
        provide("config", config);
        const __returned__ = { props, initializeScalingUpLabels, stores, provide, get LocalStore() {
          return LocalStore;
        }, get basket_store() {
          return BasketStore;
        }, get base_store() {
          return BaseStore;
        }, get config() {
          return config;
        } };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", null, [
        renderSlot(_ctx.$slots, "default")
      ]);
    }
    const application = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$7], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/scaling_up_analysis/components/app.vue"]]);
    class Report {
      constructor(input_data = {}) {
        const options = {
          name: "Report",
          setup() {
            const emitter = mitt();
            provide("emitter", emitter);
            function goTo(event) {
              let element = event.target.value;
              if (element === "#") {
                return;
              }
              if (["process", "process_PRA", "process_PRB", "process_PRC", "process_PRD", "process_PRE", "process_PRF"].includes(element)) {
                let event_element = "analysis_per_element_of_them_management_cycle";
                emitter.emit(event_element);
                setTimeout(() => {
                  emitter.emit("sub_elem_4");
                }, 500);
                setTimeout(() => {
                  window.ModularForms.Helpers.Animation.scrollPageToAnchor(element);
                }, 800);
              } else {
                emitter.emit(element);
                setTimeout(() => {
                  window.ModularForms.Helpers.Animation.scrollPageToAnchor(element);
                }, 500);
              }
            }
            return {
              goTo,
              url: input_data.url
            };
          }
        };
        const app = createApp(
          options || {},
          input_data || {}
        );
        app.component("app", application);
        app.component("general_info", generalInfo);
        app.component("management_context", managementContext);
        app.component("grouping", grouping);
        app.component("map_view", mapView);
        app.component("preview_template", previewTemplate);
        app.component("container", container);
        app.component("container_view", containerView);
        app.component("container_analysis_management_cycle", containerAnalysisManagementCycle);
        app.component("container_section", containerSection);
        app.component("container_upper_lower_radars", containerUpperLowerRadars);
        app.component("container_actions", containerActions);
        app.component("datatable_custom", datatableCustom);
        app.component("datatable_interact_with_radar", datatableInteractWithRadar);
        app.component("datatable_interact_with_scatter", datatableInteractWithScatter);
        app.component("datatable_scaling", datatableScaling);
        app.component("bar_reverse", barReverse);
        app.component("bar_category_stack", barCategoryStack);
        app.component("imet_bar_error", imetBarError);
        app.component("scaling_radar", scalingRadar);
        app.component("treemap", treemap);
        app.component("dopa_chart_bar", dopa_chart_bar);
        app.component("dopa_chart_doughnut", scalingDopaChartDoughnut);
        app.component("scatter", scatter);
        app.component("radar_threats", radarThreats);
        app.component("color_picker", colorPicker);
        app.component("basket", basket);
        app.component("guidance", guidance);
        app.component("small_menu", smallMenu);
        app.component("checkboxes_list", checkboxesList);
        app.component("tooltip", tooltip);
        app.component("imet_bar_chart", imetBarChart);
        app.component("dopa_indicators_table", dopa_indicators_table);
        app.component("text_editor", textEditor);
        return app;
      }
    }
    class Preview {
      constructor(input_data = {}) {
        const options = {
          name: "Preview",
          setup() {
            const emitter = mitt();
            provide("emitter", emitter);
            const printReport = () => {
              window.print();
            };
            const downloadFiles = () => {
              window.location.href = input_data.url;
            };
            return {
              printReport,
              downloadFiles
            };
          }
        };
        const app = createApp(
          options || {},
          input_data || {}
        );
        app.component("app", application);
        app.component("preview_template", previewTemplate);
        return app;
      }
    }
    const _sfc_main$6 = {
      name: "dopa_radar",
      props: {
        data: {
          type: [Number, String],
          default: null
        },
        radar_width: {
          type: Number,
          default: 400
        },
        radar_height: {
          type: Number,
          default: 350
        }
      },
      data: function() {
        return {
          labels: [],
          radar1: [],
          radar2: []
        };
      },
      mounted() {
        let _this = this;
        let elem = this.$el.querySelector("div.dopa_radar");
        if (this.data != null && this.data != "null" && this.data !== "[]") {
          debugger;
          this.chart = init(elem);
          this.chart.setOption(_this.radar_options());
        }
      },
      methods: {
        get_values() {
          var _a2;
          let _this = this;
          (_a2 = JSON.parse(this.data)) == null ? void 0 : _a2.forEach(function(item) {
            _this.labels.push({ name: item.title.replace(" ", "\n"), max: 100 });
            _this.radar1.push(item.country_avg);
            _this.radar2.push(item.site_norm_value);
          });
        },
        radar_options() {
          this.get_values();
          return {
            tooltip: {
              trigger: "axis"
            },
            legend: {
              data: ["Country Average", "Protected Area"]
            },
            radar: {
              indicator: this.labels,
              radius: 100,
              center: ["50%", "55%"],
              name: {
                textStyle: {
                  color: "#111"
                }
              }
            },
            series: [
              {
                type: "radar",
                data: [
                  {
                    value: this.radar2,
                    itemStyle: {
                      color: "#8fbf4b"
                    },
                    areaStyle: {
                      color: "#8fbf4b",
                      opacity: 0.4
                    },
                    symbolSize: 6,
                    name: "Protected Area",
                    tooltip: {
                      trigger: "item"
                    }
                  },
                  {
                    value: this.radar1,
                    itemStyle: {
                      color: "#679b95"
                    },
                    areaStyle: {
                      color: "#679b95",
                      opacity: 0.4
                    },
                    symbolSize: 6,
                    name: "Country Average",
                    tooltip: {
                      trigger: "item"
                    }
                  }
                ]
              }
            ]
          };
        }
      }
    };
    const _hoisted_1$6 = { class: "container" };
    function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", _hoisted_1$6, [
        createBaseVNode("div", {
          class: "dopa_radar",
          style: normalizeStyle("width:" + $props.radar_width + "px; height: " + $props.radar_height + "px;")
        }, null, 4)
      ]);
    }
    const dopa_radar = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$6], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/templates/dopa/chart_radar.vue"]]);
    const _sfc_main$5 = {
      __name: "editor",
      props: {
        modelValue: {
          type: String,
          required: true
        },
        action: {
          type: String,
          required: true,
          validator: (value) => ["edit", "show"].includes(value)
        },
        field: {
          type: String,
          required: true
        }
      },
      emits: ["update:modelValue"],
      setup(__props, { expose: __expose, emit: __emit }) {
        __expose();
        const props = __props;
        const emit = __emit;
        const updateContent = (value) => {
          emit("update:modelValue", value);
        };
        const __returned__ = { props, emit, updateContent };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$5 = { class: "mt-2" };
    const _hoisted_2$5 = {
      key: 0,
      class: "text-editor-edit"
    };
    const _hoisted_3$4 = {
      key: 1,
      class: "field-preview",
      style: { "max-width": "none", "margin-bottom": "10px" }
    };
    const _hoisted_4$4 = ["innerHTML"];
    const _hoisted_5$4 = ["innerHTML"];
    function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_editor = resolveComponent("editor", true);
      return openBlock(), createElementBlock("div", _hoisted_1$5, [
        $setup.props.action === "edit" ? (openBlock(), createElementBlock("div", _hoisted_2$5, [
          createVNode(_component_editor, {
            "model-value": $props.modelValue,
            "onUpdate:modelValue": $setup.updateContent
          }, null, 8, ["model-value"])
        ])) : $setup.props.action === "show" ? (openBlock(), createElementBlock("div", _hoisted_3$4, [
          createBaseVNode("div", { innerHTML: $props.modelValue }, null, 8, _hoisted_4$4)
        ])) : createCommentVNode("", true),
        createBaseVNode("div", {
          class: "text-editor-print",
          innerHTML: $props.modelValue
        }, null, 8, _hoisted_5$4)
      ]);
    }
    const report_editor = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5], ["__scopeId", "data-v-9cca538b"], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/inputs/editor.vue"]]);
    class Analysis {
      constructor(input_data = {}, custom_props = {}) {
        let _this = this;
        const options = {
          name: "Analysis",
          setup() {
            return _this.setupApp(input_data);
          }
        };
        return this.createApp(options, input_data);
      }
      setupApp(input_data) {
        const status = ref(input_data.status);
        const report = reactive(input_data.report);
        const scores = input_data.scores;
        const labels = input_data.labels;
        watch(report, () => {
          status.value = "changed";
        }, {
          deep: true
        });
        onMounted(() => {
          if (input_data.connection) {
            loadMap();
          }
        });
        function saveReport() {
          status.value = "loading";
          fetch(input_data.url, {
            method: "post",
            headers: {
              "Content-Type": "application/json",
              "X-CSRF-Token": window.Laravel.csrfToken
            },
            body: JSON.stringify({
              _method: "PATCH",
              report
            })
          }).then((response) => response.json()).then(function(data) {
            if (!(data.hasOwnProperty("status") && data.status === "success")) {
              status.value = "error";
            }
            status.value = "saved";
          }).catch(function(error) {
            status.value = "error";
          });
        }
        function printReport() {
          window.print();
        }
        let radar_values = {};
        ["context", "planning", "inputs", "process", "outputs", "outcomes"].forEach(function(value, index) {
          let label = labels[value];
          radar_values[label] = scores[value].avg_indicator || null;
        });
        function loadMap() {
          const report_map = new window.mapboxgl.Map({
            container: "map",
            style: BiopamaWDPA.base_layer,
            center: [30, 0],
            zoom: 4,
            minZoom: 2,
            maxZoom: 12,
            attributionControl: false
          });
          report_map.on("load", function() {
            BiopamaWDPA.addWdpaLayer(report_map, input_data.wdpa_id);
          });
        }
        return {
          status,
          report,
          scores,
          radar_values,
          saveReport,
          printReport,
          dopa_indicators: input_data.dopa_indicators,
          api_data: input_data.api_data,
          connection: input_data.connection
        };
      }
      createApp(options, input_data) {
        return createApp(options, input_data).component("dopa_indicators_table", dopa_indicators_table).component("editor", editor).component("report-editor", report_editor).component("dopa_radar", dopa_radar).component("dopa_chart_bar", dopa_chart_bar).component("imet_radar", imet_radar);
      }
    }
    const _sfc_main$4 = {
      __name: "checkbox-boolean",
      props: {
        id: { type: String, default: "" },
        value: { type: [String, Number, Boolean, Array, Object], default: null },
        dataClass: { type: String, default: "" },
        dataRules: { type: String, default: "" },
        dataNumeric: { type: Boolean, default: false },
        label: { type: String, default: null }
      },
      emits: ["update:modelValue"],
      setup(__props, { expose: __expose, emit: __emit }) {
        __expose();
        const props = __props;
        const emit = __emit;
        const inputValue = ref(props.value === true || props.value === "1" || props.value === 1);
        const isChecked = computed(() => {
          return inputValue.value === true || inputValue.value === 1 || inputValue.value === "1";
        });
        watch(() => props.value, (newValue) => {
          inputValue.value = newValue;
        });
        const checkChange = () => {
          inputValue.value = !inputValue.value;
          setModuleValue();
        };
        const emitValue = (value) => {
          emit("update:modelValue", value);
        };
        onBeforeMount(() => {
          if (props.value === null) {
            setModuleValue();
          }
        });
        onMounted(() => {
          document.querySelector(".checkbox").classList.remove("field-edit");
        });
        const setModuleValue = () => {
          let moduleValue = false;
          if (props.dataNumeric) {
            moduleValue = inputValue.value ? true : false;
          } else {
            moduleValue = inputValue.value;
          }
          emitValue(moduleValue);
        };
        const __returned__ = { props, emit, inputValue, isChecked, checkChange, emitValue, setModuleValue, ref, computed, watch, onBeforeMount, onMounted };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$4 = ["name", "id", "checked"];
    const _hoisted_2$4 = ["for", "innerHTML"];
    function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("span", {
        class: normalizeClass(["checkbox", $props.dataClass])
      }, [
        createBaseVNode("input", {
          type: "checkbox",
          name: $props.id,
          id: "bool-check_" + $props.id,
          checked: $setup.isChecked,
          onClick: $setup.checkChange
        }, null, 8, _hoisted_1$4),
        createBaseVNode("label", {
          for: "bool-check_" + $props.id,
          innerHTML: $props.label
        }, null, 8, _hoisted_2$4)
      ], 2);
    }
    const checkbox_boolean = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/inputs/checkbox-boolean.vue"]]);
    const _sfc_main$3 = {
      __name: "objectives",
      props: {
        report: {
          type: [Object, Array],
          default: () => ({})
        },
        objectives: {
          type: Object,
          default: () => ({})
        }
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const props = __props;
        const Locale2 = window.ModularForms.Helpers.Locale;
        const checkboxes = ref([]);
        const are_checked_all = ref(false);
        const saveDisabled = ref(false);
        const listItems = ref([]);
        onMounted(() => {
          let data = "{}";
          if ("objectives" in props.report[0] && props.report[0]["objectives"]) {
            data = props.report[0]["objectives"];
          }
          const objectives2 = JSON.parse(data);
          checkboxes.value = Array.isArray(objectives2) ? objectives2 : [];
        });
        const selectValue = (value) => {
          if (checkboxes.includes(value)) {
            checkboxes = checkboxes.filter((item) => item !== value);
          } else {
            checkboxes.push(value);
            selected();
          }
        };
        const selectValueByIdAndValue = (id, value) => {
          if (is_value_included(id)) {
            checkboxes.value = checkboxes.value.filter((item) => item.id !== id);
          } else {
            checkboxes.value.push({ id, value });
          }
          props.report[0]["objectives"] = JSON.stringify(checkboxes.value);
        };
        const is_value_included = (id) => {
          if (checkboxes.value.length) {
            return checkboxes.value.some((check2) => check2.id === id);
          }
          return false;
        };
        const is_checked = (id) => {
          if (checkboxes.value.length) {
            return checkboxes.value.some((checkbox2) => checkbox2.id === id);
          }
          return false;
        };
        const initSettings = (items) => {
          listItems.value = items;
        };
        const toggle2 = () => {
          saveDisabled.value = checkboxes.value.length === 0;
        };
        const check_all = () => {
          if (!are_checked_all.value) {
            const checkboxes2 = [...document.querySelectorAll(".vue-checkboxes")];
            for (const key in checkboxes2) {
              if (key > 0) {
                const check_box = checkboxes2[key];
                const exist = is_value_included(parseInt(check_box.defaultValue));
                if (!exist) {
                  checkboxes2.push({
                    id: check_box.defaultValue,
                    value: check_box.getAttribute("data-name")
                  });
                }
              }
            }
          } else {
            clearSelections();
          }
          selected();
        };
        const clearSelections = () => {
          checkboxes.value = [];
          are_checked_all.value = false;
        };
        const __returned__ = { props, Locale: Locale2, checkboxes, are_checked_all, saveDisabled, listItems, selectValue, selectValueByIdAndValue, is_value_included, is_checked, initSettings, toggle: toggle2, check_all, clearSelections, ref, onMounted, computed };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1$3 = { class: "module-container" };
    const _hoisted_2$3 = { class: "module-header" };
    const _hoisted_3$3 = { class: "module-title" };
    const _hoisted_4$3 = { class: "module-body" };
    const _hoisted_5$3 = { class: "max-w-12xl" };
    const _hoisted_6$2 = { class: "w-8/12" };
    const _hoisted_7$2 = ["innerHTML"];
    const _hoisted_8$1 = { class: "col text-center" };
    const _hoisted_9$1 = { class: "checkbox" };
    const _hoisted_10$1 = ["checked", "data-name", "id", "onClick", "value"];
    const _hoisted_11$1 = ["for"];
    const _hoisted_12$1 = { class: "max-w-12xl" };
    const _hoisted_13$1 = { class: "w-8/12" };
    const _hoisted_14$1 = ["innerHTML"];
    const _hoisted_15$1 = { class: "col text-center" };
    const _hoisted_16$1 = { class: "checkbox" };
    const _hoisted_17$1 = ["checked", "data-name", "id", "onClick", "value"];
    const _hoisted_18$1 = ["for"];
    function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", _hoisted_1$3, [
        createBaseVNode("div", _hoisted_2$3, [
          createBaseVNode("div", _hoisted_3$3, toDisplayString($setup.Locale.getLabel("imet-core::oecm_report.general_planning.objectives_title")), 1)
        ]),
        createBaseVNode("div", _hoisted_4$3, [
          createBaseVNode("table", _hoisted_5$3, [
            createBaseVNode("tr", null, [
              createBaseVNode("th", _hoisted_6$2, toDisplayString($setup.Locale.getLabel("imet-core::oecm_report.general_planning.intervention_context")), 1),
              createBaseVNode("th", null, toDisplayString($setup.Locale.getLabel("imet-core::oecm_report.general_planning.prioritize_in_management")), 1)
            ]),
            (openBlock(true), createElementBlock(Fragment, null, renderList($props.objectives["context"], (objective, index) => {
              return openBlock(), createElementBlock("tr", {
                class: "mt-3",
                key: index
              }, [
                createBaseVNode("td", { innerHTML: objective }, null, 8, _hoisted_7$2),
                createBaseVNode("td", _hoisted_8$1, [
                  createBaseVNode("span", _hoisted_9$1, [
                    createBaseVNode("input", {
                      type: "checkbox",
                      checked: $setup.is_checked(index),
                      "data-name": objective,
                      id: objective,
                      onClick: ($event) => $setup.selectValueByIdAndValue(index, objective),
                      class: "vue-checkboxes",
                      value: index
                    }, null, 8, _hoisted_10$1),
                    createBaseVNode("label", { for: objective }, null, 8, _hoisted_11$1)
                  ])
                ])
              ]);
            }), 128))
          ]),
          createBaseVNode("table", _hoisted_12$1, [
            createBaseVNode("tr", null, [
              createBaseVNode("th", _hoisted_13$1, toDisplayString($setup.Locale.getLabel("imet-core::oecm_report.general_planning.management_evaluation")), 1),
              createBaseVNode("th", null, toDisplayString($setup.Locale.getLabel("imet-core::oecm_report.general_planning.prioritize_in_management")), 1)
            ]),
            (openBlock(true), createElementBlock(Fragment, null, renderList($props.objectives["evaluation"], (objective, index) => {
              return openBlock(), createElementBlock("tr", {
                class: "mt-3",
                key: index
              }, [
                createBaseVNode("td", { innerHTML: objective }, null, 8, _hoisted_14$1),
                createBaseVNode("td", _hoisted_15$1, [
                  createBaseVNode("span", _hoisted_16$1, [
                    createBaseVNode("input", {
                      type: "checkbox",
                      checked: $setup.is_checked(index),
                      "data-name": objective,
                      id: objective,
                      onClick: ($event) => $setup.selectValueByIdAndValue(index, objective),
                      class: "vue-checkboxes",
                      value: index
                    }, null, 8, _hoisted_17$1),
                    createBaseVNode("label", { for: objective }, null, 8, _hoisted_18$1)
                  ])
                ])
              ]);
            }), 128))
          ])
        ])
      ]);
    }
    const objectives = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/report/oecm/objectives.vue"]]);
    const _sfc_main$2 = {
      name: "roadmap",
      props: {
        action: {
          type: String,
          default: "edit"
        },
        report: {
          type: [Object, Array],
          default: () => {
          }
        },
        group_key: {
          type: Number,
          default: 0
        },
        default_schema: {
          type: Object,
          default: () => {
          }
        }
      },
      mounted: function() {
        if (!this.current_report) {
          this.get_values();
        }
      },
      data() {
        return {
          Locale: window.ModularForms.Helpers.Locale,
          current_report: null,
          outcome2_list: [1, 2],
          outcome1_list: [1, 2]
        };
      },
      methods: {
        outcome_list_add_items(list, label = "annual_targets2_activity") {
          const arr = [3, 4, 5];
          let add2 = 0;
          for (const i2 in arr) {
            for (const key in this.current_report) {
              if (key.startsWith(label + arr[i2])) {
                if (this.current_report[key] !== this.default_schema[key]) {
                  add2 = arr[i2];
                }
              }
            }
          }
          for (let i2 = 3; i2 <= add2; i2++) {
            list.push(i2);
          }
        },
        get_values: function() {
          if (Array.isArray(this.report)) {
            this.current_report = this.report[this.group_key];
          } else {
            this.current_report = this.report[0];
          }
          this.current_report.group_key = this.group_key;
          this.outcome_list_add_items(this.outcome2_list);
          this.outcome_list_add_items(this.outcome1_list, "annual_targets1_activity");
        },
        add_activity_outcome2_item: function() {
          this.outcome2_list.push(this.outcome2_list.length + 1);
        },
        add_activity_outcome1_item: function() {
          this.outcome1_list.push(this.outcome1_list.length + 1);
        },
        remove_outcome2_item: function() {
          this.outcome2_list.pop();
        },
        remove_outcome1_item: function() {
          this.outcome1_list.pop();
        }
      }
    };
    const _hoisted_1$2 = { class: "module-container" };
    const _hoisted_2$2 = {
      key: 0,
      class: "module-body flex flex-col gap-y-4"
    };
    const _hoisted_3$2 = { class: "flex width-full content-center justify-between" };
    const _hoisted_4$2 = { class: "width w-8/12" };
    const _hoisted_5$2 = { class: "flex" };
    const _hoisted_6$1 = { class: "w-6/12" };
    const _hoisted_7$1 = { class: "w-6/12" };
    const _hoisted_8 = { class: "flex width-full content-center justify-between" };
    const _hoisted_9 = { class: "width w-8/12" };
    const _hoisted_10 = { class: "flex" };
    const _hoisted_11 = { class: "w-6/12" };
    const _hoisted_12 = { class: "w-6/12" };
    const _hoisted_13 = { class: "flex width-full content-center justify-between" };
    const _hoisted_14 = { class: "width w-8/12" };
    const _hoisted_15 = { class: "flex" };
    const _hoisted_16 = { class: "flex width-full content-center justify-between" };
    const _hoisted_17 = { class: "width w-8/12" };
    const _hoisted_18 = { class: "flex" };
    const _hoisted_19 = { class: "w-6/12" };
    const _hoisted_20 = { class: "w-6/12" };
    const _hoisted_21 = { class: "flex width-full content-center justify-between" };
    const _hoisted_22 = { class: "width w-8/12" };
    const _hoisted_23 = { class: "flex" };
    function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_report_editor = resolveComponent("report-editor");
      const _component_checkbox_boolean = resolveComponent("checkbox-boolean");
      return openBlock(), createElementBlock("div", _hoisted_1$2, [
        _cache[18] || (_cache[18] = createBaseVNode("div", { class: "module-header" }, [
          createBaseVNode("div", { class: "module-title" })
        ], -1)),
        $data.current_report ? (openBlock(), createElementBlock("div", _hoisted_2$2, [
          createBaseVNode("div", _hoisted_3$2, [
            createBaseVNode("div", _hoisted_4$2, [
              createBaseVNode("h4", null, toDisplayString($data.Locale.getLabel("imet-core::oecm_report.table_of_planning.possible_roadmap")), 1)
            ]),
            createBaseVNode("div", null, [
              createBaseVNode("h5", null, toDisplayString($data.Locale.getLabel("imet-core::oecm_report.table_of_planning.year")) + "1", 1)
            ]),
            createBaseVNode("div", null, [
              createBaseVNode("h5", null, toDisplayString($data.Locale.getLabel("imet-core::oecm_report.table_of_planning.year")) + "2", 1)
            ]),
            createBaseVNode("div", null, [
              createBaseVNode("h5", null, toDisplayString($data.Locale.getLabel("imet-core::oecm_report.table_of_planning.year")) + "3", 1)
            ]),
            createBaseVNode("div", null, [
              createBaseVNode("h5", null, toDisplayString($data.Locale.getLabel("imet-core::oecm_report.table_of_planning.year")) + "4", 1)
            ]),
            createBaseVNode("div", null, [
              createBaseVNode("h5", null, toDisplayString($data.Locale.getLabel("imet-core::oecm_report.table_of_planning.year")) + "5", 1)
            ])
          ]),
          createBaseVNode("div", _hoisted_5$2, [
            createBaseVNode("h5", _hoisted_6$1, toDisplayString($data.Locale.getLabel("imet-core::oecm_report.table_of_planning.long_term_objectives")), 1),
            createBaseVNode("div", _hoisted_7$1, [
              createVNode(_component_report_editor, {
                modelValue: $data.current_report["long_term"],
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.current_report["long_term"] = $event),
                onUpdate: _cache[1] || (_cache[1] = ($event) => $data.current_report["long_term"] = $event),
                action: $props.action
              }, null, 8, ["modelValue", "action"])
            ])
          ]),
          createBaseVNode("h5", null, toDisplayString($data.Locale.getLabel("imet-core::oecm_report.table_of_planning.outcome")) + " 1", 1),
          createBaseVNode("div", _hoisted_8, [
            createBaseVNode("div", _hoisted_9, [
              createVNode(_component_report_editor, {
                modelValue: $data.current_report["outcome"],
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.current_report["outcome"] = $event),
                onUpdate: _cache[3] || (_cache[3] = ($event) => $data.current_report["outcome"] = $event),
                action: $props.action
              }, null, 8, ["modelValue", "action"])
            ]),
            (openBlock(), createElementBlock(Fragment, null, renderList([1, 2, 3, 4, 5], (year) => {
              return createBaseVNode("div", {
                class: "col",
                key: year
              }, [
                createVNode(_component_checkbox_boolean, {
                  value: $data.current_report["outcome_year" + year],
                  modelValue: $data.current_report["outcome_year" + year],
                  "onUpdate:modelValue": ($event) => $data.current_report["outcome_year" + year] = $event,
                  onUpdate: ($event) => $data.current_report["outcome_year" + year] = $event,
                  id: $data.current_report["group_key"] + "_outcome_year" + year
                }, null, 8, ["value", "modelValue", "onUpdate:modelValue", "onUpdate", "id"])
              ]);
            }), 64))
          ]),
          createBaseVNode("div", _hoisted_10, [
            createBaseVNode("div", _hoisted_11, [
              createBaseVNode("h5", null, toDisplayString($data.Locale.getLabel("imet-core::oecm_report.table_of_planning.annual_multi_annual_targets")), 1)
            ]),
            createBaseVNode("div", _hoisted_12, [
              createVNode(_component_report_editor, {
                modelValue: $data.current_report["annual_targets1"],
                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => $data.current_report["annual_targets1"] = $event),
                onUpdate: _cache[5] || (_cache[5] = ($event) => $data.current_report["annual_targets1"] = $event),
                action: $props.action
              }, null, 8, ["modelValue", "action"])
            ])
          ]),
          (openBlock(true), createElementBlock(Fragment, null, renderList(this.outcome1_list.length, (activity) => {
            return openBlock(), createElementBlock("div", { key: activity }, [
              createBaseVNode("h6", null, toDisplayString($data.Locale.getLabel("imet-core::oecm_report.table_of_planning.activity")) + " " + toDisplayString(activity), 1),
              createBaseVNode("div", _hoisted_13, [
                createBaseVNode("div", _hoisted_14, [
                  createVNode(_component_report_editor, {
                    modelValue: $data.current_report["annual_targets1_activity" + activity],
                    "onUpdate:modelValue": ($event) => $data.current_report["annual_targets1_activity" + activity] = $event,
                    onUpdate: ($event) => $data.current_report["annual_targets1_activity" + activity] = $event,
                    action: $props.action
                  }, null, 8, ["modelValue", "onUpdate:modelValue", "onUpdate", "action"])
                ]),
                (openBlock(), createElementBlock(Fragment, null, renderList([1, 2, 3, 4, 5], (year) => {
                  return createBaseVNode("div", {
                    class: "col",
                    key: year
                  }, [
                    createVNode(_component_checkbox_boolean, {
                      value: $data.current_report["annual_targets1_activity" + activity + "_year" + year],
                      modelValue: $data.current_report["annual_targets1_activity" + activity + "_year" + year],
                      "onUpdate:modelValue": ($event) => $data.current_report["annual_targets1_activity" + activity + "_year" + year] = $event,
                      onUpdate: ($event) => $data.current_report["annual_targets1_activity" + activity + "_year" + year] = $event,
                      id: $data.current_report["group_key"] + "_annual_targets1_activity" + activity + "_year" + year
                    }, null, 8, ["value", "modelValue", "onUpdate:modelValue", "onUpdate", "id"])
                  ]);
                }), 64))
              ])
            ]);
          }), 128)),
          createBaseVNode("div", _hoisted_15, [
            $data.outcome1_list.length < 5 ? (openBlock(), createElementBlock("button", {
              key: 0,
              type: "button",
              class: "btn-nav small add-item",
              onClick: _cache[6] || (_cache[6] = (...args) => $options.add_activity_outcome1_item && $options.add_activity_outcome1_item(...args))
            }, [
              _cache[14] || (_cache[14] = createBaseVNode("span", { class: "fas fa-fw fa-plus-circle white" }, null, -1)),
              createTextVNode(" " + toDisplayString($data.Locale.getLabel("modular-forms::common.add_item")), 1)
            ])) : createCommentVNode("", true),
            $data.outcome1_list.length > 1 ? (openBlock(), createElementBlock("button", {
              key: 1,
              type: "button",
              class: "btn-nav small red remove-item",
              onClick: _cache[7] || (_cache[7] = (...args) => $options.remove_outcome1_item && $options.remove_outcome1_item(...args))
            }, _cache[15] || (_cache[15] = [
              createBaseVNode("span", { class: "fas fa-fw fa-trash white" }, null, -1)
            ]))) : createCommentVNode("", true)
          ]),
          createBaseVNode("h5", null, toDisplayString($data.Locale.getLabel("imet-core::oecm_report.table_of_planning.outcome")) + " 2", 1),
          createBaseVNode("div", _hoisted_16, [
            createBaseVNode("div", _hoisted_17, [
              createVNode(_component_report_editor, {
                modelValue: $data.current_report["outcome2"],
                "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => $data.current_report["outcome2"] = $event),
                onUpdate: _cache[9] || (_cache[9] = ($event) => $data.current_report["outcome2"] = $event),
                action: $props.action
              }, null, 8, ["modelValue", "action"])
            ]),
            (openBlock(), createElementBlock(Fragment, null, renderList([1, 2, 3, 4, 5], (year) => {
              return createBaseVNode("div", {
                class: "col",
                key: year
              }, [
                createVNode(_component_checkbox_boolean, {
                  value: $data.current_report["outcome2_year" + year],
                  modelValue: $data.current_report["outcome2_year" + year],
                  "onUpdate:modelValue": ($event) => $data.current_report["outcome2_year" + year] = $event,
                  onUpdate: ($event) => $data.current_report["outcome2_year" + year] = $event,
                  id: $data.current_report["group_key"] + "_outcome2_year" + year
                }, null, 8, ["value", "modelValue", "onUpdate:modelValue", "onUpdate", "id"])
              ]);
            }), 64))
          ]),
          createBaseVNode("div", _hoisted_18, [
            createBaseVNode("div", _hoisted_19, [
              createBaseVNode("h5", null, toDisplayString($data.Locale.getLabel("imet-core::oecm_report.table_of_planning.annual_multi_annual_targets")), 1)
            ]),
            createBaseVNode("div", _hoisted_20, [
              createVNode(_component_report_editor, {
                modelValue: $data.current_report["annual_targets2"],
                "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => $data.current_report["annual_targets2"] = $event),
                onUpdate: _cache[11] || (_cache[11] = ($event) => $data.current_report["annual_targets2"] = $event),
                action: $props.action
              }, null, 8, ["modelValue", "action"])
            ])
          ]),
          (openBlock(true), createElementBlock(Fragment, null, renderList(this.outcome2_list.length, (activity) => {
            return openBlock(), createElementBlock("div", { key: activity }, [
              createBaseVNode("h6", null, toDisplayString($data.Locale.getLabel("imet-core::oecm_report.table_of_planning.activity")) + " " + toDisplayString(activity), 1),
              createBaseVNode("div", _hoisted_21, [
                createBaseVNode("div", _hoisted_22, [
                  createVNode(_component_report_editor, {
                    modelValue: $data.current_report["annual_targets2_activity" + activity],
                    "onUpdate:modelValue": ($event) => $data.current_report["annual_targets2_activity" + activity] = $event,
                    onUpdate: ($event) => $data.current_report["annual_targets2_activity" + activity] = $event,
                    action: $props.action
                  }, null, 8, ["modelValue", "onUpdate:modelValue", "onUpdate", "action"])
                ]),
                (openBlock(), createElementBlock(Fragment, null, renderList([1, 2, 3, 4, 5], (year) => {
                  return createBaseVNode("div", {
                    class: "col",
                    key: year
                  }, [
                    createVNode(_component_checkbox_boolean, {
                      value: $data.current_report["annual_targets2_activity" + activity + "_year" + year],
                      modelValue: $data.current_report["annual_targets2_activity" + activity + "_year" + year],
                      "onUpdate:modelValue": ($event) => $data.current_report["annual_targets2_activity" + activity + "_year" + year] = $event,
                      onUpdate: ($event) => $data.current_report["annual_targets2_activity" + activity + "_year" + year] = $event,
                      id: $data.current_report["group_key"] + "_annual_targets2_activity" + activity + "_year" + year
                    }, null, 8, ["value", "modelValue", "onUpdate:modelValue", "onUpdate", "id"])
                  ]);
                }), 64))
              ])
            ]);
          }), 128)),
          createBaseVNode("div", _hoisted_23, [
            $data.outcome2_list.length < 5 ? (openBlock(), createElementBlock("button", {
              key: 0,
              type: "button",
              class: "btn-nav small add-item",
              onClick: _cache[12] || (_cache[12] = (...args) => $options.add_activity_outcome2_item && $options.add_activity_outcome2_item(...args))
            }, [
              _cache[16] || (_cache[16] = createBaseVNode("span", { class: "fas fa-fw fa-plus-circle white" }, null, -1)),
              createTextVNode(" " + toDisplayString($data.Locale.getLabel("modular-forms::common.add_item")), 1)
            ])) : createCommentVNode("", true),
            $data.outcome2_list.length > 1 ? (openBlock(), createElementBlock("button", {
              key: 1,
              type: "button",
              class: "btn-nav small red remove-item",
              onClick: _cache[13] || (_cache[13] = (...args) => $options.remove_outcome2_item && $options.remove_outcome2_item(...args))
            }, _cache[17] || (_cache[17] = [
              createBaseVNode("span", { class: "fas fa-fw fa-trash white" }, null, -1)
            ]))) : createCommentVNode("", true)
          ])
        ])) : createCommentVNode("", true)
      ]);
    }
    const roadmap = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2], ["__scopeId", "data-v-d11a656e"], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/report/oecm/roadmap.vue"]]);
    const _sfc_main$1 = {
      name: "table_input",
      props: {
        action: {
          type: String,
          default: "edit"
        },
        report: {
          type: [Object, Array],
          default: () => {
          }
        },
        group_key: {
          type: Number,
          default: 0
        }
      },
      data() {
        return {
          Locale: window.ModularForms.Helpers.Locale,
          current_report: null
        };
      },
      mounted: function() {
        if (!this.current_report) {
          this.get_values();
        }
      },
      methods: {
        get_values: function() {
          if (Array.isArray(this.report)) {
            this.current_report = this.report[this.group_key];
          } else {
            this.current_report = this.report[0];
          }
          this.current_report.group_key = this.group_key;
        },
        label_item: function() {
          if (this.group_key) {
            return "." + this.group_key;
          }
          return "";
        }
      }
    };
    const _hoisted_1$1 = ["id"];
    const _hoisted_2$1 = { class: "module-header" };
    const _hoisted_3$1 = {
      class: "module-title",
      id: "ar5"
    };
    const _hoisted_4$1 = {
      key: 0,
      class: "module-body"
    };
    const _hoisted_5$1 = {
      key: 1,
      class: "field-preview",
      style: { "max-width": "none", "margin-bottom": "10px" }
    };
    function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_editor = resolveComponent("editor");
      return openBlock(), createElementBlock("div", {
        class: "module-container",
        id: $props.group_key
      }, [
        createBaseVNode("div", _hoisted_2$1, [
          createBaseVNode("div", _hoisted_3$1, "AR.5" + toDisplayString(this.label_item()) + " " + toDisplayString($data.Locale.getLabel("imet-core::oecm_report.table_of_planning.title")), 1)
        ]),
        $data.current_report ? (openBlock(), createElementBlock("div", _hoisted_4$1, [
          createBaseVNode("h5", null, toDisplayString($data.Locale.getLabel("imet-core::oecm_report.table_of_planning.previous_state")), 1),
          ($props.action = "edit") ? (openBlock(), createBlock(_component_editor, {
            key: 0,
            modelValue: $data.current_report["previous_state"],
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.current_report["previous_state"] = $event),
            onUpdate: _cache[1] || (_cache[1] = ($event) => $data.current_report["previous_state"] = $event)
          }, null, 8, ["modelValue"])) : (openBlock(), createElementBlock("div", _hoisted_5$1, toDisplayString($data.current_report.previous_state) + "} ", 1)),
          createBaseVNode("h5", null, toDisplayString($data.Locale.getLabel("imet-core::oecm_report.table_of_planning.impacts")), 1),
          createVNode(_component_editor, {
            modelValue: $data.current_report["impacts"],
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.current_report["impacts"] = $event),
            onUpdate: _cache[3] || (_cache[3] = ($event) => $data.current_report["impacts"] = $event)
          }, null, 8, ["modelValue"]),
          createBaseVNode("h5", null, toDisplayString($data.Locale.getLabel("imet-core::oecm_report.table_of_planning.responses")), 1),
          createVNode(_component_editor, {
            modelValue: $data.current_report["responses"],
            "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => $data.current_report["responses"] = $event),
            onUpdate: _cache[5] || (_cache[5] = ($event) => $data.current_report["responses"] = $event)
          }, null, 8, ["modelValue"]),
          createBaseVNode("h5", null, toDisplayString($data.Locale.getLabel("imet-core::oecm_report.table_of_planning.proposed_short")), 1),
          createVNode(_component_editor, {
            modelValue: $data.current_report["proposed_short"],
            "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => $data.current_report["proposed_short"] = $event),
            onUpdate: _cache[7] || (_cache[7] = ($event) => $data.current_report["proposed_short"] = $event)
          }, null, 8, ["modelValue"]),
          createBaseVNode("h5", null, toDisplayString($data.Locale.getLabel("imet-core::oecm_report.table_of_planning.proposed_long")), 1),
          createVNode(_component_editor, {
            modelValue: $data.current_report["proposed_long"],
            "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => $data.current_report["proposed_long"] = $event),
            onUpdate: _cache[9] || (_cache[9] = ($event) => $data.current_report["proposed_long"] = $event)
          }, null, 8, ["modelValue"])
        ])) : createCommentVNode("", true)
      ], 8, _hoisted_1$1);
    }
    const table_input = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1], ["__file", "/var/www/html/vendor/andreamarelli/imet-core/src/resources/assets/js/report/oecm/table_input.vue"]]);
    class OECMAnalysis extends Analysis {
      constructor(input_data = {}, custom_props = {}) {
        return super(input_data, custom_props).component("objectives", objectives).component("roadmap", roadmap).component("table_input", table_input).component("checkbox-boolean", checkbox_boolean).component("imet_score_bar", imetScoreBar);
      }
      setupApp(input_data) {
        let setup_obj = super.setupApp(input_data);
        let table_input_elems = ref(input_data.table_input_elems);
        let short_long_objectives = input_data.short_long_objectives;
        let loading_objectives = input_data.loading_objectives;
        let error_objectives = input_data.error_objectives;
        const default_schema = input_data.default_schema;
        const objectives_url = input_data.objectives_url;
        onMounted(() => {
          if (setup_obj.report.length > 0) {
            for (const items in setup_obj.report) {
              for (const item in setup_obj.report[items]) {
                if (setup_obj.report[items][item] === null) {
                  setup_obj.report[items][item] = "";
                }
              }
            }
            table_input_elems.value = setup_obj.report.map((elem, index) => index);
          }
          getObjectives();
        });
        const reportLength = computed(() => {
          return setup_obj.report.length;
        });
        watch(setup_obj.status, (value) => {
          if (value === "saved") {
            setTimeout(() => {
              setup_obj.status = "idle";
            }, 4e3);
          }
        });
        watch(setup_obj.report, () => {
          setup_obj.status = "changed";
        }, { deep: true });
        function addItem() {
          if (table_input_elems.value.length < 10) {
            const id = table_input_elems.value.length;
            table_input_elems.value.push(id);
            const new_schema = JSON.parse(JSON.stringify(default_schema));
            for (const item in new_schema) {
              if (new_schema[item] === null) {
                new_schema[item] = "";
              }
            }
            setup_obj.report.push(new_schema);
          }
        }
        function deleteItem(index) {
          const key = table_input_elems.value.pop();
          setup_obj.report.splice(key, 1);
        }
        function getObjectives() {
          loading_objectives = true;
          fetch(objectives_url, {
            method: "get",
            headers: {
              "Content-Type": "application/json",
              "X-CSRF-Token": window.Laravel.csrfToken
            }
          }).then((response) => response.json()).then(function(data) {
            error_objectives = false;
            short_long_objectives = data;
            loading_objectives = false;
          }).catch((error) => {
            error_objectives = true;
            loading_objectives = false;
          });
        }
        return {
          ...setup_obj,
          addItem,
          deleteItem,
          getObjectives,
          reportLength,
          table_input_elems,
          short_long_objectives,
          loading_objectives,
          error_objectives
        };
      }
      createApp(options, input_data) {
        return super.createApp(options, input_data);
      }
    }
    function useLoadFromPrevious(component_data) {
      const records = unref(component_data.records);
      const previous_url = component_data.previous_url;
      const show_language = ref(true);
      const available_years = ref(null);
      const prev_year_selection = ref(null);
      const retrieving_years = ref(false);
      const current_year = ref(records[0]["Year"]);
      const current_pa = ref(records[0]["wdpa_id"]);
      watch(prev_year_selection, (value) => {
        show_language.value = value === null || value === "no_import";
        records[0]["prev_year_selection"] = value;
      });
      function validateRecord() {
        let status;
        if (current_year.value !== records[0]["Year"] && current_pa.value !== records[0]["wdpa_id"]) {
          prev_year_selection.value = null;
          available_years.value = null;
        }
        if (![null, ""].includes(records[0]["wdpa_id"]) && ![null, ""].includes(records[0]["Year"]) && (current_pa.value !== records[0]["wdpa_id"] || current_year.value !== records[0]["Year"])) {
          try {
            retrievePreviousYears();
          } catch (e2) {
            retrieving_years.value = false;
            available_years.value = null;
          }
        }
        if (![null, ""].includes(records[0]["Year"]) && ![null, ""].includes(records[0]["wdpa_id"]) && (prev_year_selection.value === "no_import" && records[0]["language"] !== null || prev_year_selection.value !== "no_import" && prev_year_selection.value !== null || available_years.value === null && records[0]["language"] !== null)) {
          status = "idle";
        } else {
          status = "init";
        }
        status = status !== "init" && status !== "changed" ? "changed" : status;
        current_pa.value = records[0]["wdpa_id"];
        current_year.value = records[0]["Year"];
        return status;
      }
      function retrievePreviousYears() {
        available_years.value = null;
        retrieving_years.value = true;
        fetch(previous_url, {
          method: "post",
          headers: {
            "Content-Type": "application/json",
            "X-CSRF-Token": window.Laravel.csrfToken
          },
          body: JSON.stringify({
            year: records[0]["Year"],
            wdpa_id: records[0]["wdpa_id"]
          })
        }).then((response) => response.json()).then(function(data) {
          retrieving_years.value = false;
          if (Object.values(data).length > 0) {
            parseAvailableYears(data);
          } else {
            available_years.value = null;
          }
        });
      }
      function parseAvailableYears(data) {
        available_years.value = data;
        available_years.value["no_import"] = "No";
        let years = Object.values(available_years.value);
        let duplicates = foundDuplicates(years);
        Object.keys(available_years.value).forEach(function(key) {
          if (duplicates.includes(available_years.value[key])) {
            available_years.value[key] = available_years.value[key] + " (IMET #" + key + ")";
          }
        });
      }
      function foundDuplicates(list) {
        let sorted_arr = list.slice().sort();
        let results = [];
        for (let i2 = 0; i2 < sorted_arr.length - 1; i2++) {
          if (sorted_arr[i2 + 1] === sorted_arr[i2]) {
            results.push(sorted_arr[i2]);
          }
        }
        return results;
      }
      return {
        show_language,
        retrieving_years,
        available_years,
        validateRecord,
        prev_year_selection
      };
    }
    class Create extends ModuleImet {
      constructor(input_data = {}) {
        const custom_props = {
          previous_url: {
            type: String,
            default: null
          }
        };
        return super(input_data, custom_props);
      }
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        const { show_language, retrieving_years, available_years, validateRecord, prev_year_selection } = useLoadFromPrevious({
          records: setup_obj.records,
          previous_url: props.previous_url
        });
        watch(setup_obj.records, () => {
          setup_obj.status.value = "idle";
          setup_obj.status.value = validateRecord();
        }, { deep: true });
        return {
          ...setup_obj,
          show_language,
          retrieving_years,
          available_years,
          prev_year_selection
        };
      }
    }
    let CreateNonWDPA$1 = class CreateNonWDPA extends ModuleImet {
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        watch(setup_obj.records, () => {
          setup_obj.status.value = "idle";
          recordChanged();
        }, { deep: true });
        function recordChanged() {
          let empty = [];
          for (const [key, value] of Object.entries(setup_obj.records[0])) {
            if (value === null || value === "") {
              empty.push(key);
            }
          }
          if (empty.includes("version") && empty.includes("FormID") && empty.includes("UpdateDate") && empty.includes("UpdateBy")) {
            if (empty.length === 4 || empty.length === 5 && empty.includes("rep_m_area") || empty.length === 5 && empty.includes("rep_area")) {
              setup_obj.status.value = "changed";
            } else {
              setup_obj.status.value = "init";
            }
          } else {
            setup_obj.status.value = "init";
          }
        }
        return {
          ...setup_obj
        };
      }
    };
    let Areas$4 = class Areas extends ModuleImet {
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        const AdministrativeArea_km2 = ref(input_data.records[0]["AdministrativeArea"] / 100);
        const WDPAArea_km2 = ref(input_data.records[0]["WDPAArea"] / 100);
        const GISArea_km2 = ref(input_data.records[0]["GISArea"] / 100);
        function convertToKm(fieldName) {
          if (fieldName === "AdministrativeArea") {
            AdministrativeArea_km2.value = parseFloat(setup_obj.records[0][fieldName]) / 100;
          } else if (fieldName === "WDPAArea") {
            WDPAArea_km2.value = parseFloat(setup_obj.records[0][fieldName]) / 100;
          } else if (fieldName === "GISArea") {
            GISArea_km2.value = parseFloat(setup_obj.records[0][fieldName]) / 100;
          }
        }
        function convertToHa(fieldName) {
          nextTick().then(() => {
            if (fieldName === "AdministrativeArea") {
              setup_obj.records[0][fieldName] = AdministrativeArea_km2.value * 100;
            } else if (fieldName === "WDPAArea") {
              setup_obj.records[0][fieldName] = WDPAArea_km2.value * 100;
            } else if (fieldName === "GISArea") {
              setup_obj.records[0][fieldName] = GISArea_km2.value * 100;
            }
          });
        }
        return {
          ...setup_obj,
          AdministrativeArea_km2,
          WDPAArea_km2,
          GISArea_km2,
          convertToKm,
          convertToHa
        };
      }
    };
    let ControlLevel$1 = class ControlLevel extends ModuleImet {
      constructor(input_data = {}) {
        const custom_props = {
          area: {
            type: Number,
            default: input_data.area
          }
        };
        return super(input_data, custom_props);
      }
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        const area_percentage = computed(() => {
          let result2 = null;
          let value = setup_obj.records[0]["UnderControlArea"];
          let value2 = props.area;
          if (isValid2(props.area) && isValid2(value) && value > 0) {
            result2 = parseFloat(value) / parseFloat(value2) * 100;
            result2 = result2.toFixed(2);
          }
          return result2;
        });
        const average_time = computed(() => {
          let result2 = null;
          let value = setup_obj.records[0]["UnderControlPatrolManDay"];
          let value2 = props.area;
          if (isValid2(props.area) && isValid2(value) && value > 0) {
            result2 = parseFloat(value) / parseFloat(value2);
            result2 = result2.toFixed(2);
          }
          return result2;
        });
        const area_percentage_conversion = computed(() => {
          let result2 = null;
          let value = setup_obj.records[0]["UnderControlPatrolKm"];
          let value2 = props.area;
          if (isValid2(props.area) && isValid2(value) && value > 0) {
            result2 = parseFloat(value) / parseFloat(value2) * 10;
            result2 = result2.toFixed(2);
          }
          return result2;
        });
        const average_time_controlled = computed(() => {
          let result2 = null;
          let value = setup_obj.records[0]["UnderControlPatrolKm"];
          let value2 = setup_obj.records[0]["UnderControlArea"];
          if (isValid2(props.area) && isValid2(value) && value > 0) {
            result2 = parseFloat(value) / parseFloat(value2);
            result2 = result2.toFixed(2);
          }
          return result2;
        });
        const ecologicalMonitoringPatrolKm_percentage = computed(() => {
          let result2 = null;
          let value = setup_obj.records[0]["EcologicalMonitoringPatrolKm"];
          let value2 = props.area;
          if (isValid2(props.area) && isValid2(value) && value > 0) {
            result2 = parseFloat(value) / parseFloat(value2) * 10;
            result2 = result2.toFixed(2);
          }
          return result2;
        });
        function isValid2(n2) {
          return !isNaN(parseFloat(n2)) && isFinite(n2) && n2 !== null;
        }
        return {
          ...setup_obj,
          area_percentage,
          average_time,
          area_percentage_conversion,
          average_time_controlled,
          ecologicalMonitoringPatrolKm_percentage
        };
      }
    };
    let ManagementStaff$1 = class ManagementStaff extends ModuleImet {
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        const diffs = computed(() => {
          let diffs2 = [];
          setup_obj.records.forEach(function(item, index) {
            diffs2[index] = null;
            if (item["ExpectedPermanent"] !== null && item["ActualPermanent"] !== null) {
              diffs2[index] = parseInt(item["ActualPermanent"]) - parseInt(item["ExpectedPermanent"]);
            }
          });
          return diffs2;
        });
        return {
          ...setup_obj,
          diffs
        };
      }
    };
    let FinancialResources$1 = class FinancialResources extends ModuleImet {
      constructor(input_data = {}) {
        const custom_props = {
          area: {
            type: Number,
            default: input_data.area
          }
        };
        return super(input_data, custom_props);
      }
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        const functioning_costs_1 = computed(() => {
          let value = setup_obj.records[0]["ManagementFinancialPlanCosts"];
          return calc_ratio(value, props.area);
        });
        const functioning_costs_2 = computed(() => {
          let value = setup_obj.records[0]["OperationalWorkPlanCosts"];
          return calc_ratio(value, props.area);
        });
        const functioning_costs_3 = computed(() => {
          let value = setup_obj.records[0]["TotalBudget"];
          return calc_ratio(value, props.area);
        });
        const estimation_financial_plan_2 = computed(() => {
          let value = setup_obj.records[0]["OperationalWorkPlanCosts"];
          let value2 = setup_obj.records[0]["ManagementFinancialPlanCosts"];
          return calc_percentage(value, value2);
        });
        const estimation_financial_plan_3 = computed(() => {
          let value = setup_obj.records[0]["TotalBudget"];
          let value2 = setup_obj.records[0]["ManagementFinancialPlanCosts"];
          return calc_percentage(value, value2);
        });
        const estimation_operational_plan_3 = computed(() => {
          let value = setup_obj.records[0]["TotalBudget"];
          let value2 = setup_obj.records[0]["OperationalWorkPlanCosts"];
          return calc_percentage(value, value2);
        });
        function calc_ratio(value, value2) {
          if (isValid2(value2) && isValid2(value) && value > 0 && value2 > 0) {
            return (parseFloat(value) / parseFloat(value2)).toFixed(1);
          }
          return null;
        }
        function calc_percentage(value, value2) {
          if (isValid2(value2) && isValid2(value) && value > 0 && value2 > 0) {
            return (parseFloat(value) / parseFloat(value2) * 100).toFixed(2);
          }
          return null;
        }
        function isValid2(n2) {
          return !isNaN(parseFloat(n2)) && isFinite(n2) && n2 !== null;
        }
        return {
          ...setup_obj,
          functioning_costs_1,
          functioning_costs_2,
          functioning_costs_3,
          estimation_financial_plan_2,
          estimation_financial_plan_3,
          estimation_operational_plan_3
        };
      }
    };
    let FinancialAvailableResources$1 = class FinancialAvailableResources extends ModuleImet {
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        const totals = computed(() => {
          let result2 = [];
          setup_obj.records.forEach(function(item, index) {
            result2[index] = 0;
            result2[index] += item["NationalBudget"] !== null ? parseFloat(item["NationalBudget"]) : 0;
            result2[index] += item["OwnRevenues"] !== null ? parseFloat(item["OwnRevenues"]) : 0;
            result2[index] += item["Disputes"] !== null ? parseFloat(item["Disputes"]) : 0;
            result2[index] += item["Partners"] !== null ? parseFloat(item["Partners"]) : 0;
            result2[index] = result2[index] === 0 ? null : result2[index];
          });
          return result2;
        });
        const percentages = computed(() => {
          let result2 = [];
          let totalPlannedBudget = parseFloat(getTotalBudget());
          setup_obj.records.forEach(function(item, index) {
            let total = parseFloat(totals[index]);
            if (total > 0 && totalPlannedBudget > 0) {
              result2[index] = (total / totalPlannedBudget * 100).toFixed(1) + " %";
            }
          });
          return result2;
        });
        function getTotalBudget() {
          return window.imet__v1__context__financial_resources.records[0]["TotalBudget"];
        }
        return {
          ...setup_obj,
          totals,
          percentages
        };
      }
    };
    let FinancialResourcesBudgetLines$1 = class FinancialResourcesBudgetLines extends ModuleImet {
      constructor(input_data = {}) {
        const custom_props = {
          area: {
            type: Number,
            default: input_data.area
          }
        };
        return super(input_data, custom_props);
      }
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        const costs = computed(() => {
          let result2 = [];
          setup_obj.records.forEach(function(item, index) {
            result2[index] = 0;
            if (props.area !== null && props.area > 0) {
              result2[index] = item["Amount"] / props.area * 100;
            }
            result2[index] = result2[index] === 0 ? null : result2[index].toFixed(2);
          });
          return result2;
        });
        const percentages = computed(() => {
          let result2 = [];
          let totalBudget = get_total_budget();
          setup_obj.records.forEach(function(item, index) {
            let cost = parseFloat(costs.value[index]);
            result2[index] = "";
            if (cost > 0 && totalBudget > 0) {
              result2[index] = (cost / totalBudget * 100).toFixed(1) + " %";
            }
          });
          return result2;
        });
        const sumBudget = computed(() => {
          return setup_obj.sumColumnFloat("Amount");
        });
        function get_total_budget() {
          return window.imet__v1__context__financial_available_resources.totals.reduce(
            (accumulator, currentValue) => accumulator + currentValue
          );
        }
        return {
          ...setup_obj,
          costs,
          percentages,
          sumBudget
        };
      }
    };
    let Equipments$2 = class Equipments extends ModuleImet {
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        const averages = computed(() => {
          return setup_obj.calculateGroupsAverages("AdequacyLevel");
        });
        return {
          ...setup_obj,
          averages
        };
      }
    };
    let MenacesPressions$1 = class MenacesPressions extends ModuleImet {
      constructor(input_data = {}) {
        const custom_props = {
          groupsByCategory: {
            type: Object,
            default: () => input_data.groupsByCategory
          }
        };
        return super(input_data, custom_props);
      }
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        const recordStats = computed(() => {
          let stats = [];
          let fields = ["Impact", "Extension", "Duration", "Trend", "Probability"];
          setup_obj.records.forEach(function(record) {
            let record_values = [];
            fields.forEach(function(field) {
              record_values.push(record[field]);
            });
            stats.push(calculateStats(record_values, true));
          });
          return stats;
        });
        const groupStats = computed(() => {
          let stats = {};
          Object.keys(props.groups).forEach(function(group) {
            let group_stats = [];
            setup_obj.records.forEach(function(record, index) {
              if (record[props.group_key_field] === group) {
                group_stats.push(recordStats.value[index]);
              }
            });
            stats[group] = calculateStats(group_stats);
          });
          return stats;
        });
        const categoryStats = computed(() => {
          let stats = [];
          props.groupsByCategory.forEach(function(groups_by_category) {
            let category_stats = [];
            Object.entries(groupStats.value).forEach(([group_key, group_stats]) => {
              if (groups_by_category.includes(group_key)) {
                category_stats.push(group_stats);
              }
            });
            if (category_stats.every(function(v2) {
              return v2 === null;
            })) {
              stats.push(null);
            } else {
              stats.push(
                (calculateStats(category_stats) * 100 / 3).toFixed(2)
              );
            }
          });
          return stats;
        });
        function calculateStats(values2, rows = false) {
          let numCategories = 4;
          let prod = 1;
          let count2 = 0;
          values2.forEach(function(value, index) {
            if (value !== null) {
              if (index === 3 && rows === true) {
                prod *= (numCategories + 1) / 2 - parseFloat(value) * (numCategories - 1) / 4;
              } else {
                prod *= numCategories - parseFloat(value);
              }
              count2++;
            }
          });
          return count2 > 0 ? (4 - Math.pow(prod, 1 / count2)).toFixed(2) : null;
        }
        return {
          ...setup_obj,
          recordStats,
          groupStats,
          categoryStats
        };
      }
    };
    let Equipments$1 = class Equipments extends ModuleImet {
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        const averages = computed(() => {
          return setup_obj.calculateGroupsAverages("Importance");
        });
        return {
          ...setup_obj,
          averages
        };
      }
    };
    class ControlLevel extends ModuleImet {
      constructor(input_data = {}) {
        const custom_props = {
          stats: {
            type: Array,
            default: []
          }
        };
        return super(input_data, custom_props);
      }
    }
    class InformationAvailability extends ModuleImet {
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        const averages = computed(() => {
          return setup_obj.calculateGroupsAverages("EvaluationScore");
        });
        return {
          ...setup_obj,
          averages
        };
      }
    }
    class DesignatedValuesConservation extends ModuleImet {
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        const averages = computed(() => {
          return setup_obj.calculateGroupsAverages("EvaluationScore");
        });
        return {
          ...setup_obj,
          averages
        };
      }
    }
    class DesignatedValuesConservationTendency extends ModuleImet {
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        const averages = computed(() => {
          return setup_obj.calculateGroupsAverages("EvaluationScore");
        });
        return {
          ...setup_obj,
          averages
        };
      }
    }
    class GeographicalLocation extends ModuleImet {
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        const limit_exists = computed(() => {
          return setup_obj.records[0]["LimitsExist"] === "true" || setup_obj.records[0]["LimitsExist"] === true || setup_obj.records[0]["LimitsExist"] === 1 || setup_obj.records[0]["LimitsExist"] === "1";
        });
        return {
          ...setup_obj,
          limit_exists
        };
      }
    }
    let Areas$3 = class Areas extends ModuleImet {
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        const AdministrativeArea_km2 = ref(input_data.records[0]["AdministrativeArea"] / 100);
        const WDPAArea_km2 = ref(input_data.records[0]["WDPAArea"] / 100);
        const GISArea_km2 = ref(input_data.records[0]["GISArea"] / 100);
        function convertToKm(fieldName) {
          if (fieldName === "AdministrativeArea") {
            AdministrativeArea_km2.value = parseFloat(setup_obj.records[0][fieldName]) / 100;
          } else if (fieldName === "WDPAArea") {
            WDPAArea_km2.value = parseFloat(setup_obj.records[0][fieldName]) / 100;
          } else if (fieldName === "GISArea") {
            GISArea_km2.value = parseFloat(setup_obj.records[0][fieldName]) / 100;
          }
        }
        function convertToHa(fieldName) {
          nextTick().then(() => {
            if (fieldName === "AdministrativeArea") {
              setup_obj.records[0][fieldName] = AdministrativeArea_km2.value * 100;
            } else if (fieldName === "WDPAArea") {
              setup_obj.records[0][fieldName] = WDPAArea_km2.value * 100;
            } else if (fieldName === "GISArea") {
              setup_obj.records[0][fieldName] = GISArea_km2.value * 100;
            }
          });
        }
        function calculateShapeIndex() {
          let area = getArea();
          let boundary_length = parseFloat(setup_obj.records[0]["BoundaryLength"]);
          if (isValidNumber(area) && isValidNumber(boundary_length)) {
            let calc = Math.sqrt(3.14) / (2 * 3.14) * boundary_length / Math.sqrt(area);
            setup_obj.records[0]["Index"] = calc.toFixed(2).toString();
          } else {
            setup_obj.records[0]["Index"] = null;
          }
        }
        function getArea() {
          let area = null;
          area = isValidNumber(AdministrativeArea_km2.value) ? AdministrativeArea_km2.value : area;
          area = isValidNumber(WDPAArea_km2.value) ? WDPAArea_km2.value : area;
          area = isValidNumber(GISArea_km2.value) ? GISArea_km2.value : area;
          return area;
        }
        function isValidNumber(num) {
          if (num !== null) {
            num = parseFloat(num);
            return num > 0;
          }
          return false;
        }
        return {
          ...setup_obj,
          calculateShapeIndex,
          AdministrativeArea_km2,
          WDPAArea_km2,
          GISArea_km2,
          convertToKm,
          convertToHa,
          getArea
        };
      }
    };
    class Sectors extends ModuleImet {
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        const area_percentage = computed(() => {
          let result2 = [];
          let area = getPaArea();
          setup_obj.records.forEach(function(item, index) {
            let underControlArea = item["UnderControlArea"];
            if (isValid2(area) && isValid2(underControlArea) && underControlArea > 0) {
              result2[index] = (parseFloat(underControlArea) / parseFloat(area) * 100).toFixed(2);
            } else {
              result2[index] = null;
            }
          });
          return result2;
        });
        const average_time = computed(() => {
          let result2 = [];
          setup_obj.records.forEach(function(item, index) {
            let UnderControlPatrolManDay2 = item["UnderControlPatrolManDay"];
            let area = item["UnderControlArea"];
            if (isValid2(area) && isValid2(UnderControlPatrolManDay2) && UnderControlPatrolManDay2 > 0) {
              result2[index] = (parseFloat(UnderControlPatrolManDay2) / parseFloat(area)).toFixed(2);
            } else {
              result2[index] = null;
            }
          });
          return result2;
        });
        const sumUnderControlArea = computed(() => {
          return setup_obj.sumColumnFloat("UnderControlArea");
        });
        const UnderControlPatrolKm = computed(() => {
          return setup_obj.sumColumnFloat("UnderControlPatrolKm");
        });
        const UnderControlPatrolManDay = computed(() => {
          return setup_obj.sumColumnFloat("UnderControlPatrolManDay");
        });
        function getPaArea() {
          let area = window.imet__v2__context__areas.getArea();
          if (area !== null) {
            area = parseFloat(area.toString().replace(",", "."));
          }
          return area;
        }
        function isValid2(n2) {
          return !isNaN(parseFloat(n2)) && isFinite(n2) && n2 !== null;
        }
        return {
          ...setup_obj,
          area_percentage,
          average_time,
          sumUnderControlArea,
          UnderControlPatrolKm,
          UnderControlPatrolManDay
        };
      }
    }
    class ManagementStaff extends ModuleImet {
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        const diffs = computed(() => {
          let diffs2 = [];
          setup_obj.records.forEach(function(item, index) {
            diffs2[index] = null;
            if (item["ExpectedPermanent"] !== null && item["ActualPermanent"] !== null) {
              diffs2[index] = parseInt(item["ActualPermanent"]) - parseInt(item["ExpectedPermanent"]);
            }
          });
          return diffs2;
        });
        return {
          ...setup_obj,
          diffs
        };
      }
    }
    class FinancialResources extends ModuleImet {
      constructor(input_data = {}) {
        const custom_props = {
          area: {
            type: Number,
            default: input_data.area
          }
        };
        return super(input_data, custom_props);
      }
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        const functioning_costs_1 = computed(() => {
          let value = setup_obj.records[0]["ManagementFinancialPlanCosts"];
          return calc_ratio(value, props.area);
        });
        const functioning_costs_2 = computed(() => {
          let value = setup_obj.records[0]["OperationalWorkPlanCosts"];
          return calc_ratio(value, props.area);
        });
        const functioning_costs_3 = computed(() => {
          let value = setup_obj.records[0]["TotalBudget"];
          return calc_ratio(value, props.area);
        });
        const estimation_financial_plan_2 = computed(() => {
          let value = setup_obj.records[0]["OperationalWorkPlanCosts"];
          let value2 = setup_obj.records[0]["ManagementFinancialPlanCosts"];
          return calc_percentage(value, value2);
        });
        const estimation_financial_plan_3 = computed(() => {
          let value = setup_obj.records[0]["TotalBudget"];
          let value2 = setup_obj.records[0]["ManagementFinancialPlanCosts"];
          return calc_percentage(value, value2);
        });
        const estimation_operational_plan_3 = computed(() => {
          let value = setup_obj.records[0]["TotalBudget"];
          let value2 = setup_obj.records[0]["OperationalWorkPlanCosts"];
          return calc_percentage(value, value2);
        });
        function calc_ratio(value, value2) {
          if (isValid2(value2) && isValid2(value) && value > 0 && value2 > 0) {
            return (parseFloat(value) / parseFloat(value2)).toFixed(1);
          }
          return null;
        }
        function calc_percentage(value, value2) {
          if (isValid2(value2) && isValid2(value) && value > 0 && value2 > 0) {
            return (parseFloat(value) / parseFloat(value2) * 100).toFixed(2);
          }
          return null;
        }
        function isValid2(n2) {
          return !isNaN(parseFloat(n2)) && isFinite(n2) && n2 !== null;
        }
        return {
          ...setup_obj,
          functioning_costs_1,
          functioning_costs_2,
          functioning_costs_3,
          estimation_financial_plan_2,
          estimation_financial_plan_3,
          estimation_operational_plan_3
        };
      }
    }
    class FinancialAvailableResources extends ModuleImet {
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        const totals = computed(() => {
          let result2 = [];
          setup_obj.records.forEach(function(item, index) {
            result2[index] = 0;
            result2[index] += item["NationalBudget"] !== null ? parseFloat(item["NationalBudget"]) : 0;
            result2[index] += item["OwnRevenues"] !== null ? parseFloat(item["OwnRevenues"]) : 0;
            result2[index] += item["Disputes"] !== null ? parseFloat(item["Disputes"]) : 0;
            result2[index] += item["Partners"] !== null ? parseFloat(item["Partners"]) : 0;
            result2[index] = result2[index] === 0 ? null : result2[index];
          });
          return result2;
        });
        const percentages = computed(() => {
          let result2 = [];
          let totalPlannedBudget = parseFloat(getTotalBudget());
          setup_obj.records.forEach(function(item, index) {
            let total = parseFloat(totals[index]);
            if (total > 0 && totalPlannedBudget > 0) {
              result2[index] = (total / totalPlannedBudget * 100).toFixed(1) + " %";
            }
          });
          return result2;
        });
        const sumTotals = computed(() => {
          let sum2 = 0;
          totals.value.forEach(function(item) {
            if (item !== null) {
              sum2 += item;
            }
          });
          sum2 = sum2 / 2;
          return sum2;
        });
        const totalIsValid = computed(() => {
          return sumTotals.value === null || sumTotals.value === "" || isNaN(sumTotals.value) || sumTotals.value > 0 && parseFloat(sumTotals.value).toFixed(2) === parseFloat(getTotalBudget()).toFixed(2);
        });
        function getTotalBudget() {
          return window.imet__v2__context__financial_resources.records[0]["TotalBudget"];
        }
        return {
          ...setup_obj,
          totals,
          percentages,
          sumTotals,
          totalIsValid
        };
      }
    }
    class FinancialResourcesBudgetLines extends ModuleImet {
      constructor(input_data = {}) {
        const custom_props = {
          area: {
            type: Number,
            default: input_data.area
          }
        };
        return super(input_data, custom_props);
      }
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        const costs = computed(() => {
          let result2 = [];
          setup_obj.records.forEach(function(item, index) {
            result2[index] = 0;
            if (props.area !== null && props.area > 0) {
              result2[index] = item["Amount"] / props.area * 100;
            }
            result2[index] = result2[index] === 0 ? null : result2[index].toFixed(2);
          });
          return result2;
        });
        const percentages = computed(() => {
          let result2 = [];
          let totalBudget = get_total_budget();
          setup_obj.records.forEach(function(item, index) {
            result2[index] = "";
            if (item["Amount"] > 0 && totalBudget > 0) {
              result2[index] = (item["Amount"] / totalBudget * 100).toFixed(1) + " %";
            }
          });
          return result2;
        });
        const sumBudget = computed(() => {
          return setup_obj.sumColumnFloat("Amount");
        });
        const totalIsValid = computed(() => {
          return sumBudget.value === null || sumBudget.value === "" || isNaN(sumBudget.value) || sumBudget.value > 0 && parseFloat(sumBudget.value).toFixed(2) === parseFloat(get_total_budget()).toFixed(2);
        });
        function get_total_budget() {
          return window.imet__v2__context__financial_resources.records[0]["TotalBudget"];
        }
        return {
          ...setup_obj,
          costs,
          percentages,
          sumBudget,
          totalIsValid
        };
      }
    }
    class Equipments extends ModuleImet {
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        const averages = computed(() => {
          return setup_obj.calculateGroupsAverages("AdequacyLevel");
        });
        return {
          ...setup_obj,
          averages
        };
      }
    }
    class MenacesPressions extends ModuleImet {
      constructor(input_data = {}) {
        const custom_props = {
          marine_predefined: {
            type: Array,
            default: () => input_data.marine_predefined
          },
          groupsByCategory: {
            type: Object,
            default: () => input_data.groupsByCategory
          }
        };
        return super(input_data, custom_props);
      }
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        const recordStats = computed(() => {
          let stats = [];
          let fields = ["Impact", "Extension", "Duration", "Trend", "Probability"];
          setup_obj.records.forEach(function(record) {
            let record_values = [];
            fields.forEach(function(field) {
              record_values.push(record[field]);
            });
            stats.push(calculateStats(record_values, true));
          });
          return stats;
        });
        const groupStats = computed(() => {
          let stats = {};
          Object.keys(props.groups).forEach(function(group) {
            let group_stats = [];
            setup_obj.records.forEach(function(record, index) {
              if (record[props.group_key_field] === group) {
                group_stats.push(recordStats.value[index]);
              }
            });
            stats[group] = calculateStats(group_stats);
          });
          return stats;
        });
        const categoryStats = computed(() => {
          let stats = [];
          props.groupsByCategory.forEach(function(groups_by_category) {
            let category_stats = [];
            Object.entries(groupStats.value).forEach(([group_key, group_stats]) => {
              if (groups_by_category.includes(group_key)) {
                category_stats.push(group_stats);
              }
            });
            if (category_stats.every(function(v2) {
              return v2 === null;
            })) {
              stats.push(null);
            } else {
              stats.push(
                (calculateStats(category_stats) * 100 / 3).toFixed(2)
              );
            }
          });
          return stats;
        });
        function is_marine(value) {
          return props.marine_predefined.includes(value);
        }
        function calculateStats(values2, rows = false) {
          let numCategories = 4;
          let prod = 1;
          let count2 = 0;
          values2.forEach(function(value, index) {
            if (value !== null) {
              if (index === 3 && rows === true) {
                prod *= (numCategories + 1) / 2 - parseFloat(value) * (numCategories - 1) / 4;
              } else {
                prod *= numCategories - parseFloat(value);
              }
              count2++;
            }
          });
          return count2 > 0 ? (4 - Math.pow(prod, 1 / count2)).toFixed(2) : null;
        }
        return {
          ...setup_obj,
          recordStats,
          groupStats,
          categoryStats,
          is_marine
        };
      }
    }
    class EcosystemServices extends ModuleImet {
      constructor(input_data = {}) {
        const custom_props = {
          groupsByCategory: {
            type: Object,
            default: () => input_data.groupsByCategory
          }
        };
        return super(input_data, custom_props).component("imet_score_bar", imetScoreBar);
      }
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        const recordStats = computed(() => {
          let stats = [];
          setup_obj.records.forEach(function(record) {
            if (record["Importance"] !== null && record["ImportanceRegional"] !== null && record["ImportanceGlobal"] !== null) {
              stats.push(
                parseFloat(record["Importance"]) + parseFloat(record["ImportanceRegional"]) / 3 + (2 - parseFloat(record["ImportanceGlobal"])) / 4
              );
            } else {
              stats.push(null);
            }
          });
          return stats;
        });
        const categoryStats = computed(() => {
          let category_stats = [];
          props.groupsByCategory.forEach(function(groups_by_category) {
            let category_sum = 0;
            let category_count = 0;
            setup_obj.records.forEach(function(record, index) {
              if (groups_by_category.includes(record[props.group_key_field])) {
                let row_stats = recordStats.value[index];
                if (row_stats !== null) {
                  category_sum += parseFloat(row_stats);
                  category_count++;
                }
              }
            });
            category_stats.push(
              category_sum > 0 ? (category_sum / category_count * 100 / 3).toFixed(2) : null
            );
          });
          return category_stats;
        });
        function categoryStat(index) {
          return categoryStats.value[index];
        }
        return {
          ...setup_obj,
          recordStats,
          categoryStats,
          categoryStat
        };
      }
    }
    class RegulationsAdequacy extends ModuleImet {
      constructor(input_data = {}) {
        const custom_props = {
          marine_predefined: {
            type: Array,
            default: () => input_data.marine_predefined
          }
        };
        return super(input_data, custom_props);
      }
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        function is_marine(value) {
          return props.marine_predefined.includes(value);
        }
        return {
          ...setup_obj,
          is_marine
        };
      }
    }
    class DesignAdequacy extends ModuleImet {
      constructor(input_data = {}) {
        const custom_props = {
          marine_predefined: {
            type: Array,
            default: () => input_data.marine_predefined
          }
        };
        return super(input_data, custom_props);
      }
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        function is_marine(value) {
          return props.marine_predefined.includes(value);
        }
        return {
          ...setup_obj,
          is_marine
        };
      }
    }
    class BoundaryLevel extends ModuleImet {
      constructor(input_data = {}) {
        const custom_props = {
          marine_predefined: {
            type: Array,
            default: () => input_data.marine_predefined
          }
        };
        return super(input_data, custom_props);
      }
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        function is_marine(value) {
          return props.marine_predefined.includes(value);
        }
        return {
          ...setup_obj,
          is_marine
        };
      }
    }
    let ManagementPlan$1 = class ManagementPlan extends ModuleImet {
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        const plan_exists = computed(() => {
          let exists = setup_obj.records[0]["PlanExistence"];
          return exists === "true" || exists === true;
        });
        return {
          ...setup_obj,
          plan_exists
        };
      }
    };
    class ManagementPlan extends ModuleImet {
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        const plan_exists = computed(() => {
          let exists = setup_obj.records[0]["PlanExistence"];
          return exists === "true" || exists === true;
        });
        return {
          ...setup_obj,
          plan_exists
        };
      }
    }
    class AssistanceActivities extends ModuleImet {
      constructor(input_data = {}) {
        const custom_props = {
          marine_predefined: {
            type: Array,
            default: () => input_data.marine_predefined
          },
          terrestrial_predefined: {
            type: Array,
            default: () => input_data.terrestrial_predefined
          }
        };
        return super(input_data, custom_props);
      }
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        function is_marine(value) {
          return props.marine_predefined.includes(value);
        }
        function is_terrestrial(value) {
          return props.terrestrial_predefined.includes(value);
        }
        return {
          ...setup_obj,
          is_marine,
          is_terrestrial
        };
      }
    }
    let LifeQualityImpact$1 = class LifeQualityImpact extends ModuleImet {
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        const averages = computed(() => {
          return setup_obj.calculateGroupsAverages("EvaluationScore");
        });
        return {
          ...setup_obj,
          averages
        };
      }
    };
    class CreateNonWDPA extends ModuleImet {
      constructor(input_data = {}) {
        const custom_props = {
          SubGovernanceModel_SelectionList: {
            type: Object,
            default: () => {
            }
          }
        };
        return super(input_data, custom_props);
      }
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        watch(setup_obj.records, () => {
          recordChanged();
        }, { deep: true });
        const management_unique = computed(() => {
          return setup_obj.records[0]["ManagementUnique"];
        });
        const SubGovernanceModel_options = computed(() => {
          return setup_obj.records[0]["GovernanceModel"] !== null && setup_obj.records[0]["GovernanceModel"] in props.SubGovernanceModel_SelectionList ? JSON.stringify(props.SubGovernanceModel_SelectionList[setup_obj.records[0]["GovernanceModel"]]) : JSON.stringify([]);
        });
        function recordChanged() {
          if (setup_obj.records[0]["GovernanceModel"] === null || !(setup_obj.records[0]["GovernanceModel"] in props.SubGovernanceModel_SelectionList) || !(setup_obj.records[0]["SubGovernanceModel"] in props.SubGovernanceModel_SelectionList[setup_obj.records[0]["GovernanceModel"]])) {
            setup_obj.records[0]["SubGovernanceModel"] = null;
          }
        }
        function resetManagement() {
          setup_obj.records[0]["ManagementName"] = null;
          setup_obj.records[0]["ManagementType"] = null;
          if (management_unique.value === null) {
            setup_obj.records[0]["DateOfCreation"] = null;
            setup_obj.records[0]["OfficialRecognition"] = null;
            setup_obj.records[0]["SupervisoryInstitution"] = null;
          }
        }
        return {
          ...setup_obj,
          resetManagement,
          management_unique,
          SubGovernanceModel_options
        };
      }
    }
    let Areas$2 = class Areas extends ModuleImet {
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        const AdministrativeArea_km2 = ref(input_data.records[0]["AdministrativeArea"] / 100);
        const WDPAArea_km2 = ref(input_data.records[0]["WDPAArea"] / 100);
        const GISArea_km2 = ref(input_data.records[0]["GISArea"] / 100);
        const StrictConservationArea_km2 = ref(input_data.records[0]["StrictConservationArea"] / 100);
        function convertToKm(fieldName) {
          if (fieldName === "AdministrativeArea") {
            AdministrativeArea_km2.value = parseFloat(setup_obj.records[0][fieldName]) / 100;
          } else if (fieldName === "WDPAArea") {
            WDPAArea_km2.value = parseFloat(setup_obj.records[0][fieldName]) / 100;
          } else if (fieldName === "GISArea") {
            GISArea_km2.value = parseFloat(setup_obj.records[0][fieldName]) / 100;
          } else if (fieldName === "StrictConservationArea") {
            StrictConservationArea_km2.value = parseFloat(setup_obj.records[0][fieldName]) / 100;
          }
        }
        function convertToHa(fieldName) {
          nextTick().then(() => {
            if (fieldName === "AdministrativeArea") {
              setup_obj.records[0][fieldName] = AdministrativeArea_km2.value * 100;
            } else if (fieldName === "WDPAArea") {
              setup_obj.records[0][fieldName] = WDPAArea_km2.value * 100;
            } else if (fieldName === "GISArea") {
              setup_obj.records[0][fieldName] = GISArea_km2.value * 100;
            } else if (fieldName === "StrictConservationArea") {
              setup_obj.records[0][fieldName] = StrictConservationArea_km2.value * 100;
            }
          });
        }
        return {
          ...setup_obj,
          AdministrativeArea_km2,
          WDPAArea_km2,
          GISArea_km2,
          StrictConservationArea_km2,
          convertToKm,
          convertToHa
        };
      }
    };
    let Areas$1 = class Areas extends ModuleImet {
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        const relative_importance = ref(setup_obj.records[0]["RelativeImportance"]);
        watch(setup_obj.records, () => {
          recordChanged();
        }, { deep: true });
        watch(relative_importance, () => {
          setup_obj.records[0]["RelativeImportance"] = relative_importance.value;
        });
        function recordChanged() {
          if (setup_obj.records[0]["RelativeImportance"] !== setup_obj.relative_importance) {
            setup_obj.relative_importance = setup_obj.records[0]["RelativeImportance"];
          }
        }
        return {
          ...setup_obj,
          relative_importance
        };
      }
    };
    class Areas extends ModuleImet {
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        const diffs = computed(() => {
          let diffs2 = [];
          setup_obj.records.forEach(function(item, index) {
            diffs2[index] = null;
            if (item["Number"] !== null && item["AdequateNumber"] !== null) {
              diffs2[index] += parseInt(item["Number"]) - parseInt(item["AdequateNumber"]);
            }
          });
          return diffs2;
        });
        return {
          ...setup_obj,
          diffs
        };
      }
    }
    class AnalysisStakeholderSummary {
      constructor(input_data = {}) {
        const options = {
          name: "AnalysisStakeholderSummary",
          props: {
            key_elements_importance: {
              type: Object,
              default: () => {
              }
            }
          },
          setup(props, context) {
            const Locale2 = window.ModularForms.Helpers.Locale;
            let key_elements_importance = reactive(props.key_elements_importance);
            function refresh_importance(new_items) {
              key_elements_importance.forEach(function(item, index) {
                key_elements_importance.splice(index, 1);
              });
              new_items.forEach(function(item, index) {
                key_elements_importance[index] = JSON.parse(JSON.stringify(new_items[index]));
              });
            }
            function key_elements_importance_composition(element) {
              return Locale2.getLabel("imet-core::oecm_evaluation.KeyElements.key_elements_importance_composition", {
                "imp_dir": "<b>" + element["importance_direct"] + "</b>",
                "imp_ind": "<b>" + element["importance_indirect"] + "</b>",
                "num_dir": "<b>" + element["stakeholder_direct_count"] + "</b>",
                "num_ind": "<b>" + element["stakeholder_indirect_count"] + "</b>"
              });
            }
            return {
              key_elements_importance,
              key_elements_importance_composition,
              refresh_importance
            };
          }
        };
        return createApp(options, input_data);
      }
    }
    class AnalysisStakeholder extends ModuleImet {
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        const current_stakeholder = ref(null);
        setup_obj.emitter.on("moduleSaved", (data) => {
          current_stakeholder.value = null;
          window.ModularForms.Helpers.Animation.scrollPageToAnchor("module_" + props.module_key);
          window.AnalysisStakeholderSummary.refresh_importance(data.key_elements_importance);
        });
        function isCurrentStakeholder(value) {
          return current_stakeholder.value === value;
        }
        function switchStakeholder(value) {
          if (!isCurrentStakeholder(value)) {
            current_stakeholder.value = value;
          } else {
            current_stakeholder.value = null;
          }
          setup_obj.resetModule();
        }
        function numItemPerGroupAndStakeholder(group_key, stakeholder) {
          let count2 = 0;
          setup_obj.records.forEach(function(item, index) {
            if (item[props.group_key_field] === group_key && item["Stakeholder"] === stakeholder) {
              count2++;
            }
          });
          return count2;
        }
        function addItem(group_key, stakeholder) {
          let new_empty_record = JSON.parse(JSON.stringify(toRaw(props.empty_record)));
          new_empty_record[props.group_key_field] = group_key;
          new_empty_record["Stakeholder"] = stakeholder;
          setup_obj.records.push(new_empty_record);
        }
        function deleteItem(index, group_key, stakeholder) {
          let num_records = setup_obj.numRecordsInGroup(setup_obj.records[index][props.group_key_field]);
          if (num_records > 1) {
            setup_obj.records.splice(index, 1);
          } else {
            let new_empty_record = JSON.parse(JSON.stringify(toRaw(props.empty_record)));
            new_empty_record[props.group_key_field] = group_key;
            new_empty_record["Stakeholder"] = stakeholder;
            setup_obj.records[index] = new_empty_record;
          }
        }
        return {
          ...setup_obj,
          isCurrentStakeholder,
          switchStakeholder,
          numItemPerGroupAndStakeholder,
          addItem,
          deleteItem
        };
      }
    }
    class Threats extends ModuleImet {
      constructor(input_data = {}) {
        const custom_props = {
          threats: {
            type: Object,
            default: () => input_data.threats
          }
        };
        return super(input_data, custom_props);
      }
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        const threat_stats = computed(() => {
          let stats = {};
          Object.entries(props.threats).forEach(([key, value]) => {
            setup_obj.records.forEach(function(record) {
              if (record["__threat_key"] === key) {
                let prod = 1 * (record["Impact"] !== null ? 4 - parseInt(record["Impact"]) : 1) * (record["Extension"] !== null ? 4 - parseInt(record["Extension"]) : 1) * (record["Duration"] !== null ? 4 - parseInt(record["Duration"]) : 1) * (record["Trend"] !== null ? 5 / 2 - parseInt(record["Trend"]) * 3 / 4 : 1) * (record["Probability"] !== null ? 4 - parseInt(record["Probability"]) : 1);
                let count2 = (record["Impact"] !== null ? 1 : 0) + (record["Extension"] !== null ? 1 : 0) + (record["Duration"] !== null ? 1 : 0) + (record["Trend"] !== null ? 1 : 0) + (record["Probability"] !== null ? 1 : 0);
                let score = count2 > 0 ? 4 - Math.pow(prod, 1 / count2) : null;
                score = score !== null ? ((0 - score) * 100 / 3).toFixed(1) : null;
                stats[key] = score;
              }
            });
          });
          return stats;
        });
        return {
          ...setup_obj,
          threat_stats
        };
      }
    }
    class KeyElements extends ModuleImet {
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        const Locale2 = window.ModularForms.Helpers.Locale;
        function get_index(element_id) {
          return element_id.replace(props.module_key, "").replace("Aspect", "").replaceAll("_", "");
        }
        function group_label(element_id) {
          let index = get_index(element_id);
          if (setup_obj.records[index]["__group_stakeholders"] !== null) {
            return Locale2.getLabel("imet-core::oecm_evaluation.KeyElements.from_group") + ": <b>" + setup_obj.records[index]["__group_stakeholders"] + "</b>";
          }
          return "";
        }
        function percentage_stakeholder_label(element_id) {
          let index = get_index(element_id);
          let group_key = setup_obj.records[index][props.group_key_field];
          if (group_key === "group0") {
            let num_dir = setup_obj.records[index]["__num_stakeholders_direct"];
            let num_ind = setup_obj.records[index]["__num_stakeholders_indirect"];
            if (num_dir !== null || num_ind) {
              num_dir = num_dir !== null ? parseInt(num_dir) : 0;
              num_ind = num_ind !== null ? parseInt(num_ind) : 0;
              return Locale2.getLabel("imet-core::oecm_evaluation.KeyElements.num_stakeholders", {
                "num_dir": "<b>" + num_dir + "</b>",
                "num_ind": "<b>" + num_ind + "</b>"
              });
            }
          } else if (group_key === "group1") {
            let score = setup_obj.records[index]["__score"];
            if (score !== null && score !== "") {
              return "<b>" + Locale2.getLabel("imet-core::oecm_evaluation.KeyElements.ranking") + "</b>: " + String(score);
            }
          }
          return "";
        }
        return {
          ...setup_obj,
          group_label,
          percentage_stakeholder_label
        };
      }
    }
    class KeyElementsImpact extends ModuleImet {
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        watch(setup_obj.records, () => {
          recordChanged();
        }, { deep: true });
        function recordChanged() {
          Object.entries(setup_obj.records).forEach(([index, record]) => {
            setup_obj.records[index]["EffectSH"] = calculate_effect(record["StatusSH"], record["TrendSH"]);
            setup_obj.records[index]["EffectER"] = calculate_effect(record["StatusER"], record["TrendER"]);
          });
        }
        function calculate_effect(status, trend) {
          let effect2 = null;
          if (status !== null || trend !== null) {
            effect2 = ((status !== null ? parseFloat(status) : 0) + (trend !== null ? parseFloat(trend) : 0)) / (status !== null && trend !== null ? 2 : 1);
            effect2 = effect2 * 100 / 2;
          }
          return effect2;
        }
        return {
          ...setup_obj
        };
      }
    }
    class LifeQualityImpact extends ModuleImet {
      setupApp(props, input_data) {
        let setup_obj = super.setupApp(props, input_data);
        const averages = computed(() => {
          return setup_obj.calculateGroupsAverages("EvaluationScore");
        });
        return {
          ...setup_obj,
          averages
        };
      }
    }
    window.Laravel = window.Laravel || {};
    window.ImetCore = {};
    window.ImetCore.Helpers = {};
    window.ImetCore.Components = {};
    window.mapboxgl = mapboxgl;
    window.mapboxgl.accessToken = window.accessToken;
    window.ImetCore.Helpers.BiopamaWDPA = BiopamaWDPA;
    window.ImetCore.Apps = {};
    window.ImetCore.Apps.Base = BaseImet;
    window.ImetCore.Apps.FormList = FormListImet;
    window.ImetCore.Apps.Module = ModuleImet;
    window.ImetCore.Apps.AssessmentScores = AssessmentScores;
    window.ImetCore.Apps.ScalingList = ScalingList;
    window.ImetCore.Apps.Report = Report;
    window.ImetCore.Apps.Preview = Preview;
    window.ImetCore.Apps.Analysis = Analysis;
    window.ImetCore.Apps.OECMAnalysis = OECMAnalysis;
    window.ImetCore.Apps.Modules = {
      ImetV1: {
        context: {},
        evaluation: {}
      },
      ImetV2: {
        context: {},
        evaluation: {}
      },
      Oecm: {
        context: {},
        evaluation: {}
      }
    };
    window.ImetCore.Apps.Modules.ImetV2.Create = Create;
    window.ImetCore.Apps.Modules.ImetV2.CreateNonWDPA = CreateNonWDPA$1;
    window.ImetCore.Apps.Modules.Oecm.Create = Create;
    window.ImetCore.Apps.Modules.Oecm.CreateNonWDPA = CreateNonWDPA$1;
    window.ImetCore.Apps.Modules.ImetV1.context.Areas = Areas$4;
    window.ImetCore.Apps.Modules.ImetV1.context.ControlLevel = ControlLevel$1;
    window.ImetCore.Apps.Modules.ImetV1.context.ManagementStaff = ManagementStaff$1;
    window.ImetCore.Apps.Modules.ImetV1.context.FinancialResources = FinancialResources$1;
    window.ImetCore.Apps.Modules.ImetV1.context.FinancialAvailableResources = FinancialAvailableResources$1;
    window.ImetCore.Apps.Modules.ImetV1.context.FinancialResourcesBudgetLines = FinancialResourcesBudgetLines$1;
    window.ImetCore.Apps.Modules.ImetV1.context.Equipments = Equipments$2;
    window.ImetCore.Apps.Modules.ImetV1.context.MenacesPressions = MenacesPressions$1;
    window.ImetCore.Apps.Modules.ImetV1.context.EcosystemServices = Equipments$1;
    window.ImetCore.Apps.Modules.ImetV1.evaluation.Menaces = ControlLevel;
    window.ImetCore.Apps.Modules.ImetV1.evaluation.InformationAvailability = InformationAvailability;
    window.ImetCore.Apps.Modules.ImetV1.evaluation.DesignatedValuesConservation = DesignatedValuesConservation;
    window.ImetCore.Apps.Modules.ImetV1.evaluation.DesignatedValuesConservationTendency = DesignatedValuesConservationTendency;
    window.ImetCore.Apps.Modules.ImetV2.context.GeographicalLocation = GeographicalLocation;
    window.ImetCore.Apps.Modules.ImetV2.context.Areas = Areas$3;
    window.ImetCore.Apps.Modules.ImetV2.context.Sectors = Sectors;
    window.ImetCore.Apps.Modules.ImetV2.context.ManagementStaff = ManagementStaff;
    window.ImetCore.Apps.Modules.ImetV2.context.FinancialResources = FinancialResources;
    window.ImetCore.Apps.Modules.ImetV2.context.FinancialAvailableResources = FinancialAvailableResources;
    window.ImetCore.Apps.Modules.ImetV2.context.FinancialResourcesBudgetLines = FinancialResourcesBudgetLines;
    window.ImetCore.Apps.Modules.ImetV2.context.Equipments = Equipments;
    window.ImetCore.Apps.Modules.ImetV2.context.MenacesPressions = MenacesPressions;
    window.ImetCore.Apps.Modules.ImetV2.context.EcosystemServices = EcosystemServices;
    window.ImetCore.Apps.Modules.ImetV2.evaluation.RegulationsAdequacy = RegulationsAdequacy;
    window.ImetCore.Apps.Modules.ImetV2.evaluation.DesignAdequacy = DesignAdequacy;
    window.ImetCore.Apps.Modules.ImetV2.evaluation.BoundaryLevel = BoundaryLevel;
    window.ImetCore.Apps.Modules.ImetV2.evaluation.ManagementPlan = ManagementPlan$1;
    window.ImetCore.Apps.Modules.ImetV2.evaluation.WorkPlan = ManagementPlan;
    window.ImetCore.Apps.Modules.ImetV2.evaluation.AssistanceActivities = AssistanceActivities;
    window.ImetCore.Apps.Modules.ImetV2.evaluation.LifeQualityImpact = LifeQualityImpact$1;
    window.ImetCore.Apps.Modules.Oecm.context.Governance = CreateNonWDPA;
    window.ImetCore.Apps.Modules.Oecm.context.Areas = Areas$2;
    window.ImetCore.Apps.Modules.Oecm.context.ManagementRelativeImportance = Areas$1;
    window.ImetCore.Apps.Modules.Oecm.context.ManagementStaff = Areas;
    window.ImetCore.Apps.Modules.Oecm.context.AnalysisStakeholderSummary = AnalysisStakeholderSummary;
    window.ImetCore.Apps.Modules.Oecm.context.AnalysisStakeholder = AnalysisStakeholder;
    window.ImetCore.Apps.Modules.Oecm.evaluation.Threats = Threats;
    window.ImetCore.Apps.Modules.Oecm.evaluation.KeyElements = KeyElements;
    window.ImetCore.Apps.Modules.Oecm.evaluation.KeyElementsImpact = KeyElementsImpact;
    window.ImetCore.Apps.Modules.Oecm.evaluation.LifeQualityImpact = LifeQualityImpact;
    class SettingsApp extends Base {
      constructor(input_data) {
        const options = {
          name: "SettingsApp",
          props: {
            records: Object,
            module_key: String,
            save_url: String
          },
          setup(props, context) {
            let records = reactive(props.records);
            let records_backup = JSON.parse(JSON.stringify(toRaw(records)));
            let status = ref("init");
            let warning_on_save = null;
            const Payload2 = window.ModularForms.Helpers.Payload;
            watch(records, (value) => {
              if (status.value !== "init" && status.value !== "changed") {
                status.value = "changed";
              }
            });
            onMounted(() => {
              status.value = "idle";
            });
            function resetModule() {
              replaceRecords(records_backup);
              nextTick().then(() => {
                status.value = "idle";
              });
            }
            function saveModule() {
              status.value = "saving";
              let data = {
                records_json: Payload2.encode(records),
                module_key: props.module_key,
                _method: "PATCH"
              };
              fetch(props.save_url, {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  "X-CSRF-Token": window.Laravel.csrfToken
                },
                body: JSON.stringify(data)
              }).then((response) => response.json()).then(function(data2) {
                if (data2.status === "success") {
                  replaceRecords(data2.records);
                  replaceRecordsBackup(data2.records);
                  nextTick().then(() => {
                    status.value = "saved";
                  });
                } else if (data2.status === "validation_error") {
                  status.value = "error";
                }
              }).catch(function(error) {
                status.value = "error";
              });
            }
            function replaceRecords(newRecords) {
              Object.entries(newRecords).forEach(([key, value]) => {
                records[key] = JSON.parse(JSON.stringify(value));
              });
            }
            function replaceRecordsBackup(newRecords) {
              Object.entries(newRecords).forEach(([key, value]) => {
                records_backup[key] = JSON.parse(JSON.stringify(value));
              });
            }
            return {
              records,
              status,
              warning_on_save,
              resetModule,
              saveModule
            };
          }
        };
        return super(options, input_data).component("simpleText", simpleText).component("simplePassword", simplePassword);
      }
    }
    const _sfc_main = {
      __name: "PasCountryUpdate",
      props: {
        iso2: String,
        iso3: String,
        name: String,
        downloaded: Boolean,
        updated: String,
        updateUrl: String
      },
      setup(__props, { expose: __expose }) {
        __expose();
        const Locale2 = window.ModularForms.Helpers.Locale;
        const props = __props;
        const loading = ref(false);
        const loaded = ref(false);
        const downloaded = ref(props.downloaded);
        const updated = ref(props.updated);
        const api_key_error = ref(false);
        const api_error = ref(false);
        function update2(iso3) {
          loading.value = true;
          fetch(props.updateUrl, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-CSRF-Token": window.Laravel.csrfToken
            },
            body: JSON.stringify({
              "iso3": iso3
            })
          }).then((response) => response.json()).then(function(data) {
            if (data.status === "success") {
              downloaded.value = true;
              updated.value = data.updated;
              loaded.value = true;
            } else {
              if (data.message.includes("API key")) {
                api_key_error.value = true;
              } else {
                api_error.value = true;
              }
            }
            loading.value = false;
          }).catch(function(error) {
            api_error.value = true;
            loading.value = false;
          });
        }
        const __returned__ = { Locale: Locale2, props, loading, loaded, downloaded, updated, api_key_error, api_error, update: update2, ref };
        Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
        return __returned__;
      }
    };
    const _hoisted_1 = { class: "bg-gray-100 py-1 px-2 flex justify-between content-center" };
    const _hoisted_2 = { class: "text-sm" };
    const _hoisted_3 = { class: "flex items-center justify-items-end" };
    const _hoisted_4 = {
      key: 0,
      class: "fa-solid fa-sync fa-spin"
    };
    const _hoisted_5 = {
      key: 1,
      class: "text-red-600 text-sm"
    };
    const _hoisted_6 = {
      key: 2,
      class: "text-red-600 text-sm"
    };
    const _hoisted_7 = {
      key: 0,
      class: "italic text-xs pr-2"
    };
    function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", _hoisted_1, [
        createBaseVNode("div", null, [
          createBaseVNode("span", {
            class: normalizeClass(["fi", "fi-" + $props.iso2.toLowerCase()])
          }, null, 2),
          _cache[2] || (_cache[2] = createTextVNode()),
          createBaseVNode("span", _hoisted_2, toDisplayString($props.name), 1)
        ]),
        createBaseVNode("div", _hoisted_3, [
          $setup.loading ? (openBlock(), createElementBlock("i", _hoisted_4)) : $setup.api_key_error ? (openBlock(), createElementBlock("span", _hoisted_5, [
            _cache[3] || (_cache[3] = createBaseVNode("i", { class: "fa-solid fa-triangle-exclamation pl-2" }, null, -1)),
            createTextVNode(" " + toDisplayString($setup.Locale.getLabel("offline.errors.missing_api_token")), 1)
          ])) : $setup.api_error ? (openBlock(), createElementBlock("span", _hoisted_6, [
            _cache[4] || (_cache[4] = createBaseVNode("i", { class: "fa-solid fa-triangle-exclamation pl-2" }, null, -1)),
            createTextVNode(" " + toDisplayString($setup.Locale.getLabel("offline.errors.generic")), 1)
          ])) : $setup.downloaded ? (openBlock(), createElementBlock(Fragment, { key: 3 }, [
            $setup.updated ? (openBlock(), createElementBlock("span", _hoisted_7, toDisplayString($setup.Locale.getLabel("offline.settings.protected_areas.last_update")) + ": " + toDisplayString($setup.updated), 1)) : createCommentVNode("", true),
            !$setup.loaded ? (openBlock(), createElementBlock("button", {
              key: 1,
              class: "btn-nav gray small whitespace-nowrap",
              onClick: _cache[0] || (_cache[0] = ($event) => $setup.update($props.iso3))
            }, [
              _cache[5] || (_cache[5] = createBaseVNode("span", { class: "fas fa-fw fa-rotate" }, null, -1)),
              createTextVNode(" " + toDisplayString($setup.Locale.getLabel("offline.settings.protected_areas.update")), 1)
            ])) : createCommentVNode("", true),
            _cache[6] || (_cache[6] = createBaseVNode("span", { class: "fas fa-fw fa-check-circle text-green-600 pl-2" }, null, -1))
          ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 4 }, [
            createBaseVNode("button", {
              class: "btn-nav gray small whitespace-nowrap",
              onClick: _cache[1] || (_cache[1] = ($event) => $setup.update($props.iso3))
            }, [
              _cache[7] || (_cache[7] = createBaseVNode("span", { class: "fas fa-fw fa-down-long" }, null, -1)),
              createTextVNode(" " + toDisplayString($setup.Locale.getLabel("offline.settings.protected_areas.download")), 1)
            ]),
            _cache[8] || (_cache[8] = createBaseVNode("span", { class: "fas fa-fw fa-xmark-circle text-red-600 pl-2" }, null, -1))
          ], 64))
        ])
      ]);
    }
    const PasCountryUpdate = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__file", "/var/www/html/resources/js/components/PasCountryUpdate.vue"]]);
    class PaUpdate extends Base {
      constructor(input_data) {
        const options = {
          name: "PaUpdate"
        };
        return super(options, input_data).component("pascountryupdate", PasCountryUpdate);
      }
    }
    window.Laravel = window.Laravel || {};
    window.OfflineImet = {};
    window.OfflineImet.SettingsApp = SettingsApp;
    window.OfflineImet.PaUpdate = PaUpdate;
  }
});
export default require_index_001();
